<html lang="en-US">
  <head>
    <meta charset="UTF-8" />

    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />

    <!-- 1. (Core) Set home screen icon for Apple devices -->
    <link
      rel="apple-touch-icon"
      href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg"
    />
    <link
      rel="apple-touch-icon"
      sizes="152x152"
      href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg"
    />
    <link
      rel="apple-touch-icon"
      sizes="167x167"
      href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg"
    />

    <!-- 2. (Core) Link to manifest file -->
    <link rel="manifest" href="manifest.json" />

    <!-- 3. (Core) Tell Apple device this is a Web app that can display fullscreen -->
    <meta name="apple-mobile-web-app-capable" content="yes" />

    <!-- 4. (Core) Set status bar style for Apple device fullscreen mode -->
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <!-- 5. (Optional) Set title displayed on home screen -->
    <meta name="apple-mobile-web-app-title" content="EPhone (Rabbit-k Edition)" />

    <!-- 6. (Compatible) Provide support for some Android browsers -->
    <meta name="mobile-web-app-capable" content="yes" />

    <!-- 7. (Backup) Standard browser tab icon -->
    <link
      rel="icon"
      type="image/png"
      href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg"
    />

    <title>EPhone (Rabbit-k Edition)</title>

    <link rel="stylesheet" href="style.css" />
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <script src="https://phoebeboo.github.io/mewoooo/pp.js" defer></script>
    <script src="game-hall.js" defer></script>
    <script src="forum.js" defer></script>
    <script src="lovers-space.js" defer></script>
    <script src="taobao.js" defer></script>
    <script src="weibo.js" defer></script>
    <script src="date.js" defer></script>
    <script src="studio.js" defer></script>
    <script src="sw.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/darkreader@4.9.84/darkreader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <script src="tukey-accounting.js" defer></script>
    <script src="kk-checkin.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="avatar-frames.js"></script>

    <style></style>

    <style id="custom-theme-style"></style>
  </head>
  <body>
    <div id="phone-screen">
      <div id="status-bar">
        <span id="status-bar-time">12:00</span>
        <div id="status-bar-battery" class="battery-container">
          <span class="battery-text">--%</span>
          <div class="battery-icon">
            <div class="battery-level"></div>
          </div>
        </div>
      </div>
      <div id="notification-bar">
        <img id="notification-avatar" src="" />
        <!-- This is the avatar -->
        <div id="notification-content">
          <div class="name"></div>
          <!-- Name -->
          <div class="message"></div>
          <!-- Message -->
        </div>
      </div>

      <div id="video-call-floating-bubble" style="display: none">
        <img id="video-floating-avatar" src="" />
      </div>

      <div id="floating-lyrics-bar">
        <span id="floating-lyric-text">‚ô™</span>

        <div
          id="lyrics-settings-btn"
          style="
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
          "
        >
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <circle cx="12" cy="12" r="3"></circle>
            <path
              d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"
            ></path>
          </svg>
        </div>
        <span class="close-btn">√ó</span>
      </div>

      <div id="lock-screen-background-blur" style="display: none"></div>

      <div id="home-screen" class="screen active">
        <div id="desktop-edit-done-btn">Done</div>
        <div class="home-screen-slider">
          <!-- Page 1, put all original content here -->
          <div class="home-page">
            <div id="main-content-area">
              <div id="profile-widget">
                <img
                  id="profile-banner-img"
                  src="https://i.postimg.cc/k495F4W5/profile-banner.jpg"
                  class="editable-image"
                />

                <div class="profile-avatar-container">
                  <img
                    id="profile-avatar-img"
                    src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg"
                    class="editable-image"
                  />

                  <img
                    id="profile-avatar-frame"
                    class="weibo-avatar-frame"
                    src=""
                    style="display: none"
                  />
                </div>

                <div class="profile-info">
                  <p id="profile-username" class="editable-text">Your Nickname</p>
                  <p id="profile-sub-username" class="editable-text">
                    @your_id
                  </p>
                  <p id="profile-bio" class="editable-text">
                    Click here to edit your bio
                  </p>
                  <p
                    id="profile-location"
                    class="editable-text"
                    data-placeholder="Click to edit location"
                  >
                    <svg
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="currentColor"
                    >
                      <path
                        d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"
                      ></path>
                    </svg>
                    <span>Click to edit location</span>
                  </p>
                </div>
              </div>
              <div id="desktop-layout">
                <div id="desktop-widget-column">
                  <div class="custom-widget-container">
                    <div
                      id="widget-bubble-1"
                      class="widget-bubble editable-text"
                      contenteditable="true"
                    >
                      Click to edit text
                    </div>
                    <div class="widget-circle-uploader">
                      <img
                        id="widget-image-1"
                        src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg"
                        class="editable-image"
                        title="Click to replace image"
                      />
                    </div>
                    <div
                      id="widget-subtext-1"
                      class="widget-subtext editable-text"
                      contenteditable="true"
                    >
                      Click to edit text
                    </div>
                  </div>
                  <div class="custom-widget-container">
                    <div
                      id="widget-bubble-2"
                      class="widget-bubble editable-text"
                      contenteditable="true"
                    >
                      Click to edit text
                    </div>
                    <div class="widget-circle-uploader">
                      <img
                        id="widget-image-2"
                        src="https://i.postimg.cc/k495F4W5/profile-banner.jpg"
                        class="editable-image"
                        title="Click to replace image"
                      />
                    </div>
                    <div
                      id="widget-subtext-2"
                      class="widget-subtext editable-text"
                      contenteditable="true"
                    >
                      Click to edit text
                    </div>
                  </div>
                </div>
                <div id="desktop-app-container">
                  <div
                    class="desktop-app-icon"
                    onclick="showScreen('chat-list-screen')"
                  >
                    <div class="icon-bg-desktop">
                      <img
                        id="icon-img-qq"
                        src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg"
                        alt="QQ"
                      />
                    </div>
                    <span class="label">QQ</span>
                  </div>
                  <div
                    class="desktop-app-icon"
                    onclick="showScreen('world-book-screen')"
                  >
                    <div class="icon-bg-desktop">
                      <img
                        id="icon-img-world-book"
                        src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg"
                        alt="World Book"
                      />
                    </div>
                    <span class="label">World Book</span>
                  </div>
                  <div id="check-phone-btn" class="desktop-app-icon">
                    <div class="icon-bg-desktop">
                      <img
                        id="icon-img-check-phone"
                        src="https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg"
                        alt="Check Phone"
                      />
                    </div>
                    <span class="label">Check Phone</span>
                  </div>
                  <div class="desktop-app-icon" id="weibo-app-icon">
                    <div class="icon-bg-desktop">
                      <img
                        id="icon-img-weibo"
                        src="https://i.postimg.cc/PqBY5wBq/weibo-icon.png"
                        alt="Weibo"
                      />
                    </div>
                    <span class="label">Weibo</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- New second page, now custom layout -->
          <div class="home-page">
            <!-- Left half avatar widget -->
            <div id="second-page-left-widget" class="custom-widget-container">
              <div class="widget-circle-uploader">
                <img
                  id="widget-image-3"
                  src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg"
                  class="editable-image"
                  title="Click to replace image"
                />
              </div>

              <div
                id="second-page-bubble"
                class="widget-bubble editable-text"
                contenteditable="true"
              >
                Click to edit text
              </div>

              <div id="new-bubbles-container">
                <div
                  id="flat-capsule-bubble"
                  class="widget-bubble editable-text"
                  contenteditable="true"
                >
                  Editable
                </div>
                <div
                  id="circular-bubble"
                  class="widget-bubble editable-text"
                  contenteditable="true"
                >
                  Text
                </div>
              </div>
            </div>
            <!-- Two side-by-side icons in top right -->
            <div id="second-page-top-right-apps">
              <div
                class="desktop-app-icon"
                onclick="showScreen('forum-screen')"
              >
                <div class="icon-bg-desktop">
                  <img
                    id="icon-img-forum"
                    src="https://i.postimg.cc/pr0T3WfC/douban-icon.png"
                    alt="Community"
                  />
                </div>
                <span class="label">Community</span>
              </div>
              <div class="desktop-app-icon" id="lovers-space-app-icon">
                <div class="icon-bg-desktop">
                  <img
                    id="icon-img-lovers-space"
                    src="https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png"
                    alt="Couple's Space"
                  />
                </div>
                <span class="label">Couple's Space</span>
              </div>

              <div
                id="second-page-x-social-app"
                class="desktop-app-icon"
                onclick="showScreen('x-social-screen')"
              >
                <div class="icon-bg-desktop">
                  <img
                    id="icon-img-x-social"
                    src="https://i.postimg.cc/8P1H0vQ8/x-logo.png"
                    alt="X Social"
                  />
                </div>
                <span class="label">X Social</span>
              </div>
              <div style="position: absolute; top: 100px; right: 85px">
                <div
                  class="desktop-app-icon"
                  onclick="showScreen('game-hall-screen')"
                >
                  <div class="icon-bg-desktop">
                    <img
                      id="icon-img-game-hall"
                      src="https://i.postimg.cc/P5gL5z2g/game-controller-icon.png"
                      alt="Game Hall"
                    />
                  </div>
                  <span class="label">Game Hall</span>
                </div>
              </div>
            </div>
            <!-- === New responsive transparent music widget === -->
            <div class="middle-layout-container">
              <div id="glass-music-widget">
                <div class="widget-main-row">
                  <!-- Left: rectangular rounded image -->
                  <div class="rect-cover-wrapper">
                    <img
                      id="music-rect-img"
                      src="https://i.postimg.cc/k495F4W5/profile-banner.jpg"
                      class="editable-image cover-img"
                      title="Click to replace cover"
                    />
                  </div>

                  <!-- Right: transparent crystal disc (overlapping) -->
                  <div class="glass-record-wrapper">
                    <div class="glass-disc">
                      <!-- Image in center of disc -->
                      <img
                        id="music-record-img"
                        src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg"
                        class="editable-image disc-center-img"
                        title="Click to replace disc image"
                      />
                      <!-- Disc highlight texture -->
                      <div class="disc-highlight"></div>
                    </div>
                  </div>
                </div>

                <!-- Bottom: text and sound waves -->
                <div class="widget-footer-row">
                  <div
                    id="music-text-line"
                    class="music-title-text editable-text"
                    contenteditable="true"
                  >
                    Click to edit song name
                  </div>
                  <!-- Rhythmic sound waves (bar count increased for width) -->
                  <div class="music-wave-bars" id="custom-wide-wave">
                    <i></i><i></i><i></i><i></i><i></i> <i></i><i></i><i></i
                    ><i></i><i></i> <i></i><i></i><i></i><i></i><i></i> <i></i
                    ><i></i><i></i><i></i><i></i>
                  </div>
                </div>
              </div>
            </div>

            <div id="new-custom-widget">
              <!-- Use a new container to wrap month and avatar -->
              <div id="new-widget-header">
                <!-- Added contenteditable and class, now freely editable with numbers or text -->
                <div
                  id="widget-month-display"
                  class="editable-text"
                  contenteditable="true"
                >
                  12
                </div>

                <img
                  id="new-widget-avatar"
                  src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg"
                  class="editable-image"
                />
              </div>
              <div
                id="new-widget-text-1"
                class="new-widget-text editable-text"
                contenteditable="true"
              >
                Editable text
              </div>
              <div class="new-widget-divider"></div>
              <div
                id="new-widget-text-2"
                class="new-widget-text editable-text"
                contenteditable="true"
              >
                Editable text
              </div>
              <div class="new-widget-divider"></div>
              <div
                id="new-widget-text-3"
                class="new-widget-text editable-text"
                contenteditable="true"
              >
                Editable text
              </div>
            </div>
            <div style="position: absolute; bottom: 105px; left: 35px">
              <div class="desktop-app-icon" id="taobao-app-icon">
                <div class="icon-bg-desktop">
                  <img
                    id="icon-img-taobao"
                    src="https://i.postimg.cc/k47tXg1j/taologo.png"
                    alt="Taobao"
                  />
                </div>
                <span
                  class="label"
                  style="
                    color: white;
                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
                  "
                  >Taobao</span
                >
              </div>
            </div>
            <div style="position: absolute; bottom: 105px; left: 120px">
              <div class="desktop-app-icon" id="date-a-live-app-icon">
                <div class="icon-bg-desktop">
                  <img
                    id="icon-img-date-a-live"
                    src="https://i.postimg.cc/W36mYgP5/DAL-icon.jpg"
                    alt="Date A Live"
                  />
                </div>
                <span
                  class="label"
                  style="
                    color: white;
                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
                  "
                  >Date A Live</span
                >
              </div>
            </div>
            <div style="position: absolute; bottom: 15px; left: 120px">
              <div class="desktop-app-icon" id="kk-checkin-app-icon">
                <div class="icon-bg-desktop">
                  <img
                    id="icon-img-kk-checkin"
                    src="https://i.postimg.cc/MGwrL0nf/kitty.png"
                    alt="KK Check-in"
                  />
                </div>
                <span
                  class="label"
                  style="
                    color: white;
                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
                  "
                  >KK Check-in</span
                >
              </div>
            </div>
            <div style="position: absolute; bottom: 15px; left: 35px">
              <div class="desktop-app-icon" id="tukey-accounting-app-icon">
                <div class="icon-bg-desktop">
                  <img
                    id="icon-img-tukey-accounting"
                    src="https://i.postimg.cc/k4fZKVXP/tu-tu.png"
                    alt="Tutu Accounting"
                  />
                </div>
                <span
                  class="label"
                  style="
                    color: white;
                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
                  "
                  >Tutu Accounting</span
                >
              </div>
            </div>
            <div style="position: absolute; bottom: 15px; left: 205px">
              <div class="desktop-app-icon" id="persona-manager-app-icon" onclick="showScreen('persona-manager-screen')">
                <div class="icon-bg-desktop">
                  <img
                    id="icon-img-persona-manager"
                    src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg"
                    alt="Personas"
                  />
                </div>
                <span
                  class="label"
                  style="
                    color: white;
                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
                  "
                  >Personas</span
                >
              </div>
            </div>
          </div>
        </div>

        <!-- Bottom Dock bar remains unchanged -->
        <div id="desktop-dock">
          <div
            class="desktop-app-icon"
            onclick="showScreen('api-settings-screen')"
          >
            <div class="icon-bg-desktop">
              <img
                id="icon-img-api-settings"
                src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg"
                alt="API Settings"
              />
            </div>
            <span class="label">API Settings</span>
          </div>

          <div class="desktop-app-icon" id="studio-app-icon">
            <div class="icon-bg-desktop">
              <!-- The id="icon-img-studio" here must be kept, used by JS to identify icon replacement -->
              <img
                id="icon-img-studio"
                src="https://i.postimg.cc/W3sLz11s/clapperboard-icon.png"
                alt="Mini Theater"
              />
            </div>
            <!-- lrq Mini Theater -->
            <span class="label">lrq Mini Theater</span>
          </div>

          <div
            class="desktop-app-icon"
            onclick="showScreen('font-settings-screen')"
          >
            <div class="icon-bg-desktop">
              <img
                id="icon-img-font"
                src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg"
                alt="Font"
              />
            </div>
            <span class="label">Font</span>
          </div>
          <div
            class="desktop-app-icon"
            onclick="showScreen('wallpaper-screen')"
          >
            <div class="icon-bg-desktop">
              <img
                id="icon-img-wallpaper"
                src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg"
                alt="Appearance Settings"
              />
            </div>
            <span class="label">Appearance Settings</span>
          </div>
        </div>

        <!-- Dots -->
        <div class="pagination-dots">
          <span class="dot active"></span>
          <span class="dot"></span>
        </div>
      </div>

      <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
      <!-- PERSONA MANAGER SCREEN                        -->
      <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
      <div id="persona-manager-screen" class="screen">
        <div class="header">
          <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
          <span>Personas</span>
          <div class="header-actions">
            <span class="action-btn" id="pm-add-btn" title="New Persona" onclick="openPersonaManagerEditor(null)">
              <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
              </svg>
            </span>
          </div>
        </div>

        <div class="form-container settings-scroll-container" id="persona-manager-body">

          <!-- ‚òÖ Active Persona section card ‚òÖ -->
          <div class="settings-group-card" id="active-persona-section" style="display:none;">
            <div class="settings-section-title">‚ú¶ Active Persona</div>
            <div id="active-persona-banner"></div>
          </div>

          <!-- No active persona notice -->
          <div id="no-active-persona-notice" class="persona-manager-empty-notice" style="display:none;">
            <span>üåê</span> No active persona ‚Äî tap a card below to switch into one!
          </div>

          <!-- ‚òÖ All personas section card ‚òÖ -->
          <div class="settings-group-card" id="all-personas-section" style="display:none;">
            <div class="settings-section-title">üé≠ All Personas</div>
            <div id="persona-manager-grid" class="persona-manager-grid"></div>
          </div>

          <!-- Empty state (no personas at all) -->
          <div id="persona-manager-empty" style="display:none; text-align:center; padding:60px 20px; color:#aaa;">
            <div style="font-size:48px; margin-bottom:12px;">üé≠</div>
            <div style="font-size:16px; font-weight:600; color:#888; margin-bottom:8px;">No Personas Yet</div>
            <div style="font-size:13px; color:#bbb;">Tap the <b>Ôºã</b> button above to create your first persona!</div>
          </div>
        </div>
      </div>

      <div id="weibo-screen" class="screen">
        <!-- This container will hold all Weibo pages -->
        <div id="weibo-page-container">
          <!-- Page 1: My Profile (updated) -->
          <div id="weibo-my-profile-view" class="weibo-view active">
            <!-- Header -->
            <div class="header">
              <span class="back-btn" onclick="showScreen('home-screen')">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>My Profile</span>
              <div class="header-actions">
                <!-- New DM button -->
                <span class="action-btn" id="weibo-my-dms-btn" title="My Messages">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="22"
                    height="22"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"
                    ></path>
                    <polyline points="22,6 12,13 2,6"></polyline>
                  </svg>
                </span>

                <!-- New "Edit" button -->
                <span
                  class="action-btn"
                  id="edit-weibo-profile-btn"
                  title="Edit Profile"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path d="M12 20h9"></path>
                    <path
                      d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"
                    ></path>
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="create-weibo-post-btn"
                  style="font-size: 28px; font-weight: 300"
                  >+</span
                >
              </div>
            </div>
            <!-- Profile content area -->
            <div id="weibo-profile-page">
              <div class="weibo-profile-header">
                <img
                  id="weibo-background-img"
                  src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg"
                  class="weibo-background"
                />

                <div class="weibo-avatar-container">
                  <img
                    id="weibo-avatar-img"
                    src="https://files.catbox.moe/q6z5fc.jpeg"
                    class="weibo-avatar"
                  />

                  <img
                    id="weibo-avatar-frame"
                    class="weibo-avatar-frame"
                    src=""
                    style="display: none"
                  />
                </div>

                <div class="weibo-nickname" id="weibo-nickname">Your Nickname</div>

                <div id="weibo-user-profession-display">Click to set profession</div>

                <div class="weibo-stats">
                  <div id="weibo-following-btn" class="weibo-stat-item">
                    <span id="weibo-following-count" class="weibo-stat-number"
                      >0</span
                    >
                    <span class="weibo-stat-label">Following</span>
                  </div>
                  <div id="weibo-posts-item" class="weibo-stat-item">
                    <span id="weibo-posts-count" class="weibo-stat-number"
                      >0</span
                    >
                    <span class="weibo-stat-label">Posts</span>
                  </div>
                  <div id="weibo-fans-item" class="weibo-stat-item">
                    <span id="weibo-fans-count" class="weibo-stat-number"
                      >0</span
                    >
                    <span class="weibo-stat-label">Followers</span>
                  </div>
                </div>
              </div>
              <div
                id="my-weibo-feed-list"
                style="
                  padding: 15px;
                  display: flex;
                  flex-direction: column;
                  gap: 15px;
                "
              ></div>
            </div>
          </div>

          <!-- Page 2: Following (unchanged) -->
          <div id="weibo-following-view" class="weibo-view">
            <div class="header">
              <span class="back-btn" onclick="showScreen('home-screen')">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Following</span>
              <span
                class="action-btn"
                id="clear-following-feed-btn"
                style="font-size: 16px; font-weight: 500"
                >Clear</span
              >
            </div>
            <div
              id="weibo-following-feed-list"
              style="
                flex-grow: 1;
                overflow-y: auto;
                padding: 15px;
                display: flex;
                flex-direction: column;
                gap: 15px;
              "
            >
              <!-- Following feed list will be dynamically generated by JS here -->
            </div>
          </div>

          <!-- Page 3: Hot Search (unchanged) -->
          <div id="weibo-hot-search-view" class="weibo-view">
            <div class="header">
              <span class="back-btn" onclick="showScreen('home-screen')">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Hot Search</span>
              <div class="header-actions">
                <span
                  class="action-btn"
                  id="generate-hot-search-btn"
                  title="Generate Hot Search"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="22"
                    height="22"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                  </svg>
                </span>
              </div>
            </div>
            <div
              id="weibo-hot-search-list"
              style="flex-grow: 1; overflow-y: auto"
            >
              <p style="text-align: center; color: #8a8a8a; margin-top: 50px">
                Click the magnifier in the top right to generate hot search
              </p>
            </div>
          </div>

          <!-- Page 4: Plaza (unchanged) -->
          <div id="weibo-plaza-view" class="weibo-view">
            <div class="header">
              <span class="back-btn" onclick="showScreen('home-screen')">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Plaza</span>
              <div class="header-actions">
                <span
                  class="action-btn"
                  id="generate-plaza-feed-btn"
                  title="Generate Plaza Feed"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="22"
                    height="22"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                  </svg>
                </span>
              </div>
            </div>
            <div
              id="weibo-plaza-feed-list"
              style="flex-grow: 1; overflow-y: auto; padding: 0"
            >
              <p style="text-align: center; color: #8a8a8a; margin-top: 50px">
                Click the magnifier in the top right to generate plaza feed
              </p>
            </div>
          </div>

          <!-- Page 5: Hot Search detail page (unchanged) -->
          <div id="weibo-hottopic-feed-view" class="weibo-view">
            <div class="header">
              <span class="back-btn" id="back-from-hottopic-btn">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span id="weibo-hottopic-title">Hot Topic</span>
              <div class="header-actions">
                <span
                  class="action-btn"
                  id="refresh-hottopic-feed-btn"
                  title="Load more"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                  </svg>
                </span>
              </div>
            </div>
            <div
              id="weibo-hottopic-feed-list"
              style="flex-grow: 1; overflow-y: auto; padding: 0"
            >
              <!-- Hot search list will be dynamically generated by JS -->
            </div>
          </div>
        </div>

        <!-- Bottom navigation bar -->
        <div id="weibo-bottom-nav">
          <div class="weibo-nav-item" data-view="weibo-hot-search-view">
            Hot Search
          </div>
          <div class="weibo-nav-item" data-view="weibo-plaza-view">Plaza</div>
          <div class="weibo-nav-item" data-view="weibo-following-view">
            Following
          </div>
          <div class="weibo-nav-item active" data-view="weibo-my-profile-view">
            My Weibo
          </div>
        </div>
      </div>

      <div id="world-book-screen" class="screen">
        <div class="header">
          <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
          <span>World Book</span>
          <div class="header-actions">
            <span
              class="action-btn"
              id="import-world-book-btn"
              title="Import World Book"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
              </svg>
            </span>

            <span
              class="action-btn"
              id="manage-categories-in-edit-mode-btn"
              style="display: none"
              title="Manage Categories"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path
                  d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
                ></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
              </svg>
            </span>

            <span
              class="action-btn btn-danger"
              id="world-book-delete-selected-btn"
              style="display: none"
              title="Delete Selected"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <polyline points="3 6 5 6 21 6"></polyline>
                <path
                  d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"
                ></path>
              </svg>
              <span
                id="world-book-delete-count"
                style="font-size: 12px; margin-left: 2px"
              ></span>
              <!-- Used to display count -->
            </span>

            <span class="action-btn" id="toggle-world-book-edit-mode-btn"
              >Edit Mode</span
            >

            <span class="action-btn" id="add-world-book-btn">+</span>
          </div>
        </div>
        <div id="world-book-list"></div>
      </div>

      <div id="world-book-editor-screen" class="screen">
        <div class="header">
          <span class="back-btn" onclick="showScreen('world-book-screen')"
            >‚Äπ</span
          >
          <span id="world-book-editor-title">Edit World Book</span>
          <span class="save-btn" id="save-world-book-btn">Save</span>
        </div>
        <div class="form-container">
          <div class="form-group">
            <label for="world-book-name-input">Title</label>
            <input
              type="text"
              id="world-book-name-input"
              placeholder="Enter world book title..."
            />
          </div>

          <div class="form-group">
            <label for="world-book-category-select">Category</label>
            <select id="world-book-category-select">
              <!-- Options will be dynamically generated by JS -->
            </select>
          </div>

          <div class="form-group" style="height: 100%">
            <label for="world-book-content-input">Content</label>
            <textarea
              id="world-book-content-input"
              placeholder="Enter detailed world setting here..."
            ></textarea>
          </div>
        </div>
      </div>

      <div id="api-settings-screen" class="screen moe-theme">
        <div class="header">
          <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
          <span> API Settings </span>
          <span style="width: 30px"></span>
        </div>

        <!-- Content scroll area -->
        <div class="form-container">
          <!-- 1. Cloud brain card -->
          <div class="moe-card">
            <div class="moe-card-header">
              <span class="icon">‚òÅÔ∏è</span>
              <h3>API Connection</h3>
            </div>
            <div class="moe-card-body">
              <div class="form-group">
                <label>Proxy URL</label>
                <input
                  type="text"
                  id="proxy-url"
                  placeholder="https://api.openai.com"
                  class="moe-input"
                />
              </div>
              <div class="form-group">
                <label>API Key</label>
                <input
                  type="password"
                  id="api-key"
                  placeholder="sk-..."
                  class="moe-input"
                />
              </div>
              <div class="form-group">
                <label>Model (type manually or select after fetching)</label>
                <!-- 1. id="model-select" is the real input, only its value is read on save -->
                <input
                  type="text"
                  id="model-select"
                  class="moe-input"
                  placeholder="e.g. gpt-4o, claude-3-5-sonnet"
                />
                <select
                  id="fetched-model-list"
                  class="moe-input"
                  style="
                    margin-top: 5px;
                    display: none;
                    border: 1px dashed var(--accent-color);
                  "
                  onchange="
                    document.getElementById('model-select').value = this.value
                  "
                >
                  <option value="">‚ñº Click here to select a fetched model</option>
                </select>
              </div>
              <div class="form-group">
                <label>Preset Config</label>
                <div class="bubble-preset-manager">
                  <select id="api-preset-select" class="moe-input"></select>
                  <button id="manage-api-presets-btn" class="moe-btn-small">
                    Manage
                  </button>
                </div>
              </div>
              <div class="form-group">
                <label
                  >Temperature (randomness):
                  <span
                    id="temperature-value"
                    style="color: var(--accent-color)"
                    >0.8</span
                  ></label
                >
                <input
                  type="range"
                  id="temperature-slider"
                  min="0"
                  max="2"
                  step="0.1"
                  value="0.8"
                  class="moe-slider"
                />
              </div>
              <div class="form-group" style="margin-top:10px">
                <label>CORS Proxy <span style="font-size:11px;color:#888">(needed when deployed to web)</span></label>
                <select id="api-cors-proxy" class="moe-input">
                  <option value="">None (local only)</option>
                  <option value="https://corsproxy.io/?">corsproxy.io (prepend style)</option>
                  <option value="custom">Custom Cloudflare Worker...</option>
                </select>
              </div>
              <div id="api-custom-proxy-group" class="form-group" style="display:none">
                <label>Cloudflare Worker URL <span style="font-size:11px;color:#888">(no trailing slash)</span></label>
                <input type="text" id="api-custom-proxy-url" class="moe-input" placeholder="https://my-worker.username.workers.dev"/>
              </div>
              <button id="fetch-models-btn" class="moe-btn-secondary">
                üì° Fetch Model List
              </button>
            </div>
          </div>

          <!-- 2. Voice synthesis card -->
          <div class="moe-card">
            <div class="moe-card-header">
              <span class="icon">üó£Ô∏è</span>
              <h3>Minimax Voice</h3>
            </div>
            <div class="moe-card-body">
              <div class="form-group">
                <label>Group ID</label>
                <input type="text" id="minimax-group-id" class="moe-input" />
              </div>
              <div class="form-group">
                <label>API Key</label>
                <input type="password" id="minimax-api-key" class="moe-input" />
              </div>
              <div class="form-group">
                <label>Service Region</label>
                <select id="minimax-provider-select" class="moe-input">
                  <option value="cn">China</option>
                  <option value="io">International</option>
                </select>
              </div>
              <div class="form-group">
                <label>Voice Model</label>
                <select
                  id="minimax-speech-model-select"
                  class="moe-input"
                ></select>
              </div>
              <button
                id="fetch-minimax-speech-models-btn"
                class="moe-btn-secondary"
              >
                üéµ Fetch Voice Models
              </button>
            </div>
          </div>

          <!-- 3. Background activity card -->
          <div class="moe-card">
            <div class="moe-card-header">
              <span class="icon">ü§ñ</span>
              <h3>Character Background Activity</h3>
            </div>
            <div class="moe-card-body">
              <div class="form-group">
                <label class="toggle-switch-label">
                  <span class="toggle-switch-text">Enable Background Activity</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="background-activity-switch" />
                    <span class="slider"></span>
                  </label>
                </label>
              </div>
              <div
                class="form-group"
                style="
                  margin-top: 15px;
                  padding-top: 15px;
                  border-top: 1px dashed #eee;
                  display: flex;
                  justify-content: space-between;
                  align-items: center;
                "
              >
                <div>
                  <span class="toggle-switch-text" style="font-weight: bold"
                    >Enable System Notifications</span
                  >
                  <!-- ‚ñº‚ñº‚ñº Updated layout: button and hint on same line ‚ñº‚ñº‚ñº -->
                  <div
                    style="
                      font-size: 12px;
                      color: #888;
                      margin-top: 6px;
                      display: flex;
                      align-items: center;
                    "
                  >
                    <span>iOS: add to home screen; Android: grant permission</span>
                    <button
                      id="check-notification-perm-btn"
                      style="
                        margin-left: 10px;
                        padding: 2px 10px;
                        background-color: rgba(0, 123, 255, 0.1);
                        color: #007bff;
                        border: 1px solid rgba(0, 123, 255, 0.2);
                        border-radius: 12px;
                        font-size: 11px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 3px;
                      "
                    >
                      <span>üîç</span> Check Permission
                    </button>
                    <button
                      id="test-system-notification-btn"
                      style="
                        margin-left: 5px;
                        padding: 2px 10px;
                        background-color: rgba(40, 167, 69, 0.1);
                        color: #28a745;
                        border: 1px solid rgba(40, 167, 69, 0.2);
                        border-radius: 12px;
                        font-size: 11px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 3px;
                      "
                    >
                      <span>üîî</span> Test Send
                    </button>
                  </div>
                </div>
                <label class="toggle-switch">
                  <input type="checkbox" id="system-notification-switch" />
                  <span class="slider"></span>
                </label>
              </div>
              <div
                id="background-activity-details"
                style="display: none; margin-top: 10px"
              >
                <div class="form-group">
                  <label>Check Interval (seconds)</label>
                  <input
                    type="number"
                    id="background-interval-input"
                    min="30"
                    value="60"
                    class="moe-input center-text"
                  />
                </div>
                <div class="form-group">
                  <label>Character Frequency Settings</label>
                  <div
                    id="background-activity-char-list"
                    class="moe-list-box"
                  ></div>
                  <div class="moe-btn-group">
                    <button id="bg-select-all-chars" class="moe-btn-mini">
                      Select All
                    </button>
                    <button id="bg-deselect-all-chars" class="moe-btn-mini">
                      Deselect All
                    </button>
                  </div>
                </div>
                <div class="form-group">
                  <label>Set Frequency</label>
                  <div class="moe-btn-group">
                    <button class="moe-btn-mini bg-freq-btn" data-freq="low">
                      Low
                    </button>
                    <button class="moe-btn-mini bg-freq-btn" data-freq="medium">
                      Medium
                    </button>
                    <button class="moe-btn-mini bg-freq-btn" data-freq="high">
                      High
                    </button>
                    <button class="moe-btn-mini bg-freq-btn" data-freq="none">
                      Off
                    </button>
                  </div>
                </div>
              </div>
              <div class="moe-divider"></div>
              <div class="form-group">
                <label>Block Cooldown (hours)</label>
                <input
                  type="number"
                  id="block-cooldown-input"
                  min="0.1"
                  step="0.1"
                  value="1"
                  class="moe-input center-text"
                />
              </div>
            </div>
          </div>

          <!-- 4. Image generation card -->
          <div class="moe-card">
            <div class="moe-card-header">
              <span class="icon">üé®</span>
              <h3>Image Generation</h3>
            </div>
            <div class="moe-card-body">
              <div class="form-group">
                <label class="toggle-switch-label">
                  <span class="toggle-switch-text">Enable Image Generation</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="novelai-switch" />
                    <span class="slider"></span>
                  </label>
                </label>
              </div>
              <div id="novelai-details" style="display: none; margin-top: 10px">

                <!-- Provider tab switcher -->
                <div class="form-group">
                  <label>Provider</label>
                  <div class="img-gen-provider-tabs">
                    <button class="img-gen-tab active" data-provider="novelai"
                      onclick="switchImageGenProvider('novelai')">NovelAI</button>
                    <button class="img-gen-tab" data-provider="pixai"
                      onclick="switchImageGenProvider('pixai')">PixAI</button>
                  </div>
                </div>

                <!-- NovelAI section -->
                <div id="novelai-provider-section">
                  <div class="form-group">
                    <label>Model</label>
                    <select id="novelai-model" class="moe-input">
                      <option value="nai-diffusion-4-curated-preview">V4.5 Curated</option>
                      <option value="nai-diffusion-4-5-full">V4.5 Full</option>
                      <option value="nai-diffusion-3">V3 Anime</option>
                    </select>
                  </div>
                  <div class="form-group">
                    <label>API Key</label>
                    <div style="position: relative">
                      <input type="password" id="novelai-api-key" class="moe-input"/>
                      <span id="novelai-key-toggle"
                        style="position:absolute;right:10px;top:10px;cursor:pointer">üëÄ</span>
                    </div>
                  </div>
                  <div class="moe-btn-group">
                    <button type="button" id="novelai-settings-btn" class="moe-btn-secondary">Settings</button>
                    <button type="button" id="novelai-test-btn" class="moe-btn-secondary">Test</button>
                  </div>
                </div>

                <!-- PixAI section -->
                <div id="pixai-provider-section" style="display:none">
                  <div class="form-group">
                    <label>Model</label>
                    <select id="pixai-model" class="moe-input">
                      <option value="1935090615918113018">Tsubaki v1.1 ‚Äî Natural Language (DiT)</option>
                      <option value="1934789864939078594">Tsubaki Flash ‚Äî Fast (DiT)</option>
                      <option value="1894092844569363483">Tsubaki ‚Äî Multi-character (DiT)</option>
                      <option value="1914519679917387494">Serin ‚Äî Korean Style (DiT)</option>
                      <option value="1861558740588989558">Haruka v2 ‚Äî Accurate Hands (SDXL)</option>
                      <option value="1811528826405408057">Hoshino ‚Äî Japanese Style (SDXL)</option>
                    </select>
                  </div>
                  <div class="form-group">
                    <label>API Key</label>
                    <div style="position: relative">
                      <input type="password" id="pixai-api-key" class="moe-input"/>
                      <span id="pixai-key-toggle"
                        style="position:absolute;right:10px;top:10px;cursor:pointer">üëÄ</span>
                    </div>
                  </div>
                  <div class="moe-btn-group">
                    <button type="button" id="pixai-settings-btn" class="moe-btn-secondary">Settings</button>
                    <button type="button" id="pixai-test-btn" class="moe-btn-secondary">Test</button>
                  </div>
                </div>

              </div>
            </div>
          </div>
          <!-- 4.5. Pollinations image generation card (new) -->
          <div class="moe-card">
            <div class="moe-card-header">
              <span class="icon">üå∏</span>
              <h3>Pollinations Image Generation</h3>
            </div>
            <div class="moe-card-body">
              <div class="form-group">
                <label>API Key (optional, for advanced features / no watermark)</label>
                <input
                  type="password"
                  id="pollinations-api-key"
                  placeholder="Bearer ..."
                  class="moe-input"
                />
                <p style="font-size: 12px; color: #888; margin-top: 5px">
                  * If left blank, the free public API will be used (may include watermark or be limited).
                </p>
              </div>
            </div>
          </div>

          <!-- 5. Storage & Backup card -->
          <div class="moe-card">
            <div class="moe-card-header">
              <span class="icon">üíæ</span>
              <h3>Storage & Backup</h3>
            </div>
            <div class="moe-card-body">
              <div class="form-group">
                <label
                  >Image Compression Quality:
                  <span id="image-quality-value">0.7</span></label
                >
                <input
                  type="range"
                  id="image-quality-slider"
                  min="0.1"
                  max="1.0"
                  step="0.1"
                  value="0.7"
                  class="moe-slider"
                />
              </div>
              <button class="moe-btn-secondary" id="compress-all-images-btn">
                üìâ Compress All Images
              </button>
              <p
                id="image-data-size-display"
                style="
                  text-align: center;
                  font-size: 12px;
                  color: #aaa;
                  margin-top: 5px;
                "
              >
                ...
              </p>

              <div class="moe-divider"></div>

              <h4
                style="
                  font-size: 14px;
                  margin-bottom: 10px;
                  color: var(--accent-color);
                "
              >
                ‚òÅÔ∏è GitHub Cloud Backup
              </h4>
              <div class="form-group">
                <input
                  type="password"
                  id="github-token"
                  placeholder="Token"
                  class="moe-input"
                  style="margin-bottom: 5px"
                />
                <input
                  type="text"
                  id="github-username"
                  placeholder="Username"
                  class="moe-input"
                  style="margin-bottom: 5px"
                />
                <input
                  type="text"
                  id="github-repo"
                  placeholder="Repository name"
                  class="moe-input"
                  style="margin-bottom: 5px"
                />
                <input
                  type="text"
                  id="github-path"
                  placeholder="Path (optional)"
                  class="moe-input"
                />
              </div>
              <div class="form-group">
                <label class="toggle-switch-label">
                  <span class="toggle-switch-text">Auto Backup </span>
                  <input type="checkbox" id="github-auto-backup-switch" />
                  <span class="toggle-switch-slider"></span>
                </label>
              </div>
              <!-- Insert below github-path input -->
              <div class="form-group" style="margin-top: 5px">
                <label>Auto Backup Mode</label>
                <div style="display: flex; gap: 10px">
                  <select
                    id="github-backup-mode"
                    class="moe-input"
                    style="flex: 1"
                  >
                    <option value="full">Full</option>
                    <option value="stream">Streaming (chunked/stable)</option>
                  </select>
                  <input
                    type="number"
                    id="github-backup-interval"
                    class="moe-input"
                    style="width: 80px"
                    placeholder="minutes"
                    value="30"
                    min="5"
                  />
                  <span style="align-self: center; font-size: 12px; color: #888"
                    >min</span
                  >
                </div>
              </div>

              <div class="moe-btn-group">
                <button id="manual-github-backup-btn" class="moe-btn-secondary">
                  ‚òÅÔ∏è Upload (Full)
                </button>
                <button
                  id="manual-github-restore-btn"
                  class="moe-btn-secondary"
                >
                  üì• Restore (Full)
                </button>
              </div>
              <div class="moe-btn-group" style="margin-top: 10px">
                <button
                  id="git-stream-upload-btn"
                  class="moe-btn-secondary"
                  style="background-color: #6f42c1; color: white"
                >
                  üåä Git Stream Upload
                </button>
                <button
                  id="git-stream-restore-btn"
                  class="moe-btn-secondary"
                  style="background-color: #6f42c1; color: white"
                >
                  üé£ Git Stream Import
                </button>
              </div>
              <p style="font-size: 12px; color: #999; margin-top: 5px">
                *
                Streaming mode splits data into multiple files (per table) for upload, solving crashes caused by large files.
              </p>

              <div class="moe-divider"></div>

              <h4
                style="
                  font-size: 14px;
                  margin-bottom: 10px;
                  color: var(--accent-color);
                "
              >
                üì¶ Local Backup
              </h4>
              <div class="moe-btn-group">
                <button class="moe-btn-secondary" id="export-data-btn">
                  Export
                </button>
                <button class="moe-btn-secondary" id="import-btn">Import</button>
                <button class="moe-btn-secondary" id="export-data-stream-btn">
                  Stream Export
                </button>
              </div>
              <button
                class="moe-btn-secondary"
                id="advanced-transfer-btn"
                style="margin-top: 8px; width: 100%"
              >
                Advanced Import/Export
              </button>

              <div class="moe-divider"></div>
              <button class="moe-btn-danger" id="clear-orphaned-data-btn">
                üßπ Clear Orphaned Data
              </button>
              <div class="moe-divider"></div>
              <button
                class="moe-btn-secondary"
                id="repair-data-btn"
                style="
                  background-color: #ff9800;
                  color: white;
                  margin-bottom: 10px;
                  width: 100%;
                  font-weight: bold;
                "
              >
                üîß Quick Fix (fix data structure errors)
              </button>
              <button
                class="moe-btn-danger"
                id="factory-reset-btn"
                style="
                  background-color: #c82333;
                  margin-top: 10px;
                  width: 100%;
                  font-weight: bold;
                "
              >
                üß® Factory Reset (clear all data)
              </button>
            </div>
          </div>

          <div style="text-align: center; margin-bottom: 15px; margin-top: 5px">
            <a
              href="https://jcny642xl7ll.feishu.cn/wiki/KGsnwECKji2xdxkCqDbcZNOnndd"
              target="_blank"
              style="
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 10px 20px;
                background-color: rgba(255, 255, 255, 0.9);
                color: var(--accent-color, #007bff);
                text-decoration: none;
                border-radius: 25px;
                font-size: 14px;
                font-weight: 600;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
                border: 1px solid rgba(0, 0, 0, 0.05);
                transition: transform 0.2s;
              "
            >
              <span>üìñ</span> Tutorials written by rabbit-k
            </a>
          </div>

          <div style="margin: 10px 0; text-align: center">
            <button
              onclick="window.openBugStation()"
              style="
                background: #fff0f6;
                color: #eb2f96;
                border: 2px dashed #ffadd2;
                border-radius: 15px;
                padding: 8px 20px;
                font-size: 13px;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 5px;
              "
            >
              üöë Error Emergency Station
              <span style="font-size: 10px; opacity: 0.7">(click to copy error)</span>
            </button>
          </div>

          <!-- Bottom padding to prevent floating button from blocking content -->
          <div style="height: 80px"></div>
        </div>

        <!-- ‚òÖ‚òÖ‚òÖ Cute floating save button ‚òÖ‚òÖ‚òÖ -->
        <button id="save-api-settings-btn" class="moe-fab-save">
          üíæ<span style="font-size: 12px; display: block; margin-top: -2px"
            >Save</span
          >
        </button>

        <!-- Hidden input -->
        <input
          id="import-data-input"
          type="file"
          accept="application/json"
          hidden
        />
      </div>

      <div id="chat-list-screen" class="screen">
        <!-- Main header (only shown in message list) -->
        <div class="header" id="main-chat-list-header">
          <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
          <span id="chat-list-title">Messages</span>
          <div class="header-actions">
            <span class="action-btn" id="add-group-chat-btn" title="Create Group Chat">
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M21 21L19 19"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </span>

            <span
              class="action-btn"
              id="import-character-card-btn"
              title="Import Character Card"
            >
              <svg
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
              </svg>
            </span>

            <span class="action-btn" id="add-chat-btn">+</span>
          </div>
        </div>

        <!-- Message list view -->
        <div id="messages-view" class="chat-list-view active">
          <div id="chat-list">
            <!-- JS will generate the chat list here -->
          </div>
        </div>

        <!-- Feed view -->
        <div id="qzone-screen" class="chat-list-view">
          <div class="qzone-header">
            <span class="back-btn" id="qzone-back-btn">‚Äπ</span>
            <!-- This button only handles returning from feed -->
            <span>Friends Feed</span>

            <div class="header-actions">
              <span
                class="action-btn"
                id="clear-qzone-posts-btn"
                title="Clear Feed"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"
                  />
                </svg>
              </span>
            </div>
          </div>
          <div class="qzone-content">
            <div class="qzone-profile-header">
              <div id="qzone-banner-container" class="qzone-banner-container">
                <img
                  id="qzone-banner-img"
                  src="https://files.catbox.moe/r5heyt.gif"
                  alt="Background"
                />
                <input
                  type="file"
                  id="qzone-banner-input"
                  accept="image/*"
                  hidden
                />
              </div>
              <div class="qzone-user-info">
                <div id="qzone-avatar-container" class="qzone-avatar-container">
                  <img
                    id="qzone-avatar-img"
                    src="https://files.catbox.moe/q6z5fc.jpeg"
                    alt="Avatar"
                  />
                  <input
                    type="file"
                    id="qzone-avatar-input"
                    accept="image/*"
                    hidden
                  />
                </div>
                <span id="qzone-nickname">{{user}}</span>
              </div>
            </div>
            <div class="qzone-actions-bar">
              <div class="action-item" id="create-shuoshuo-btn">
                <span>Status</span>
              </div>
              <div class="action-item" id="create-post-btn">
                <span>Post</span>
              </div>
              <div class="action-item" id="open-album-btn">
                <span>Album</span>
              </div>
            </div>
            <div id="qzone-posts-list"></div>
          </div>
        </div>

        <!-- Favorites view -->
        <div id="favorites-view" class="chat-list-view">
          <div class="header">
            <span class="back-btn" id="favorites-back-btn">‚Äπ</span>
            <span>My Favorites</span>
            <!-- New edit button -->
            <span class="action-btn" id="favorites-edit-btn">Edit</span>
          </div>

          <!-- Search bar container -->
          <div class="search-bar-container">
            <input
              type="search"
              id="favorites-search-input"
              placeholder="Search favorites by title, content or author..."
            />
            <button
              id="favorites-search-clear-btn"
              class="search-clear-btn"
              style="display: none"
            >
              √ó
            </button>
          </div>

          <div id="favorites-list" class="list-container">
            <!-- Favorites will be dynamically generated by JS here -->
          </div>

          <!-- New: favorites page bottom action bar -->
          <div id="favorites-action-bar" style="display: none">
            <button id="favorites-delete-selected-btn" class="action-bar-btn">
              Delete (0)
            </button>
          </div>
        </div>

        <div id="memories-view" class="chat-list-view">
          <div class="header">
            <span class="back-btn" id="memories-back-btn">‚Äπ</span>
            <span>Our Memories</span>
            <span class="action-btn" id="add-countdown-btn">+</span>
          </div>
          <div
            id="memories-list"
            class="list-container"
            style="
              padding: 15px;
              display: flex;
              flex-direction: column;
              gap: 15px;
            "
          >
            <!-- Memory cards will be dynamically generated by JS here -->
          </div>
        </div>

        <!-- Bottom navigation bar -->
        <div id="chat-list-bottom-nav">
          <div class="nav-item active" data-view="messages-view">
            <span>Messages</span>
          </div>
          <div class="nav-item" data-view="qzone-screen">
            <span>Feed</span>
          </div>

          <div class="nav-item" data-view="memories-view">
            <span>Memories</span>
          </div>

          <div class="nav-item" data-view="favorites-view">
            <span>Favorites</span>
          </div>
        </div>
      </div>

      <div id="album-screen" class="screen">
        <!-- 1. Page header with back button and title -->
        <div class="header">
          <span class="back-btn" id="album-back-btn">‚Äπ</span>
          <span>My Album</span>
          <span class="action-btn" id="create-album-btn-page">+</span>
        </div>

        <!-- 2. Page content container -->
        <div class="list-container">
          <div id="album-grid-page">
            <!-- Album list will be dynamically generated by JS here -->
          </div>
        </div>
      </div>

      <div id="album-photos-screen" class="screen">
        <!-- 1. Page header -->
        <div class="header">
          <span class="back-btn" id="album-photos-back-btn">‚Äπ</span>
          <span id="album-photos-title">Album Name</span>
          <span class="action-btn" id="album-upload-photo-btn">Upload</span>
        </div>

        <!-- 2. Page content container -->
        <div class="list-container">
          <div id="photos-grid-page">
            <!-- Photo list will be dynamically generated by JS here -->
          </div>

          <div id="photo-viewer-modal" class="modal">
            <!-- 1. Close button -->
            <button id="photo-viewer-close-btn">√ó</button>

            <!-- 2. Previous photo button -->
            <button id="photo-viewer-prev-btn" class="nav-arrow">‚Äπ</button>

            <!-- 3. Image container -->
            <div class="photo-viewer-content">
              <img id="photo-viewer-image" src="" alt="Fullscreen photo preview" />
            </div>

            <!-- 4. Next photo button -->
            <button id="photo-viewer-next-btn" class="nav-arrow">‚Ä∫</button>
          </div>
        </div>
      </div>

      <input
        type="file"
        id="album-photo-input"
        accept="image/*"
        multiple
        hidden
      />

      <div id="chat-interface-screen" class="screen">
        <div class="header">
          <!-- Default controls: title, status bar, and regular buttons -->
          <div class="default-controls">
            <span class="back-btn" id="back-to-list-btn">‚Äπ</span>

            <!-- Title and status container -->
            <div id="chat-header-title-wrapper">
              <div id="chat-header-main-line">
                <span id="chat-header-title">Chat</span>
                <!-- [New] Group announcement button -->
                <span id="group-announcement-btn" title="Group Announcement">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <rect
                      x="3"
                      y="3"
                      width="18"
                      height="18"
                      rx="2"
                      ry="2"
                    ></rect>
                    <line x1="7" y1="15" x2="17" y2="15"></line>
                  </svg>
                </span>
              </div>
              <div id="chat-header-status">
                <span class="status-dot"></span>
                <span class="status-text">Online</span>
              </div>
            </div>

            <div class="header-actions">
              <!-- Inner voice button -->
              <span
                class="action-btn"
                id="char-heart-btn"
                title="Inner Voice"
                style="display: none; cursor: pointer"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="#ff4d6d"
                  stroke="#ffc3d0"
                  stroke-width="1.5"
                >
                  <path
                    d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"
                  />
                </svg>
              </span>
              <span class="action-btn" id="listen-together-btn" title="Listen Together"
                ><img
                  src="https://i.postimg.cc/CxjpF6gK/yi-qi-ting.png"
                  alt="Listen Together"
              /></span>
              <span class="action-btn" id="chat-settings-btn" title="Chat Settings"
                ><img
                  src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png"
                  alt="Settings"
              /></span>
            </div>
          </div>

          <!-- Multi-select mode controls -->
          <div class="selection-controls">
            <span id="selection-cancel-btn">Cancel</span>
            <span id="selection-count"></span>
            <div class="header-actions">
              <span id="selection-favorite-btn" class="action-btn">Favorite</span>
              <span id="selection-share-btn" class="action-btn">Share</span>
              <span
                id="selection-delete-btn"
                class="action-btn"
                style="color: #ff3b30"
                >Delete</span
              >
            </div>
          </div>
        </div>

        <div
          id="chat-pet-container"
          style="
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
          "
        >
          <div
            id="chat-pet"
            style="
              display: none;
              position: absolute;
              cursor: grab;
              user-select: none;
              pointer-events: all;
              font-size: 80px;
              line-height: 1;
              text-align: center;
            "
          >
            <!-- Pet will be displayed here -->
          </div>
        </div>

        <!-- Chat messages area (unchanged) -->
        <div id="chat-messages">
          <div id="typing-indicator">Typing...</div>
        </div>

        <!-- Input area (final modified version) -->
        <div id="chat-input-area">
          <div id="reply-preview-bar">
            <div class="reply-preview-content">
              <div class="sender">Replying to xxx:</div>
              <div class="text">Quoted message content...</div>
            </div>
            <span id="cancel-reply-btn">√ó</span>
          </div>

          <div id="chat-input-actions-top">
            <button
              id="open-sticker-panel-btn"
              class="chat-action-icon-btn action-button"
              title="Sticker Panel"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
            </button>

            <!-- New home for "Regenerate reply" button -->
            <button id="reroll-btn" class="action-button" title="Regenerate Reply">
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
              </svg>
            </button>

            <button
              id="quick-reply-btn"
              class="chat-action-icon-btn action-button"
              title="Quick Reply"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <!-- Bubble outline -->
                <path
                  d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"
                ></path>
                <!-- Two text lines inside representing preset content -->
                <line x1="8" y1="9" x2="16" y2="9"></line>
                <line x1="8" y1="13" x2="14" y2="13"></line>
              </svg>
            </button>

            <button
              id="send-photo-btn"
              class="chat-action-icon-btn action-button"
              title="Send Photo"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path
                  d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"
                />
                <circle cx="12" cy="13" r="4" />
              </svg>
            </button>
            <button
              id="upload-image-btn"
              class="chat-action-icon-btn action-button"
              title="Upload Image"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
            <button
              id="transfer-btn"
              class="chat-action-icon-btn action-button"
              title="Transfer Money"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path>
              </svg>
            </button>
            <button
              id="voice-message-btn"
              class="chat-action-icon-btn action-button"
              title="Send Voice Message"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path
                  d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"
                />
                <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                <path d="M12 19v4" />
                <path d="M8 23h8" />
              </svg>
            </button>
            <button
              id="send-waimai-request-btn"
              class="chat-action-icon-btn action-button"
              title="Send Food Delivery Request"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z" />
                <line x1="3" y1="6" x2="21" y2="6" />
                <path d="M16 10a4 4 0 0 1-8 0" />
              </svg>
            </button>
            <button
              id="video-call-btn"
              class="chat-action-icon-btn action-button"
              title="Video Call"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <polygon points="23 7 16 12 23 17 23 7"></polygon>
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
              </svg>
            </button>
            <button
              id="group-video-call-btn"
              class="chat-action-icon-btn action-button"
              title="Group Video Call"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
              </svg>
            </button>
            <button
              id="send-poll-btn"
              class="chat-action-icon-btn action-button"
              title="Create Poll"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M8 6h10" />
                <path d="M6 6h.01" />
                <path d="M8 12h10" />
                <path d="M6 12h.01" />
                <path d="M8 18h10" />
                <path d="M6 18h.01" />
              </svg>
            </button>
            <button
              id="share-link-btn"
              class="chat-action-icon-btn action-button"
              title="Share Link"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path
                  d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"
                ></path>
                <path
                  d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"
                ></path>
              </svg>
            </button>

            <button
              id="send-location-btn"
              class="chat-action-icon-btn action-button"
              title="Send Location"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
              </svg>
            </button>

            <!-- Timeline/Archive button (in toolbar) -->
            <button
              id="timeline-branch-btn"
              class="chat-action-icon-btn action-button"
              title="Timeline/Archive"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <!-- This is a forked line icon -->
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 21v-6"></path>
                <path d="M12 9V3"></path>
                <path
                  d="M7 3.3a9.8 9.8 0 0 0-4.7 8.7c0 5.5 4.5 10 10 10s10-4.5 10-10a9.8 9.8 0 0 0-4.7-8.7"
                ></path>
              </svg>
            </button>

            <button
              id="open-tarot-btn"
              class="chat-action-icon-btn action-button"
              title="Tarot Reading"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <!-- Background left card -->
                <path
                  d="M7 6.5L4 7.5V17.5L7 16.5V6.5Z"
                  stroke="currentColor"
                  stroke-width="2.6"
                  stroke-linejoin="round"
                />
                <!-- Background right card -->
                <path
                  d="M17 6.5L20 7.5V17.5L17 16.5V6.5Z"
                  stroke="currentColor"
                  stroke-width="2.6"
                  stroke-linejoin="round"
                />
                <!-- Front center card -->
                <rect
                  x="7"
                  y="5"
                  width="10"
                  height="15"
                  rx="1.5"
                  stroke="currentColor"
                  stroke-width="2.6"
                />
                <!-- Center card star -->
                <path
                  d="M12 9.5L13.12 11.79L15.61 12.17L13.8 13.92L14.24 16.4L12 15.2L9.76 16.4L10.2 13.92L8.39 12.17L10.88 11.79L12 9.5Z"
                  fill="currentColor"
                />
              </svg>
            </button>

            <button
              id="pet-action-btn"
              class="chat-action-icon-btn action-button"
              title="My Pet"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <!-- Main outline: asymmetric ears for tilted head effect -->
                <path
                  d="M3.5 14.5C3.5 20.5 20.5 20.5 20.5 14.5C20.5 9 17.5 5.5 12.5 8.7C6.5 4.5 3.5 9 3.5 14.5Z"
                  stroke="currentColor"
                  stroke-width="2.6"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <!-- Eyes -->
                <circle cx="8.5" cy="15" r="1.5" fill="currentColor" />
                <circle cx="15.5" cy="15" r="1.5" fill="currentColor" />
                <!-- Two left whiskers -->
                <path
                  d="M4.5 14.3L2.5 13.3"
                  stroke="currentColor"
                  stroke-width="2.6"
                  stroke-linecap="round"
                />
                <path
                  d="M4.5 15.7L2.5 16.7"
                  stroke="currentColor"
                  stroke-width="2.6"
                  stroke-linecap="round"
                />
                <!-- Two right whiskers -->
                <path
                  d="M19.5 14.3L21.5 13.3"
                  stroke="currentColor"
                  stroke-width="2.6"
                  stroke-linecap="round"
                />
                <path
                  d="M19.5 15.7L21.5 16.7"
                  stroke="currentColor"
                  stroke-width="2.6"
                  stroke-linecap="round"
                />
              </svg>
            </button>
            <!-- Advance Plot button -->
            <button
              id="advance-plot-btn"
              class="chat-action-icon-btn action-button"
              title="Advance Plot ‚Äì AI ti·∫øp t·ª•c c√¢u chuy·ªán kh√¥ng c·∫ßn user reply"
            >
              <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="5,4 13,12 5,20" fill="currentColor" stroke="none"/>
                <polygon points="13,4 21,12 13,20" fill="currentColor" stroke="none"/>
              </svg>
            </button>

            <!-- Impersonate User button -->
            <button
              id="impersonate-user-btn"
              class="chat-action-icon-btn action-button"
              title="Impersonate User ‚Äì AI g·ª£i √Ω l·ªùi tho·∫°i cho b·∫°n (ch·ªâ ƒëi·ªÅn v√†o √¥ chat)"
            >
              <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="8" r="4"/>
                <path d="M4 20c0-4 3.6-7 8-7s8 3 8 7"/>
                <path d="M17 13l2 2 4-4" stroke-width="2" stroke="currentColor"/>
              </svg>
            </button>

            <!-- Poke / Pat button -->
            <button
              id="poke-pat-btn"
              class="chat-action-icon-btn action-button"
              title="Poke / Pat"
            >
              <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 8h1a4 4 0 0 1 0 8h-1"/>
                <path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"/>
                <line x1="6" y1="1" x2="6" y2="4"/>
                <line x1="10" y1="1" x2="10" y2="4"/>
                <line x1="14" y1="1" x2="14" y2="4"/>
              </svg>
            </button>

            <!-- Aurora multimedia button (changed to monochrome) -->
            <button
              id="aurora-media-btn"
              class="chat-action-icon-btn action-button"
              title="Roam Together (video/novel)"
            >
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M12 3C7.03 3 3 7.03 3 12C3 16.97 7.03 21 12 21C16.97 21 21 16.97 21 12C21 7.03 16.97 3 12 3Z"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M15 9L9 15M9 9L15 15"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M12 8V16"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
          </div>
          <div id="chat-input-main-row">
            <textarea
              id="chat-input"
              rows="1"
              placeholder="Type a message..."
            ></textarea>
            <div id="input-actions-wrapper">
              <button id="wait-reply-btn" title="Wait for Reply">
                <img
                  src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png"
                  alt="Wait for Reply"
                />
              </button>
              <button id="send-btn" class="action-button">Send</button>
            </div>
          </div>
        </div>

        <div id="chat-lock-overlay">
          <div id="chat-lock-content"></div>
        </div>

        <div id="sticker-panel">
          <div id="sticker-panel-header">
            <span class="panel-btn" id="close-sticker-panel-btn">Cancel</span>
            <span class="title">Stickers</span>
            <!-- "Edit" and "Done" buttons -->
            <div style="display: flex; gap: 10px">
              <span class="panel-btn" id="edit-user-stickers-btn">Edit</span>
              <span
                class="panel-btn"
                id="done-user-stickers-btn"
                style="display: none"
                >Done</span
              >
              <span class="panel-btn" id="add-sticker-btn">Add</span>
              <span class="panel-btn" id="upload-sticker-btn">Upload</span>
            </div>
          </div>
          <div id="sticker-grid"></div>

          <!-- Inside #sticker-panel, find id="sticker-panel-footer" -->

          <div id="sticker-category-tabs">
            <!-- Category tabs will be dynamically generated by JS here -->
          </div>

          <div id="sticker-panel-footer" style="display: none">
            <!-- Move sticker button -->
            <button id="move-selected-stickers-btn">Move to category...</button>
            <!-- Delete sticker button -->
            <button id="delete-selected-user-stickers-btn">Delete Selected (0)</button>
          </div>
        </div>

        <input
          type="file"
          id="sticker-upload-input"
          accept="image/*"
          style="display: none"
          multiple
        />
        <input
          type="file"
          id="image-upload-input"
          accept="image/*"
          style="display: none"
        />

        <!-- Music player (unchanged) -->
        <div id="music-player-overlay">
          <div class="music-player-window">
            <!-- 1. Top avatar area -->
            <div id="music-avatars-container">
              <img id="music-char-avatar" src="" alt="Character Avatar" />
              <svg id="heartbeat-line" viewBox="0 0 80 30">
                <path
                  class="heartbeat-path"
                  d="M 5 15 Q 20 0 30 15 T 55 15 L 75 15"
                ></path>
                <path
                  class="heartbeat-heart"
                  d="M 0 -2 a 2 2 0 0 1 4 0 v 2 a 2 2 0 0 1 -4 0 z"
                ></path>
              </svg>
              <img id="music-user-avatar" src="" alt="User Avatar" />
            </div>

            <div id="music-time-counter">Listened together for 0.0 hours</div>

            <!-- 2. Top action buttons -->
            <div class="music-player-top-actions">
              <div class="top-left-cluster">
                <button id="music-return-btn">‚Äπ</button>
                <button id="music-exit-btn">√ó</button>
              </div>
              <span id="music-playlist-btn">‚ò∞</span>
            </div>

            <!-- 3. Cover and lyrics toggle container -->
            <div id="music-display-area">
              <img
                id="music-album-cover"
                src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png"
                alt="Album Cover"
              />
              <div id="music-lyrics-container">
                <div id="music-lyrics-list">
                  <div class="lyric-line">‚ô™ No lyrics available ‚ô™</div>
                </div>
              </div>
            </div>

            <!-- 4. Song info -->
            <div id="music-player-song-title">Add a song</div>
            <div id="music-player-artist">...</div>

            <!-- 5. Playback controls (unchanged) -->
            <div class="music-player-controls-wrapper">
              <div class="music-progress-bar-container">
                <div id="music-current-time" class="time-display">0:00</div>
                <div class="progress-bar">
                  <div id="music-progress-fill" class="progress-bar-fill"></div>
                </div>
                <div id="music-total-time" class="time-display">0:00</div>
              </div>
              <div class="music-controls">
                <button id="music-prev-btn">‚óÄ</button>
                <button id="music-play-pause-btn" class="play-pause-btn">
                  ‚ñ∂
                </button>
                <button id="music-next-btn">‚ñ∂</button>
                <button id="music-mode-btn">Sequential</button>
                <button id="toggle-lyrics-bar-btn" title="Desktop Lyrics">
                  Float
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="music-playlist-panel">
        <div class="playlist-header">
          <span class="panel-btn" id="close-playlist-btn">Back</span>
          <span>Playlist</span>
          <div>
            <span
              class="panel-btn"
              id="delete-expired-songs-btn"
              title="Clean up expired search songs"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M3 6H5H21"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6H19Z"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </span>
            <span class="panel-btn" id="add-song-local-btn">Local</span>
            <span class="panel-btn" id="add-song-url-btn">URL</span>
            <span class="panel-btn" id="add-song-search-btn">Search</span>
          </div>
        </div>

        <div class="playlist-body" id="playlist-body"></div>
      </div>
      <input
        type="file"
        id="local-song-upload-input"
        accept="audio/*"
        multiple
        style="display: none"
      />
      <input
        type="file"
        id="lrc-upload-input"
        accept=".lrc"
        style="display: none"
      />
    </div>

    <!-- Appearance settings page (ID and layout fixed) -->
    <div id="wallpaper-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span>Appearance Settings</span>
        <span style="width: 30px"></span>
      </div>

      <!-- Content scroll area -->
      <div class="form-container settings-scroll-container">
        <!-- 1. Lock screen & security card -->
        <div class="settings-group-card">
          <div class="settings-section-title">üîí Lock Screen & Security</div>

          <div class="setting-row">
            <label class="setting-label">Enable Lock Screen</label>
            <label class="toggle-switch-label">
              <input type="checkbox" id="enable-lock-screen-toggle" />
              <span class="toggle-switch-slider"></span>
            </label>
          </div>

          <div class="setting-item">
            <label>Lock Screen Password (leave blank for none)</label>
            <input
              type="text"
              id="password-set-input"
              class="moe-input"
              placeholder="Set unlock password"
            />
          </div>

          <div class="setting-item">
            <label>Lock Screen Wallpaper</label>
            <div class="preview-upload-box">
              <div id="lockscreen-wallpaper-preview" class="mini-preview">
                Preview
              </div>
              <button
                class="upload-btn-pill"
                onclick="
                  document
                    .getElementById('lockscreen-wallpaper-upload-input')
                    .click()
                "
              >
                Change Wallpaper
              </button>
            </div>
            <input
              type="file"
              id="lockscreen-wallpaper-upload-input"
              accept="image/*"
              hidden
            />
          </div>
        </div>
        <!-- 5. Advanced beautification (CSS) card -->
        <div class="settings-group-card">
          <div class="settings-section-title">Custom CSS Styling</div>

          <div class="setting-item">
            <div style="display: flex; gap: 5px; margin-bottom: 5px">
              <select
                id="theme-selector"
                class="moe-input select"
                style="flex: 1"
              ></select>
              <button id="rename-theme-btn" class="btn-icon">‚úèÔ∏è</button>
              <button id="delete-theme-btn" class="btn-icon danger">üóëÔ∏è</button>
            </div>
            <textarea
              id="theme-css-editor"
              class="moe-input code-area"
              rows="6"
              placeholder="Enter CSS code here..."
            ></textarea>
            <div class="css-actions">
              <button id="apply-theme-btn" class="upload-btn-pill primary">
                Apply
              </button>
              <button id="save-theme-btn" class="upload-btn-pill">Save</button>
              <button id="save-as-new-theme-btn" class="upload-btn-pill">
                Save As
              </button>
              <button id="export-theme-btn" class="upload-btn-pill secondary">
                Export
              </button>
              <button id="import-theme-btn" class="upload-btn-pill secondary">
                Import
              </button>
              <button
                id="reset-theme-css-btn"
                class="upload-btn-pill danger"
                style="background-color: #ff3b30; color: white"
              >
                Reset
              </button>
              <button
                id="manage-char-css-btn"
                class="upload-btn-pill"
                style="background-color: #ff9800; color: white"
              >
                Clean Character CSS
              </button>
              <input
                type="file"
                id="import-theme-input"
                accept=".json, .txt, .css, .docx"
                hidden
              />
            </div>
          </div>
        </div>

        <!-- 2. Home screen visual card -->
        <div class="settings-group-card">
          <div class="settings-section-title">üì± Home Screen Visual</div>

          <div class="setting-row">
            <label class="setting-label">Show Status Bar</label>
            <label class="toggle-switch-label">
              <input type="checkbox" id="show-status-bar-toggle" />
              <span class="toggle-switch-slider"></span>
            </label>
          </div>

          <div class="setting-row">
            <label class="setting-label">Dark Mode</label>
            <label class="toggle-switch-label">
              <!-- ‚òÖ‚òÖ‚òÖ Core fix: ID reverted to theme-toggle-switch, fixes error ‚òÖ‚òÖ‚òÖ -->
              <input type="checkbox" id="theme-toggle-switch" />
              <span class="toggle-switch-slider"></span>
            </label>
          </div>

          <div class="setting-row">
            <label class="setting-label">Remove Text Shadow</label>
            <label class="toggle-switch-label">
              <input type="checkbox" id="remove-home-font-shadow-toggle" />
              <span class="toggle-switch-slider"></span>
            </label>
          </div>

          <div class="setting-item">
            <label>Home Screen Wallpaper</label>
            <div class="preview-upload-box">
              <div id="wallpaper-preview" class="mini-preview">Preview</div>
              <button
                class="upload-btn-pill"
                onclick="
                  document.getElementById('wallpaper-upload-input').click()
                "
              >
                Change Wallpaper
              </button>
            </div>
            <input
              type="file"
              id="wallpaper-upload-input"
              accept="image/*"
              hidden
            />
          </div>

          <div class="setting-item">
            <label>Icon/Widget Font Color</label>
            <div class="color-picker-wrapper">
              <!-- 1. Color picker (keep original ID) -->
              <input
                type="color"
                id="home-icon-widget-text-color-picker"
                value="#FFFFFF"
              />

              <!-- 2. Text input, allows manual color code entry -->
              <input
                type="text"
                id="home-icon-widget-text-color-input"
                placeholder="#FFFFFF"
                maxlength="7"
                spellcheck="false"
              />
            </div>
          </div>

          <!-- Home screen preset section -->
          <div class="setting-item">
            <label>Home Screen Preset Management</label>
            <div
              class="preset-manager-container"
              style="margin-top: 5px; border: none; padding: 0"
            >
              <div class="form-group">
                <select
                  id="home-preset-selector"
                  class="moe-input select"
                ></select>
                <div class="preset-manager-controls compact">
                  <button
                    id="apply-home-preset-btn"
                    class="preset-btn-capsule preset-btn-apply"
                    disabled
                  >
                    Apply
                  </button>
                  <button
                    id="save-home-preset-btn"
                    class="preset-btn-capsule preset-btn-save"
                  >
                    Save Current
                  </button>
                  <button
                    id="update-home-preset-btn"
                    class="preset-btn-capsule preset-btn-secondary"
                    disabled
                  >
                    Update
                  </button>
                  <button
                    id="rename-home-preset-btn"
                    class="preset-btn-capsule preset-btn-secondary"
                    disabled
                  >
                    Rename
                  </button>
                  <button
                    id="delete-home-preset-btn"
                    class="preset-btn-capsule preset-btn-delete"
                    disabled
                  >
                    Delete
                  </button>
                  <button
                    id="import-home-preset-btn"
                    class="preset-btn-capsule preset-btn-secondary"
                  >
                    Import
                  </button>
                  <button
                    id="export-home-preset-btn"
                    class="preset-btn-capsule preset-btn-secondary"
                    disabled
                  >
                    Export
                  </button>
                  <input
                    type="file"
                    id="import-home-preset-input"
                    accept=".json"
                    hidden
                  />
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- ‚òÖ‚òÖ‚òÖ New: Passerby avatar library card ‚òÖ‚òÖ‚òÖ -->
        <div class="settings-group-card">
          <div class="settings-section-title">üë• Global Passerby Avatar Library</div>
          <div class="setting-item">
            <label>Used for generating random NPC and comment section avatars</label>
            <div class="moe-btn-group">
              <button
                id="manage-passerby-avatars-btn"
                class="moe-btn-secondary"
              >
                üìÇ Manage Library
              </button>
              <button id="add-passerby-avatar-btn" class="moe-btn-secondary">
                ‚ûï Add Avatar
              </button>
            </div>
          </div>
        </div>

        <!-- 3. App icon & name card -->
        <div class="settings-group-card">
          <div class="settings-section-title">üé® Icons & Names</div>
          <div class="setting-item">
            <label>App Icon Customization</label>
            <div id="icon-settings-grid" class="icon-grid-compact">
              <!-- Generated by JS -->
            </div>
          </div>

          <div class="setting-item">
            <label>App Name Customization</label>
            <div id="icon-rename-grid" class="name-grid-compact">
              <!-- Generated by JS -->
            </div>
            <button
              class="form-button-secondary small-btn"
              id="reset-app-names-btn"
            >
              Restore Default Names
            </button>
          </div>
        </div>

        <!-- 4. Sound & background card -->
        <div class="settings-group-card">
          <div class="settings-section-title">üéµ Sound & Background</div>

          <div class="setting-item">
            <label>Ringtone URL</label>
            <input
              type="text"
              id="ringtone-url-input"
              class="moe-input"
              placeholder="Audio URL..."
            />
          </div>

          <div class="setting-item">
            <label>Notification Sound URL</label>
            <input
              type="text"
              id="notification-sound-url-input"
              class="moe-input"
              placeholder="Audio URL..."
            />
          </div>

          <div class="setting-item">
            <label>Global Chat Background</label>
            <div class="preview-upload-box">
              <!-- ‚òÖ‚òÖ‚òÖ Change: removed landscape class name, now portrait ‚òÖ‚òÖ‚òÖ -->
              <div id="global-bg-preview" class="mini-preview">Preview</div>
              <div class="btn-col">
                <button
                  class="upload-btn-pill"
                  onclick="
                    document.getElementById('global-bg-upload-input').click()
                  "
                >
                  Upload Background
                </button>
                <button
                  class="upload-btn-pill danger"
                  id="remove-global-bg-btn"
                >
                  Remove Background
                </button>
              </div>
            </div>
            <input
              type="file"
              id="global-bg-upload-input"
              accept="image/*"
              hidden
            />
            <button
              class="form-button-secondary small-btn danger-text"
              id="clear-all-single-bgs-btn"
              style="margin-top: 10px"
            >
              Clear All Individual Chat Backgrounds
            </button>
          </div>
        </div>

        <!-- Bottom padding to prevent save button from blocking -->
        <div style="height: 80px"></div>
      </div>

      <!-- ‚òÖ‚òÖ‚òÖ Floating save button ‚òÖ‚òÖ‚òÖ -->
      <button id="save-wallpaper-btn" class="moe-fab-save">
        üíæ<span style="font-size: 12px; display: block; margin-top: -2px"
          >Save</span
        >
      </button>
    </div>

    <!-- Share link feature HTML -->
    <div id="browser-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="browser-back-btn">‚Äπ</span>
        <span id="browser-title"></span>
        <span style="width: 30px"></span>
      </div>
      <div id="browser-content" class="list-container">
        <!-- Article content will be dynamically generated by JS here -->
      </div>
    </div>

    <div id="font-settings-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span>Font Presets</span>
        <span style="width: 30px"></span>
        <!-- Keep this placeholder so title is perfectly centered -->
      </div>
      <div class="form-container" style="gap: 20px">
        <p
          style="
            font-size: 13px;
            color: #ff6b6b;
            background-color: rgba(255, 107, 107, 0.1);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 107, 107, 0.2);
            text-align: center;
            width: 100%;
            box-sizing: border-box;
          "
        >
          Importing large local fonts may cause a crash! Using URL is recommended.
        </p>
        <!-- Font preset slot container -->
        <div id="font-preset-container">
          <!-- 5 slots will be dynamically generated by JavaScript here -->
        </div>

        <!-- Global font preview area -->
        <div class="form-group" style="width: 100%">
          <label>Current Global Font Preview</label>
          <div id="font-preview">
            <p style="font-size: 20px; margin: 0 0 10px 0">
              Hello World
            </p>
            <p style="margin: 0">This is the global font preview, 12345.</p>
          </div>
        </div>

        <button class="form-button form-button-secondary" id="reset-font-btn">
          Restore Default Font
        </button>
      </div>
    </div>

    <!-- Hidden file picker for handling local uploads -->
    <input
      type="file"
      id="font-preset-local-upload"
      accept=".ttf,.otf,.woff,.woff2"
      style="display: none"
    />

    <!-- All HTML screens for "Check Character's Phone" feature -->

    <!-- 1. Character selection screen (unchanged) -->
    <div id="character-selection-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span>Select Phone to View</span>
        <span style="width: 30px"></span>
      </div>
      <div id="character-selection-list" class="list-container"></div>
    </div>

    <div id="character-phone-container" class="screen">
      <div class="character-phone-frame">
        <div class="character-phone-notch"></div>
        <div class="character-phone-inner-screen">
          <!-- 1. ËßíËâ≤ÊâãÊú∫ÁöÑ‰∏ªÁïåÈù¢ -->
          <div id="character-phone-screen" class="character-phone-page active">
            <div class="header character-phone-header">
              <span
                class="back-btn"
                data-target-screen="character-selection-screen"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span id="character-phone-owner-name"></span>
              <div class="header-actions">
                <span
                  class="action-btn"
                  id="clear-character-data-btn"
                  title="Clear All Data"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-character-data-btn"
                  title="Refresh All Data"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path d="M23 4v6h-6M1 20v-6h6" />
                    <path
                      d="M3.51 9a9 9 0 0114.85-3.36L20.5 10M3.5 14a9 9 0 0114.85 3.36L20.5 14"
                    />
                  </svg>
                </span>
              </div>
            </div>

            <!-- Top-left widget -->
            <div id="char-phone-widget-1" class="char-phone-widget">
              <img id="char-phone-widget-img-1" src="" />
            </div>
            <!-- Bottom-right widget -->
            <div id="char-phone-widget-2" class="char-phone-widget">
              <img id="char-phone-widget-img-2" src="" />
            </div>

            <div
              id="character-app-grid"
              class="app-grid-standard"
              style="padding-top: 60px"
            ></div>
          </div>

          <!-- 2. Character phone - chat list -->
          <div
            id="character-chat-list-screen"
            class="character-phone-page"
            style="display: flex; flex-direction: column; height: 100%"
          >
            <div class="header character-phone-header" style="flex-shrink: 0">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Messages</span>
              <div class="header-actions">
                <!-- ‚òÖ New: delete button on messages page ‚òÖ -->
                <span
                  class="action-btn"
                  id="clear-npc-chats-btn"
                  title="Clear All NPC Chats"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-chat-message-btn"
                  title="Generate New Chat"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"
                    />
                  </svg>
                </span>
              </div>
            </div>

            <div
              id="character-chat-list"
              class="list-container"
              style="
                padding: 0;
                flex-grow: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
              "
            ></div>
          </div>

          <!-- 3. Character phone - chat history -->
          <div id="character-chat-history-screen" class="character-phone-page">
            <div class="header character-phone-header">
              <span
                class="back-btn"
                data-target-page="character-chat-list-screen"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span id="character-chat-with-name"></span>
            </div>
            <div
              id="character-chat-history-messages"
              class="list-container"
              style="
                padding: 15px;
                display: flex;
                flex-direction: column;
                gap: 15px;
                background-color: #e5ddd5;
              "
            ></div>
          </div>

          <!-- 4. Character phone - shopping cart -->
          <div id="character-shopping-cart-screen" class="character-phone-page">
            <div class="header character-phone-header">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Shopping Cart</span>
              <div class="header-actions">
                <!-- ‚òÖ New: delete button on shopping cart page ‚òÖ -->
                <span
                  class="action-btn"
                  id="clear-cart-items-btn"
                  title="Clear Shopping Cart"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-cart-item-btn"
                  title="Add New Item"
                >
                  <svg
                    width="22"
                    height="22"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                  </svg>
                </span>
              </div>
            </div>
            <div id="character-shopping-cart-list" class="list-container"></div>
          </div>

          <!-- 5. Character phone - memos -->
          <div id="character-memos-screen" class="character-phone-page">
            <div class="header character-phone-header">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Memos</span>
              <div class="header-actions">
                <!-- ‚òÖ New: delete button on memos page ‚òÖ -->
                <span
                  class="action-btn"
                  id="clear-memos-btn"
                  title="Clear Memos"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-memo-btn"
                  title="Write New Memo"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"
                    />
                  </svg>
                </span>
              </div>
            </div>
            <div id="character-memos-list" class="list-container"></div>
          </div>

          <!-- 6. Character phone - browser -->
          <div id="character-browser-screen" class="character-phone-page">
            <div class="header character-phone-header">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Browser</span>
              <div class="header-actions">
                <!-- ‚òÖ New: delete button on browser page ‚òÖ -->
                <span
                  class="action-btn"
                  id="clear-browser-history-btn"
                  title="Clear History"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-browser-history-btn"
                  title="Generate New History"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"
                    ></path>
                    <path
                      d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"
                    ></path>
                  </svg>
                </span>
              </div>
            </div>
            <div id="character-browser-list" class="list-container"></div>
          </div>

          <!-- 7. Character phone - browser search result detail -->
          <div
            id="character-browser-detail-screen"
            class="character-phone-page"
          >
            <div class="header character-phone-header">
              <span
                class="back-btn"
                data-target-page="character-browser-screen"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span id="character-browser-detail-title">Search Results</span>
            </div>
            <div
              id="character-browser-detail-content"
              class="list-container"
              style="padding: 15px; line-height: 1.7"
            ></div>
          </div>

          <!-- 8. Character phone - album -->
          <div id="character-album-screen" class="character-phone-page">
            <div class="header character-phone-header">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Album</span>
              <div class="header-actions">
                <!-- ‚òÖ New: delete button on album page ‚òÖ -->
                <span
                  class="action-btn"
                  id="clear-album-photos-btn"
                  title="Clear Album"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-album-photo-btn"
                  title="Generate New Photo"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <rect
                      x="3"
                      y="3"
                      width="18"
                      height="18"
                      rx="2"
                      ry="2"
                    ></rect>
                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                    <polyline points="21 15 16 10 5 21"></polyline>
                  </svg>
                </span>
              </div>
            </div>
            <div id="character-album-grid" class="list-container"></div>
          </div>

          <!-- 9. Character Phone - Bank -->
          <div id="character-bank-screen" class="character-phone-page">
            <div class="header character-phone-header">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Wallet</span>
              <div class="header-actions">
                <!-- ‚òÖ New: delete button on wallet page ‚òÖ -->
                <span
                  class="action-btn"
                  id="clear-bank-transactions-btn"
                  title="Clear Transactions"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-bank-transaction-btn"
                  title="Generate New Transaction"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <line x1="12" y1="1" x2="12" y2="23"></line>
                    <path
                      d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"
                    ></path>
                  </svg>
                </span>
              </div>
            </div>
            <div id="character-bank-details" class="list-container"></div>
          </div>

          <!-- 10. Character Phone - Movement Trajectory -->
          <div id="character-trajectory-screen" class="character-phone-page">
            <div class="header character-phone-header">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Footprints</span>
              <div class="header-actions">
                <!-- ‚òÖ New: delete button on footprints page ‚òÖ -->
                <span
                  class="action-btn"
                  id="clear-trajectory-btn"
                  title="Clear Footprints"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-trajectory-btn"
                  title="Generate New Footprints"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"
                    ></path>
                    <circle cx="12" cy="10" r="3"></circle>
                  </svg>
                </span>
              </div>
            </div>
            <div id="character-trajectory-list" class="list-container"></div>
          </div>

          <!-- 11. Character Phone - App Usage Records -->
          <div id="character-app-usage-screen" class="character-phone-page">
            <div class="header character-phone-header">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Screen Time</span>
              <div class="header-actions">
                <!-- ‚òÖ New: delete button on usage records page ‚òÖ -->
                <span
                  class="action-btn"
                  id="clear-app-usage-btn"
                  title="Clear Records"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-app-usage-btn"
                  title="Generate New Records"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0z"
                    ></path>
                  </svg>
                </span>
              </div>
            </div>
            <div id="character-app-usage-list" class="list-container"></div>
          </div>

          <!-- 12. Character Phone - Diary -->
          <div id="character-diary-screen" class="character-phone-page">
            <div class="header character-phone-header">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Diary</span>
              <div class="header-actions">
                <!-- ‚òÖ New: delete button on diary page ‚òÖ -->
                <span
                  class="action-btn"
                  id="clear-diary-entries-btn"
                  title="Clear Diary"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
                    />
                  </svg>
                </span>
                <span
                  class="action-btn"
                  id="generate-diary-entry-btn"
                  title="Write New Diary Entry"
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path
                      d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"
                    />
                  </svg>
                </span>
              </div>
            </div>
            <div id="character-diary-list" class="list-container"></div>
          </div>

          <div
            id="character-phone-appearance-screen"
            class="character-phone-page"
          >
            <div class="header character-phone-header">
              <span class="back-btn" data-target-page="character-phone-screen">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </span>
              <span>Appearance Settings</span>
              <span style="width: 30px"></span>
            </div>
            <!-- Reuse existing .form-container style for scrolling and layout -->
            <div class="form-container" style="padding: 15px; gap: 25px">
              <!-- Wallpaper settings area -->
              <div>
                <label style="font-weight: 500; color: var(--text-secondary)"
                  >Phone Wallpaper</label
                >
                <div
                  id="char-phone-wallpaper-preview"
                  class="wallpaper-preview"
                  style="
                    height: 240px;
                    width: 135px;
                    margin: 10px auto;
                    border-radius: 12px;
                  "
                >
                  Click below to upload
                </div>
                <button
                  id="upload-char-phone-wallpaper-btn"
                  class="form-button"
                >
                  Upload Wallpaper
                </button>
                <button
                  id="remove-char-phone-wallpaper-btn"
                  class="form-button form-button-secondary"
                  style="margin-top: 10px"
                >
                  Remove Wallpaper
                </button>
              </div>

              <hr style="width: 100%; opacity: 0.2" />

              <div>
                <label style="font-weight: 500; color: var(--text-secondary)"
                  >In-App Wallpaper</label
                >
                <div
                  id="char-phone-app-wallpaper-preview"
                  class="wallpaper-preview"
                  style="
                    height: 240px;
                    width: 135px;
                    margin: 10px auto;
                    border-radius: 12px;
                  "
                >
                  Click below to upload
                </div>
                <button
                  id="upload-char-phone-app-wallpaper-btn"
                  class="form-button"
                >
                  Upload In-App Wallpaper
                </button>
                <button
                  id="remove-char-phone-app-wallpaper-btn"
                  class="form-button form-button-secondary"
                  style="margin-top: 10px"
                >
                  Remove In-App Wallpaper
                </button>
              </div>

              <hr style="width: 100%; opacity: 0.2" />

              <!-- App icon settings area -->
              <div>
                <label style="font-weight: 500; color: var(--text-secondary)"
                  >App Icons</label
                >
                <div
                  id="char-phone-icon-settings-grid"
                  style="
                    display: grid;
                    grid-template-columns: repeat(3, 1fr);
                    gap: 20px;
                    margin-top: 15px;
                    text-align: center;
                  "
                >
                  <!-- App icon settings will be dynamically generated here by JS -->
                </div>
              </div>

              <hr style="width: 100%; opacity: 0.2" />
              <!-- Desktop widget settings area -->
              <div>
                <label style="font-weight: 500; color: var(--text-secondary)"
                  >Desktop Widgets</label
                >
                <!-- Widget 1: Top-left corner -->
                <div class="form-group" style="margin-top: 15px">
                  <label>Top-Left Widget</label>
                  <div class="avatar-upload">
                    <img
                      id="char-phone-widget-preview-1"
                      class="wallpaper-preview"
                      style="height: 100px; width: 100px; margin-bottom: 0"
                    />
                    <div
                      style="display: flex; flex-direction: column; gap: 8px"
                    >
                      <button
                        class="form-button-secondary"
                        id="upload-widget-1-btn"
                        style="margin-top: 0"
                      >
                        Upload Image
                      </button>
                      <button
                        class="form-button-secondary"
                        id="remove-widget-1-btn"
                        style="
                          margin-top: 0;
                          border-color: #ff3b30;
                          color: #ff3b30;
                        "
                      >
                        Remove Image
                      </button>
                    </div>
                  </div>
                </div>
                <!-- Widget 2: Bottom-right corner -->
                <div class="form-group" style="margin-top: 15px">
                  <label>Bottom-Right Widget</label>
                  <div class="avatar-upload">
                    <img
                      id="char-phone-widget-preview-2"
                      class="wallpaper-preview"
                      style="height: 100px; width: 100px; margin-bottom: 0"
                    />
                    <div
                      style="display: flex; flex-direction: column; gap: 8px"
                    >
                      <button
                        class="form-button-secondary"
                        id="upload-widget-2-btn"
                        style="margin-top: 0"
                      >
                        Upload Image
                      </button>
                      <button
                        class="form-button-secondary"
                        id="remove-widget-2-btn"
                        style="
                          margin-top: 0;
                          border-color: #ff3b30;
                          color: #ff3b30;
                        "
                      >
                        Remove Image
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              <hr style="width: 100%; opacity: 0.2; margin-top: 25px" />
              <div class="preset-manager-container">
                <div style="width: 100%; text-align: left; margin-bottom: 15px">
                  <label style="font-weight: 500; color: var(--text-secondary)"
                    >Appearance Presets</label
                  >
                </div>
                <div class="form-group">
                  <select
                    id="char-phone-preset-selector"
                    class="form-group select"
                  ></select>
                  <div class="preset-manager-controls">
                    <!-- Full-width Apply button -->
                    <button
                      id="apply-char-phone-preset-btn"
                      class="preset-btn-capsule preset-btn-apply"
                      disabled
                    >
                      Apply
                    </button>

                    <!-- 2x2 grid buttons -->
                    <button
                      id="save-char-phone-preset-btn"
                      class="preset-btn-capsule preset-btn-save"
                    >
                      Save
                    </button>
                    <button
                      id="update-char-phone-preset-btn"
                      class="preset-btn-capsule preset-btn-secondary"
                      disabled
                    >
                      Update
                    </button>
                    <button
                      id="rename-char-phone-preset-btn"
                      class="preset-btn-capsule preset-btn-secondary"
                      disabled
                    >
                      Rename
                    </button>
                    <button
                      id="import-char-phone-preset-btn"
                      class="preset-btn-capsule preset-btn-secondary"
                    >
                      Import
                    </button>
                    <button
                      id="export-char-phone-preset-btn"
                      class="preset-btn-capsule preset-btn-secondary"
                      disabled
                    >
                      Export
                    </button>
                    <button
                      id="delete-char-phone-preset-btn"
                      class="preset-btn-capsule preset-btn-delete"
                      disabled
                    >
                      Delete
                    </button>

                    <input
                      type="file"
                      id="import-char-phone-preset-input"
                      accept=".json"
                      hidden
                    />
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- Hidden file selectors for upload handling -->
          <input
            type="file"
            id="char-phone-wallpaper-upload-input"
            accept="image/*"
            hidden
          />
          <input
            type="file"
            id="char-phone-icon-upload-input"
            accept="image/*"
            hidden
          />

          <input
            type="file"
            id="char-phone-widget-1-upload-input"
            accept="image/*"
            hidden
          />
          <input
            type="file"
            id="char-phone-widget-2-upload-input"
            accept="image/*"
            hidden
          />
          <input
            type="file"
            id="char-phone-app-wallpaper-upload-input"
            accept="image/*"
            hidden
          />
        </div>
      </div>
    </div>
    <!-- "Check Phone" feature - generate chat contact selection modal -->
    <div id="chat-gen-selector-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Select Chat Contact</span>
        </div>
        <div
          class="modal-body"
          style="padding: 0; display: flex; flex-direction: column"
        >
          <!-- Top: random option -->
          <div
            style="
              padding: 15px;
              border-bottom: 1px solid var(--border-color);
              background: var(--secondary-bg);
            "
          >
            <label class="toggle-switch-label" style="margin: 0">
              <span class="toggle-switch-text" style="font-weight: bold"
                >üé≤ Random (AI decides)</span
              >
              <input type="checkbox" id="chat-gen-random-checkbox" checked />
              <span class="toggle-switch-slider"></span>
            </label>
            <p
              style="
                font-size: 12px;
                color: var(--text-secondary);
                margin-top: 5px;
                margin-bottom: 0;
              "
            >
              Turn off to specify a particular character/NPC below.
            </p>
          </div>

          <!-- List: specific character selection -->
          <div
            id="chat-gen-list"
            class="contact-picker-list"
            style="flex-grow: 1; opacity: 0.5; pointer-events: none"
          >
            <!-- List items generated by JS -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-chat-gen-btn">Cancel</button>
          <button class="save" id="confirm-chat-gen-btn">Start Generating</button>
        </div>
      </div>
    </div>

    <div id="generation-overlay" class="modal">
      <div class="loading-content">
        <!-- This is a pink cat paw -->
        <div class="cat-paw">
          <div class="pad main"></div>
          <div class="pad toe t1"></div>
          <div class="pad toe t2"></div>
          <div class="pad toe t3"></div>
        </div>
        <p id="generation-text">Generating...</p>
      </div>
    </div>

    <!-- Screen for selecting contacts to create group chat -->
    <div id="contact-picker-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="cancel-contact-picker-btn">Cancel</span>
        <span>Select Contacts</span>
        <span class="save-btn" id="confirm-contact-picker-btn">Done(0)</span>
      </div>
      <div class="list-container" id="contact-picker-list">
        <!-- Contact list will be dynamically generated by JS -->
      </div>
    </div>

    <!-- Group member management screen -->
    <div id="member-management-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-member-management">‚Äπ</span>
        <span>Group Member Management</span>
        <span style="width: 30px"></span>
      </div>
      <div class="list-container" id="member-management-list">
        <!-- Existing member list will be dynamically generated here -->
      </div>
      <div id="member-management-actions">
        <button id="add-existing-contact-btn">Add from Friends List</button>
        <button id="create-new-member-btn">Create New Group Member</button>
        <button id="ai-generate-members-btn">‚ú® AI Generate Members</button>
      </div>
    </div>

    <!-- Weibo user persona and career settings modal -->
    <div id="weibo-user-settings-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span>My Weibo Settings</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Presets</label>
            <div class="bubble-preset-manager">
              <!-- Reuse existing styles -->
              <select
                id="weibo-user-preset-select"
                class="form-group select"
              ></select>
              <button id="manage-weibo-user-presets-btn" class="action-btn">
                Manage
              </button>
            </div>
          </div>
          <div class="form-group">
            <label for="weibo-user-profession-modal-input"
              >Profession (displayed below nickname)</label
            >
            <input
              type="text"
              id="weibo-user-profession-modal-input"
              placeholder="e.g., Professional esports player, beauty blogger"
            />
          </div>
          <div class="form-group">
            <label for="weibo-user-persona-modal-input"
              >Hidden Persona (for AI reference when generating comments)</label
            >
            <textarea
              id="weibo-user-persona-modal-input"
              rows="4"
              placeholder="e.g., Cold personality, rarely interacts with fans, only replies to sponsors' comments."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-weibo-user-settings-btn">
            Cancel
          </button>
          <button class="save" id="save-weibo-user-settings-btn">Save</button>
        </div>
      </div>
    </div>

    <div id="weibo-action-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span id="weibo-action-modal-title">Perform Action</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="weibo-action-actor-select">Select Actor</label>
            <select
              id="weibo-action-actor-select"
              class="form-group select"
            ></select>
          </div>
          <div class="form-group">
            <label>Select Action Type</label>

            <div id="weibo-action-type-select" style="text-align: left">
              <label
                ><input
                  type="radio"
                  name="weibo_action_type"
                  value="post"
                  checked
                />
                Post a new Weibo</label
              >
              <label
                ><input
                  type="radio"
                  name="weibo_action_type"
                  value="comment_plaza"
                />
                Comment on latest Plaza Weibo</label
              >

              <label
                ><input
                  type="radio"
                  name="weibo_action_type"
                  value="comment_user"
                />
                Comment on user's latest Weibo</label
              >
            </div>
          </div>
          <div class="form-group">
            <label for="weibo-action-prompt-input"
              >About... (optional, brief hint)</label
            >
            <textarea
              id="weibo-action-prompt-input"
              rows="2"
              placeholder="e.g., Won the match today, very happy or respond to recent hot search"
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-weibo-action-btn">Cancel</button>
          <button class="save" id="confirm-weibo-action-btn">Execute</button>
        </div>
      </div>
    </div>

    <div id="char-sticker-manager-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-sticker-manager">‚Äπ</span>
        <span id="sticker-manager-title">Sticker Management</span>
        <!-- Add "Edit/Done" buttons here -->
        <div class="header-actions">
          <span class="action-btn" id="edit-char-stickers-btn">Edit</span>
          <span
            class="action-btn"
            id="done-char-stickers-btn"
            style="display: none"
            >Done</span
          >
        </div>
      </div>
      <input
        type="file"
        id="char-sticker-upload-input"
        accept="image/*"
        style="display: none"
        multiple
      />
      <div
        class="modal-body"
        style="padding: 0; display: flex; flex-direction: column; flex-grow: 1"
      >
        <!-- Tab switching -->
        <div class="frame-tabs">
          <div id="sticker-tab-exclusive" class="frame-tab active">
            Exclusive Stickers
          </div>
          <div id="sticker-tab-common" class="frame-tab">Common Stickers</div>
        </div>

        <!-- Exclusive stickers content area -->
        <div id="sticker-content-exclusive" class="frame-content active">
          <div class="sticker-panel-header" style="justify-content: flex-end">
            <div style="display: flex; gap: 10px">
              <span class="panel-btn" id="add-exclusive-sticker-btn"
                >Batch Add</span
              >
              <span class="panel-btn" id="upload-exclusive-sticker-btn"
                >Upload Local</span
              >
            </div>
          </div>
          <div id="exclusive-sticker-grid" class="sticker-grid"></div>
        </div>

        <!-- Common stickers content area -->
        <div id="sticker-content-common" class="frame-content">
          <div class="sticker-panel-header" style="justify-content: flex-end">
            <div style="display: flex; gap: 10px">
              <span class="panel-btn" id="add-common-sticker-btn"
                >Batch Add</span
              >
              <span class="panel-btn" id="upload-common-sticker-btn"
                >Upload Local</span
              >
            </div>
          </div>
          <div id="common-sticker-grid" class="sticker-grid"></div>
        </div>
      </div>
      <!-- Action bar for batch deletion -->
      <div id="char-sticker-footer" style="display: none">
        <button id="delete-selected-char-stickers-btn">Delete Selected (0)</button>
      </div>
    </div>

    <!-- Incoming call request modal -->
    <div id="incoming-call-modal" class="modal">
      <div class="incoming-call-content">
        <img id="caller-avatar" class="caller-avatar" src="" />
        <div id="caller-name" class="caller-name"></div>
        <div class="caller-text">Invites you to video call</div>
        <div class="incoming-call-actions">
          <div class="action-button-wrapper">
            <button
              id="decline-call-btn"
              class="call-action-btn decline"
            ></button>
            <span>Decline</span>
          </div>
          <div class="action-button-wrapper">
            <button
              id="accept-call-btn"
              class="call-action-btn accept"
            ></button>
            <span>Accept</span>
          </div>
        </div>
      </div>
    </div>

    <div id="music-search-results-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Search Results</span>
        </div>
        <div class="modal-body" id="search-results-list" style="padding: 0">
          <!-- Search results will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button
            class="cancel"
            id="cancel-music-search-btn"
            style="width: 100%"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <div id="video-call-screen" class="screen">
      <!-- This screen serves both modes -->

      <!-- ======================================================= -->
      <!-- Mode 1: Brand new [Visual] video call interface -->
      <!-- ======================================================= -->
      <div id="visual-call-interface" style="display: none">
        <!-- Hidden by default -->
        <!-- 1. Video background layer (large and small images here) -->
        <div class="video-background">
          <!-- Main image container -->
          <div id="video-main-view" class="video-container">
            <img src="" alt="Main video feed" />
            <video
              id="video-main-stream"
              autoplay
              playsinline
              muted
              style="
                display: none;
                width: 100%;
                height: 100%;
                object-fit: cover;
              "
            ></video>
          </div>
          <!-- Small image container (picture-in-picture) -->
          <div id="video-pip-view" class="video-container pip">
            <img src="" alt="PiP video feed" />
            <video
              id="video-pip-stream"
              autoplay
              playsinline
              muted
              style="
                display: none;
                width: 100%;
                height: 100%;
                object-fit: cover;
                transform: scaleX(-1);
              "
            ></video>
          </div>
        </div>

        <!-- 2. Top status bar -->
        <div class="video-call-top-bar">
          <button class="video-minimize-btn" onclick="minimizeVideoCall()">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <polyline points="4 14 10 14 10 20"></polyline>
              <polyline points="20 10 14 10 14 4"></polyline>
            </svg>
          </button>

          <span id="visual-call-timer">00:00</span>
        </div>

        <!-- 3. Chat bubble display area -->
        <div id="video-call-messages-visual" class="video-call-main">
          <!-- Chat bubbles will be dynamically generated here by JS -->
        </div>
        <div class="video-call-controls">
          <!-- Re-roll button -->
          <button
            id="reroll-call-btn"
            class="control-btn reroll-btn"
            title="Regenerate"
          ></button>
          <button
            id="flip-real-camera-btn"
            class="control-btn"
            style="
              display: none;
              background-image: url(&quot;https://api.iconify.design/ion:camera-reverse-outline.svg?color=white&quot;);
              background-size: 60%;
              background-repeat: no-repeat;
              background-position: center;
            "
            title="Flip front/back camera"
          ></button>
          <!-- [Key addition] Speak button -->
          <button
            id="user-speak-btn-visual"
            class="control-btn speak-btn"
            title="Speak"
          ></button>
          <!-- Switch camera button -->
          <button
            id="switch-camera-btn"
            class="control-btn switch-camera-btn"
            title="Switch Camera"
          ></button>
          <!-- Hang up button -->
          <button
            id="hang-up-btn-visual"
            class="control-btn hangup-btn"
          ></button>
        </div>
      </div>

      <!-- ======================================================= -->

      <!-- ======================================================= -->
      <div id="text-call-interface" style="display: none">
        <!-- Hidden by default -->
        <div class="video-call-top-bar">
          <button class="video-minimize-btn" onclick="minimizeVideoCall()">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <polyline points="4 14 10 14 10 20"></polyline>
              <polyline points="20 10 14 10 14 4"></polyline>
            </svg>
          </button>
          <!-- ‚ñ≤‚ñ≤‚ñ≤ -->
          <span id="call-timer">00:00</span>
        </div>
        <div class="video-call-avatar-area">
          <div id="participant-avatars-grid">
            <!-- JS will dynamically generate avatars here -->
          </div>
        </div>
        <div id="video-call-main" class="video-call-main">
          <!-- Dialogue content will be dynamically generated here -->
        </div>
        <div class="video-call-controls">
          <!-- [Addition] Add re-roll button for old mode too -->
          <button
            id="reroll-call-btn-text"
            class="control-btn reroll-btn"
            title="Regenerate"
          ></button>
          <button id="user-speak-btn" class="control-btn speak-btn"></button>
          <button id="hang-up-btn" class="control-btn hangup-btn"></button>
          <button
            id="join-call-btn"
            class="control-btn join-btn"
            style="display: none"
          ></button>
        </div>
      </div>
    </div>

    <!-- Outgoing call screen -->
    <div id="outgoing-call-screen" class="screen">
      <div class="outgoing-call-content">
        <img id="outgoing-call-avatar" class="caller-avatar" src="" />
        <div id="outgoing-call-name" class="caller-name"></div>
        <div class="caller-text">Calling...</div>
        <div class="outgoing-call-actions">
          <button id="cancel-call-btn" class="call-action-btn decline"></button>
          <span>Cancel</span>
        </div>
      </div>
    </div>

    <!-- Call history screen -->
    <div id="call-history-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="call-history-back-btn">‚Äπ</span>
        <span id="call-history-title">Call History</span>
        <span style="width: 30px"></span>
        <!-- Placeholder to keep title centered -->
      </div>
      <div
        id="call-history-list"
        class="list-container"
        style="padding: 15px; display: flex; flex-direction: column; gap: 15px"
      >
        <!-- Call history cards will be dynamically generated here by JS -->
      </div>
    </div>

    <div id="chat-search-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="search-back-btn">‚Äπ</span>
        <span>Search Chat History</span>
        <span style="width: 30px"></span>
        <!-- Placeholder -->
      </div>
      <div class="form-container" style="padding-bottom: 0">
        <!-- Search criteria input area -->
        <div class="form-group">
          <label for="keyword-search-input">Keyword</label>
          <input
            type="text"
            id="keyword-search-input"
            placeholder="Enter keyword to search..."
          />
        </div>
        <div class="form-group">
          <label for="sender-search-select">Person</label>
          <select id="sender-search-select">
            <!-- Options will be dynamically generated by JS -->
          </select>
        </div>
        <div class="form-group">
          <label for="date-search-input">Date</label>
          <input type="date" id="date-search-input" />
        </div>
        <button class="form-button" id="perform-search-btn">Start Search</button>

        <!-- Search results display area -->
        <div
          id="chat-search-results-list"
          class="list-container"
          style="margin-top: 15px; padding: 0"
        >
          <!-- Search results will be dynamically generated here by JS -->
        </div>
      </div>
    </div>

    <div id="lock-screen" class="screen">
      <div id="lock-clock-container">
        <div id="lock-main-time">12:00</div>
        <div id="lock-main-date">Monday, January 1</div>
      </div>
      <div id="unlock-hint">Swipe up to unlock</div>
    </div>

    <div id="password-modal-overlay" class="modal">
      <div class="password-modal-content">
        <p>Enter Password</p>
        <input type="password" id="password-input-field" maxlength="20" />
        <div class="password-actions">
          <button id="password-cancel-btn">Cancel</button>
          <button id="password-confirm-btn">Enter</button>
        </div>
      </div>
    </div>

    <div id="lovers-space-screen" class="screen">
      <!-- Â§¥ÈÉ® -->
      <div id="ls-header">
        <div class="ls-header-overlay"></div>
        <div class="ls-header-top-bar">
          <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
          <span id="ls-char-name"></span>
          <div class="header-actions">
            <span class="action-btn" id="ls-settings-btn" title="Space Settings">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <circle cx="12" cy="12" r="3"></circle>
                <path
                  d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"
                ></path>
              </svg>
            </span>
            <span class="action-btn" id="ls-change-bg-btn" title="Change Background">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
              </svg>
            </span>
            <span class="action-btn" id="ls-switch-char-btn">Switch</span>
          </div>
        </div>
        <div class="ls-avatar-and-counter-wrapper">
          <div class="ls-header-avatars">
            <img id="ls-user-avatar" src="" />
            <span class="heart-icon">‚ù§</span>
            <img id="ls-char-avatar" src="" />
          </div>
          <div id="ls-days-counter"></div>
        </div>
      </div>

      <div id="ls-tab-bar">
        <div
          class="ls-tab-item active"
          data-view="ls-moments-view"
          title="Status"
        >
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path
              d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"
            ></path>
          </svg>
        </div>
        <div class="ls-tab-item" data-view="ls-album-view" title="Album">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <circle cx="8.5" cy="8.5" r="1.5"></circle>
            <polyline points="21 15 16 10 5 21"></polyline>
          </svg>
        </div>
        <div class="ls-tab-item" data-view="ls-letters-view" title="Love Letters">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path
              d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"
            ></path>
            <polyline points="22,6 12,13 2,6"></polyline>
          </svg>
        </div>
        <div class="ls-tab-item" data-view="ls-shares-view" title="Shares">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <circle cx="18" cy="5" r="3"></circle>
            <circle cx="6" cy="12" r="3"></circle>
            <circle cx="18" cy="19" r="3"></circle>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
          </svg>
        </div>
        <div class="ls-tab-item" data-view="ls-questions-view" title="Questions">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="17" x2="12.01" y2="17"></line>
          </svg>
        </div>
        <div class="ls-tab-item" data-view="ls-diary-view" title="Diary">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
            <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
          </svg>
        </div>
        <div class="ls-tab-item" data-view="ls-pomodoro-view" title="Pomodoro Timer">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <circle cx="12" cy="12" r="10"></circle>
            <polyline points="12 6 12 12 16 14"></polyline>
          </svg>
        </div>
        <div class="ls-tab-item" data-view="ls-activity-view" title="Today's Footprints">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
          </svg>
        </div>
      </div>

      <!-- Content display area -->
      <div id="ls-content-area">
        <div id="ls-moments-view" class="ls-view active">
          <div id="ls-moments-list"></div>
          <button id="ls-add-moment-btn" class="ls-fab-btn">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <line
                x1="12"
                y1="5"
                x2="12"
                y2="19"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
              <line
                x1="5"
                y1="12"
                x2="19"
                y2="12"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
            </svg>
          </button>
        </div>
        <div id="ls-album-view" class="ls-view">
          <div id="ls-album-list"></div>
          <button id="ls-add-album-btn" class="ls-fab-btn">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <line
                x1="12"
                y1="5"
                x2="12"
                y2="19"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
              <line
                x1="5"
                y1="12"
                x2="19"
                y2="12"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
            </svg>
          </button>
        </div>

        <div id="ls-letters-view" class="ls-view">
          <div id="ls-letters-list"></div>
          <button id="ls-add-letter-btn" class="ls-fab-btn">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <line
                x1="12"
                y1="5"
                x2="12"
                y2="19"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
              <line
                x1="5"
                y1="12"
                x2="19"
                y2="12"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
            </svg>
          </button>
        </div>

        <div id="ls-shares-view" class="ls-view">
          <div id="ls-shares-list"></div>
        </div>
        <div id="ls-questions-view" class="ls-view">
          <div id="ls-questions-list"></div>
          <button id="ls-add-question-btn" class="ls-fab-btn">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <line
                x1="12"
                y1="5"
                x2="12"
                y2="19"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
              <line
                x1="5"
                y1="12"
                x2="19"
                y2="12"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
            </svg>
          </button>
        </div>

        <div id="ls-diary-view" class="ls-view">
          <!-- Calendar and mood jar content will be dynamically generated here by JS -->
        </div>

        <!-- ‚òÖ‚òÖ‚òÖ New interface for Pomodoro timer ‚òÖ‚òÖ‚òÖ -->
        <div id="ls-pomodoro-view" class="ls-view">
          <!-- Pomodoro home page, shows history and start button -->
          <div id="ls-pomodoro-home">
            <div id="ls-pomodoro-start-btn-container">
              <div id="ls-pomodoro-start-icon">Ôºã</div>
              <p>Start a new focus session</p>
            </div>
            <div id="ls-pomodoro-history-list">
              <!-- History will be generated here by JS -->
            </div>
          </div>
          <div id="ls-pomodoro-timer-active" style="display: none">
            <div class="pomodoro-char-avatar-container">
              <img id="pomodoro-char-avatar" src="" />
              <div id="pomodoro-char-log"></div>
            </div>
            <div class="pomodoro-timer-display">
              <div id="pomodoro-current-task"></div>
              <div id="pomodoro-time">25:00</div>
            </div>
            <div
              class="pomodoro-controls"
              style="display: flex; gap: 15px; margin-top: 20px"
            >
              <!-- New cute music button -->
              <button id="pomodoro-music-btn" title="Music Playlist">
                <!-- Using an SVG icon instead of a simple note character -->
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M9 18V5l12-2v13"></path>
                  <circle cx="6" cy="18" r="3"></circle>
                  <circle cx="18" cy="16" r="3"></circle>
                </svg>
              </button>
              <button
                id="pomodoro-pause-btn"
                style="background-color: #ffca28; color: #fff"
              >
                Pause / Break
              </button>
              <button id="pomodoro-end-btn">End Focus</button>
            </div>
          </div>
        </div>
        <div id="ls-activity-view" class="ls-view">
          <!-- Today's footprints content will be dynamically generated here by JS -->
        </div>
      </div>
    </div>

    <!-- Chat settings modal (cute layout - integrated features) -->
    <div id="chat-settings-modal" class="modal">
      <div class="modal-content moe-settings-content">
        <div class="modal-header moe-modal-header">
          <span>‚ú® Chat Settings ‚ú®</span>
        </div>

        <div class="modal-body moe-settings-body">
          <!-- ============================== -->
          <!-- 1. Basic profile card -->
          <!-- ============================== -->
          <div class="settings-group-card moe-card">
            <div class="settings-section-title">üìù Basic Info</div>
            <div class="form-group" id="chat-name-group">
              <label>Character's Real Name / Group Chat Name (AI only recognizes this, changing it affects memory)</label>
              <input type="text" id="chat-name-input" class="moe-input" />
            </div>
            <!-- Added remark name input, hidden by default, JS controls display -->
            <div
              class="form-group"
              id="chat-remark-group"
              style="display: none"
            >
              <label>Nickname (display only, AI doesn't know)</label>
              <input
                type="text"
                id="chat-remark-input"
                class="moe-input"
                placeholder="Set a nickname..."
              />
            </div>

            <div
              class="form-group"
              id="assign-group-section"
              style="display: none"
            >
              <label for="assign-group-select">Friend Group</label>
              <div class="input-with-btn-row">
                <select id="assign-group-select" class="moe-input"></select>
                <button id="manage-groups-btn" class="moe-btn-small">
                  Manage
                </button>
              </div>
            </div>

            <div class="form-group" id="my-group-nickname-group">
              <label for="my-group-nickname-input">My Group Nickname</label>
              <input
                type="text"
                id="my-group-nickname-input"
                class="moe-input"
              />
            </div>

            <!-- Avatar area (side-by-side layout) -->
            <div class="moe-grid-row">
              <!-- Other party/group avatar -->
              <div class="form-group" id="ai-avatar-group">
                <label>Their Avatar</label>
                <div class="avatar-upload-column">
                  <img id="ai-avatar-preview" class="preview-img" />
                  <div class="btn-stack">
                    <button
                      onclick="
                        document.getElementById('ai-avatar-input').click()
                      "
                      class="moe-btn-mini"
                    >
                      Upload
                    </button>
                    <button
                      class="change-frame-btn moe-btn-mini"
                      data-type="ai"
                    >
                      Frame
                    </button>
                    <button
                      id="manage-ai-avatar-library-btn"
                      class="moe-btn-mini"
                    >
                      Gallery
                    </button>
                  </div>
                  <input
                    type="file"
                    id="ai-avatar-input"
                    accept="image/*"
                    hidden
                  />
                </div>
              </div>

              <div
                class="form-group"
                id="group-avatar-group"
                style="display: none"
              >
                <label>Group Avatar</label>
                <div class="avatar-upload-column">
                  <img id="group-avatar-preview" class="preview-img" />
                  <div class="btn-stack">
                    <button
                      onclick="
                        document.getElementById('group-avatar-input').click()
                      "
                      class="moe-btn-mini"
                    >
                      Upload
                    </button>
                  </div>
                  <input
                    type="file"
                    id="group-avatar-input"
                    accept="image/*"
                    hidden
                  />
                </div>
              </div>

              <!-- My avatar -->
              <div class="form-group" id="my-avatar-group">
                <label>My Avatar</label>
                <div class="avatar-upload-column">
                  <img id="my-avatar-preview" class="preview-img" />
                  <div class="btn-stack">
                    <button
                      onclick="
                        document.getElementById('my-avatar-input').click()
                      "
                      class="moe-btn-mini"
                    >
                      Upload
                    </button>
                    <button
                      class="change-frame-btn moe-btn-mini"
                      data-type="my"
                    >
                      Frame
                    </button>
                    <button id="open-persona-library-btn" class="moe-btn-mini">
                      Preset
                    </button>
                  </div>
                  <input
                    type="file"
                    id="my-avatar-input"
                    accept="image/*"
                    hidden
                  />
                </div>
              </div>
            </div>

            <!-- Replace original id="couple-avatar-group" -->
            <div class="form-group" id="couple-avatar-group">
              <div class="moe-divider"></div>
              <div
                style="
                  display: flex;
                  justify-content: space-between;
                  align-items: center;
                  margin-bottom: 8px;
                "
              >
                <label class="toggle-switch-label" style="margin: 0">
                  <span
                    class="toggle-switch-text"
                    style="font-weight: 600; color: #ff6b81"
                    >‚ù§Ô∏è Couple Avatar Mode</span
                  >
                  <input type="checkbox" id="couple-avatar-toggle" />
                  <span class="toggle-switch-slider"></span>
                </label>

                <!-- Modified button style -->
                <button
                  id="manage-couple-avatar-library-btn"
                  class="moe-btn-secondary"
                  style="
                    margin: 0;
                    padding: 4px 12px;
                    font-size: 12px;
                    background-color: #fff0f3;
                    color: #ff6b81;
                    border: 1px solid #ffc2d1;
                    border-radius: 15px;
                  "
                >
                  üìÇ Manage Couple Avatar Library
                </button>
              </div>

              <div
                id="couple-avatar-desc-container"
                style="
                  display: none;
                  margin-top: 10px;
                  background: #fff0f3;
                  padding: 8px;
                  border-radius: 8px;
                "
              >
                <label
                  style="
                    font-size: 12px;
                    color: #ff8fa3;
                    display: block;
                    margin-bottom: 4px;
                  "
                  >Current Couple Avatar Description (AI reference)</label
                >
                <input
                  type="text"
                  id="couple-avatar-description"
                  class="moe-input"
                  style="background: #fff; border-color: #ffc2d1"
                  placeholder="e.g., A little cat looking at the moon"
                />
              </div>
            </div>
          </div>

          <!-- ============================== -->
          <!-- 2. Persona & memory card -->
          <!-- ============================== -->
          <div class="settings-group-card moe-card">
            <div class="settings-section-title">üß† AI Brain & Settings</div>

            <div class="form-group" id="ai-persona-group">
              <label for="ai-persona">Their Persona</label>
              <textarea id="ai-persona" rows="3" class="moe-input"></textarea>
            </div>
            <!-- ‚òÖ Use Global Persona toggle ‚òÖ -->
            <div class="form-group" id="use-global-persona-group">
              <div style="display:flex; justify-content:space-between; align-items:center; background:#f0f4ff; padding:10px 14px; border-radius:14px; margin-bottom:4px;">
                <div>
                  <div style="font-weight:600; font-size:14px; color:#4d96ff;">üåê Use Global Persona</div>
                  <div style="font-size:12px; color:#888;" id="global-persona-sync-label">Sync "My Persona" with active persona.</div>
                </div>
                <label class="toggle-switch-label" style="margin:0">
                  <input type="checkbox" id="use-global-persona-toggle" onchange="onUseGlobalPersonaToggle(this.checked)"/>
                  <span class="toggle-switch-slider"></span>
                </label>
              </div>
            </div>

            <div class="form-group" id="my-persona-group">
              <label for="my-persona">My Persona</label>
              <textarea id="my-persona" rows="3" class="moe-input"></textarea>
            </div>

            <div class="form-group" id="group-members-group">
              <label>Group Members Settings</label>
              <div
                id="group-members-settings"
                class="moe-list-box"
                style="margin-bottom: 10px"
              ></div>
              <button id="manage-members-btn" class="moe-btn-secondary">
                üë• Manage Group Members
              </button>
            </div>

            <!-- ‚òÖ‚òÖ‚òÖ Change: place NPC library and stickers side by side here ‚òÖ‚òÖ‚òÖ -->
            <div style="display: flex; gap: 10px; margin-top: 15px">
              <!-- NPC library button -->
              <div id="npc-library-group" style="flex: 1">
                <button
                  id="manage-npcs-btn"
                  class="moe-btn-secondary"
                  style="margin-top: 0; width: 100%"
                >
                  ü§ñ NPC Library
                </button>
              </div>
              <!-- Stickers button -->
              <div id="char-sticker-group" style="flex: 1">
                <button
                  id="manage-char-stickers-btn"
                  class="moe-btn-secondary"
                  style="margin-top: 0; width: 100%"
                >
                  üò∂ Stickers
                </button>
              </div>
            </div>

            <!-- Weibo settings -->
            <div class="form-group" id="weibo-profession-group">
              <div class="moe-divider"></div>
              <label>Weibo Profession</label>
              <input
                type="text"
                id="weibo-profession-input"
                class="moe-input"
                placeholder="e.g., Esports player"
              />
            </div>
            <div class="form-group" id="weibo-instruction-group">
              <label>Weibo Instructions (AI's guidelines when posting)</label>
              <textarea
                id="weibo-instruction-input"
                rows="2"
                class="moe-input"
                placeholder="e.g., Cold personality, rarely interacts with fans"
              ></textarea>
            </div>

            <!-- Link settings -->
            <div class="moe-divider"></div>
            <div class="form-group" id="world-book-link-group">
              <label>Linked World Books (multi-select)</label>
              <div class="custom-multiselect">
                <div class="select-box moe-input">
                  <span class="selected-options-text">-- Click to select --</span>
                  <span class="arrow-down">‚ñº</span>
                </div>
                <div
                  id="world-book-checkboxes-container"
                  class="checkboxes-container"
                ></div>
              </div>
            </div>

            <div class="form-group" id="memory-link-group">
              <label>Memory Sharing (select chats to link)</label>
              <div class="custom-multiselect" id="memory-link-multiselect">
                <div class="select-box moe-input">
                  <span class="selected-options-text">-- Click to select --</span>
                  <span class="arrow-down">‚ñº</span>
                </div>
                <div
                  id="memory-link-checkboxes-container"
                  class="checkboxes-container"
                ></div>
              </div>
              <div
                style="
                  margin-top: 8px;
                  display: flex;
                  align-items: center;
                  gap: 10px;
                  background: #f9f9f9;
                  padding: 8px;
                  border-radius: 8px;
                "
              >
                <label style="margin: 0; font-size: 13px; color: #666"
                  >Shared count:</label
                >
                <input
                  type="number"
                  id="link-memory-depth-input"
                  value="5"
                  min="1"
                  max="20"
                  class="moe-input"
                  style="width: 80px; text-align: center"
                />
              </div>
            </div>

            <!-- Original code -->
            <div class="form-group">
              <label for="max-memory">Context Memory Count</label>
              <input
                type="number"
                id="max-memory"
                value="10"
                class="moe-input"
              />
            </div>

            <div class="form-group">
              <label>Reply Count Range (Min - Max)</label>
              <div style="display: flex; gap: 10px; align-items: center">
                <input
                  type="number"
                  id="min-reply-count-input"
                  class="moe-input"
                  min="1"
                  placeholder="Min"
                  style="text-align: center"
                />
                <span>to</span>
                <input
                  type="number"
                  id="max-reply-count-input"
                  class="moe-input"
                  min="1"
                  placeholder="Max"
                  style="text-align: center"
                />
                <span>msgs</span>
              </div>
              <p style="font-size: 12px; color: #999; margin-top: 5px">
                Recommended: single chat 2-5, group chat 3-8.
              </p>
            </div>

            <div class="info-tags">
              <span class="tag"
                >Total messages:
                <span id="total-message-count-display">--</span></span
              >
              <span class="tag"
                >token:
                <span id="context-token-count-display">-- Tokens</span></span
              >
            </div>
          </div>

          <!-- ============================== -->
          <!-- 3. Gameplay mode card -->
          <!-- ============================== -->
          <div class="settings-group-card moe-card">
            <div class="settings-section-title">üéÆ Gameplay & Modes</div>

            <!-- Offline mode -->
            <div class="form-group" id="offline-mode-section">
              <label class="toggle-switch-label">
                <span class="toggle-switch-text">Offline Mode (Dating IRL)</span>
                <input type="checkbox" id="offline-mode-toggle" />
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
            <div
              id="offline-mode-details"
              class="moe-details-box"
              style="display: none"
            >
              <div class="form-group">
                <label>Preset Management</label>
                <div class="input-with-btn-row">
                  <select id="offline-preset-select" class="moe-input"></select>
                  <button id="manage-offline-presets-btn" class="moe-btn-small">
                    Manage
                  </button>
                </div>
              </div>
              <div class="form-group">
                <label>Scene Prompt</label>
                <textarea
                  id="offline-prompt-input"
                  rows="3"
                  class="moe-input"
                  placeholder="e.g., You are in a quiet caf√©..."
                ></textarea>
              </div>
              <div class="form-group">
                <label>Writing Style (Style)</label>
                <textarea
                  id="offline-style-input"
                  rows="2"
                  class="moe-input"
                  placeholder="e.g., Describe actions and expressions in detail..."
                ></textarea>
              </div>
              <div class="form-group">
                <label>Target Word Count</label>
                <input
                  type="number"
                  id="offline-word-count-input"
                  value="300"
                  class="moe-input"
                />
              </div>
              <div
                class="form-group"
                style="border-top: 1px dashed #ddd; padding-top: 10px"
              >
                <label class="toggle-switch-label" style="margin: 0">
                  <span class="toggle-switch-text" style="font-size: 13px"
                    >Auto-generate image each round</span
                  >
                  <input type="checkbox" id="offline-novelai-toggle" />
                  <span
                    class="toggle-switch-slider"
                    style="transform: scale(0.8)"
                  ></span>
                </label>
              </div>
            </div>

            <!-- Impersonate User Settings -->
            <div class="form-group">
              <label class="toggle-switch-label">
                <span class="toggle-switch-text">‚úèÔ∏è Impersonate User Settings</span>
                <input type="checkbox" id="impersonate-expand-toggle" style="display:none"/>
              </label>
            </div>
            <div class="moe-details-box" id="impersonate-settings-details" style="display: block">
              <div class="form-group">
                <label style="font-size:12px; color:#888; margin-bottom:4px; display:block">
                  Custom Prompt
                  <span style="font-weight:400"> ‚Äî use <code>{{user}}</code>, <code>{{char}}</code>, <code>{{wordCount}}</code></span>
                </label>
                <textarea
                  id="impersonate-prompt-input"
                  rows="5"
                  class="moe-input"
                  placeholder="Leave blank to use default prompt"
                ></textarea>
              </div>
              <div class="form-group">
                <label>Target Word Count</label>
                <input
                  type="number"
                  id="impersonate-wordcount-input"
                  value="150"
                  min="30"
                  max="2000"
                  step="10"
                  class="moe-input"
                />
              </div>
            </div>

            <!-- Chat summary -->
            <div class="form-group">
              <label class="toggle-switch-label">
                <span class="toggle-switch-text">Long-term Memory Summary</span>
                <input type="checkbox" id="summary-toggle" />
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
            <div
              id="summary-details-container"
              class="moe-details-box"
              style="display: none"
            >
              <div class="form-group">
                <label>Summary Mode</label>
                <div style="display: flex; gap: 20px; margin-top: 5px">
                  <label
                    ><input
                      type="radio"
                      name="summary-mode"
                      value="auto"
                      checked
                    />
                    Auto Summary</label
                  >
                  <label
                    ><input type="radio" name="summary-mode" value="manual" />
                    Manual Summary</label
                  >
                </div>
              </div>
              <div class="form-group">
                <label>Trigger Count</label>
                <input
                  type="number"
                  id="summary-count-input"
                  value="20"
                  min="5"
                  class="moe-input"
                />
              </div>
              <div class="form-group">
                <label>Summary Prompt</label>
                <textarea
                  id="summary-prompt-input"
                  rows="3"
                  class="moe-input"
                ></textarea>
              </div>
              <div class="moe-btn-group">
                <button id="view-summaries-btn" class="moe-btn-secondary">
                  View/Manage Summaries
                </button>
                <button id="manual-summary-btn" class="moe-btn-secondary">
                  Summarize Now
                </button>
              </div>
            </div>

            <!-- Streak system -->
            <div class="form-group" id="streak-settings-section">
              <label class="toggle-switch-label">
                <span class="toggle-switch-text">Streak System</span>
                <input type="checkbox" id="streak-enabled-toggle" />
                <span class="toggle-switch-slider"></span>
              </label>
              <button
                id="open-intimacy-panel-btn"
                class="moe-btn-secondary"
                style="display: none; margin-bottom: 10px"
              >
                üèÖ View Intimacy Panel
              </button>

              <div
                id="streak-details-container"
                class="moe-details-box"
                style="display: none"
              >
                <div class="moe-grid-row">
                  <div class="form-group">
                    <label>Initial Days</label>
                    <input
                      type="number"
                      id="streak-initial-days-input"
                      class="moe-input"
                    />
                  </div>
                  <div class="form-group">
                    <label>Extinguish Rule</label>
                    <select
                      id="streak-extinguish-threshold-select"
                      class="moe-input"
                    >
                      <option value="1">Extinguish after 1 day</option>
                      <option value="3">Extinguish after 3 days</option>
                      <option value="7">Extinguish after 7 days</option>
                      <option value="-1">Never extinguish</option>
                    </select>
                  </div>
                </div>
                <div class="form-group">
                  <label>Lit Icon URL (optional)</label>
                  <input
                    type="text"
                    id="streak-lit-icon-url"
                    class="moe-input"
                    placeholder="Default: üî•"
                  />
                </div>
                <div class="form-group">
                  <label>Extinguished Icon URL (optional)</label>
                  <input
                    type="text"
                    id="streak-extinguished-icon-url"
                    class="moe-input"
                    placeholder="Default: üßä"
                  />
                </div>
                <div class="form-group">
                  <label>Font Color</label>
                  <input
                    type="color"
                    id="streak-font-color-picker"
                    class="moe-input"
                    style="height: 40px; padding: 2px"
                  />
                </div>
              </div>
            </div>

            <!-- Group chat background -->
            <div
              class="form-group"
              id="group-background-activity-group"
              style="display: none"
            >
              <label class="toggle-switch-label">
                <span class="toggle-switch-text">Group Chat Background Activity</span>
                <input type="checkbox" id="group-background-activity-switch" />
                <span class="toggle-switch-slider"></span>
              </label>
              <div
                id="group-background-interval-settings"
                class="moe-details-box"
                style="display: none"
              >
                <label>Activity Interval (seconds)</label>
                <input
                  type="number"
                  id="group-background-interval-input"
                  min="60"
                  value="120"
                  class="moe-input"
                />
              </div>
            </div>

            <div class="form-group">
              <label class="toggle-switch-label">
                <span class="toggle-switch-text">Real-time Time Awareness</span>
                <input type="checkbox" id="time-perception-toggle" checked />
                <span class="toggle-switch-slider"></span>
              </label>
              <div
                id="custom-time-container"
                style="display: none; margin-top: 5px"
              >
                <label>Custom Time</label>
                <input
                  type="datetime-local"
                  id="custom-time-input"
                  class="moe-input"
                />
              </div>
            </div>
          </div>

          <!-- ============================== -->
          <!-- 4. Voice & video card -->
          <!-- ============================== -->
          <div class="settings-group-card moe-card">
            <div class="settings-section-title">üìû Voice & Video</div>

            <div class="form-group" id="minimax-voice-id-group">
              <label>Minimax Voice ID</label>
              <input
                type="text"
                id="minimax-voice-id-input"
                class="moe-input"
                placeholder="e.g., male-01"
              />
            </div>

            <div class="form-group" id="minimax-language-boost-group">
              <label for="minimax-language-boost-select"
                >Minimax Language Boost</label
              >
              <p
                style="
                  font-size: 12px;
                  font-weight: normal;
                  color: #999;
                  margin-top: 5px;
                  margin-bottom: 10px;
                "
              >
                Boost recognition for specific languages or dialects. Usually "Auto" is fine.
              </p>
              <select id="minimax-language-boost-select">
                <option value="">None (default)</option>
                <option value="auto">Auto</option>
                <option value="Chinese">Chinese (Mandarin)</option>
                <option value="Chinese,Yue">Cantonese</option>
                <option value="English">English</option>
                <option value="Japanese">Japanese</option>
                <option value="Korean">Korean</option>
                <option value="French">French</option>
                <option value="Spanish">Spanish</option>
                <option value="Arabic">Arabic</option>
                <option value="Russian">Russian</option>
                <option value="Portuguese">Portuguese</option>
                <option value="German">German</option>
                <option value="Turkish">Turkish</option>
                <option value="Dutch">Dutch</option>
                <option value="Ukrainian">Ukrainian</option>
                <option value="Vietnamese">Vietnamese</option>
                <option value="Indonesian">Indonesian</option>
                <option value="Italian">Italian</option>
                <option value="Thai">Thai</option>
                <option value="Polish">Polish</option>
                <option value="Romanian">Romanian</option>
                <option value="Greek">Greek</option>
                <option value_="">--- Other ---</option>
                <option value="Czech">Czech</option>
                <option value="Finnish">Finnish</option>
                <option value="Hindi">Hindi</option>
                <option value="Bulgarian">Bulgarian</option>
                <option value="Danish">Danish</option>
                <option value="Hebrew">Hebrew</option>
                <option value="Malay">Malay</option>
                <option value="Persian">Persian</option>
                <option value="Slovak">Slovak</option>
                <option value="Swedish">Swedish</option>
                <option value="Croatian">Croatian</option>
                <option value="Filipino">Filipino</option>
                <option value="Hungarian">Hungarian</option>
                <option value="Norwegian">Norwegian</option>
                <option value="Slovenian">Slovenian</option>
                <option value="Catalan">Catalan</option>
                <option value="Nynorsk">Nynorsk</option>
                <option value="Tamil">Tamil</option>
                <option value="Afrikaans">Afrikaans</option>
              </select>
            </div>

            <div class="form-group" id="minimax-speed-group">
              <label>Voice Speed: <span id="minimax-speed-value">1.0</span></label>
              <input
                type="range"
                id="minimax-speed-slider"
                min="0.5"
                max="2"
                step="0.1"
                value="1.0"
                class="moe-slider"
              />
            </div>

            <div class="form-group" id="video-call-settings-group">
              <div class="moe-divider"></div>
              <label class="toggle-switch-label">
                <span class="toggle-switch-text">Visual Video Call Interface</span>
                <input type="checkbox" id="visual-video-call-switch" />
                <span class="toggle-switch-slider"></span>
              </label>

              <div
                id="video-call-image-uploads"
                class="moe-details-box"
                style="display: none"
              >
                <div class="moe-grid-row">
                  <div class="center-text">
                    <label>Their Feed</label>
                    <div
                      class="video-preview-box"
                      onclick="
                        document
                          .getElementById('char-video-image-input')
                          .click()
                      "
                    >
                      <img
                        id="char-video-image-preview"
                        src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png"
                      />
                      <span>Click to upload</span>
                    </div>
                    <input
                      type="file"
                      id="char-video-image-input"
                      accept="image/*"
                      hidden
                    />
                  </div>
                  <div class="center-text">
                    <label>My Feed</label>
                    <div
                      class="video-preview-box"
                      onclick="
                        document
                          .getElementById('user-video-image-input')
                          .click()
                      "
                    >
                      <img
                        id="user-video-image-preview"
                        src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png"
                      />
                      <span>Click to upload</span>
                    </div>
                    <input
                      type="file"
                      id="user-video-image-input"
                      accept="image/*"
                      hidden
                    />
                  </div>
                </div>
              </div>
              <label
                class="toggle-switch-label"
                style="
                  margin-top: 10px;
                  border-top: 1px dashed #eee;
                  padding-top: 10px;
                "
              >
                <span class="toggle-switch-text">Use real camera for my feed</span>
                <input type="checkbox" id="user-real-camera-switch" />
                <span class="toggle-switch-slider"></span>
              </label>

              <label class="toggle-switch-label" style="margin-top: 10px">
                <span class="toggle-switch-text">Enable Voice Access</span>
                <input type="checkbox" id="video-call-voice-access-switch" />
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
          </div>

          <!-- ============================== -->
          <!-- 5. Visual styling card -->
          <!-- ============================== -->
          <div class="settings-group-card moe-card">
            <div class="settings-section-title">üé® Visual Styling</div>

            <div class="form-group">
              <label>Chat Background</label>
              <div class="bg-upload-container">
                <div class="bg-preview-wrapper">
                  <img
                    id="bg-preview"
                    class="bg-preview-img"
                    style="width: 100px; height: 150px; border-radius: 10px"
                  />
                  <button
                    id="remove-bg-btn"
                    style="
                      position: absolute;
                      top: -5px;
                      right: -5px;
                      width: 20px;
                      height: 20px;
                      border-radius: 50%;
                      background: red;
                      color: white;
                      border: none;
                      cursor: pointer;
                    "
                  >
                    √ó
                  </button>
                </div>
                <button
                  onclick="document.getElementById('bg-input').click()"
                  class="moe-btn-small"
                  style="width: auto"
                >
                  Upload
                </button>
                <input type="file" id="bg-input" accept="image/*" hidden />
              </div>
            </div>

            <div class="form-group">
              <label>Bubble Theme</label>
              <div
                class="theme-selector"
                style="display: flex; flex-wrap: wrap; gap: 10px"
              >
                <!-- Native radio buttons, JS will fill or keep as-is -->
                <label
                  ><input
                    type="radio"
                    name="theme-select"
                    value="default"
                    id="theme-default"
                  />
                  Default</label
                >
                <label
                  ><input type="radio" name="theme-select" value="pink_blue" />
                  Pink-Blue</label
                >
                <label
                  ><input type="radio" name="theme-select" value="blue_white" />
                  Blue-White</label
                >
                <label
                  ><input
                    type="radio"
                    name="theme-select"
                    value="purple_yellow"
                  />
                  Purple-Yellow</label
                >
                <label
                  ><input
                    type="radio"
                    name="theme-select"
                    value="black_white"
                  />
                  Black-White</label
                >
                <label
                  ><input
                    type="radio"
                    name="theme-select"
                    value="yellow_white"
                  />
                  Yellow-White</label
                >
                <label
                  ><input type="radio" name="theme-select" value="red_black" />
                  Red-Black</label
                >
                <label
                  ><input
                    type="radio"
                    name="theme-select"
                    value="blue_yellow"
                  />
                  Blue-Yellow</label
                >
                <label
                  ><input
                    type="radio"
                    name="theme-select"
                    value="pink_yellow"
                  />
                  Pink-Yellow</label
                >
                <label
                  ><input
                    type="radio"
                    name="theme-select"
                    value="pink_purple"
                  />
                  Pink-Purple</label
                >
                <label
                  ><input type="radio" name="theme-select" value="gray_white" />
                  Gray-White</label
                >
                <label
                  ><input type="radio" name="theme-select" value="blue_green" />
                  Blue-Green</label
                >
                <label
                  ><input type="radio" name="theme-select" value="pink_white" />
                  Pink-White</label
                >
                <label
                  ><input type="radio" name="theme-select" value="pink_black" />
                  Pink-Black</label
                >
                <label
                  ><input type="radio" name="theme-select" value="pink_green" />
                  Pink-Green</label
                >
                <label
                  ><input
                    type="radio"
                    name="theme-select"
                    value="green_black"
                  />
                  Green-Black</label
                >
              </div>
              <button
                id="reset-theme-btn"
                class="moe-btn-mini"
                style="width: auto; margin-top: 5px"
              >
                Restore Default Theme
              </button>
            </div>

            <div class="form-group">
              <label>Font Size: <span id="font-size-value">13px</span></label>
              <input
                type="range"
                id="font-size-slider"
                min="12"
                max="20"
                step="1"
                class="moe-slider"
              />
            </div>

            <div class="form-group">
              <label>Bubble Style Presets</label>
              <div class="input-with-btn-row">
                <select
                  id="bubble-style-preset-select"
                  class="moe-input"
                ></select>
                <button id="manage-bubble-presets-btn" class="moe-btn-small">
                  Manage
                </button>
              </div>
              <div class="moe-btn-group">
                <button id="export-bubble-preset-btn" class="moe-btn-mini">
                  Export
                </button>
                <button id="import-bubble-preset-btn" class="moe-btn-mini">
                  Import
                </button>
              </div>
              <input
                type="file"
                id="import-bubble-preset-input"
                accept=".json, .txt, .css, .docx"
                hidden
              />
            </div>

            <div class="form-group">
              <label
                >Custom CSS
                <button
                  id="reset-custom-css-btn"
                  class="moe-btn-mini"
                  style="margin-left: 5px; padding: 2px 6px"
                >
                  Reset
                </button></label
              >
              <textarea
                id="custom-css-input"
                rows="4"
                class="moe-input code-area"
                placeholder="/* Enter custom CSS code here */"
              ></textarea>
            </div>

            <div class="form-group">
              <label>Live Preview</label>
              <div id="settings-preview-area" class="preview-box"></div>
            </div>

            <!-- NAI image generation settings -->
            <div
              class="form-group"
              id="nai-character-settings-group"
              style="display: none"
            >
              <div class="moe-divider"></div>
              <label>NovelAI Image Gen (Single Chat)</label>
              <div style="display: flex; gap: 15px; margin: 10px 0">
                <label
                  ><input
                    type="radio"
                    name="nai-prompt-source"
                    value="system"
                    checked
                  />
                  System Default</label
                >
                <label
                  ><input
                    type="radio"
                    name="nai-prompt-source"
                    value="character"
                  />
                  Character Exclusive</label
                >
              </div>
              <button id="character-nai-prompts-btn" class="moe-btn-secondary">
                Configure Character Prompts
              </button>
            </div>

            <div
              class="form-group"
              id="group-nai-settings-group"
              style="display: none"
            >
              <div class="moe-divider"></div>
              <label>NovelAI Image Gen (Group Chat)</label>
              <div style="display: flex; gap: 15px; margin: 10px 0">
                <label
                  ><input
                    type="radio"
                    name="group-nai-prompt-source"
                    value="system"
                    checked
                  />
                  System Default</label
                >
                <label
                  ><input
                    type="radio"
                    name="group-nai-prompt-source"
                    value="character"
                  />
                  Character Exclusive</label
                >
              </div>
              <button
                id="group-character-nai-prompts-btn"
                class="moe-btn-secondary"
              >
                Configure Character Prompts
              </button>
            </div>
          </div>

          <!-- ============================== -->
          <!-- 6. Data & operations card -->
          <!-- ============================== -->
          <div class="settings-group-card moe-card">
            <div class="settings-section-title">üíæ Data & Operations</div>

            <div class="moe-btn-group">
              <button id="import-chat-history-btn" class="moe-btn-secondary">
                Import Chat History
              </button>
              <button id="export-chat-history-btn" class="moe-btn-secondary">
                Export Chat History
              </button>
            </div>
            <input
              type="file"
              id="import-chat-history-input"
              accept="application/json"
              hidden
            />

            <button
              id="search-chat-btn"
              class="moe-btn-secondary"
              style="margin-top: 10px"
            >
              üîç Search Chat Content
            </button>

            <div class="moe-divider"></div>

            <div class="moe-btn-group">
              <button id="clear-chat-btn" class="moe-btn-danger">
                üßπ Clear Chat
              </button>
              <button id="block-chat-btn" class="moe-btn-danger">
                üö´ Block Contact
              </button>
            </div>
          </div>

          <!-- Bottom padding to prevent floating button overlap -->
          <div style="height: 80px"></div>
        </div>

        <!-- Floating save button (FAB) -->
        <div
          class="modal-footer"
          style="
            border: none;
            padding: 0;
            position: absolute;
            bottom: 0;
            width: 100%;
            pointer-events: none;
          "
        >
          <!-- Cancel button on the left -->
          <button
            id="cancel-chat-settings-btn"
            class="moe-fab-cancel"
            style="pointer-events: auto"
          >
            ‚ùå<span style="font-size: 10px; display: block">Cancel</span>
          </button>

          <!-- Save button on the right -->
          <button
            id="save-chat-settings-btn"
            class="moe-fab-save"
            style="pointer-events: auto"
          >
            üíæ<span style="font-size: 10px; display: block">Save</span>
          </button>
        </div>
      </div>
    </div>

    <div id="persona-library-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>My Persona Library</span
          ><button id="add-persona-preset-btn" class="action-button">
            Add
          </button>
        </div>
        <div class="modal-body"><div id="persona-library-grid"></div></div>
        <div class="modal-footer">
          <button class="cancel" id="close-persona-library-btn">Close</button>
        </div>
      </div>
    </div>

    <div id="persona-editor-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span id="persona-editor-title">Add Persona Preset</span>
        </div>
        <div class="modal-body">
          <!-- NPC name input -->
          <div class="form-group" id="npc-editor-name-group">
            <label for="npc-editor-name-input">NPC Name</label>
            <input type="text" id="npc-editor-name-input" />
          </div>
          <div class="form-group">
            <label>Avatar</label>
            <div class="avatar-upload">
              <img id="preset-avatar-preview" />
              <button
                onclick="document.getElementById('preset-avatar-input').click()"
              >
                Upload Avatar
              </button>

              <button
                id="persona-editor-change-frame-btn"
                class="change-frame-btn"
                data-type="member"
              >
                Change Frame
              </button>
              <input type="file" id="preset-avatar-input" accept="image/*" />
            </div>
          </div>
          <div class="form-group">
            <label for="preset-persona-input">Persona</label>
            <textarea
              id="preset-persona-input"
              rows="4"
              placeholder="Enter detailed settings for this persona..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-persona-editor-btn">Cancel</button>
          <button class="save" id="save-persona-preset-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- PERSONA MANAGER EDITOR MODAL                  -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <div id="persona-manager-editor-modal" class="modal">
      <div class="modal-content moe-settings-content" style="max-height:90vh; overflow-y:auto;">
        <div class="modal-header">
          <span id="pm-editor-title">‚ú® New Persona</span>
        </div>
        <div class="modal-body">

          <!-- Identity Card -->
          <div class="settings-group-card" style="margin-bottom:14px;">
            <div class="settings-section-title">ü™™ Identity</div>

            <div class="form-group">
              <label>Display Name <span style="color:#e74c3c;">*</span></label>
              <input type="text" id="pm-editor-name" class="moe-input" placeholder="e.g. Rich CEO"/>
            </div>

            <div class="form-group">
              <label>Color Theme</label>
              <div id="pm-editor-color-picker" class="pm-color-picker">
                <div class="pm-color-dot selected" data-color="#4d96ff" style="background:#4d96ff;"></div>
                <div class="pm-color-dot" data-color="#ff6b6b" style="background:#ff6b6b;"></div>
                <div class="pm-color-dot" data-color="#51cf66" style="background:#51cf66;"></div>
                <div class="pm-color-dot" data-color="#fcc419" style="background:#fcc419;"></div>
                <div class="pm-color-dot" data-color="#cc5de8" style="background:#cc5de8;"></div>
                <div class="pm-color-dot" data-color="#f06595" style="background:#f06595;"></div>
              </div>
              <input type="hidden" id="pm-editor-color" value="#4d96ff"/>
            </div>

            <div class="form-group">
              <label>Avatar URL</label>
              <div style="display:flex; gap:10px; align-items:center;">
                <input type="text" id="pm-editor-avatar" class="moe-input" placeholder="https://..." style="flex:1;"
                  oninput="document.getElementById('pm-editor-avatar-preview').src=this.value||'https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg'"/>
                <img id="pm-editor-avatar-preview" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg"
                  style="width:50px;height:50px;border-radius:50%;object-fit:cover;border:2px solid #ddd;flex-shrink:0;"/>
              </div>
            </div>

            <div class="form-group">
              <label>Nickname (shown everywhere)</label>
              <input type="text" id="pm-editor-nickname" class="moe-input" placeholder="e.g. Alex"/>
            </div>

            <div class="form-group">
              <label>My Persona Description</label>
              <textarea id="pm-editor-description" rows="3" class="moe-input" placeholder="Describe this persona's personality, background..."></textarea>
            </div>

            <div class="form-group">
              <label>Starting Balance (¬•)</label>
              <input type="number" id="pm-editor-balance" class="moe-input" value="0" min="0" step="100"/>
            </div>
          </div>

          <!-- Weibo Card -->
          <div class="settings-group-card" style="margin-bottom:14px;">
            <div class="settings-section-title">üåê Weibo Profile</div>
            <div style="font-size:12px; color:#999; margin-bottom:10px;">Optional ‚Äî leave blank to inherit from Identity above</div>

            <div class="form-group">
              <label>Weibo Nickname</label>
              <input type="text" id="pm-editor-weibo-nickname" class="moe-input" placeholder="Leave blank to use nickname above"/>
            </div>

            <div class="form-group">
              <label>Weibo Avatar URL</label>
              <div style="display:flex; gap:10px; align-items:center;">
                <input type="text" id="pm-editor-weibo-avatar" class="moe-input" placeholder="Leave blank to use avatar above" style="flex:1;"
                  oninput="document.getElementById('pm-editor-weibo-avatar-preview').src=this.value||'https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg'"/>
                <img id="pm-editor-weibo-avatar-preview" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg"
                  style="width:50px;height:50px;border-radius:50%;object-fit:cover;border:2px solid #ddd;flex-shrink:0;"/>
              </div>
            </div>

            <div class="form-group">
              <label>Profession</label>
              <input type="text" id="pm-editor-weibo-profession" class="moe-input" placeholder="e.g. CEO, Student..."/>
            </div>

            <div class="form-group">
              <label>Weibo Bio / User Persona</label>
              <textarea id="pm-editor-weibo-persona" rows="3" class="moe-input" placeholder="How does this persona present themselves on Weibo..."></textarea>
            </div>
          </div>
        </div>

        <div class="modal-footer">
          <button class="cancel" onclick="closePersonaManagerEditor()">Cancel</button>
          <button id="pm-editor-delete-btn" onclick="deletePersonaFromManager()" class="moe-btn-danger" style="display:none;">
            üóë Delete
          </button>
          <button onclick="savePersonaFromModal()" class="save">üíæ Save</button>
        </div>
      </div>
    </div>

    <div id="member-settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header"><span>Edit Group Member</span></div>
        <div class="modal-body">
          <div class="form-group">
            <label for="member-name-input">Name</label
            ><input type="text" id="member-name-input" />
          </div>
          <div class="form-group">
            <label for="member-persona-input">Persona</label
            ><textarea id="member-persona-input" rows="4"></textarea>
          </div>

          <div class="form-group">
            <label>Avatar</label>
            <div class="avatar-upload">
              <img id="member-avatar-preview" />
              <button
                onclick="document.getElementById('member-avatar-input').click()"
              >
                Upload Avatar
              </button>
              <!-- Change avatar frame button -->
              <button
                id="member-editor-change-frame-btn"
                class="change-frame-btn"
              >
                Change Frame
              </button>
              <input
                type="file"
                id="member-avatar-input"
                accept="image/*"
                hidden
              />
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-member-settings-btn">Cancel</button
          ><button class="save" id="save-member-settings-btn">Save</button>
        </div>
      </div>
    </div>

    <div id="custom-modal-overlay">
      <div id="custom-modal">
        <div class="custom-modal-header" id="custom-modal-title"></div>
        <div class="custom-modal-body" id="custom-modal-body"></div>
        <div class="custom-modal-footer">
          <button id="custom-modal-cancel">Cancel</button>
          <button id="custom-modal-confirm" class="confirm-btn">Confirm</button>
        </div>
      </div>
    </div>

    <div id="preset-actions-modal" class="modal">
      <div id="custom-modal" style="width: 250px">
        <div class="custom-modal-footer">
          <button id="preset-action-edit">Edit Preset</button>
          <button id="preset-action-delete" class="btn-danger">Delete Preset</button>
          <button
            id="preset-action-cancel"
            style="
              margin-top: 8px;
              border-radius: 8px;
              background-color: #f0f0f0;
            "
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <div id="transfer-modal">
      <div class="transfer-content">
        <div class="transfer-header">Surprise them!</div>
        <div class="transfer-input-group">
          <label for="transfer-amount">Transfer Amount</label>
          <input
            type="number"
            id="transfer-amount"
            placeholder="0.00"
            min="0"
            max="9999999999999"
            step="0.01"
          />
        </div>
        <div class="transfer-input-group">
          <label for="transfer-note">Note (optional)</label>
          <input
            type="text"
            id="transfer-note"
            placeholder="Leave a little note~"
            maxlength="20"
          />
        </div>
        <div class="transfer-actions">
          <button id="transfer-cancel-btn">Cancel</button>
          <button id="transfer-confirm-btn">Confirm Transfer</button>
        </div>
      </div>
    </div>

    <div id="battery-alert-modal">
      <div class="battery-alert-content">
        <img id="battery-alert-image" src="" />
        <p id="battery-alert-text"></p>
      </div>
    </div>

    <audio id="audio-player" style="display: none"></audio>

    <audio id="dating-bgm-player" loop></audio>

    <audio id="tts-audio-player" style="display: none"></audio>

    <audio id="ringtone-player" loop></audio>
    <audio id="notification-sound-player" preload="auto"></audio>
    <audio
      id="strong-keep-alive-player"
      loop
      src="https://files.catbox.moe/7jn7bp.mp3"
    ></audio>

    <div id="create-post-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 90%">
        <div class="modal-header">
          <span id="create-post-modal-title">Post Status</span>
          <!-- Using ID so JS can modify the title -->
        </div>
        <div class="modal-body">
          <!-- Public text input area -->
          <div class="form-group">
            <textarea
              id="post-public-text"
              rows="3"
              placeholder="Share something new..."
            ></textarea>
          </div>

          <!-- Mode switch -->
          <div class="post-mode-switcher">
            <button id="switch-to-image-mode" class="mode-btn active">
              Upload Image
            </button>
            <button id="switch-to-text-image-mode" class="mode-btn">
              Use Text Image
            </button>
          </div>

          <!-- Image mode area -->
          <div id="image-mode-content" class="post-mode-content active">
            <div class="form-group">
              <div
                id="post-image-preview-container"
                class="post-image-preview-container"
              >
                <img id="post-image-preview" src="" alt="Image preview" />
                <button id="post-remove-image-btn">√ó</button>
              </div>
              <div class="post-image-upload-options">
                <button
                  id="post-upload-local-btn"
                  class="form-button-secondary"
                >
                  Upload Local
                </button>
                <button id="post-use-url-btn" class="form-button-secondary">
                  Web URL
                </button>
                <input
                  type="file"
                  id="post-local-image-input"
                  accept="image/*"
                  hidden
                />
              </div>
            </div>
            <!-- Image description for AI, hidden in Weibo mode -->
            <div
              id="post-image-desc-group"
              class="form-group"
              style="display: none"
            >
              <label>Image Description (required, for AI)</label>
              <input
                type="text"
                id="post-image-description"
                placeholder="Briefly describe the image to help AI understand"
              />
            </div>
          </div>

          <!-- Text image mode area -->
          <div id="text-image-mode-content" class="post-mode-content">
            <div class="form-group">
              <label>Text Image (description for AI, visible after clicking image)</label>
              <textarea
                id="post-hidden-text"
                rows="4"
                placeholder="Write the image description here..."
              ></textarea>
            </div>
          </div>

          <div class="form-group" id="post-visibility-group">
            <label>Visibility</label>
            <div style="display: flex; gap: 20px; margin-bottom: 10px">
              <label
                ><input type="radio" name="visibility" value="all" checked />
                Visible to all</label
              >
              <label
                ><input type="radio" name="visibility" value="groups" />
                Visible to groups only</label
              >
            </div>
            <div
              id="post-visibility-groups"
              style="
                display: none;
                max-height: 120px;
                overflow-y: auto;
                background-color: #f0f2f5;
                padding: 10px;
                border-radius: 8px;
              "
            >
              <!-- Group checkboxes will be dynamically generated here by JS -->
            </div>
          </div>

          <!-- Comment toggle for feed feature, hidden in Weibo mode -->
          <div
            class="form-group"
            id="post-comments-toggle-group"
            style="margin-top: 15px"
          >
            <label for="post-comments-toggle" class="toggle-switch-label">
              <span class="toggle-switch-text">Allow characters to see comment section</span>
              <input type="checkbox" id="post-comments-toggle" checked />
              <span class="toggle-switch-slider"></span>
            </label>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-post-btn">Cancel</button>
          <button class="save" id="confirm-create-post-btn">Post</button>
        </div>
      </div>
    </div>

    <!-- NovelAI generation settings modal -->
    <div id="novelai-settings-modal" class="modal" style="display: none">
      <div
        class="modal-content"
        style="max-width: 600px; width: 90%; max-height: 85vh; overflow-y: auto"
      >
        <div class="modal-header">
          <span>NovelAI Generation Settings</span>
          <span
            class="close"
            id="close-novelai-settings"
            style="
              cursor: pointer;
              float: right;
              font-size: 28px;
              font-weight: bold;
            "
            >&times;</span
          >
        </div>
        <div class="modal-body" style="padding: 20px">
          <div class="form-group">
            <label style="color: #333">Image Size (oplus supports unlimited small images)</label>
            <select
              id="nai-resolution"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
              "
            >
              <optgroup label="Small">
                <option value="512x768">Portrait (512x768)</option>
                <option value="768x512">Landscape (768x512)</option>
                <option value="640x640">Square (640x640)</option>
              </optgroup>
              <optgroup label="Normal">
                <option value="832x1216">Vertical (832x1216)</option>
                <option value="1216x832">Horizontal (1216x832)</option>
                <option value="1024x1024" selected>Square (1024x1024)</option>
              </optgroup>
              <optgroup label="Wallpaper">
                <option value="1088x1920">Portrait (1088x1920)</option>
                <option value="1920x1088">Landscape (1920x1088)</option>
              </optgroup>
            </select>
            <small style="color: #666"
              >Recommended to use officially supported standard sizes for best results</small
            >
          </div>

          <div class="form-group">
            <label style="color: #333">Sampling Steps</label>
            <input
              type="number"
              id="nai-steps"
              value="28"
              min="1"
              max="50"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
              "
            />
            <small style="color: #666"
              >Recommended: 28 (higher values = better quality but slower)</small
            >
          </div>

          <div class="form-group">
            <label style="color: #333">Prompt Adherence (CFG Scale)</label>
            <input
              type="number"
              id="nai-cfg-scale"
              value="5"
              min="1"
              max="20"
              step="0.5"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
              "
            />
            <small style="color: #666"
              >Recommended: 5 (controls how closely image follows prompt)</small
            >
          </div>

          <div class="form-group">
            <label style="color: #333">Sampler</label>
            <select
              id="nai-sampler"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
              "
            >
              <option value="k_euler">Euler</option>
              <option value="k_euler_ancestral" selected>
                Euler Ancestral
              </option>
              <option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
              <option value="k_dpmpp_2m">DPM++ 2M</option>
              <option value="k_dpmpp_sde">DPM++ SDE</option>
              <option value="ddim">DDIM</option>
            </select>
          </div>

          <div class="form-group">
            <label style="color: #333">Random Seed</label>
            <input
              type="number"
              id="nai-seed"
              value="-1"
              min="-1"
              max="9999999999"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
              "
            />
            <small style="color: #666"
              >-1 means random; fixed seed reproduces the same image</small
            >
          </div>

          <div class="form-group">
            <label style="color: #333">Negative Prompt Preset (UC Preset)</label>
            <select
              id="nai-uc-preset"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
              "
            >
              <option value="0">Preset 0 - Heavy</option>
              <option value="1" selected>Preset 1 - Light</option>
              <option value="2">Preset 2 - Human Focus</option>
              <option value="3">Preset 3 - None</option>
            </select>
          </div>

          <div class="form-group">
            <label style="color: #333">Quality Tags</label>
            <div style="display: flex; align-items: center; gap: 10px">
              <input
                type="checkbox"
                id="nai-quality-toggle"
                checked
                style="width: auto"
              />
              <span style="color: #666; font-size: 14px"
                >Auto-add quality enhancement tags</span
              >
            </div>
          </div>

          <div class="form-group">
            <label style="color: #333">SMEA (Enhance Details)</label>
            <div style="display: flex; align-items: center; gap: 10px">
              <input
                type="checkbox"
                id="nai-smea"
                checked
                style="width: auto"
              />
              <span style="color: #666; font-size: 14px">Enable SMEA Enhancement</span>
            </div>
          </div>

          <div class="form-group">
            <label style="color: #333">SMEA DYN (Dynamic Optimization)</label>
            <div style="display: flex; align-items: center; gap: 10px">
              <input type="checkbox" id="nai-smea-dyn" style="width: auto" />
              <span style="color: #666; font-size: 14px">Enable Dynamic SMEA</span>
            </div>
          </div>

          <div class="form-group">
            <label style="color: #333">Default Positive Prompt</label>
            <textarea
              id="nai-default-positive"
              rows="3"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
                resize: vertical;
              "
              placeholder="masterpiece, best quality, 1girl, beautiful..."
            >
masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style</textarea
            >
            <small style="color: #666"
              >This prompt will be used automatically during generation (if not filled in the test dialog)</small
            >
          </div>

          <div class="form-group">
            <label style="color: #333">Default Negative Prompt</label>
            <textarea
              id="nai-default-negative"
              rows="3"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
                resize: vertical;
              "
              placeholder="lowres, bad anatomy, bad hands, text, error..."
            >
lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry</textarea
            >
          </div>

          <div
            class="form-group"
            style="
              border-top: 1px solid #ddd;
              padding-top: 15px;
              margin-top: 15px;
            "
          >
            <label style="color: #333">üåê CORS Proxy Settings</label>
            <select
              id="nai-cors-proxy"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
              "
            >
              <option value="">‚ùå Direct (no proxy)</option>
              <option value="https://corsproxy.io/?" selected>
                ‚úÖ corsproxy.io (Recommended)
              </option>
              <option value="https://api.allorigins.win/raw?url=">
                allorigins.win
              </option>
              <option value="https://cors-anywhere.herokuapp.com/">
                cors-anywhere (requires activation)
              </option>
              <option value="custom">üîß Custom Proxy</option>
            </select>
            <small style="color: #e74c3c; display: block; margin-top: 8px">
              ‚ö†Ô∏è Running locally will encounter CORS issues; a proxy is required. Recommended: corsproxy.io
            </small>
          </div>

          <div
            id="nai-custom-proxy-group"
            class="form-group"
            style="display: none"
          >
            <label style="color: #333">Custom Proxy URL</label>
            <input
              type="text"
              id="nai-custom-proxy-url"
              placeholder="https://your-proxy.com/?"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 8px;
                width: 100%;
                border-radius: 4px;
              "
            />
            <small style="color: #666"
              >Proxy URL should end with / or ?, e.g., https://proxy.com/?</small
            >
          </div>
        </div>
        <div class="modal-footer">
          <button
            id="reset-nai-settings-btn"
            class="form-button form-button-secondary"
            style="margin-right: 10px"
          >
            Reset to Default
          </button>
          <button
            id="save-nai-settings-btn"
            class="form-button form-button-secondary"
          >
            Save Settings
          </button>
        </div>
      </div>
    </div>

    <!-- PixAI generation settings modal -->
    <div id="pixai-settings-modal" class="modal" style="display: none">
      <div class="modal-content" style="max-width: 600px; width: 90%; max-height: 85vh; overflow-y: auto">
        <div class="modal-header">
          <span>PixAI Generation Settings</span>
          <span class="close" id="close-pixai-settings"
            style="cursor:pointer; float:right; font-size:28px; font-weight:bold">&times;</span>
        </div>
        <div class="modal-body" style="padding: 20px">

          <!-- Resolution -->
          <div class="form-group">
            <label style="color:#333">Image Size</label>
            <select id="pai-resolution" class="moe-input">
              <optgroup label="DiT / SDXL">
                <option value="768x1280" selected>Portrait (768√ó1280)</option>
                <option value="1280x768">Landscape (1280√ó768)</option>
                <option value="1024x1024">Square (1024√ó1024)</option>
                <option value="896x1152">Portrait (896√ó1152)</option>
                <option value="1152x896">Landscape (1152√ó896)</option>
              </optgroup>
              <optgroup label="SD v1 (Hoshino / older)">
                <option value="512x768">Portrait (512√ó768)</option>
                <option value="768x512">Landscape (768√ó512)</option>
                <option value="512x512">Square (512√ó512)</option>
                <option value="768x1024">Portrait (768√ó1024)</option>
                <option value="1024x768">Landscape (1024√ó768)</option>
              </optgroup>
            </select>
          </div>

          <!-- Steps -->
          <div class="form-group">
            <label style="color:#333">Sampling Steps</label>
            <input type="number" id="pai-steps" value="28" min="8" max="50" class="moe-input"/>
          </div>

          <!-- CFG Scale -->
          <div class="form-group">
            <label style="color:#333">Prompt Adherence (CFG Scale)</label>
            <input type="number" id="pai-cfg-scale" value="5" min="1.1" max="15" step="0.5" class="moe-input"/>
          </div>

          <!-- Seed -->
          <div class="form-group">
            <label style="color:#333">Random Seed (-1 = random)</label>
            <input type="number" id="pai-seed" value="-1" min="-1" max="9999999999" class="moe-input"/>
          </div>

          <!-- Default Positive Prompt -->
          <div class="form-group">
            <label style="color:#333">Default Positive Prompt</label>
            <textarea id="pai-default-positive" rows="3" class="moe-input"
              placeholder="masterpiece, best quality, 1girl, beautiful..."
            >masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style</textarea>
          </div>

          <!-- Default Negative Prompt -->
          <div class="form-group">
            <label style="color:#333">Default Negative Prompt</label>
            <textarea id="pai-default-negative" rows="3" class="moe-input"
              placeholder="lowres, bad anatomy, bad hands, text, error..."
            >lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry</textarea>
          </div>

          <!-- CORS Proxy -->
          <div class="form-group" style="border-top:1px solid #ddd; padding-top:15px; margin-top:15px">
            <label style="color:#333">üåê CORS Proxy Settings</label>
            <select id="pai-cors-proxy" class="moe-input">
              <option value="">‚ùå Direct (no proxy)</option>
              <option value="https://corsproxy.io/?" selected>‚úÖ corsproxy.io (Recommended)</option>
              <option value="https://api.allorigins.win/raw?url=">allorigins.win</option>
              <option value="https://cors-anywhere.herokuapp.com/">cors-anywhere (requires activation)</option>
              <option value="custom">üîß Custom Proxy</option>
            </select>
          </div>
          <div id="pai-custom-proxy-group" class="form-group" style="display:none">
            <label style="color:#333">Custom Proxy URL</label>
            <input type="text" id="pai-custom-proxy-url" class="moe-input" placeholder="https://your-proxy.com/?"/>
          </div>

        </div>
        <div class="modal-footer">
          <button id="reset-pixai-settings-btn" class="form-button form-button-secondary" style="margin-right:10px">
            Reset to Default
          </button>
          <button id="save-pixai-settings-btn" class="form-button form-button-secondary">
            Save Settings
          </button>
        </div>
      </div>
    </div>

    <!-- NovelAI test generation modal -->
    <div id="novelai-test-modal" class="modal" style="display: none">
      <div
        class="modal-content"
        style="max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto"
      >
        <div class="modal-header">
          <span>üñºÔ∏è NovelAI Test Generation</span>
          <span
            class="close"
            id="close-novelai-test"
            style="
              cursor: pointer;
              float: right;
              font-size: 28px;
              font-weight: bold;
            "
            >&times;</span
          >
        </div>
        <div class="modal-body" style="padding: 20px">
          <div class="form-group">
            <label style="color: #333"
              >Positive Prompt (this prompt is only for testing in this dialog)</label
            >
            <textarea
              id="nai-test-prompt"
              rows="4"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 10px;
                width: 100%;
                border-radius: 4px;
                resize: vertical;
              "
              placeholder="1girl, solo, long hair, blue eyes, smile..."
            >
1girl, solo, long hair, blue eyes, smile, outdoors, cherry blossoms, spring</textarea
            >
          </div>

          <div class="form-group">
            <label style="color: #333">Negative Prompt (optional, leave blank to use default)</label>
            <textarea
              id="nai-test-negative"
              rows="3"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 10px;
                width: 100%;
                border-radius: 4px;
                resize: vertical;
              "
              placeholder="Leave blank to use default negative prompt from settings"
            ></textarea>
          </div>

          <div style="text-align: center; margin: 20px 0">
            <button
              id="nai-generate-btn"
              style="
                background-color: #007bff;
                color: white;
                border: none;
                padding: 12px 30px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 16px;
                font-weight: bold;
              "
            >
              Generate Image
            </button>
          </div>

          <div
            id="nai-test-status"
            style="
              text-align: center;
              color: #666;
              margin: 15px 0;
              display: none;
            "
          >
            Generating, please wait...
          </div>

          <div id="nai-test-result" style="display: none; margin-top: 20px">
            <div style="font-weight: bold; color: #333; margin-bottom: 10px">
              Generation Result:
            </div>
            <div
              style="
                text-align: center;
                background: #f8f9fa;
                padding: 15px;
                border-radius: 8px;
                border: 1px solid #e9ecef;
              "
            >
              <img
                id="nai-result-image"
                style="
                  max-width: 100%;
                  border-radius: 8px;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
              />
            </div>
            <div style="margin-top: 10px; text-align: center">
              <button
                id="nai-download-btn"
                class="form-button-secondary"
                style="margin: 0"
              >
                Download Image
              </button>
            </div>
          </div>

          <div
            id="nai-test-error"
            style="
              display: none;
              margin-top: 15px;
              padding: 12px;
              background: #f8d7da;
              color: #721c24;
              border-radius: 6px;
              border: 1px solid #f5c6cb;
            "
          ></div>
        </div>
        <div class="modal-footer">
          <button id="close-nai-test-btn" class="form-button">Close</button>
        </div>
      </div>
    </div>

    <!-- PixAI test generation modal -->
    <div id="pixai-test-modal" class="modal" style="display: none">
      <div class="modal-content" style="max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto">
        <div class="modal-header">
          <span>üñºÔ∏è PixAI Test Generation</span>
          <span class="close" id="close-pixai-test"
            style="cursor:pointer; float:right; font-size:28px; font-weight:bold">&times;</span>
        </div>
        <div class="modal-body" style="padding: 20px">

          <div class="form-group">
            <label style="color:#333">Positive Prompt (test only)</label>
            <textarea id="pai-test-prompt" rows="4" class="moe-input"
              placeholder="1girl, solo, long hair, blue eyes, smile..."
            >1girl, solo, long hair, blue eyes, smile, outdoors, cherry blossoms, spring</textarea>
          </div>

          <div class="form-group">
            <label style="color:#333">Negative Prompt (optional ‚Äî leave blank to use default)</label>
            <textarea id="pai-test-negative" rows="3" class="moe-input"
              placeholder="Leave blank to use default negative prompt from settings"></textarea>
          </div>

          <div style="text-align:center; margin: 20px 0">
            <button id="pai-generate-btn"
              style="background:#007bff; color:#fff; border:none; padding:12px 30px; border-radius:6px; cursor:pointer; font-size:16px; font-weight:bold">
              Generate Image
            </button>
          </div>

          <div id="pai-test-status" style="text-align:center; color:#666; margin:15px 0; display:none">
            Generating, please wait‚Ä¶ (polling PixAI task)
          </div>

          <div id="pai-test-result" style="display:none; margin-top:20px">
            <div style="font-weight:bold; color:#333; margin-bottom:10px">Generation Result:</div>
            <div style="text-align:center; background:#f8f9fa; padding:15px; border-radius:8px; border:1px solid #e9ecef">
              <img id="pai-result-image" style="max-width:100%; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.1)"/>
            </div>
            <div style="margin-top:10px; text-align:center">
              <button id="pai-download-btn" class="form-button-secondary" style="margin:0">Download Image</button>
            </div>
          </div>

          <div id="pai-test-error"
            style="display:none; margin-top:15px; padding:12px; background:#f8d7da; color:#721c24; border-radius:6px; border:1px solid #f5c6cb">
          </div>
        </div>
        <div class="modal-footer">
          <button id="close-pai-test-btn" class="form-button">Close</button>
        </div>
      </div>
    </div>

    <!-- Character-exclusive NAI image generation settings modal -->
    <div id="character-nai-prompts-modal" class="modal" style="display: none">
      <div class="modal-content">
        <div class="modal-header">
          <span>Character-Exclusive NAI Prompt Configuration</span>
          <span
            class="close"
            id="close-character-nai-prompts"
            style="
              cursor: pointer;
              float: right;
              font-size: 28px;
              font-weight: bold;
            "
            >&times;</span
          >
        </div>
        <div class="modal-body">
          <p
            style="
              font-size: 13px;
              color: #666;
              margin-bottom: 20px;
              background-color: #f0f8ff;
              padding: 12px;
              border-radius: 6px;
              border-left: 3px solid #007bff;
            "
          >
            üí° Prompts configured here only apply to NAI image generation for the current character, and do not affect other characters or system settings
          </p>

          <div class="form-group">
            <label
              for="character-nai-positive"
              style="color: #333; font-weight: 600"
            >
              Positive Prompt
            </label>
            <textarea
              id="character-nai-positive"
              rows="4"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 10px;
                width: 100%;
                border-radius: 4px;
                resize: vertical;
                font-size: 13px;
              "
              placeholder="e.g., masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style"
            ></textarea>
            <small
              style="
                display: block;
                color: #666;
                font-size: 12px;
                margin-top: 5px;
              "
            >
              Describe the image style you want to generate; you can include artist tags
            </small>
          </div>

          <div class="form-group">
            <label
              for="character-nai-negative"
              style="color: #333; font-weight: 600"
            >
              Negative Prompt
            </label>
            <textarea
              id="character-nai-negative"
              rows="4"
              style="
                background-color: #f8f9fa;
                color: #333;
                border: 1px solid #ccc;
                padding: 10px;
                width: 100%;
                border-radius: 4px;
                resize: vertical;
                font-size: 13px;
              "
              placeholder="e.g., lowres, bad anatomy, bad hands, text, error, missing fingers"
            ></textarea>
            <small
              style="
                display: block;
                color: #666;
                font-size: 12px;
                margin-top: 5px;
              "
            >
              Describe elements you want to avoid
            </small>
          </div>
        </div>
        <div class="modal-footer">
          <button
            id="reset-character-nai-prompts-btn"
            class="form-button form-button-secondary"
            style="margin-right: 10px"
          >
            Clear Configuration
          </button>
          <button
            id="save-character-nai-prompts-btn"
            class="form-button form-button-secondary"
          >
            Save
          </button>
        </div>
      </div>
    </div>

    <div id="group-management-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Manage Friend Groups</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Create New Group</label>
            <div style="display: flex; gap: 10px">
              <input
                type="text"
                id="new-group-name-input"
                placeholder="Enter group name..."
                style="flex-grow: 1"
              />
              <button
                id="add-new-group-btn"
                class="form-button"
                style="width: auto; margin-top: 0; padding: 0 15px"
              >
                Add
              </button>
            </div>
          </div>
          <hr style="opacity: 0.2" />
          <div
            id="existing-groups-list"
            style="display: flex; flex-direction: column; gap: 10px"
          >
            <!-- Group list will be dynamically generated by JS -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="save" id="close-group-manager-btn" style="width: 100%">
            Done
          </button>
        </div>
      </div>
    </div>

    <div id="message-actions-modal" class="modal">
      <div id="custom-modal" style="width: 260px">
        <div class="custom-modal-footer" id="message-actions-footer">
          <!-- Regenerate Image (hidden by default, shown for NAI images) -->
          <button
            id="reroll-nai-btn"
            style="display: none"
            class="msg-action-grid-span"
          >
            üé® Regenerate Image
          </button>
          <!-- 2-column grid for main actions -->
          <div class="msg-action-grid">
            <button id="edit-message-btn">‚úèÔ∏è Edit</button>
            <button id="copy-message-btn">üìã Copy</button>
            <button id="recall-message-btn">üóëÔ∏è Recall</button>
            <button id="quote-message-btn">üí¨ Quote</button>
            <button id="select-message-btn" class="msg-action-grid-span">‚òëÔ∏è Multi-select</button>
          </div>
          <!-- Cancel ‚Äî full width -->
          <button id="cancel-message-action-btn" class="msg-action-cancel">Cancel</button>
        </div>
      </div>
    </div>

    <div id="post-actions-modal" class="modal">
      <div id="custom-modal" style="width: 250px">
        <div class="custom-modal-footer">
          <button id="edit-post-btn">Edit Post</button>
          <button id="copy-post-btn">Copy Content</button>
          <button id="cancel-post-action-btn">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Poke / Pat choice modal -->
    <div id="poke-choice-modal" class="modal">
      <div id="custom-modal" style="width: 230px">
        <div class="custom-modal-header" style="text-align:center; padding: 14px 16px 10px">
          Choose an action
        </div>
        <div class="custom-modal-footer" style="flex-direction: column">
          <button id="do-poke-btn" style="width:100%; border:none; border-bottom:1px solid #dbdbdb; padding:14px; font-size:16px; cursor:pointer; background:none; color:var(--accent-color)">
            üëâ Poke
          </button>
          <button id="do-pat-btn" style="width:100%; border:none; border-bottom:1px solid #dbdbdb; padding:14px; font-size:16px; cursor:pointer; background:none; color:var(--accent-color)">
            ü§ö Pat
          </button>
          <button id="cancel-poke-btn" style="width:100%; border:none; padding:14px; font-size:16px; cursor:pointer; background:#f0f0f0; color:#555; border-radius: 0 0 14px 14px">
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Visual message editor modal -->
    <div id="message-editor-modal" class="modal">
      <div class="modal-content" style="height: 75%">
        <div class="modal-header">
          <span>Edit & Split Message</span>
        </div>
        <div class="modal-body" id="message-editor-body">
          <!-- Editor container, JS dynamically generates text boxes here -->
          <div id="message-editor-container"></div>
          <!-- Button to add new message -->
          <button
            id="add-message-editor-block-btn"
            class="form-button form-button-secondary"
            style="margin-top: 15px"
          >
            [+] Add Next Message
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-advanced-editor-btn">Cancel</button>
          <button class="save" id="save-advanced-editor-btn">Save Changes</button>
        </div>
      </div>
    </div>

    <!-- [New] Food delivery payment request modal -->
    <div id="waimai-request-modal" class="modal">
      <div class="modal-content" style="width: 300px">
        <div class="modal-header">
          <span id="waimai-modal-title">Food Delivery</span>
        </div>
        <div class="modal-body">

          <!-- Mode toggle: Request Payment vs Order for Them -->
          <div class="waimai-mode-toggle">
            <button class="waimai-mode-btn active" id="waimai-mode-request" data-mode="request">
              üí≥ Request Payment
            </button>
            <button class="waimai-mode-btn" id="waimai-mode-order" data-mode="order">
              üõµ Order for Them
            </button>
          </div>

          <!-- Wallet balance ‚Äî only shown in "Order for Them" mode -->
          <div id="waimai-balance-display" style="display:none">
            <span class="waimai-balance-label">Your wallet:</span>
            <span id="waimai-balance-value" class="waimai-balance-value">¬•0.00</span>
          </div>

          <!-- Item Info -->
          <div class="form-group">
            <label for="waimai-product-info">Item Info</label>
            <input
              type="text"
              id="waimai-product-info"
              placeholder="e.g., Mango pomelo sago"
            />
          </div>

          <!-- Quantity (new) -->
          <div class="form-group">
            <label for="waimai-quantity">Quantity</label>
            <input
              type="number"
              id="waimai-quantity"
              placeholder="e.g., 1"
              min="1"
              step="1"
              value="1"
            />
          </div>

          <!-- Amount -->
          <div class="form-group">
            <label for="waimai-amount" id="waimai-amount-label">Amount (¬•)</label>
            <input
              type="number"
              id="waimai-amount"
              placeholder="e.g., 21"
              min="0"
              step="0.01"
            />
          </div>

          <!-- Note ‚Äî only shown in "Order for Them" mode -->
          <div class="form-group" id="waimai-note-group" style="display: none">
            <label for="waimai-note">Note (optional)</label>
            <input
              type="text"
              id="waimai-note"
              placeholder="e.g., Less sugar, extra ice"
            />
          </div>

        </div>
        <div class="modal-footer">
          <button class="cancel" id="waimai-cancel-btn">Cancel</button>
          <button class="save" id="waimai-confirm-btn">Send Request</button>
        </div>
      </div>
    </div>

    <!-- New appointment/countdown modal -->
    <div id="create-countdown-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>New Appointment</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="countdown-title-input">Appointment Title</label>
            <input
              type="text"
              id="countdown-title-input"
              placeholder="e.g., My Birthday"
            />
          </div>
          <div class="form-group">
            <label for="countdown-date-input">Appointment Date & Time</label>
            <input
              type="datetime-local"
              id="countdown-date-input"
              style="
                width: 95%;
                padding: 8px;
                border-radius: 8px;
                border: 1px solid var(--border-color);
              "
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-countdown-btn">Cancel</button>
          <button class="save" id="confirm-create-countdown-btn">
            Save Appointment
          </button>
        </div>
      </div>
    </div>

    <!-- [New] Send red packet modal -->
    <div id="red-packet-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>Send Red Packet</span>
        </div>
        <div class="modal-body" style="padding: 0">
          <!-- 1. Tab switching -->
          <div class="frame-tabs">
            <div id="rp-tab-group" class="frame-tab active">Random Red Packet</div>
            <div id="rp-tab-direct" class="frame-tab">Exclusive Red Packet</div>
          </div>

          <!-- 2. Random red packet content area -->
          <div
            id="rp-content-group"
            class="frame-content"
            style="padding: 20px 15px"
          >
            <div class="form-group">
              <label>Total Amount (¬•)</label>
              <input type="number" id="rp-group-amount" placeholder="0.00" />
            </div>
            <div class="form-group">
              <label>Number of Packets</label>
              <input
                type="number"
                id="rp-group-count"
                placeholder="Enter number of packets"
              />
            </div>
            <div class="form-group">
              <label>Greeting</label>
              <input
                type="text"
                id="rp-group-greeting"
                placeholder="May you be prosperous!"
              />
            </div>
            <p
              id="rp-group-total"
              style="
                text-align: center;
                font-size: 24px;
                font-weight: bold;
                margin: 10px 0;
              "
            >
              ¬• 0.00
            </p>
            <button id="send-group-packet-btn" class="form-button">
              Pack the Money
            </button>
          </div>

          <!-- 3. Exclusive red packet content area -->
          <div
            id="rp-content-direct"
            class="frame-content"
            style="display: none; padding: 20px 15px"
          >
            <div class="form-group">
              <label>Send To</label>
              <select id="rp-direct-receiver"></select>
            </div>
            <div class="form-group">
              <label>Amount (¬•)</label>
              <input type="number" id="rp-direct-amount" placeholder="0.00" />
            </div>
            <div class="form-group">
              <label>Greeting</label>
              <input
                type="text"
                id="rp-direct-greeting"
                placeholder="May you be prosperous!"
              />
            </div>
            <p
              id="rp-direct-total"
              style="
                text-align: center;
                font-size: 24px;
                font-weight: bold;
                margin: 10px 0;
              "
            >
              ¬• 0.00
            </p>
            <button id="send-direct-packet-btn" class="form-button">
              Pack the Money
            </button>
          </div>
        </div>
        <div class="modal-footer" style="justify-content: center">
          <button class="cancel" id="cancel-red-packet-btn" style="width: 100%">
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- [New] Red packet details modal -->
    <div id="red-packet-details-modal" class="modal">
      <div
        class="modal-content"
        style="width: 280px; height: auto; background-color: #f7f7f7"
      >
        <div
          class="modal-header"
          style="
            background-color: #f96259;
            color: white;
            border-bottom: none;
            padding-bottom: 5px;
          "
        >
          <div style="text-align: center; width: 100%">
            <div id="rp-details-sender" style="font-size: 16px"></div>
            <div style="font-size: 13px; opacity: 0.8">'s Red Packet</div>
          </div>
        </div>
        <div class="modal-body" style="padding: 15px">
          <p
            id="rp-details-greeting"
            style="
              text-align: center;
              font-size: 20px;
              color: #333;
              margin: 0 0 20px 0;
            "
          ></p>
          <div
            id="rp-details-my-amount"
            style="text-align: center; display: none; margin-bottom: 20px"
          >
            <span style="font-size: 40px; font-weight: bold; color: #e44d44"
              >0.00</span
            >
            <span style="font-size: 18px; color: #e44d44">¬•</span>
          </div>
          <div
            id="rp-details-summary"
            style="
              font-size: 13px;
              color: #8a8a8a;
              border-top: 1px solid #e0e0e0;
              padding-top: 10px;
            "
          ></div>
          <div
            id="rp-details-list"
            style="max-height: 150px; overflow-y: auto; margin-top: 10px"
          >
            <!-- Claim details will be dynamically generated here by JS -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="save" id="close-rp-details-btn" style="width: 100%">
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- Create poll modal -->
    <div id="create-poll-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>Create Poll</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="poll-question-input">Poll Question</label>
            <textarea
              id="poll-question-input"
              rows="2"
              placeholder="e.g., What movie should we watch tonight?"
            ></textarea>
          </div>
          <div class="form-group">
            <label>Poll Options (at least 2)</label>
            <div
              id="poll-options-container"
              style="display: flex; flex-direction: column; gap: 8px"
            >
              <!-- Poll options will be dynamically generated here by JS -->
            </div>
            <button
              id="add-poll-option-btn"
              class="form-button form-button-secondary"
              style="margin-top: 12px"
            >
              + Add Option
            </button>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-poll-btn">Cancel</button>
          <button class="save" id="confirm-create-poll-btn">Create Poll</button>
        </div>
      </div>
    </div>

    <!-- AI avatar library management modal -->
    <div id="ai-avatar-library-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="ai-avatar-library-title">Their Avatar Library</span>
          <button id="add-ai-avatar-btn" class="action-button">Add</button>
        </div>
        <div class="modal-body" style="padding: 15px">
          <div
            id="ai-avatar-library-grid"
            style="
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
              gap: 15px;
            "
          >
            <!-- Avatar library content will be dynamically generated by JS -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-ai-avatar-library-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- User share link modal -->
    <div id="share-link-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>Share Link</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="link-title-input">Title</label>
            <input
              type="text"
              id="link-title-input"
              placeholder="Enter article or link title"
            />
          </div>
          <div class="form-group">
            <label for="link-description-input">Summary (optional)</label>
            <textarea
              id="link-description-input"
              rows="2"
              placeholder="Briefly describe the link content"
            ></textarea>
          </div>
          <div class="form-group">
            <label for="link-source-input">Source Name (optional)</label>
            <input
              type="text"
              id="link-source-input"
              placeholder="e.g., Zhihu Daily, Bilibili"
            />
          </div>
          <div class="form-group">
            <label for="link-content-input"
              >Full Content (optional, for in-browser display)</label
            >
            <textarea
              id="link-content-input"
              rows="4"
              placeholder="Paste or enter the full article content"
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-share-link-btn">Cancel</button>
          <button class="save" id="confirm-share-link-btn">Share</button>
        </div>
      </div>
    </div>

    <!-- Transfer actions modal -->
    <div id="transfer-actions-modal" class="modal">
      <div class="transfer-actions-content">
        <div class="transfer-actions-header">Select Action</div>
        <div class="transfer-actions-body">
          <p>
            You received a transfer from
            <strong id="transfer-sender-name"></strong>.
          </p>
        </div>
        <div class="transfer-actions-footer">
          <button id="transfer-action-decline" class="action-btn decline">
            Decline
          </button>
          <button id="transfer-action-accept" class="action-btn accept">
            Accept
          </button>
        </div>
        <button id="transfer-action-cancel" class="cancel-btn">√ó</button>
      </div>
    </div>

    <!-- Call transcript details modal -->
    <div id="call-transcript-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="transcript-modal-title">Call Details</span>
        </div>
        <div
          class="modal-body"
          id="transcript-modal-body"
          style="background-color: #f0f2f5"
        >
          <!-- Call transcript will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button
            class="cancel"
            id="delete-transcript-btn"
            style="
              background-color: #ff3b30;
              color: white;
              border-color: #ff3b30;
            "
          >
            Delete Record
          </button>
          <button
            class="save"
            id="close-transcript-modal-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- Share target selector modal -->
    <div id="share-target-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="share-target-modal-title">Share to...</span>
        </div>
        <div class="modal-body" id="share-target-list" style="padding: 0">
          <!-- Chat list will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-share-target-btn">Cancel</button>
          <button class="save" id="confirm-share-target-btn">Confirm Share</button>
        </div>
      </div>
    </div>

    <!-- Shared history viewer modal -->
    <div id="shared-history-viewer-modal" class="modal">
      <div class="modal-content" style="height: 80%">
        <div class="modal-header">
          <span id="shared-history-viewer-title">Chat History</span>
        </div>
        <div
          class="modal-body"
          id="shared-history-viewer-content"
          style="background-color: #f0f2f5"
        >
          <!-- Shared chat history bubbles will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-shared-history-viewer-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- World book category manager modal -->
    <div id="world-book-category-manager-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Manage World Book Categories</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>New Category</label>
            <div style="display: flex; gap: 10px">
              <input
                type="text"
                id="new-category-name-input"
                placeholder="Enter category name..."
                style="flex-grow: 1"
              />
              <button
                id="add-new-category-btn"
                class="form-button"
                style="width: auto; margin-top: 0; padding: 0 15px"
              >
                Add
              </button>
            </div>
          </div>
          <hr style="opacity: 0.2" />
          <div
            id="existing-categories-list"
            style="display: flex; flex-direction: column; gap: 10px"
          >
            <!-- Category list will be dynamically generated by JS -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-category-manager-btn"
            style="width: 100%"
          >
            Done
          </button>
        </div>
      </div>
    </div>

    <!-- Character-exclusive NPC library management screen -->
    <div id="npc-management-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-npc-management">‚Äπ</span>
        <span id="npc-management-title">NPC Library Management</span>
        <span class="action-btn" id="add-new-npc-btn">+</span>
      </div>
      <div class="list-container" id="npc-management-list">
        <!-- NPC list will be dynamically generated here by JS -->
      </div>
    </div>

    <!-- 1. Forum main screen (shows all groups) -->
    <div id="forum-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span>Circles</span>
        <div class="header-actions">
          <span
            class="action-btn filter-btn"
            id="forum-filter-btn"
            title="Filter"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polygon
                points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"
              ></polygon>
            </svg>
          </span>
          <span class="action-btn" id="open-forum-bookshelf-btn" title="Bookshelf">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="22"
              height="22"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M4 3h12.5a1.5 1.5 0 0 1 1.5 1.5V21" />
              <path d="M4 21V4.5A1.5 1.5 0 0 1 5.5 3H18" />
              <path d="M9 7h6" />
              <path d="M9 11h6" />
              <path d="M9 15h6" />
              <path d="M4 21h16" />
            </svg>
          </span>

          <span
            class="action-btn"
            id="create-group-btn"
            style="font-size: 28px; font-weight: 300"
            >+</span
          >
        </div>
      </div>
      <div
        id="forum-group-list"
        class="list-container"
        style="
          padding: 15px;
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 15px;
          align-content: start;
        "
      >
        <!-- Group list will be dynamically generated here by JS -->
      </div>
    </div>

    <div id="group-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-to-forum-list">‚Äπ</span>
        <span id="group-screen-title">Group Name</span>
        <div class="header-actions">
          <span
            class="action-btn filter-btn"
            id="group-filter-btn"
            title="Filter"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polygon
                points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"
              ></polygon>
            </svg>
          </span>

          <span
            class="action-btn"
            id="generate-group-content-btn"
            title="Generate Content"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
            </svg>
          </span>
          <span
            class="action-btn"
            id="create-forum-post-btn"
            style="font-size: 28px; font-weight: 300"
            >+</span
          >
        </div>
      </div>
      <!-- Fanfic creation console (no buttons version) -->
      <div id="fanfic-preference-bar" style="display: none">
        <!-- 1. Top title bar -->
        <div id="fanfic-bar-header">
          <span class="bar-title">ü™Ñ Fanfic Creation Console</span>
          <span id="fanfic-bar-toggle-icon">‚ñº</span>
        </div>

        <!-- 2. Collapsible content area -->
        <div id="fanfic-bar-content">
          <!-- Preset management -->
          <div class="fanfic-row presets-row">
            <select id="fanfic-preset-select">
              <option value="">-- Load Config --</option>
            </select>
            <button id="save-fanfic-preset-btn" class="mini-btn">Save</button>
            <button id="delete-fanfic-preset-btn" class="mini-btn danger">
              Delete
            </button>
          </div>

          <!-- CP selection -->
          <div class="fanfic-row cp-row">
            <select id="fanfic-char1-select"></select>
            <span class="cp-symbol">√ó</span>
            <select id="fanfic-char2-select"></select>
          </div>

          <!-- Core parameters -->
          <div class="fanfic-row params-row">
            <div class="input-group">
              <label>Target Word Count</label>
              <input
                type="text"
                id="fanfic-wordcount-input"
                placeholder="e.g., 3000 words"
              />
            </div>
            <div class="input-group">
              <label>Story Type</label>
              <input
                type="text"
                id="fanfic-type-input"
                placeholder="e.g., Fluff/ABO"
              />
            </div>
            <div class="input-group">
              <label>Length</label>
              <select id="fanfic-length-select">
                <option value="short">Short</option>
                <option value="long">Long Serial</option>
              </select>
            </div>
          </div>

          <!-- Writing style -->
          <div class="fanfic-row full-width">
            <label>Writing Style / Guidelines</label>
            <input
              type="text"
              id="fanfic-style-input"
              placeholder="e.g., Detailed psychology, first person..."
            />
          </div>

          <!-- World view -->
          <div class="fanfic-row full-width">
            <label>World Setting / Plot Overview</label>
            <textarea
              id="fanfic-worldview-input"
              rows="2"
              placeholder="Enter background setting here..."
            ></textarea>
          </div>
        </div>
      </div>

      <div id="group-post-list" class="list-container" style="padding-top: 0">
        <!-- Post list will be dynamically generated here by JS -->
      </div>
    </div>

    <!-- 3. Single post page (shows post content and comments) -->
    <div id="post-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-to-group-screen">‚Äπ</span>
        <span>Post Details</span>
        <div class="header-actions">
          <span class="action-btn" id="repost-to-chat-btn">Repost</span>
        </div>
      </div>
      <div
        id="post-detail-content"
        class="list-container"
        style="padding: 20px"
      >
        <!-- Post and comments will be dynamically generated here by JS -->
      </div>
      <!-- Comment input box for post page -->
      <div
        id="post-comment-input-area"
        class="chat-input-area"
        style="visibility: visible"
      >
        <div class="chat-input-main-row">
          <textarea
            id="post-comment-input"
            rows="1"
            placeholder="Post your comment..."
          ></textarea>
          <button id="send-post-comment-btn" class="action-button">Send</button>
        </div>
      </div>
    </div>

    <div id="forum-bookshelf-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-forum-bookshelf">?</span>
        <span>Circle Bookshelf</span>
      </div>
      <div
        id="forum-bookshelf-list"
        class="list-container forum-bookshelf-list"
        style="padding-top: 0"
      >
        <!-- Followed serials will be shown here -->
      </div>
    </div>

    <div id="forum-series-detail-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-series-detail">?</span>
        <span id="forum-series-detail-title">Series Details</span>
        <div class="header-actions">
          <span class="action-btn" id="series-next-chapter-btn">Next Chapter</span>
        </div>
      </div>
      <div
        id="forum-series-meta"
        class="list-container"
        style="padding-top: 0"
      ></div>
      <div
        id="forum-series-chapter-list"
        class="list-container forum-series-chapter-list"
        style="padding-top: 0"
      ></div>
    </div>

    <div id="forum-filter-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 60%">
        <div class="modal-header">
          <span>Filter by Category</span>
        </div>
        <div class="modal-body">
          <div id="forum-filter-category-list">
            <!-- Category tags will be dynamically generated here by JS -->
          </div>
        </div>
        <div class="modal-footer" style="justify-content: space-between">
          <button class="cancel" id="reset-forum-filter-btn" style="width: 30%">
            Reset
          </button>
          <button
            class="cancel"
            id="cancel-forum-filter-btn"
            style="width: 30%"
          >
            Cancel
          </button>
          <button class="save" id="apply-forum-filter-btn" style="width: 30%">
            Apply
          </button>
        </div>
      </div>
    </div>

    <!-- Custom avatar frame manager modal -->
    <div id="custom-frame-manager-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Manage My Avatar Frames</span>
          <button id="upload-custom-frame-btn" class="action-button">
            Upload
          </button>
        </div>
        <div class="modal-body" style="padding: 15px">
          <div
            id="custom-frame-grid"
            style="
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
              gap: 15px;
            "
          >
            <!-- Custom avatar frames will be dynamically generated here by JS -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="save" id="close-frame-manager-btn" style="width: 100%">
            Close
          </button>
        </div>
      </div>
    </div>
    <input
      type="file"
      id="custom-frame-upload-input"
      accept="image/png, image/gif"
      hidden
      multiple
    />

    <!-- Avatar frame selection modal -->
    <div id="avatar-frame-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Select Avatar Frame</span>

          <button id="manage-custom-frames-btn" class="action-button">
            Manage
          </button>
        </div>
        <div class="modal-body" style="padding: 15px">
          <div id="avatar-frame-grid" class="frame-grid">
            <!-- Avatar frame options (including "none" and custom ones) will be generated here -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-frame-settings-btn">Cancel</button>
          <button class="save" id="save-frame-settings-btn">Save</button>
        </div>
      </div>
    </div>

    <div id="send-location-modal" class="modal">
      <div
        class="modal-content"
        style="width: 300px; height: auto; max-height: 80%"
      >
        <div class="modal-header">
          <span>Send Location & Track</span>
        </div>
        <div class="modal-body" style="padding-bottom: 5px">
          <!-- Core info -->
          <div class="form-group">
            <label for="user-location-input">My Location (start)</label>
            <input
              type="text"
              id="user-location-input"
              placeholder="e.g., Coffee shop downtown"
            />
          </div>
          <div class="form-group">
            <label for="ai-location-input">Their Location (end)</label>
            <input
              type="text"
              id="ai-location-input"
              placeholder="e.g., Lighthouse by the sea"
            />
          </div>
          <div class="form-group">
            <label for="distance-input">Distance</label>
            <input
              type="text"
              id="distance-input"
              placeholder="e.g., About 5km (required)"
            />
          </div>

          <hr style="opacity: 0.2" />

          <!-- Movement track input area -->
          <div class="form-group">
            <label>Movement Track (optional, fill in order)</label>
            <div
              id="trajectory-points-container"
              style="display: flex; flex-direction: column; gap: 8px"
            >
              <!-- JS will dynamically add inputs here -->
            </div>
            <button
              id="add-trajectory-point-btn"
              class="form-button form-button-secondary"
              style="margin-top: 12px"
            >
              + Add Waypoint
            </button>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="location-cancel-btn">Cancel</button>
          <button class="save" id="location-confirm-btn">Send</button>
        </div>
      </div>
    </div>

    <!-- Floating lyrics bar settings modal -->
    <div id="lyrics-settings-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Floating Lyrics Settings</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="lyrics-font-size-slider"
              >Font Size: <span id="lyrics-font-size-value">14px</span></label
            >
            <input
              type="range"
              id="lyrics-font-size-slider"
              min="12"
              max="24"
              value="14"
              style="width: 100%"
            />
          </div>
          <div class="form-group">
            <label for="lyrics-bg-opacity-slider"
              >Background Opacity: <span id="lyrics-bg-opacity-value">0%</span></label
            >
            <input
              type="range"
              id="lyrics-bg-opacity-slider"
              min="0"
              max="100"
              value="0"
              style="width: 100%"
            />
          </div>
          <div class="form-group">
            <label for="lyrics-font-color-picker">Font Color</label>
            <input
              type="color"
              id="lyrics-font-color-picker"
              value="#FFFFFF"
              style="width: 100%; height: 40px"
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="reset-lyrics-settings-btn">
            Reset to Default
          </button>
          <button class="save" id="close-lyrics-settings-btn">Done</button>
        </div>
      </div>
    </div>
    <div id="music-source-selector-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Select Search Source</span>
        </div>
        <div class="modal-body" style="text-align: left; padding: 20px">
          <!-- ‚ñº‚ñº‚ñº Modified/added section start ‚ñº‚ñº‚ñº -->
          <label style="display: block; margin-bottom: 15px; cursor: pointer">
            <input type="radio" name="search-source" value="all" checked />
            Aggregate Search (NetEase + QQ Music)
          </label>
          <label style="display: block; margin-bottom: 15px; cursor: pointer">
            <input type="radio" name="search-source" value="netease" /> NetEase Only
            (vkeys API)
          </label>
          <label style="display: block; margin-bottom: 15px; cursor: pointer">
            <input type="radio" name="search-source" value="tencent" /> QQ Music Only
            (vkeys API)
          </label>
          <!-- Added GD Music option -->
          <label
            style="
              display: block;
              cursor: pointer;
              color: #ff5722;
              font-weight: bold;
            "
          >
            <input type="radio" name="search-source" value="gdstudio" />
            GD Music (Recommended)
          </label>
          <!-- ‚ñ≤‚ñ≤‚ñ≤ Modified/added section end ‚ñ≤‚ñ≤‚ñ≤ -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-source-select-btn">Cancel</button>
          <button class="save" id="confirm-source-select-btn">Start Search</button>
        </div>
      </div>
    </div>

    <div id="weibo-following-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Following List</span>
        </div>
        <div class="modal-body" style="padding: 0">
          <div id="weibo-following-list-container">
            <!-- Following list will be dynamically generated here by JS -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-following-list-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- Tarot divination main modal -->
    <div id="tarot-divination-modal" class="modal">
      <div class="modal-content" style="height: 85%; width: 95%">
        <!-- 1. Divination settings view -->
        <div id="tarot-setup-view">
          <div class="modal-header">
            <span>Tarot Divination</span>
            <div>
              <span
                id="tarot-history-btn"
                class="action-btn"
                style="font-size: 16px"
                >History</span
              >
              <span
                id="close-tarot-modal-btn"
                class="action-btn"
                style="font-size: 16px"
                >Close</span
              >
            </div>
          </div>
          <div class="modal-body">
            <div class="form-group">
              <label for="tarot-question-input">Your Question or Focus</label>
              <textarea
                id="tarot-question-input"
                rows="2"
                placeholder="e.g., How is my love life recently?"
              ></textarea>
            </div>
            <div class="form-group">
              <label for="tarot-spread-select">Select Spread</label>
              <select id="tarot-spread-select">
                <option value="single">Single Card - Quick Guidance</option>
                <option value="three_past_present_future">
                  Three Cards - Past/Present/Future
                </option>
                <option value="three_situation_challenge_advice">
                  Three Cards - Situation/Challenge/Advice
                </option>
                <option value="celtic_cross">
                  Celtic Cross - Deep Analysis (10 cards)
                </option>
              </select>
            </div>
            <div class="form-group">
              <label>Card Orientation</label>
              <div style="display: flex; gap: 20px">
                <label
                  ><input
                    type="radio"
                    name="tarot-orientation"
                    value="upright"
                    checked
                  />
                  Upright Only</label
                >
                <label
                  ><input
                    type="radio"
                    name="tarot-orientation"
                    value="reversed"
                  />
                  Include Reversed</label
                >
              </div>
            </div>
            <button
              id="draw-tarot-cards-btn"
              class="form-button"
              style="margin-top: 20px"
            >
              Shuffle & Draw
            </button>
          </div>
        </div>

        <!-- 2. Divination result view (hidden by default) -->
        <div
          id="tarot-result-view"
          style="
            display: none;
            height: 100%;
            display: flex;
            flex-direction: column;
          "
        >
          <div class="modal-header">
            <span
              id="back-to-tarot-setup-btn"
              class="action-btn"
              style="font-size: 16px"
              >Back</span
            >
            <span>Divination Result</span>
          </div>
          <div class="modal-body" id="tarot-result-display">
            <!-- Results will be dynamically generated here by JS -->
          </div>
          <div class="modal-footer">
            <button id="send-tarot-result-btn" class="save" style="width: 100%">
              Send to Tarot Reader for Interpretation
            </button>
          </div>
        </div>

        <!-- 3. History view (hidden by default) -->
        <div
          id="tarot-history-view"
          style="
            display: none;
            height: 100%;
            display: flex;
            flex-direction: column;
          "
        >
          <div class="modal-header">
            <span
              id="back-to-tarot-main-btn"
              class="action-btn"
              style="font-size: 16px"
              >Back</span
            >
            <span>Divination History</span>
          </div>
          <div class="modal-body" id="tarot-history-list">
            <!-- History will be dynamically generated here by JS -->
          </div>
        </div>
      </div>
    </div>

    <!-- 2. Character switch modal -->
    <div id="ls-char-selector-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Select Space</span>
        </div>
        <div class="modal-body" id="ls-char-selector-list" style="padding: 0">
          <!-- Character list will be dynamically generated by JS -->
        </div>
        <div class="modal-footer">
          <button
            class="cancel"
            id="ls-cancel-switch-char-btn"
            style="width: 100%"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- 3. Post status modal -->
    <div id="ls-create-moment-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Something to say...</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <textarea
              id="ls-moment-content-input"
              rows="5"
              placeholder="Write your private words here..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="ls-cancel-moment-btn">Cancel</button>
          <button class="save" id="ls-confirm-moment-btn">Post</button>
        </div>
      </div>
    </div>

    <!-- 4. Create album/upload photo modal (modified version) -->
    <div id="ls-create-album-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <!-- Title has been modified -->
          <span id="ls-album-modal-title">Upload Photo</span>
        </div>
        <div class="modal-body">
          <!-- New: mode switch (reusing existing styles) -->
          <div class="post-mode-switcher">
            <button id="ls-switch-to-image-mode" class="mode-btn active">
              Upload Image
            </button>
            <button id="ls-switch-to-text-image-mode" class="mode-btn">
              Use Text Image
            </button>
          </div>

          <!-- Mode 1: Upload image -->
          <div id="ls-image-mode-content" class="post-mode-content active">
            <div class="form-group">
              <label>Select Photo (single only)</label>
              <div id="ls-photo-preview-container"></div>
              <button
                class="form-button form-button-secondary"
                id="ls-select-photos-btn"
              >
                Select Photo
              </button>
              <!-- Key: the input here has had the multiple attribute removed, now single selection only -->
              <input type="file" id="ls-photo-input" accept="image/*" hidden />
            </div>
            <div class="form-group">
              <label>Image Description (required)</label>
              <textarea
                id="ls-photo-desc-input"
                rows="3"
                placeholder="Write a caption for this photo..."
              ></textarea>
            </div>
          </div>

          <!-- Mode 2: Use text image -->
          <div
            id="ls-text-image-mode-content"
            class="post-mode-content"
            style="display: none"
          >
            <div class="form-group">
              <label>Text Image Description (required)</label>
              <textarea
                id="ls-text-image-desc-input"
                rows="5"
                placeholder="Write your mood or story here..."
              ></textarea>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="ls-cancel-album-btn">Cancel</button>
          <button class="save" id="ls-confirm-album-btn">Confirm Upload</button>
        </div>
      </div>
    </div>

    <!-- Lovers Space - write love letter / reply modal -->
    <div id="ls-create-letter-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span id="ls-letter-modal-title">Write a Letter to Them</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="ls-letter-recipient-input">Recipient</label>
            <!-- Recipient is usually fixed, so we disable this input -->
            <input type="text" id="ls-letter-recipient-input" disabled />
          </div>
          <div class="form-group">
            <label for="ls-letter-content-input">Letter Content</label>
            <textarea
              id="ls-letter-content-input"
              rows="8"
              placeholder="Write your feelings here..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="ls-cancel-letter-btn">Cancel</button>
          <button class="save" id="ls-confirm-letter-btn">Send</button>
        </div>
      </div>
    </div>

    <!-- Lovers Space - letter viewer -->
    <div id="ls-letter-viewer-modal" class="modal">
      <div class="ls-letter-viewer-content">
        <!-- Header: recipient info -->
        <div class="letter-viewer-header">
          <img id="ls-viewer-recipient-avatar" class="meta-avatar" />
          <div class="recipient-info">
            <div class="label">To my dear:</div>
            <div id="ls-viewer-recipient-name" class="name"></div>
          </div>
        </div>
        <!-- Middle: letter body -->
        <div id="ls-viewer-body" class="letter-viewer-body">
          <!-- JS will fill in letter content here -->
        </div>
        <!-- Bottom: sender info and action buttons -->
        <div class="letter-viewer-footer">
          <div class="sender-info">
            <div id="ls-viewer-sender-name"></div>
            <div id="ls-viewer-timestamp" class="timestamp"></div>
          </div>
          <div class="letter-actions">
            <button id="ls-close-letter-viewer-btn">Close</button>
            <button id="ls-reply-letter-btn" class="primary">Reply</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Lovers Space settings modal -->
    <div id="ls-settings-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Lovers Space Settings</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="ls-start-date-input">Our First Day Together</label>
            <input
              type="date"
              id="ls-start-date-input"
              style="width: 100%; padding: 10px; box-sizing: border-box"
            />
          </div>

          <hr style="opacity: 0.2; margin: 20px 0" />
          <div class="form-group">
            <label>Danger Zone</label>
            <div style="display: flex; gap: 10px">
              <button
                id="ls-cancel-space-btn"
                class="form-button form-button-secondary"
                style="
                  background-color: #ffe5e5;
                  color: #ff3b30;
                  border-color: #ffc2d1;
                  flex: 1;
                  margin: 0;
                "
              >
                Cancel Space
              </button>
              <button
                id="ls-disconnect-space-btn"
                class="form-button form-button-secondary"
                style="
                  background-color: #ff3b30;
                  color: white;
                  border-color: #ff3b30;
                  flex: 1;
                  margin: 0;
                "
              >
                End Relationship
              </button>
            </div>
            <p style="font-size: 12px; color: #8a8a8a; margin-top: 8px">
              <strong>Cancel Space</strong>:
              Sets the space to disabled state but keeps all data. Will not notify the other party.<br />
              <strong>End Relationship</strong>:
              Also cancels the space, but notifies the other party that the relationship has ended and they will comment on it.
            </p>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="ls-settings-cancel-btn">Cancel</button>
          <button class="save" id="ls-settings-save-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- Lovers Space - ask question modal -->
    <div id="ls-ask-question-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Ask a Question</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <textarea
              id="ls-question-content-input"
              rows="5"
              placeholder="Ask them a question..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="ls-cancel-ask-btn">Cancel</button>
          <button class="save" id="ls-confirm-ask-btn">Ask Them</button>
        </div>
      </div>
    </div>

    <!-- Lovers Space - answer question modal -->
    <div id="ls-answer-question-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Answer Their Question</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Question:</label>
            <p
              id="ls-answer-question-text"
              style="
                background-color: #f0f2f5;
                padding: 10px;
                border-radius: 8px;
              "
            ></p>
          </div>
          <div class="form-group">
            <label for="ls-answer-content-input">Your Answer:</label>
            <textarea
              id="ls-answer-content-input"
              rows="5"
              placeholder="Answer thoughtfully..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="ls-cancel-answer-btn">Cancel</button>
          <button class="save" id="ls-confirm-answer-btn">Confirm Answer</button>
        </div>
      </div>
    </div>

    <!-- 1. This is the player's dedicated audio engine -->
    <audio id="ls-audio-player" style="display: none"></audio>

    <!-- 2. This is the player's main window interface -->
    <div id="ls-music-player-overlay" class="modal">
      <div class="music-player-window">
        <!-- Cover and lyrics toggle container -->
        <div
          id="ls-display-area"
          style="
            width: 192px;
            height: 192px;
            margin-bottom: 20px;
            cursor: pointer;
          "
        >
          <!-- Album cover -->
          <img
            id="ls-album-cover"
            src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png"
            alt="Album cover"
            style="
              width: 100%;
              height: 100%;
              border-radius: 12px;
              box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            "
          />

          <!-- Lyrics container -->
          <div
            id="ls-lyrics-container"
            style="
              display: none;
              width: 100%;
              height: 100%;
              overflow: hidden;
              text-align: center;
              color: #333;
              font-weight: 500;
            "
          >
            <div id="ls-lyrics-list" style="transition: transform 0.5s ease">
              <!-- Lyrics will be displayed here -->
            </div>
          </div>
        </div>

        <!-- Song info -->
        <div id="ls-song-title" style="font-size: 18px; font-weight: 600">
          No song
        </div>
        <div
          id="ls-artist"
          style="font-size: 14px; color: #666; margin-bottom: 15px"
        >
          ...
        </div>

        <!-- Progress bar -->
        <div class="music-progress-bar-container" style="width: 100%">
          <div id="ls-current-time" class="time-display">0:00</div>
          <div class="progress-bar" id="ls-progress-bar">
            <div id="ls-progress-fill" class="progress-bar-fill"></div>
          </div>
          <div id="ls-total-time" class="time-display">0:00</div>
        </div>

        <!-- Control buttons -->
        <div class="music-controls" style="margin-bottom: 15px">
          <button id="ls-prev-btn">‚óÄ</button>
          <button id="ls-play-pause-btn" class="play-pause-btn">‚ñ∂</button>
          <button id="ls-next-btn">‚ñ∂</button>
        </div>

        <!-- Bottom action buttons -->
        <div class="music-bottom-actions" style="width: 100%">
          <button
            id="ls-playlist-btn"
            style="
              background-color: rgba(0, 123, 255, 0.1);
              color: var(--accent-color);
              margin-right: 5px;
            "
          >
            Playlist
          </button>
          <button
            id="ls-close-player-btn"
            style="
              background-color: rgba(0, 0, 0, 0.05);
              color: #333;
              margin-left: 5px;
            "
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- 3. This is the playlist slide-in panel -->
    <div id="ls-music-playlist-panel" class="music-playlist-panel">
      <div class="playlist-header">
        <span class="panel-btn" id="ls-close-playlist-btn">Back</span>
        <span>Playlist</span>
        <span
          class="panel-btn"
          id="ls-clear-playlist-btn"
          style="color: #ff3b30"
          >Clear</span
        >
      </div>
      <div class="playlist-body" id="ls-playlist-body">
        <!-- Playlist content will be generated here -->
      </div>
    </div>

    <!-- Lovers Space Pomodoro - settings modal -->
    <div id="ls-pomodoro-setup-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>New Focus Session</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="pomodoro-task-input">Focus Task</label>
            <input
              type="text"
              id="pomodoro-task-input"
              placeholder="e.g., Study JS, Finish work report"
            />
          </div>
          <div class="form-group">
            <label for="pomodoro-duration-input">Focus Duration (minutes)</label>
            <input
              type="number"
              id="pomodoro-duration-input"
              value="25"
              min="1"
            />
          </div>
          <div class="form-group">
            <label>Timer Mode</label>
            <div style="display: flex; gap: 20px">
              <label
                ><input
                  type="radio"
                  name="pomodoro-mode"
                  value="countdown"
                  checked
                />
                Countdown</label
              >
              <label
                ><input type="radio" name="pomodoro-mode" value="countup" />
                Count Up</label
              >
            </div>
          </div>
          <div class="form-group">
            <label for="pomodoro-talk-interval-input"
              >Character Encouragement Interval (minutes, 0 = no auto-encouragement)</label
            >
            <input
              type="number"
              id="pomodoro-talk-interval-input"
              value="5"
              min="0"
            />
          </div>
          <div class="form-group">
            <label>Background Music (BGM)</label>
            <select
              id="pomodoro-bgm-source-select"
              style="
                width: 100%;
                padding: 8px;
                border-radius: 6px;
                border: 1px solid #ccc;
                margin-bottom: 10px;
              "
            >
              <option value="none">üîï Mute / Don't play</option>
              <option value="global">üéµ Listen together playlist</option>
              <option value="custom">üìÇ Custom Pomodoro playlist</option>
            </select>

            <!-- Custom playlist management panel (hidden by default) -->
            <div
              id="pomodoro-custom-playlist-panel"
              style="
                display: none;
                background: #f5f5f5;
                padding: 10px;
                border-radius: 8px;
              "
            >
              <div
                id="pomodoro-custom-list"
                style="
                  max-height: 100px;
                  overflow-y: auto;
                  margin-bottom: 8px;
                  font-size: 13px;
                "
              >
                <p style="color: #999; text-align: center; margin: 10px 0">
                  No songs
                </p>
              </div>
              <div style="display: flex; gap: 5px">
                <button
                  id="pomo-add-bgm-local"
                  class="form-button-secondary"
                  style="margin: 0; padding: 5px 10px; font-size: 12px"
                >
                  + Local
                </button>
                <button
                  id="pomo-add-bgm-url"
                  class="form-button-secondary"
                  style="margin: 0; padding: 5px 10px; font-size: 12px"
                >
                  + URL
                </button>
                <button
                  id="pomo-clear-bgm"
                  class="form-button-secondary"
                  style="
                    margin: 0;
                    padding: 5px 10px;
                    font-size: 12px;
                    color: #ff3b30;
                    border-color: #ff3b30;
                  "
                >
                  Clear
                </button>
              </div>
              <!-- Hidden file input -->
              <input
                type="file"
                id="pomo-bgm-file-input"
                accept="audio/*"
                multiple
                style="display: none"
              />
            </div>
          </div>

          <div class="form-group">
            <label>Custom Background (optional)</label>
            <div style="display: flex; gap: 10px; align-items: center">
              <input
                type="text"
                id="pomodoro-bg-url-input"
                placeholder="Paste image URL"
                style="flex-grow: 1"
              />
              <button
                id="pomodoro-bg-local-upload-btn"
                class="form-button-secondary"
                style="margin: 0; padding: 12px; width: auto"
              >
                Upload Local
              </button>
            </div>
            <input
              type="file"
              id="pomodoro-bg-file-input"
              accept="image/*"
              hidden
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="pomodoro-cancel-setup-btn">Cancel</button>
          <button class="save" id="pomodoro-confirm-setup-btn">Start Focus</button>
        </div>
      </div>
    </div>

    <!-- Lovers Space Pomodoro - history detail modal -->
    <div id="ls-pomodoro-history-viewer-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="pomodoro-history-viewer-title">Focus Records</span>
        </div>
        <div class="modal-body" id="pomodoro-history-viewer-content">
          <!-- Chat records will be generated here by JS -->
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="pomodoro-close-history-viewer-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- 1. Group editor modal (for modifying group info and world setting) -->
    <div id="forum-group-editor-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span>Edit Group Info</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="group-editor-name-input">Group Name</label>
            <input type="text" id="group-editor-name-input" />
          </div>
          <div class="form-group">
            <label for="group-editor-desc-input">Group Description</label>
            <input type="text" id="group-editor-desc-input" />
          </div>
          <div class="form-group">
            <label for="group-editor-icon-input">Group Icon (Emoji)</label>
            <input type="text" id="group-editor-icon-input" />
          </div>
          <div class="form-group">
            <label for="group-editor-categories-input"
              >Group Categories (separated by #, e.g., #SciFi #Future)</label
            >
            <input
              type="text"
              id="group-editor-categories-input"
              placeholder="e.g., #SciFi #Future"
            />
          </div>
          <div class="form-group">
            <label for="group-editor-worldview-input"
              >Group World Setting (for AI reference when generating content)</label
            >
            <textarea
              id="group-editor-worldview-input"
              rows="5"
              placeholder="Describe this group's unique background setting in detail..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-group-editor-btn">Cancel</button>
          <button class="save" id="save-group-editor-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- 2. Category manager modal -->
    <div id="forum-category-manager-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Manage Circle Categories</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>New Category</label>
            <div style="display: flex; gap: 10px">
              <input
                type="text"
                id="new-forum-category-name-input"
                placeholder="Enter category name, no '#' needed..."
                style="flex-grow: 1"
              />
              <button
                id="add-new-forum-category-btn"
                class="form-button"
                style="width: auto; margin-top: 0; padding: 0 15px"
              >
                Add
              </button>
            </div>
          </div>
          <hr style="opacity: 0.2" />
          <div
            id="existing-forum-categories-list"
            style="display: flex; flex-direction: column; gap: 10px"
          >
            <!-- Category list will be dynamically generated by JS -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-forum-category-manager-btn"
            style="width: 100%"
          >
            Done
          </button>
        </div>
      </div>
    </div>

    <div id="aurora-setup-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Roaming Together</span>
          <span
            id="open-aurora-bookshelf-btn"
            class="action-btn"
            style="font-size: 14px"
            >üìö Bookshelf</span
          >
        </div>
        <div class="modal-body">
          <!-- 1. Title input -->
          <div class="form-group">
            <label for="aurora-title-input">Roaming Theme / Title</label>
            <input
              type="text"
              id="aurora-title-input"
              placeholder="e.g., Rainy Night Talk, Titanic..."
            />
          </div>

          <!-- 2. Mode selection -->
          <div class="form-group">
            <label>Mode Selection</label>
            <div style="display: flex; gap: 15px; flex-wrap: wrap">
              <label
                ><input type="radio" name="aurora-mode" value="video" checked />
                Watch Video</label
              >
              <label
                ><input type="radio" name="aurora-mode" value="text" />
                Read Novel</label
              >
              <!-- Added custom option -->
              <label
                ><input type="radio" name="aurora-mode" value="custom" />
                Custom (Audio+Image)</label
              >
            </div>
          </div>

          <!-- 3. Video mode input area -->
          <div id="aurora-video-inputs" class="aurora-input-group">
            <div class="form-group">
              <label>Video File (mp4, webm)</label>
              <input type="file" id="aurora-video-file" accept="video/*,.mkv" />
            </div>
            <div class="form-group">
              <label>Subtitle File (optional .srt, .vtt)</label>
              <input
                type="file"
                id="aurora-sub-file-video"
                accept=".srt,.vtt,.lrc"
              />
              <!-- ‚òÖ‚òÖ‚òÖ New: subtitle URL input ‚òÖ‚òÖ‚òÖ -->
              <input
                type="text"
                id="aurora-sub-url-video"
                placeholder="Or paste subtitle link (SRT/VTT/LRC)"
                style="margin-top: 5px"
              />
            </div>
          </div>

          <div
            id="aurora-text-inputs"
            class="aurora-input-group"
            style="display: none"
          >
            <div class="form-group">
              <label>Novel/Text File (.txt)</label>
              <input type="file" id="aurora-text-file" accept=".txt" />
              <!-- ‚òÖ‚òÖ‚òÖ New: novel URL input ‚òÖ‚òÖ‚òÖ -->
              <input
                type="text"
                id="aurora-text-url"
                placeholder="Or paste txt file link"
                style="margin-top: 5px"
              />
            </div>
          </div>

          <!-- 5. Custom mode input area -->
          <div
            id="aurora-custom-inputs"
            class="aurora-input-group"
            style="display: none"
          >
            <div class="form-group">
              <label>Background Image (jpg, png, gif)</label>
              <input type="file" id="aurora-custom-img" accept="image/*" />
            </div>
            <div class="form-group">
              <label>Audio File (mp3, wav, m4a)</label>
              <input type="file" id="aurora-custom-audio" accept="audio/*" />
            </div>
            <div class="form-group">
              <label>Subtitle File (optional .srt, .vtt)</label>
              <input
                type="file"
                id="aurora-sub-file-custom"
                accept=".srt,.vtt,.lrc"
              />
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-aurora-setup">Cancel</button>
          <button class="save" id="confirm-aurora-setup">Start Roaming</button>
        </div>
      </div>
    </div>

    <!-- Roaming player modal (fixed: close button disappearing issue) -->
    <div
      id="aurora-player-overlay"
      style="
        display: none;
        position: absolute;
        top: 100px;
        left: 50%;
        transform: translateX(-50%);
        width: 320px;
        height: 400px;
        background: #000;
        border-radius: 12px;
        z-index: 9999;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.1);
        flex-direction: column;
        overflow: hidden;
      "
    >
      <!-- Top drag handle -->
      <div
        id="aurora-drag-handle"
        style="
          width: 100%;
          height: 40px;
          flex-shrink: 0;
          padding: 0 10px;
          background: linear-gradient(90deg, #e0c3fc 0%, #8ec5fc 100%);
          cursor: grab;
          display: flex;
          align-items: center;
          justify-content: space-between;
          z-index: 100;
          box-sizing: border-box; /* ‚òÖ‚òÖ‚òÖ Core fix: prevent content from overflowing container ‚òÖ‚òÖ‚òÖ */
        "
      >
        <span
          style="
            font-size: 14px;
            color: #333;
            font-weight: 800;
            pointer-events: none;
          "
          >‚ú® Roaming</span
        >

        <!-- Font size adjustment and close button group -->
        <div style="display: flex; gap: 10px; align-items: center">
          <button
            id="aurora-font-down"
            style="
              background: rgba(255, 255, 255, 0.4);
              border: 1px solid rgba(0, 0, 0, 0.1);
              border-radius: 4px;
              padding: 2px 8px;
              font-weight: bold;
              cursor: pointer;
              color: #333;
              font-size: 12px;
            "
          >
            A-
          </button>
          <button
            id="aurora-font-up"
            style="
              background: rgba(255, 255, 255, 0.4);
              border: 1px solid rgba(0, 0, 0, 0.1);
              border-radius: 4px;
              padding: 2px 8px;
              font-weight: bold;
              cursor: pointer;
              color: #333;
              font-size: 12px;
            "
          >
            A+
          </button>
          <!-- Close button: larger font size, bigger click area -->
          <span
            id="aurora-close-player"
            style="
              cursor: pointer;
              font-weight: 900;
              color: #333;
              font-size: 24px;
              line-height: 1;
              padding: 0 5px;
            "
            >√ó</span
          >
        </div>
      </div>

      <!-- Content area -->
      <div
        id="aurora-content-area"
        style="
          width: 100%;
          flex-grow: 1;
          position: relative;
          background: #000;
          display: flex;
          align-items: center;
          justify-content: center;
          overflow: hidden;
        "
      >
        <!-- Video player -->
        <video
          id="aurora-video-element"
          style="width: 100%; height: 100%; object-fit: contain; display: none"
          playsinline
          webkit-playsinline
        ></video>

        <!-- Text reader -->
        <div
          id="aurora-text-viewer"
          style="
            display: none;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
            font-size: 16px;
            line-height: 1.8;
            color: #e0e0e0;
            font-family: sans-serif;
          "
        >
          <div id="aurora-text-body" style="white-space: pre-wrap"></div>
        </div>

        <!-- Custom audio+image player -->
        <div
          id="aurora-custom-viewer"
          style="display: none; width: 100%; height: 100%; position: relative"
        >
          <img
            id="aurora-custom-bg-img"
            style="width: 100%; height: 100%; display: block; object-fit: cover"
          />
          <div
            id="aurora-custom-subtitle-display"
            style="
              position: absolute;
              bottom: 10%;
              left: 0;
              width: 100%;
              text-align: center;
              color: white;
              text-shadow:
                0 2px 4px black,
                0 0 4px black;
              font-size: 16px;
              padding: 0 10px;
              pointer-events: none;
              font-weight: 500;
              z-index: 20;
            "
          ></div>
          <audio
            id="aurora-custom-audio-element"
            controls
            style="
              width: 100%;
              height: 40px;
              opacity: 0;
              position: absolute;
              bottom: 0;
              left: 0;
              z-index: 30;
            "
          ></audio>
        </div>
      </div>

      <!-- Bottom bar -->
      <div
        style="
          padding: 5px 12px;
          height: 28px;
          flex-shrink: 0;
          font-size: 12px;
          color: #888;
          background: #121212;
          border-top: 1px solid #333;
          display: flex;
          align-items: center;
          justify-content: space-between;
        "
      >
        <span
          id="aurora-playing-title"
          style="
            max-width: 50%;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
          "
          >Not playing</span
        >
        <span
          id="aurora-save-book-btn"
          style="
            cursor: pointer;
            display: none;
            color: #d4af37;
            font-weight: bold;
          "
          >üì• Save to Shelf</span
        >
        <span id="aurora-info-status">Waiting...</span>
      </div>

      <!-- Mobile touch resize handle -->
      <div
        id="aurora-resize-handle"
        style="
          position: absolute;
          bottom: 0;
          right: 0;
          width: 30px;
          height: 30px;
          background: linear-gradient(135deg, transparent 50%, #8ec5fc 50%);
          cursor: nwse-resize;
          z-index: 101;
          touch-action: none;
        "
      ></div>
    </div>

    <!-- Vintage bookshelf screen -->
    <div id="aurora-bookshelf-screen" class="screen">
      <div
        class="header"
        style="
          background-color: #3e2723 !important;
          color: #e0c097 !important;
          border-bottom: 1px solid #5d4037;
        "
      >
        <span class="back-btn" id="back-from-bookshelf" style="color: #e0c097"
          >‚Äπ</span
        >
        <span
          style="
            font-family: &quot;serif&quot;;
            font-weight: bold;
            letter-spacing: 2px;
          "
          >Book Collection</span
        >
        <span style="width: 30px"></span>
      </div>
      <!-- Bookshelf background container -->
      <div id="bookshelf-container">
        <!-- Books will be generated here by JS -->
      </div>
    </div>

    <div id="game-hall-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span>Game Hall</span>
        <span style="width: 30px"></span>
        <!-- Placeholder -->
      </div>
      <div class="list-container" style="padding: 20px">
        <p style="text-align: center; color: var(--text-secondary)">
          Choose a game to start!
        </p>
        <div id="game-hall-grid">
          <!-- Game list will be shown here -->
          <div class="game-card" data-game="werewolf">
            <div class="game-icon">üê∫</div>
            <div class="game-info">
              <div class="game-title">Werewolf</div>
              <div class="game-desc">Logic vs. lies</div>
            </div>
          </div>
          <div class="game-card" data-game="sea-turtle-soup">
            <div class="game-icon">üê¢</div>
            <div class="game-info">
              <div class="game-title">Sea Turtle Soup</div>
              <div class="game-desc">Uncover the truth of the scenario</div>
            </div>
          </div>
          <div class="game-card" data-game="script-kill">
            <div class="game-icon">üìú</div>
            <div class="game-info">
              <div class="game-title">Murder Mystery</div>
              <div class="game-desc">Play roles, solve the mystery</div>
            </div>
          </div>
          <div class="game-card" data-game="guess-what">
            <div class="game-icon">üó£Ô∏è</div>
            <div class="game-info">
              <div class="game-title">Word Guess</div>
              <div class="game-desc">Time to test your chemistry</div>
            </div>
          </div>
          <div class="game-card" data-game="ludo">
            <div class="game-icon">üé≤</div>
            <div class="game-info">
              <div class="game-title">Heartbeat Ludo</div>
              <div class="game-desc">An adventure just for the two of you</div>
            </div>
          </div>

          <div class="game-card" data-game="undercover">
            <div class="game-icon">üïµÔ∏è</div>
            <div class="game-info">
              <div class="game-title">Who's the Spy</div>
              <div class="game-desc">Disguise your words, set logical traps</div>
            </div>
          </div>

          <p
            style="
              grid-column: 1 / -1;
              text-align: center;
              color: var(--text-secondary);
              font-size: 14px;
              margin-top: 20px;
            "
          >
            More games are being developed rapidly...
          </p>
        </div>
      </div>
    </div>

    <!-- 1. Werewolf game setup screen -->
    <div id="werewolf-setup-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‚Äπ</span>
        <span>Werewolf - Game Setup</span>
      </div>
      <div class="form-container">
        <div class="form-group">
          <label for="werewolf-player-count">Select Player Count</label>
          <select id="werewolf-player-count">
            <option value="6">6 Players (2 Wolves, 2 Villagers, Seer, Guard)</option>
            <option value="9">9 Players (3 Wolves, 3 Villagers, Seer, Witch, Hunter)</option>
            <option value="12">
              12 Players (4 Wolves, 4 Villagers, Seer, Witch, Hunter, Idiot)
            </option>
          </select>
        </div>
        <div class="form-group">
          <label>Invite Players (you are auto-joined)</label>
          <div
            id="werewolf-player-selection"
            class="list-container"
            style="
              height: 300px;
              border: 1px solid var(--border-color);
              border-radius: 8px;
            "
          >
            <!-- Player selection list will be dynamically generated by JS -->
          </div>
        </div>
        <button id="start-werewolf-game-btn" class="form-button">
          Start Game
        </button>
      </div>
    </div>

    <!-- 2. Werewolf game main screen -->
    <div id="werewolf-game-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="exit-werewolf-game-btn">‚Äπ Exit</span>
        <span id="werewolf-game-title">Werewolf</span>
        <span class="action-btn" id="werewolf-my-role-btn">My Role</span>
      </div>
      <!-- Game main content area -->
      <div id="werewolf-game-content">
        <!-- Player seats area -->
        <div id="werewolf-players-grid">
          <!-- Player avatars and status will be dynamically generated by JS -->
        </div>
        <!-- Game log/info area -->
        <div id="werewolf-log-container">
          <div id="werewolf-game-log">
            <!-- Game process info will be shown here -->
          </div>
        </div>
        <!-- Player action area -->
        <div id="werewolf-action-area">
          <!-- Player buttons will be shown here based on game phase -->
        </div>
      </div>
    </div>

    <!-- Werewolf game summary card -->
    <div id="werewolf-summary-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span>Game Summary</span>
        </div>
        <div
          class="modal-body"
          id="werewolf-summary-content"
          style="white-space: pre-wrap; line-height: 1.7"
        >
          <!-- Summary content will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="repost-summary-btn">Send Review to Chat</button>
          <button class="save" id="back-to-hall-btn">Back to Hall</button>
        </div>
      </div>
    </div>

    <!-- Werewolf review send target selector -->
    <div id="werewolf-target-picker-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Select Players to Send To</span>
        </div>
        <div class="modal-body" id="werewolf-target-list" style="padding: 0">
          <!-- Player list will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button
            id="wt-select-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Select All
          </button>
          <button
            id="wt-deselect-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Deselect All
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="wt-cancel-btn">Cancel</button>
          <button class="save" id="wt-confirm-btn">Confirm Send</button>
        </div>
      </div>
    </div>

    <!-- 1. Sea Turtle Soup game main screen -->
    <div id="sea-turtle-soup-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="exit-sts-game-btn">‚Äπ Exit</span>
        <span>Sea Turtle Soup</span>
        <span class="action-btn" id="reveal-sts-answer-btn">Reveal Answer</span>
      </div>
      <div
        id="sts-game-content"
        style="
          display: flex;
          flex-direction: column;
          height: 100%;
          overflow: hidden;
          padding: 10px;
          box-sizing: border-box;
        "
      >
        <!-- Player seats area -->
        <div
          id="sts-players-grid"
          style="
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 10px;
            padding: 10px;
            flex-shrink: 0;
          "
        >
          <!-- Player avatars and status will be dynamically generated by JS -->
        </div>
        <!-- Game log/info area -->
        <div
          id="sts-log-container"
          style="
            flex-grow: 1;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            padding: 10px;
            overflow-y: auto;
            margin: 10px 0;
            min-height: 0;
          "
        >
          <div id="sts-game-log">
            <!-- Game process info will be shown here -->
          </div>
        </div>

        <div
          id="sts-action-area"
          class="chat-input-area"
          style="visibility: visible"
        >
          <div class="chat-input-main-row">
            <textarea
              id="sts-question-input"
              rows="1"
              placeholder="Type question or answer..."
            ></textarea>
            <!-- New "Guess Answer" button -->
            <button
              id="guess-sts-answer-btn"
              class="action-button"
              style="background-color: #ff9800"
            >
              Guess Answer
            </button>
            <button id="send-sts-question-btn" class="action-button">
              Ask
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- 2. Sea Turtle Soup game setup modal -->
    <div id="sea-turtle-soup-setup-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 85%">
        <div class="modal-header">
          <span>Sea Turtle Soup - Game Setup</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Invite Players (you are auto-joined)</label>
            <div
              id="sts-player-selection"
              class="list-container"
              style="
                height: 200px;
                border: 1px solid var(--border-color);
                border-radius: 8px;
              "
            >
              <!-- Player selection list will be dynamically generated by JS -->
            </div>
          </div>
          <div class="form-group">
            <label>Who sets the riddle?</label>
            <select id="sts-riddle-provider-select">
              <option value="user">I'll set it</option>
              <option value="random_ai">Random AI</option>
            </select>
          </div>
          <!-- User riddle input area (hidden by default) -->
          <div id="sts-user-riddle-input-area" style="display: none">
            <div class="form-group">
              <label for="sts-user-riddle-surface">Riddle Surface</label>
              <textarea
                id="sts-user-riddle-surface"
                rows="2"
                placeholder="e.g., A man walks into a bar and orders a glass of water..."
              ></textarea>
            </div>
            <div class="form-group">
              <label for="sts-user-riddle-answer">Riddle Answer (full story)</label>
              <textarea
                id="sts-user-riddle-answer"
                rows="4"
                placeholder="e.g., The man had hiccups, he wanted water to cure them..."
              ></textarea>
            </div>
          </div>
          <!-- AI riddle input area (hidden by default) -->
          <div id="sts-ai-riddle-input-area" style="display: none">
            <div class="form-group">
              <label for="sts-ai-riddle-type">Riddle Type (optional)</label>
              <input
                type="text"
                id="sts-ai-riddle-type"
                placeholder="e.g., Horror, Heartwarming, Mind-bending, Classic"
              />
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-sts-setup-btn">Cancel</button>
          <button class="save" id="start-sts-game-btn">Start Game</button>
        </div>
      </div>
    </div>

    <!-- 1. Sea Turtle Soup game summary card -->
    <div id="sts-summary-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span>Game Summary</span>
        </div>
        <div
          class="modal-body"
          id="sts-summary-content"
          style="white-space: pre-wrap; line-height: 1.7"
        >
          <!-- Summary content will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="share-sts-summary-btn">Share Review</button>
          <button class="save" id="back-to-hall-from-sts-btn">Back to Hall</button>
        </div>
      </div>
    </div>

    <!-- 2. Sea Turtle Soup review send target selector -->
    <div id="sts-share-target-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Select Players to Share With</span>
        </div>
        <div class="modal-body" id="sts-share-target-list" style="padding: 0">
          <!-- Player list will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button
            id="sts-select-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Select All
          </button>
          <button
            id="sts-deselect-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Deselect All
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="sts-cancel-share-btn">Cancel</button>
          <button class="save" id="sts-confirm-share-btn">Confirm Share</button>
        </div>
      </div>
    </div>

    <!-- 1. Murder Mystery game setup screen -->
    <div id="script-kill-setup-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‚Äπ</span>
        <span>Murder Mystery - Game Setup</span>
      </div>
      <div class="form-container">
        <div class="form-group">
          <label>Select Script</label>
          <div style="display: flex; gap: 10px">
            <select
              id="script-kill-script-select"
              style="flex-grow: 1"
            ></select>
            <button
              id="manage-custom-scripts-btn"
              class="form-button-secondary"
              style="margin-top: 0; padding: 0 15px"
            >
              Manage
            </button>
          </div>
        </div>
        <div class="form-group">
          <label>Invite Players (you are auto-joined)</label>
          <div
            id="script-kill-player-selection"
            class="list-container"
            style="
              height: 300px;
              border: 1px solid var(--border-color);
              border-radius: 8px;
            "
          >
            <!-- Player selection list will be dynamically generated by JS -->
          </div>
        </div>
        <div class="form-group">
          <label class="toggle-switch-label">
            <span class="toggle-switch-text"
              >Free Role Selection (off = random assignment)</span
            >
            <input type="checkbox" id="script-kill-free-choice-toggle" />
            <span class="toggle-switch-slider"></span>
          </label>
        </div>
        <button id="start-script-kill-game-btn" class="form-button">
          Start Game
        </button>
      </div>
    </div>

    <!-- 2. Murder Mystery game main screen -->
    <div id="script-kill-game-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="exit-script-kill-game-btn">‚Äπ Exit</span>
        <span id="script-kill-game-title">Murder Mystery</span>
        <div class="header-actions">
          <span class="action-btn" id="script-kill-my-role-btn">My Role</span>
          <span class="action-btn" id="script-kill-all-evidence-btn"
            >Public Clues</span
          >
        </div>
      </div>
      <div id="script-kill-game-content">
        <div id="script-kill-players-grid">
          <!-- Player avatars and status will be dynamically generated by JS -->
        </div>
        <div id="script-kill-log-container">
          <div id="script-kill-game-log">
            <!-- Game process info will be shown here -->
          </div>
        </div>
        <div id="script-kill-action-area">
          <!-- Player buttons will be shown here based on game phase -->
        </div>
      </div>
    </div>

    <!-- Murder Mystery custom script manager modal -->
    <div id="script-kill-manager-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Manage Custom Scripts</span>
          <div class="header-actions">
            <button
              id="import-script-btn"
              class="action-button"
              style="font-size: 14px"
            >
              Import
            </button>

            <button
              id="open-sk-ai-generator-btn"
              class="action-button"
              style="font-size: 14px"
            >
              AI Generate
            </button>

            <button id="add-new-script-btn" class="action-button">Add</button>
          </div>
        </div>

        <div class="modal-body" id="custom-scripts-list" style="padding: 0">
          <!-- Custom script list will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-script-manager-btn"
            style="width: 100%"
          >
            Done
          </button>
        </div>
      </div>
    </div>

    <!-- 1. Script editor main modal (visual version) -->
    <div id="script-kill-editor-modal" class="modal">
      <div class="modal-content" style="height: 90%">
        <div class="modal-header">
          <span id="script-editor-title">Script Editor</span>
        </div>
        <div
          class="modal-body"
          style="display: flex; flex-direction: column; gap: 15px"
        >
          <!-- Basic info -->
          <div class="form-group">
            <label for="script-name-input">Script Name</label>
            <input type="text" id="script-name-input" />
          </div>
          <div class="form-group">
            <label for="script-background-input">Story Background</label>
            <textarea id="script-background-input" rows="3"></textarea>
          </div>

          <hr style="opacity: 0.2" />

          <!-- Character settings area -->
          <div>
            <div
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
              "
            >
              <label style="margin: 0; font-weight: 600">Character Settings</label>
              <button
                id="sk-add-role-btn"
                class="form-button-secondary"
                style="margin: 0; padding: 5px 15px"
              >
                + Add Character
              </button>
            </div>
            <div id="sk-roles-container" class="sk-item-container">
              <!-- Character cards will be dynamically generated here by JS -->
            </div>
          </div>

          <!-- Clue card area -->
          <div>
            <div
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
              "
            >
              <label style="margin: 0; font-weight: 600">Clue Cards</label>
              <button
                id="sk-add-clue-btn"
                class="form-button-secondary"
                style="margin: 0; padding: 5px 15px"
              >
                + Add Clue
              </button>
            </div>
            <div id="sk-clues-container" class="sk-item-container">
              <!-- Clue cards will be dynamically generated here by JS -->
            </div>
          </div>

          <!-- Final truth -->
          <div class="form-group">
            <label for="sk-truth-input">Final Truth</label>
            <textarea id="sk-truth-input" rows="3"></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-script-editor-btn">Cancel</button>
          <button class="save" id="save-script-btn">Save Script</button>
        </div>
      </div>
    </div>

    <!-- 2. Sub-modal for editing individual characters/clues -->
    <div id="sk-item-editor-modal" class="modal" style="z-index: 1003">
      <div class="modal-content" style="height: auto; max-height: 85%">
        <div class="modal-header">
          <span id="sk-item-editor-title"></span>
        </div>
        <div class="modal-body">
          <!-- Character edit fields (hidden by default) -->
          <div id="sk-role-editor-fields" style="display: none">
            <div class="form-group">
              <label for="sk-role-name-input">Character Name</label>
              <input type="text" id="sk-role-name-input" />
            </div>
            <div class="form-group">
              <label for="sk-role-desc-input">Character Description</label>
              <textarea id="sk-role-desc-input" rows="3"></textarea>
            </div>
            <div class="form-group">
              <label for="sk-role-storyline-input"
                >Storyline (detailed movements during the incident)</label
              >
              <textarea id="sk-role-storyline-input" rows="5"></textarea>
            </div>
            <div class="form-group">
              <label for="sk-role-tasks-input">Secret Mission</label>
              <textarea id="sk-role-tasks-input" rows="2"></textarea>
            </div>
            <div class="form-group">
              <label class="toggle-switch-label">
                <span class="toggle-switch-text">Is the Killer</span>
                <input type="checkbox" id="sk-role-killer-toggle" />
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
          </div>
          <!-- Clue edit fields (hidden by default) -->
          <div id="sk-clue-editor-fields" style="display: none">
            <div class="form-group">
              <label for="sk-clue-owner-select">Clue Owner</label>
              <select id="sk-clue-owner-select">
                <!-- Options will be dynamically generated by JS -->
              </select>
            </div>
            <div class="form-group">
              <label for="sk-clue-desc-input">Clue Description</label>
              <textarea id="sk-clue-desc-input" rows="4"></textarea>
            </div>
            <div class="form-group">
              <label class="toggle-switch-label">
                <span class="toggle-switch-text">Is Key Clue</span>
                <input type="checkbox" id="sk-clue-key-toggle" />
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="sk-item-editor-cancel-btn">Cancel</button>
          <button class="save" id="sk-item-editor-save-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- 4. Character identity card modal -->
    <div id="script-kill-role-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="sk-role-name">Your Character</span>
        </div>
        <div
          class="modal-body"
          id="sk-role-details"
          style="white-space: pre-wrap; line-height: 1.7"
        >
          <!-- Character description, missions etc. will be shown here -->
        </div>
        <div class="modal-footer">
          <button class="save" id="close-sk-role-modal-btn" style="width: 100%">
            Got It
          </button>
        </div>
      </div>
    </div>

    <!-- 5. Personal clue board modal -->
    <div id="script-kill-evidence-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>My Clue Board</span>
        </div>
        <div
          class="modal-body"
          id="sk-evidence-list"
          style="
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
          "
        >
          <!-- Found clue cards will be shown here -->
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-sk-evidence-modal-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- 6. Voting modal -->
    <div id="script-kill-vote-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 70%">
        <div class="modal-header">
          <span id="sk-vote-title">Final Vote</span>
        </div>
        <div
          class="modal-body"
          id="sk-vote-options-list"
          style="text-align: left; padding: 20px"
        >
          <!-- Vote options will be dynamically generated by JS -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-sk-vote-btn">Cancel</button>
          <button class="save" id="confirm-sk-vote-btn">Confirm Vote</button>
        </div>
      </div>
    </div>
    <!-- Murder Mystery game summary card -->
    <div id="script-kill-summary-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span>Game Summary</span>
        </div>
        <div
          class="modal-body"
          id="script-kill-summary-content"
          style="white-space: pre-wrap; line-height: 1.7"
        >
          <!-- Summary content will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="repost-sk-summary-btn">
            Forward Review to Chat
          </button>
          <button class="save" id="back-to-hall-from-sk-btn">Back to Hall</button>
        </div>
      </div>
    </div>

    <!-- Murder Mystery review send target selector -->
    <div id="script-kill-target-picker-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Select Players to Forward To</span>
        </div>
        <div class="modal-body" id="script-kill-target-list" style="padding: 0">
          <!-- Player list will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button
            id="sk-select-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Select All
          </button>
          <button
            id="sk-deselect-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Deselect All
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="sk-cancel-share-btn">Cancel</button>
          <button class="save" id="sk-confirm-share-btn">Confirm Forward</button>
        </div>
      </div>
    </div>

    <div id="sk-ai-generator-modal" class="modal">
      <div class="modal-content" style="height: 90%">
        <div class="modal-header">
          <span>AI Script Generator</span>
        </div>
        <div
          class="modal-body"
          style="display: flex; flex-direction: column; gap: 15px"
        >
          <div class="form-group">
            <label for="sk-ai-elements-input">Core Elements (comma-separated)</label>
            <input
              type="text"
              id="sk-ai-elements-input"
              placeholder="e.g., Modern, Murder, Snowstorm Manor, Inheritance"
            />
          </div>

          <div class="form-group">
            <label for="sk-ai-player-count-input"
              >Player Count (including killer, recommended 4-8)</label
            >
            <input
              type="number"
              id="sk-ai-player-count-input"
              value="5"
              min="3"
              max="12"
              style="
                width: 100%;
                box-sizing: border-box;
                padding: 10px;
                border-radius: 6px;
                border: 1px solid var(--border-color);
              "
            />
          </div>

          <div class="form-group">
            <label for="sk-ai-summary-input">Plot Overview (optional)</label>
            <textarea
              id="sk-ai-summary-input"
              rows="4"
              placeholder="Write a simple story outline to help the AI better understand your ideas..."
            ></textarea>
          </div>
          <button id="sk-trigger-ai-generation-btn" class="form-button">
            Start Generating
          </button>

          <hr style="opacity: 0.2; margin: 5px 0" />

          <div
            class="form-group"
            style="
              flex-grow: 1;
              min-height: 0;
              display: flex;
              flex-direction: column;
            "
          >
            <label>AI Generation Result Preview</label>
            <div
              id="sk-ai-result-preview"
              style="
                flex-grow: 1;
                overflow-y: auto;
                background: #f0f2f5;
                padding: 10px;
                border-radius: 8px;
                white-space: pre-wrap;
                line-height: 1.6;
                color: #555;
              "
            >
              Click "Start Generating" and results will appear here...
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="sk-ai-generator-cancel-btn">Close</button>
          <!-- This save button is initially disabled, activated after successful generation -->
          <button class="save" id="sk-ai-generator-save-btn" disabled>
            Save Script
          </button>
        </div>
      </div>
    </div>

    <!-- 1. "Word Guess" game setup screen -->
    <div id="guess-what-setup-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‚Äπ</span>
        <span>Word Guess - Game Setup</span>
      </div>
      <div class="form-container">
        <div class="form-group">
          <label>Invite a Player</label>
          <div
            id="guess-what-player-selection"
            class="list-container"
            style="
              height: 200px;
              border: 1px solid var(--border-color);
              border-radius: 8px;
            "
          >
            <!-- Player selection list will be dynamically generated by JS -->
          </div>
        </div>
        <div class="form-group">
          <label>Select Game Mode</label>
          <div style="display: flex; gap: 20px">
            <label
              ><input
                type="radio"
                name="guess_what_mode"
                value="ai_guesses"
                checked
              />
              I set, AI guesses</label
            >
            <label
              ><input
                type="radio"
                name="guess_what_mode"
                value="user_guesses"
              />
              AI sets, I guess</label
            >
          </div>
        </div>
        <!-- Input box for "I set" mode -->
        <div class="form-group" id="user-word-input-container">
          <label for="guess-what-user-word">Enter your word</label>
          <input
            type="text"
            id="guess-what-user-word"
            placeholder="e.g., Apple, Wandering Earth..."
          />
        </div>
        <button id="start-guess-what-game-btn" class="form-button">
          Start Game
        </button>
      </div>
    </div>

    <!-- 2. "Word Guess" game main screen -->
    <div id="guess-what-game-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="exit-guess-what-game-btn">‚Äπ Exit</span>
        <span id="guess-what-game-title">Word Guess</span>
        <span class="action-btn" id="give-up-guess-what-btn">Give Up</span>
      </div>
      <!-- Game main content area -->
      <div
        id="guess-what-game-content"
        style="
          display: flex;
          flex-direction: column;
          height: 100%;
          overflow: hidden;
          padding: 10px;
          box-sizing: border-box;
        "
      >
        <!-- Game log/info area -->
        <div
          id="guess-what-log-container"
          style="
            flex-grow: 1;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            padding: 10px;
            overflow-y: auto;
            margin: 10px 0;
            min-height: 0;
          "
        >
          <div id="guess-what-game-log">
            <!-- Game process info will be shown here -->
          </div>
        </div>
        <!-- Player action area -->
        <div
          id="guess-what-action-area"
          class="chat-input-area"
          style="visibility: visible"
        >
          <div class="chat-input-main-row">
            <textarea
              id="guess-what-user-input"
              rows="1"
              placeholder="Enter hint or guess..."
            ></textarea>
            <button id="send-guess-what-input-btn" class="action-button">
              Send
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- "Word Guess" game summary card -->
    <div id="guess-what-summary-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span>Game Summary</span>
        </div>
        <div
          class="modal-body"
          id="guess-what-summary-content"
          style="white-space: pre-wrap; line-height: 1.7"
        >
          <!-- Summary content will be dynamically generated here by JS -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="forward-guess-what-summary-btn">
            Forward to Them
          </button>
          <button class="save" id="close-guess-what-summary-btn">
            Back to Hall
          </button>
        </div>
      </div>
    </div>

    <!-- 1. Ludo game setup screen -->
    <div id="ludo-setup-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‚Äπ</span>
        <span>Heartbeat Ludo - Game Setup</span>
      </div>
      <div class="form-container">
        <div class="form-group">
          <label>Select a Player</label>
          <!-- Invite list, will be filled by JS -->
          <div
            id="ludo-player-selection"
            class="list-container"
            style="
              height: 200px;
              border: 1px solid var(--border-color);
              border-radius: 8px;
            "
          ></div>
        </div>

        <div class="form-group">
          <label>Select Question Bank</label>
          <div style="display: flex; align-items: center; gap: 10px">
            <select
              id="ludo-question-bank-select"
              style="flex-grow: 1"
            ></select>
            <button
              id="manage-ludo-question-banks-btn"
              class="form-button-secondary"
              style="margin-top: 0; padding: 12px; width: auto"
            >
              Manage Banks
            </button>
          </div>
        </div>

        <button id="start-ludo-game-btn" class="form-button">Start Game</button>
      </div>
    </div>

    <!-- 2. Ludo game main screen -->
    <div id="ludo-game-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="exit-ludo-game-btn">‚Äπ Exit</span>
        <span>Heartbeat Ludo</span>
        <!-- A reset game button can be placed here -->
        <span class="action-btn" id="restart-ludo-game-btn" title="Restart">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <polyline points="23 4 23 10 17 10"></polyline>
            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
          </svg>
        </span>
      </div>
      <!-- Game main content area -->
      <div id="ludo-game-content">
        <!-- Board area -->
        <div id="ludo-board-container">
          <div id="ludo-board">
            <!-- Board squares will be dynamically generated by JS -->
          </div>
          <!-- Player pieces -->
          <div id="ludo-user-piece" class="ludo-piece user"></div>
          <div id="ludo-char-piece" class="ludo-piece char"></div>
        </div>

        <!-- Ê∏∏ÊàèÊó•ÂøóÂå∫Âüü -->
        <div id="ludo-log-container">
          <div id="ludo-game-log"></div>
        </div>

        <!-- Áé©ÂÆ∂Êìç‰ΩúÂå∫ -->
        <div id="ludo-action-area"></div>
      </div>
    </div>

    <!-- Weibo DM list screen -->
    <div id="weibo-dm-list-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-dm-list">‚Äπ</span>
        <span id="weibo-dm-list-title">Fans DMs</span>
        <!-- "Generate More" button -->
        <div class="header-actions">
          <span
            class="action-btn"
            id="generate-more-dms-btn"
            title="Generate More DMs"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
            </svg>
          </span>

          <!-- "Clear All" button -->
          <span class="action-btn" id="clear-all-dms-btn" title="Clear All DMs">
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
              />
            </svg>
          </span>
        </div>
      </div>
      <div id="weibo-dm-list" class="list-container" style="padding: 0">
        <!-- DM list will be dynamically generated by JS -->
      </div>
    </div>

    <div id="weibo-dm-detail-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-dm-detail">‚Äπ</span>
        <span id="weibo-dm-detail-title"></span>
        <span style="width: 30px"></span>
        <!-- Placeholder -->
      </div>
      <div
        id="weibo-dm-messages"
        class="list-container"
        style="
          display: flex;
          flex-direction: column;
          gap: 15px;
          padding: 15px;
          background-color: #f0f2f5;
        "
      >
        <!-- Chat bubbles will be dynamically generated by JS -->
      </div>
    </div>

    <!-- index.html -->

    <div id="taobao-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span>Taobao</span>
        <div class="header-actions">
          <span
            class="action-btn"
            id="clear-taobao-products-btn"
            style="font-size: 16px; font-weight: 500"
            >Clear</span
          >
          <span class="action-btn" id="add-product-btn" title="Add Product"
            >+</span
          >
        </div>
      </div>

      <!-- 1. Top tab navigation (includes "Eleme") -->
      <div class="taobao-tabs">
        <button class="taobao-tab active" data-view="products-view">
          Home
        </button>

        <button class="taobao-tab" data-view="eleme-view">Eleme</button>

        <button class="taobao-tab" data-view="cart-view">
          Cart<span id="cart-item-count-badge" style="display: none">0</span>
        </button>
        <button class="taobao-tab" data-view="orders-view">My Orders</button>
        <button class="taobao-tab" data-view="my-view">Me</button>
      </div>

      <!-- 2. Page content container -->
      <div class="taobao-content">
        <!-- "Home" view -->
        <div id="products-view" class="taobao-view active">
          <div class="taobao-search-bar">
            <input
              type="search"
              id="product-search-input"
              placeholder="Search, let AI create great finds for you!"
            />
            <button id="product-search-btn">Search</button>
          </div>
          <div id="product-category-tabs"></div>
          <div id="product-grid" class="product-grid"></div>
        </div>

        <div id="eleme-view" class="taobao-view">
          <div class="taobao-search-bar">
            <!-- Êñ∞Â¢ûÔºöËøôÊòØÁ¨¨‰∏ÄË°åÁöÑ‚ÄúÊêúÁ¥¢‚ÄùÁªÑ -->
            <div class="eleme-search-group">
              <input
                type="search"
                id="eleme-search-input"
                placeholder="What do you want to eat? Let AI find it for you!"
              />
              <button id="eleme-search-btn">Search</button>
            </div>

            <!-- Êñ∞Â¢ûÔºöËøôÊòØÁ¨¨‰∫åË°åÁöÑ‚ÄúÂäüËÉΩ‚ÄùÁªÑ -->
            <div class="eleme-actions-group">
              <button
                id="eleme-add-manual-btn"
                class="header-actions"
                title="Add Food Manually"
              >
                +
              </button>
              <button
                id="eleme-generate-ai-btn"
                class="header-actions"
                title="AI Generate Food"
              >
                ‚ú®
              </button>
              <button id="eleme-clear-all-btn" class="header-btn">üóëÔ∏è</button>
            </div>
          </div>

          <div id="eleme-grid" class="product-grid">
            <!-- Food list will be dynamically generated by JS here -->
          </div>
        </div>

        <!-- "Cart" view -->
        <div id="cart-view" class="taobao-view">
          <div id="cart-item-list"></div>
          <div id="cart-checkout-bar" style="display: none">
            <div class="total-price">
              Total: <span id="cart-total-price">¬• 0.00</span>
            </div>
            <div style="display: flex; gap: 10px">
              <button id="share-cart-to-char-btn">Share to Pay</button>
              <button id="buy-for-char-btn">Buy for Them</button>
              <button id="checkout-btn">Checkout (0)</button>
            </div>
          </div>
        </div>

        <!-- "My Orders" view -->
        <div id="orders-view" class="taobao-view">
          <div id="order-list" class="order-list"></div>
        </div>

        <!-- "Me" view -->
        <div id="my-view" class="taobao-view">
          <div id="user-balance-container">
            <p>My Balance</p>
            <h2 id="user-balance-display">¬• 0.00</h2>
            <button id="top-up-btn" class="form-button">Top Up Wallet</button>
          </div>
          <div
            id="balance-details-list"
            class="order-list"
            style="padding: 0 15px"
          ></div>
        </div>
      </div>
    </div>

    <div id="product-detail-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>Product Details</span>
        </div>
        <div class="modal-body" id="product-detail-body">
          <!-- Detail content will be dynamically generated by JS -->
        </div>
        <!-- Reviews section -->
        <div id="product-reviews-section">
          <h3>Product Reviews</h3>
          <div id="product-reviews-list"></div>
          <button
            id="generate-reviews-btn"
            class="form-button form-button-secondary"
          >
            ‚ú® AI Generate Reviews
          </button>
        </div>

        <div class="modal-footer">
          <button class="cancel" id="close-product-detail-btn">Close</button>
          <button class="save" id="detail-add-to-cart-btn">Add to Cart</button>
        </div>
      </div>
    </div>

    <!-- 2. Add product method selection modal -->
    <div id="add-product-choice-modal" class="modal">
      <div id="custom-modal" style="width: 250px">
        <div class="custom-modal-header">Select Add Method</div>
        <div class="custom-modal-footer">
          <button id="add-product-manual-btn">Add Manually</button>
          <button id="add-product-link-btn">Identify Link</button>
          <button id="add-product-ai-btn">AI Generate</button>
          <button
            id="cancel-add-choice-btn"
            style="
              margin-top: 8px;
              border-radius: 8px;
              background-color: #f0f0f0;
            "
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- 3. Manual add/edit product modal -->
    <div id="product-editor-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span id="product-editor-title">Add New Product</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="product-name-input">Product Name</label>
            <input type="text" id="product-name-input" />
          </div>
          <div class="form-group">
            <label for="product-price-input">Price (¬•)</label>
            <input type="number" id="product-price-input" />
          </div>
          <div class="form-group">
            <label for="product-image-input">Image URL</label>
            <input type="text" id="product-image-input" />
          </div>
          <div class="form-group">
            <label for="product-category-input">Category (optional)</label>
            <input
              type="text"
              id="product-category-input"
              placeholder="e.g., Clothing, Snacks..."
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-product-editor-btn">Cancel</button>
          <button class="save" id="save-product-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- 4. Identify link modal -->
    <div id="add-from-link-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Paste Share Text</span>
        </div>
        <div class="modal-body">
          <textarea
            id="link-paste-area"
            rows="6"
            placeholder="Paste the full Taobao or Pinduoduo share text here..."
          ></textarea>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-link-paste-btn">Cancel</button>
          <button class="save" id="confirm-link-paste-btn">Identify</button>
        </div>
      </div>
    </div>

    <!-- Logistics details screen -->
    <div id="logistics-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="logistics-back-btn">‚Äπ</span>
        <span>Logistics Details</span>
        <span style="width: 30px"></span>
        <!-- Placeholder for centering title -->
      </div>
      <div id="logistics-content-area" class="list-container">
        <!-- Logistics info will be dynamically generated by JS here -->
      </div>
    </div>

    <!-- 1. "Who's the Spy" game setup screen -->
    <div id="undercover-setup-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‚Äπ</span>
        <span>Who's the Spy - Game Setup</span>
      </div>
      <div class="form-container">
        <div class="form-group">
          <label>Invite Mode</label>
          <div style="display: flex; gap: 20px">
            <label style="cursor: pointer"
              ><input
                type="radio"
                name="undercover_invite_mode"
                value="manual"
                checked
              />
              Manual Invite</label
            >
            <label style="cursor: pointer"
              ><input
                type="radio"
                name="undercover_invite_mode"
                value="random"
              />
              Random Invite</label
            >
          </div>
        </div>

        <!-- Random invite options -->
        <div id="undercover-random-invite-options" style="display: none">
          <div class="form-group">
            <label for="undercover-random-player-count"
              >How many AI/NPCs to invite? (excluding yourself)</label
            >
            <input
              type="number"
              id="undercover-random-player-count"
              min="2"
              max="15"
              value="5"
              style="width: 100%; box-sizing: border-box; padding: 10px"
            />
          </div>
        </div>

        <!-- Manual invite options -->
        <div id="undercover-manual-invite-options">
          <div class="form-group">
            <label>Select players to invite</label>
            <div
              id="undercover-player-selection"
              class="list-container"
              style="
                height: 350px;
                border: 1px solid var(--border-color);
                border-radius: 8px;
              "
            >
              <!-- Player selection list will be dynamically generated by JS -->
            </div>
          </div>
        </div>

        <button id="start-undercover-game-btn" class="form-button">
          Start Game
        </button>
        <p
          style="
            text-align: center;
            color: var(--text-secondary);
            font-size: 13px;
            margin-top: 15px;
          "
        >
          Game requires at least 3 players.<br />
          3-5 players: 1 spy<br />
          6-8 players: 1 spy, 1 blank<br />
          9+ players: 2 spies, 1 blank
        </p>
      </div>
    </div>

    <!-- 2. "Who's the Spy" game main screen -->
    <div id="undercover-game-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="exit-undercover-game-btn">‚Äπ Exit</span>
        <span id="undercover-game-title">Who's the Spy</span>
        <span class="action-btn" id="undercover-my-word-btn">My Word</span>
      </div>
      <!-- Game main content area -->
      <div
        id="undercover-game-content"
        style="
          display: flex;
          flex-direction: column;
          height: 100%;
          overflow: hidden;
          padding: 10px;
          box-sizing: border-box;
        "
      >
        <!-- Player seats area -->
        <div
          id="undercover-players-grid"
          style="
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 15px;
            padding: 10px;
            flex-shrink: 0;
          "
        >
          <!-- Player avatars and status will be dynamically generated by JS -->
        </div>
        <!-- Game log/info area -->
        <div
          id="undercover-log-container"
          style="
            flex-grow: 1;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            padding: 10px;
            overflow-y: auto;
            margin: 10px 0;
            min-height: 0;
          "
        >
          <div id="undercover-game-log">
            <!-- Game progress info will be shown here -->
          </div>
        </div>
        <!-- Player action area -->
        <div
          id="undercover-action-area"
          style="
            flex-shrink: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            min-height: 50px;
          "
        >
          <!-- Player buttons will be shown here based on game phase -->
        </div>
      </div>
    </div>

    <div id="undercover-summary-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span>Game Summary</span>
        </div>
        <div
          class="modal-body"
          id="undercover-summary-content"
          style="white-space: pre-wrap; line-height: 1.7"
        >
          <!-- Summary content will be dynamically generated by JS here -->
        </div>
        <div class="modal-footer">
          <!-- "Share Review" button -->
          <button class="cancel" id="repost-undercover-summary-btn">
            Share Review to Chat
          </button>
          <button class="save" id="back-to-hall-from-undercover-btn">
            Back to Hall
          </button>
        </div>
      </div>
    </div>

    <!-- 1. User DM list screen -->
    <div id="user-dm-list-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-user-dm-list">‚Äπ</span>
        <span>My DMs</span>
        <div class="header-actions">
          <!-- This button generates new fan DMs with AI -->
          <span
            class="action-btn"
            id="generate-new-user-dms-btn"
            title="Generate New DMs"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
            </svg>
          </span>
          <!-- This button clears all DMs -->
          <span
            class="action-btn"
            id="clear-all-user-dms-btn"
            title="Clear All DMs"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"
              />
            </svg>
          </span>
        </div>
      </div>
      <div
        id="user-dm-list-container"
        class="list-container"
        style="padding: 0"
      >
        <!-- DM list will be dynamically generated by JS here -->
      </div>
    </div>

    <!-- 2. User DM detail screen (chat with fan) -->
    <div id="user-dm-detail-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-user-dm-detail">‚Äπ</span>
        <span id="user-dm-detail-title"></span>
        <!-- Fan name -->
        <span style="width: 30px"></span>
        <!-- Placeholder -->
      </div>
      <div
        id="user-dm-messages-container"
        class="list-container"
        style="
          display: flex;
          flex-direction: column;
          gap: 15px;
          padding: 15px;
          background-color: #f0f2f5;
        "
      >
        <!-- Chat bubbles will be dynamically generated by JS here -->
      </div>
      <!-- Chat input box -->

      <div id="user-dm-input-area" class="chat-input-area">
        <div class="chat-input-main-row">
          <textarea
            id="user-dm-input"
            rows="1"
            placeholder="Chat with your fan..."
          ></textarea>

          <div id="input-actions-wrapper">
            <!-- "Trigger AI response" button -->
            <button
              id="user-dm-trigger-ai-btn"
              class="action-button chat-action-icon-btn"
              title="Let them speak first"
            >
              <svg
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path
                  d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"
                ></path>
              </svg>
            </button>
            <!-- "Reroll" button -->
            <button
              id="user-dm-reroll-btn"
              class="action-button chat-action-icon-btn"
              title="Regenerate Reply"
            >
              <svg
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
              </svg>
            </button>

            <button id="user-dm-send-btn" class="action-button">Send</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Character Weibo profile screen -->
    <div id="weibo-char-profile-screen" class="screen">
      <!-- Header with back button and character name -->
      <div class="header">
        <span class="back-btn" id="back-from-char-profile">‚Äπ</span>
        <span id="weibo-char-profile-title">Character Profile</span>
        <div class="header-actions">
          <span
            class="action-btn"
            id="edit-char-weibo-profile-btn"
            title="Edit Character Profile"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M12 20h9"></path>
              <path
                d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"
              ></path>
            </svg>
          </span>
        </div>
      </div>
      <!-- Character profile content area -->
      <div id="weibo-char-profile-page" class="weibo-profile-page">
        <!-- Reuses personal profile scroll style -->
        <div class="weibo-profile-header">
          <img
            id="weibo-char-background-img"
            src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg"
            class="weibo-background"
          />
          <div class="weibo-avatar-container">
            <img
              id="weibo-char-avatar-img"
              src="https://files.catbox.moe/q6z5fc.jpeg"
              class="weibo-avatar"
            />
            <img
              id="weibo-char-avatar-frame"
              class="weibo-avatar-frame"
              src=""
              style="display: none"
            />
          </div>
          <div class="weibo-nickname" id="weibo-char-nickname">Character Nickname</div>
          <div id="weibo-char-profession-display">Character Profession</div>

          <div class="weibo-stats">
            <div
              id="weibo-char-following-item"
              class="weibo-stat-item"
              style="cursor: pointer"
            >
              <span id="weibo-char-following-count" class="weibo-stat-number"
                >0</span
              >
              <span class="weibo-stat-label">Following</span>
            </div>
            <div id="weibo-char-posts-item" class="weibo-stat-item">
              <span id="weibo-char-posts-count" class="weibo-stat-number"
                >0</span
              >
              <span class="weibo-stat-label">Posts</span>
            </div>
            <div
              id="weibo-char-fans-item"
              class="weibo-stat-item"
              style="cursor: pointer"
            >
              <span id="weibo-char-fans-count" class="weibo-stat-number"
                >0</span
              >
              <span class="weibo-stat-label">Fans</span>
            </div>
          </div>
        </div>
        <div
          id="char-weibo-feed-list"
          style="
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
          "
        >
          <!-- Character's Weibo posts will be dynamically generated by JS here -->
        </div>
      </div>
    </div>

    <!-- Character Weibo profile edit modal -->
    <div id="char-weibo-editor-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Edit Character Weibo Profile</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Weibo Avatar</label>
            <div class="avatar-upload">
              <img id="char-weibo-editor-avatar-preview" />
              <button
                onclick="
                  document
                    .getElementById('char-weibo-editor-avatar-input')
                    .click()
                "
              >
                Upload Avatar
              </button>
              <button class="change-frame-btn" data-type="char-weibo">
                Change Frame
              </button>
              <input
                type="file"
                id="char-weibo-editor-avatar-input"
                accept="image/*"
                hidden
              />
            </div>
          </div>
          <div class="form-group">
            <label for="char-weibo-editor-nickname-input">Weibo Nickname</label>
            <input type="text" id="char-weibo-editor-nickname-input" />
          </div>
          <div class="form-group">
            <label>Weibo Background</label>
            <div class="avatar-upload">
              <img
                id="char-weibo-editor-bg-preview"
                style="width: 120px; height: 67.5px; border-radius: 8px"
              />
              <button
                onclick="
                  document.getElementById('char-weibo-editor-bg-input').click()
                "
              >
                Upload Background
              </button>
              <input
                type="file"
                id="char-weibo-editor-bg-input"
                accept="image/*"
                hidden
              />
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-char-weibo-editor-btn">Cancel</button>
          <button class="save" id="save-char-weibo-editor-btn">Save</button>
        </div>
      </div>
    </div>

    <div id="date-a-live-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span>Date A Live</span>
        <div class="header-actions">
          <!-- "+" button -->
          <span
            class="action-btn"
            id="create-dating-scene-btn"
            title="Create New Scene"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <line x1="12" y1="5" x2="12" y2="19"></line>
              <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
          </span>

          <span class="action-btn" id="dating-history-btn" title="Date History">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
              <polyline points="3 3 3 8 8 8" />
              <path d="M12 6V12L16 14" />
            </svg>
          </span>
          <span
            class="action-btn"
            id="refresh-dating-scene-btn"
            title="Refresh Scene"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="23 4 23 10 17 10"></polyline>
              <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
          </span>
        </div>
      </div>
      <div id="dating-scene-content" class="list-container">
        <!-- Dating scene cards will be dynamically generated by JS here -->
      </div>
    </div>

    <!-- Pet feature modal -->
    <div id="pet-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 85%">
        <div class="modal-header">
          <span id="pet-modal-title">My Pet</span>
        </div>
        <div class="modal-body">
          <!-- Pet info preview area -->
          <div
            id="pet-preview-area"
            style="text-align: center; margin-bottom: 20px"
          >
            <div
              id="pet-preview-display"
              style="
                font-size: 60px;
                line-height: 1;
                margin-bottom: 10px;
                cursor: pointer;
              "
              title="Click to change image"
            ></div>
            <strong id="pet-preview-name" style="font-size: 18px"></strong>
            <p
              id="pet-preview-type"
              style="
                font-size: 14px;
                color: var(--text-secondary);
                margin: 5px 0;
              "
            ></p>
          </div>

          <!-- Pet stats display area -->
          <div id="pet-stats-area" style="display: none">
            <div id="pet-hunger-bar" class="stat-bar-container">
              <span class="stat-label">Fullness</span>
              <div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
            </div>
            <div id="pet-happiness-bar" class="stat-bar-container">
              <span class="stat-label">Mood</span>
              <div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
            </div>
            <div id="pet-intimacy-user-bar" class="stat-bar-container">
              <span class="stat-label">Closeness to You</span>
              <div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
            </div>
            <div id="pet-intimacy-char-bar" class="stat-bar-container">
              <span class="stat-label">Closeness to Them</span>
              <div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
            </div>
          </div>

          <!-- Interaction buttons area (includes "Chat" button) -->
          <div
            id="pet-interaction-area"
            style="
              display: flex;
              justify-content: center;
              gap: 15px;
              margin-bottom: 20px;
              padding-bottom: 15px;
              border-bottom: 1px solid var(--border-color);
            "
          >
            <button class="form-button-secondary" data-action="feed">
              Feed
            </button>
            <button class="form-button-secondary" data-action="play">
              Play
            </button>
            <button class="form-button-secondary" data-action="touch">
              Pet
            </button>
            <button class="form-button-secondary" data-action="chat">
              Chat
            </button>
          </div>

          <!-- Settings area -->
          <div class="form-group">
            <label for="pet-type-input">Type (free text)</label>
            <input
              type="text"
              id="pet-type-input"
              placeholder="e.g., kitten, hamster, sunflower..."
            />
          </div>
          <div class="form-group">
            <label for="pet-name-input">Nickname</label>
            <input
              type="text"
              id="pet-name-input"
              placeholder="Give it a name"
            />
          </div>
          <div class="form-group">
            <label for="pet-image-input">Appearance (Emoji or Image URL)</label>
            <input
              type="text"
              id="pet-image-input"
              placeholder="Enter an Emoji like üêà or an image link"
            />
          </div>
          <!-- Persona input -->
          <div class="form-group">
            <label for="pet-persona-input">Pet Persona & Background</label>
            <textarea
              id="pet-persona-input"
              rows="3"
              placeholder="Describe its personality and story; AI will roleplay based on this."
            ></textarea>
          </div>
          <div class="form-group">
            <label class="toggle-switch-label">
              <span>Show in chat interface</span>
              <input type="checkbox" id="pet-display-toggle" />
              <span class="toggle-switch-slider"></span>
            </label>
          </div>
          <div id="pet-position-controls" style="display: none">
            <div class="form-group">
              <label for="pet-size-slider"
                >Size: <span id="pet-size-value">100px</span></label
              >
              <input
                type="range"
                id="pet-size-slider"
                min="30"
                max="200"
                value="100"
                style="width: 100%"
              />
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="cancel"
            id="pet-abandon-btn"
            style="
              background-color: #ffdde5;
              color: #ff3b30;
              border-color: #ffc2d1;
            "
          >
            Release Pet
          </button>

          <button class="cancel" id="pet-modal-cancel-btn">Cancel</button>
          <button class="save" id="pet-modal-save-btn">Save</button>
        </div>
      </div>
    </div>

    <input
      type="file"
      id="pet-custom-image-input"
      accept="image/*"
      style="display: none"
    />
    <!-- Pet chat modal -->
    <div id="pet-chat-modal" class="modal">
      <div class="modal-content" style="height: 80%">
        <div class="modal-header">
          <span id="pet-chat-title">Chat with Pet</span>
        </div>
        <div
          id="pet-chat-messages"
          class="modal-body"
          style="
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            gap: 15px;
          "
        >
          <!-- Pet chat history will be shown here -->
        </div>
        <!-- Reuses main chat input style -->
        <div
          id="pet-chat-input-area"
          class="chat-input-area"
          style="border-top: 1px solid var(--border-color)"
        >
          <div class="chat-input-main-row">
            <textarea
              id="pet-chat-input"
              rows="1"
              placeholder="Say something to it..."
            ></textarea>
            <button id="send-to-pet-btn" class="action-button">Send</button>
          </div>
        </div>
      </div>
    </div>

    <div id="weibo-char-selector-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Select Content Protagonist</span>
        </div>
        <div
          class="modal-body"
          id="weibo-char-selector-list"
          style="padding: 0; overflow-y: auto"
        >
          <!-- Character list will be dynamically generated by JS here -->
        </div>
        <div class="modal-footer" style="justify-content: space-between">
          <button
            id="weibo-select-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Select All
          </button>
          <button
            id="weibo-deselect-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Deselect All
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="weibo-cancel-char-select-btn">Cancel</button>
          <button class="save" id="weibo-confirm-char-select-btn">Confirm</button>
        </div>
      </div>
    </div>

    <!-- Lovers Space - Mood diary editor modal -->
    <div id="ls-diary-editor-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span id="ls-diary-editor-title">Record Today's Mood</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Choose an emoji to represent today's mood</label>
            <div
              id="ls-emoji-selector"
              style="
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                font-size: 24px;
                cursor: pointer;
                justify-content: center;
                padding: 10px 0;
              "
            >
              <!-- Emojis will be generated by JS -->
            </div>
          </div>
          <div class="form-group">
            <label for="ls-diary-content-input">Write your diary</label>
            <textarea
              id="ls-diary-content-input"
              rows="6"
              placeholder="Did anything special happen today..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="ls-cancel-diary-btn">Cancel</button>
          <button class="save" id="ls-save-diary-btn">Save Diary</button>
        </div>
      </div>
    </div>

    <!-- Lovers Space - Diary viewer modal -->
    <div id="ls-diary-viewer-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span id="ls-diary-viewer-title">View Diary</span>
        </div>
        <div
          id="ls-diary-viewer-body"
          class="modal-body"
          style="display: flex; flex-direction: column; gap: 20px"
        >
          <!-- Diary content will be dynamically generated by JS -->
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="ls-close-diary-viewer-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- Lovers Space - Daily footprint calendar modal -->
    <div id="ls-activity-calendar-modal" class="modal">
      <div class="modal-content" style="max-width: 380px">
        <div class="modal-header">
          <span id="ls-activity-calendar-title">üíï Footprint Calendar üíï</span>
        </div>
        <div class="modal-body" id="ls-activity-calendar-body"></div>
      </div>
    </div>

    <div id="summary-viewer-modal" class="modal">
      <div class="modal-content" style="height: 80%">
        <div class="modal-header">
          <span id="summary-viewer-title">Chat Summary</span>
        </div>
        <div class="modal-body" id="summary-list" style="padding: 15px">
          <!-- Summary list will be dynamically generated by JS here -->
        </div>
        <div class="modal-footer" style="display: flex; gap: 10px">
          <!-- "Condense All" button -->
          <button
            class="form-button-secondary"
            id="concise-all-summaries-btn"
            style="flex: 1; margin: 0"
          >
            Condense All
          </button>
          <button
            class="save"
            id="close-summary-viewer-btn"
            style="flex: 1; margin: 0"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- AI-generated products result/selection modal -->
    <div id="ai-generated-products-modal" class="modal">
      <div class="modal-content" style="height: 80%">
        <div class="modal-header">
          <span id="ai-products-modal-title">AI Generated the Following Items for You</span>
        </div>
        <div class="modal-body" style="padding: 15px">
          <div id="ai-product-results-grid" class="product-grid"></div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-ai-products-modal-btn"
            style="width: 100%"
          >
            Done
          </button>
        </div>
      </div>
    </div>

    <!-- Ludo question bank manager modal -->
    <div id="ludo-qbank-manager-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Manage Question Banks</span>

          <div class="header-actions">
            <span
              class="action-btn"
              id="import-ludo-qbank-btn"
              title="Import Bank"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
              </svg>
            </span>
            <span
              class="action-btn"
              id="add-ludo-qbank-btn"
              style="font-size: 16px"
              >New</span
            >
          </div>
        </div>
        <div class="modal-body" id="ludo-qbank-list" style="padding: 0">
          <!-- Question bank list will be dynamically generated by JS here -->
        </div>
        <div class="modal-footer">
          <button class="save" id="close-qbank-manager-btn" style="width: 100%">
            Done
          </button>
        </div>
      </div>
    </div>

    <!-- Ludo question editor modal -->
    <div id="ludo-question-editor-modal" class="modal">
      <div class="modal-content" style="height: 80%">
        <div class="modal-header">
          <span class="back-btn" id="back-to-qbank-manager-btn">‚Äπ</span>
          <span id="ludo-question-editor-title">Edit Questions</span>
          <span
            class="action-btn"
            id="add-ludo-question-btn"
            style="font-size: 28px; font-weight: 300"
            >+</span
          >
        </div>
        <div class="modal-body" id="ludo-question-list" style="padding: 10px">
          <!-- Question list will be dynamically generated by JS here -->
        </div>
      </div>
    </div>

    <!-- Ludo single question editor modal -->
    <div id="ludo-single-question-editor-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span id="ludo-single-question-title">Edit Question</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="ludo-question-text-input">Question Content</label>
            <textarea id="ludo-question-text-input" rows="4"></textarea>
          </div>
          <div class="form-group">
            <label>Question Type</label>
            <div style="display: flex; gap: 20px">
              <label
                ><input
                  type="radio"
                  name="ludo_question_type"
                  value="both_answer"
                  checked
                />
                Both Answer</label
              >
              <label
                ><input
                  type="radio"
                  name="ludo_question_type"
                  value="single_answer"
                />
                One Answers, One Reviews</label
              >
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-single-question-btn">Cancel</button>
          <button class="save" id="save-single-question-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- Ludo game summary card -->
    <div id="ludo-summary-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span>Game Summary</span>
        </div>
        <div
          class="modal-body"
          id="ludo-summary-content"
          style="text-align: left; line-height: 1.7"
        >
          <!-- Summary content will be dynamically generated by JS here -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="share-ludo-summary-btn">Share with Them</button>
          <button class="save" id="back-to-hall-from-ludo-btn">Back to Hall</button>
        </div>
      </div>
    </div>
    <!-- "Who's the Spy" game summary card -->
    <div id="undercover-summary-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span>Game Summary</span>
        </div>
        <div
          class="modal-body"
          id="undercover-summary-content"
          style="white-space: pre-wrap; line-height: 1.7"
        >
          <!-- Summary content will be dynamically generated by JS here -->
        </div>
        <div class="modal-footer">
          <!-- "Share Review" button -->
          <button class="cancel" id="repost-undercover-summary-btn">
            Share Review to Chat
          </button>
          <button class="save" id="back-to-hall-from-undercover-btn">
            Back to Hall
          </button>
        </div>
      </div>
    </div>

    <!-- "Who's the Spy" review send target selector -->
    <div id="undercover-target-picker-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Select Players to Send To</span>
        </div>
        <div class="modal-body" id="undercover-target-list" style="padding: 0">
          <!-- Player list will be dynamically generated by JS here -->
        </div>
        <div class="modal-footer">
          <button
            id="uc-select-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Select All
          </button>
          <button
            id="uc-deselect-all-btn"
            class="form-button-secondary"
            style="width: 45%; margin: 0"
          >
            Deselect All
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="uc-cancel-share-btn">Cancel</button>
          <button class="save" id="uc-confirm-share-btn">Confirm Send</button>
        </div>
      </div>
    </div>

    <!-- Group announcement modal -->
    <div id="group-announcement-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>Group Announcement</span>
        </div>
        <div class="modal-body" id="announcement-content-area">
          <!-- Announcement content will be shown here -->
        </div>
        <div class="modal-footer" id="announcement-footer">
          <!-- Buttons will be dynamically generated by JS -->
        </div>
      </div>
    </div>
    <!-- Inner voice panel style editor modal -->
    <div id="inner-voice-editor-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Edit Inner Voice Panel Style</span>
        </div>
        <div class="modal-body">
          <!-- === Start: Custom inner voice fields === -->
          <div class="form-group">
            <label>Custom Inner Voice Fields (Label + AI Generation Instruction)</label>
            <div style="font-size: 12px; color: #666; margin-bottom: 10px">
              Left: display title, Right: specific AI instruction.
            </div>

            <!-- Field 1: clothing -->
            <div style="display: flex; gap: 5px; margin-bottom: 8px">
              <input
                type="text"
                id="iv-label-clothing"
                placeholder="Title (e.g., Outfit)"
                class="moe-input"
                style="flex: 1"
              />
              <textarea
                id="iv-prompt-clothing"
                rows="1"
                placeholder="Instruction (e.g., Describe your current outfit)"
                class="moe-input"
                style="flex: 2; resize: vertical"
              ></textarea>
            </div>

            <!-- Field 2: behavior -->
            <div style="display: flex; gap: 5px; margin-bottom: 8px">
              <input
                type="text"
                id="iv-label-behavior"
                placeholder="Title (e.g., Behavior)"
                class="moe-input"
                style="flex: 1"
              />
              <textarea
                id="iv-prompt-behavior"
                rows="1"
                placeholder="Instruction (e.g., Describe your actions and expressions)"
                class="moe-input"
                style="flex: 2; resize: vertical"
              ></textarea>
            </div>

            <!-- Field 3: thoughts -->
            <div style="display: flex; gap: 5px; margin-bottom: 8px">
              <input
                type="text"
                id="iv-label-thoughts"
                placeholder="Title (e.g., Thoughts)"
                class="moe-input"
                style="flex: 1"
              />
              <textarea
                id="iv-prompt-thoughts"
                rows="1"
                placeholder="Instruction (e.g., Describe your inner thoughts)"
                class="moe-input"
                style="flex: 2; resize: vertical"
              ></textarea>
            </div>

            <!-- Field 4: naughty -->
            <div style="display: flex; gap: 5px; margin-bottom: 8px">
              <input
                type="text"
                id="iv-label-naughty"
                placeholder="Title (e.g., Naughty Thoughts)"
                class="moe-input"
                style="flex: 1"
              />
              <textarea
                id="iv-prompt-naughty"
                rows="1"
                placeholder="Instruction (e.g., Describe your devious thoughts)"
                class="moe-input"
                style="flex: 2; resize: vertical"
              ></textarea>
            </div>
          </div>
          <hr style="opacity: 0.2" />
          <!-- === End replacement === -->

          <hr style="opacity: 0.2" />
          <!-- === End addition === -->
          <!-- Card background color -->
          <div class="form-group">
            <label for="iv-card-bg-color">Card Background Color</label>
            <input
              type="color"
              id="iv-card-bg-color"
              value="#FFFFFF"
              style="width: 100%; height: 40px"
            />
          </div>
          <!-- Card opacity -->
          <div class="form-group">
            <label for="iv-opacity-slider"
              >Card Background Opacity: <span id="iv-opacity-value">70%</span></label
            >
            <input
              type="range"
              id="iv-opacity-slider"
              min="0"
              max="1"
              step="0.05"
              value="0.7"
              style="width: 100%"
            />
          </div>
          <hr style="opacity: 0.2" />
          <!-- Background colors for four labels -->
          <div class="form-group">
            <label for="iv-color-clothing">"Outfit" Label Background Color</label>
            <input
              type="color"
              id="iv-color-clothing"
              value="#f0a1a8"
              style="width: 100%; height: 40px"
            />
          </div>
          <div class="form-group">
            <label for="iv-color-behavior">"Behavior" Label Background Color</label>
            <input
              type="color"
              id="iv-color-behavior"
              value="#81c784"
              style="width: 100%; height: 40px"
            />
          </div>
          <div class="form-group">
            <label for="iv-color-thoughts">"Thoughts" Label Background Color</label>
            <input
              type="color"
              id="iv-color-thoughts"
              value="#64b5f6"
              style="width: 100%; height: 40px"
            />
          </div>
          <div class="form-group">
            <label for="iv-color-naughty">"Naughty Thoughts" Label Background Color</label>
            <input
              type="color"
              id="iv-color-naughty"
              value="#ba68c8"
              style="width: 100%; height: 40px"
            />
          </div>

          <hr style="opacity: 0.2; margin: 20px 0" />
          <div class="form-group">
            <label for="iv-icon-color">Icon Color</label>
            <input
              type="color"
              id="iv-icon-color"
              value="#ff8a80"
              style="width: 100%; height: 40px"
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="iv-editor-cancel-btn">Cancel</button>
          <button class="save" id="iv-editor-save-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- AI generate group members modal -->
    <div id="ai-generate-members-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>AI Generate Group Members</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="ai-member-count-input">Number to Generate (1-20)</label>
            <input
              type="number"
              id="ai-member-count-input"
              value="3"
              min="1"
              max="20"
            />
          </div>
          <div class="form-group">
            <label for="ai-member-prompt-input">Requirements (optional, AI will reference)</label>
            <textarea
              id="ai-member-prompt-input"
              rows="4"
              placeholder="e.g., A group of college students who love outdoor adventures, each with different personalities..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-ai-generate-members-btn">
            Cancel
          </button>
          <button class="save" id="confirm-ai-generate-members-btn">
            Start Generating
          </button>
        </div>
      </div>
    </div>

    <!-- Date invitation & payment modal -->
    <div id="dating-payment-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span id="dating-modal-title">Send Date Invitation</span>
        </div>
        <div class="modal-body" style="text-align: center">
          <p>Your selected date is:</p>
          <h3
            id="dating-modal-scene-name"
            style="color: var(--accent-color); margin: 10px 0"
          ></h3>
          <p id="dating-modal-scene-cost" style="font-weight: bold"></p>
          <hr style="opacity: 0.2; margin: 20px 0" />
          <p>Who's paying?</p>
          <div
            id="dating-payment-options"
            style="display: flex; flex-direction: column; gap: 10px"
          >
            <!-- Payment option buttons will be dynamically generated by JS -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="dating-cancel-btn" style="width: 100%">
            Maybe Next Time
          </button>
        </div>
      </div>
    </div>

    <!-- Date character selection modal -->
    <div id="dating-char-selector-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Select Date Partner</span>
        </div>
        <div
          class="modal-body"
          id="dating-char-selector-list"
          style="padding: 0"
        >
          <!-- Character list will be dynamically generated by JS here -->
        </div>
        <div class="modal-footer">
          <button
            class="cancel"
            id="dating-cancel-char-select-btn"
            style="width: 100%"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <div id="dating-game-screen" class="screen">
      <!-- 1. Dynamic background image (bottom layer) -->
      <div id="dating-game-background"></div>

      <!-- 2. Character sprite container (middle layer) -->
      <div id="dating-game-sprite-container">
        <img id="dating-game-sprite" src="" />
      </div>

      <!-- 3. UI overlay (top layer, contains header/text box/options) -->
      <div class="dating-game-ui-overlay">
        <div class="header">
          <span class="back-btn" id="end-date-btn">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M15 18l-6-6 6-6" />
            </svg>
          </span>

          <span id="dating-game-char-name"></span>
          <div class="header-actions">
            <!-- Heart value bars -->
            <div id="dating-values-container">
              <div id="romance-value" class="value-display">
                <!-- JS will generate 5 pink hearts here -->
              </div>
              <div id="lust-value" class="value-display">
                <!-- JS will generate 5 yellow hearts here -->
              </div>
            </div>
            <span class="action-btn" id="dating-bgm-btn" title="Background Music">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
              </svg>
            </span>
            <span
              class="action-btn"
              id="dating-game-settings-btn"
              title="Scene Settings"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <circle cx="12" cy="12" r="3"></circle>
                <path
                  d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"
                ></path>
              </svg>
            </span>
            <span
              class="action-btn"
              id="dating-game-reroll-btn"
              title="Reroll Response"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
              </svg>
            </span>
          </div>
        </div>

        <!-- 3b. Bottom text box -->
        <div class="dating-game-textbox">
          <p id="dating-game-text-content">Date is about to begin...</p>
        </div>
        <div id="dating-completion-bar-container">
          <div id="dating-completion-bar-fill"></div>
          <span id="dating-completion-text">0%</span>
        </div>
        <!-- 3c. Player action area -->
        <div id="dating-game-choices" class="dating-game-choices">
          <!-- Choice buttons will be dynamically generated by JS here -->
        </div>
      </div>
    </div>
    <!-- Dating BGM control panel -->
    <div id="dating-bgm-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Select Background Music</span>
        </div>
        <div class="modal-body" style="padding: 15px">
          <!-- Control buttons -->
          <div
            class="bgm-controls"
            style="display: flex; gap: 10px; margin-bottom: 15px"
          >
            <button
              id="dating-bgm-random-btn"
              class="form-button-secondary"
              style="flex: 1; margin: 0"
            >
              Random Play
            </button>
            <button
              id="dating-bgm-stop-btn"
              class="form-button-secondary"
              style="
                flex: 1;
                margin: 0;
                background-color: #ffe5e5;
                color: #ff3b30;
                border-color: #ffc2d1;
              "
            >
              Stop Playing
            </button>
          </div>
          <!-- Volume control -->
          <div class="form-group">
            <label for="dating-bgm-volume-slider"
              >Volume: <span id="dating-bgm-volume-value">100%</span></label
            >
            <input
              type="range"
              id="dating-bgm-volume-slider"
              min="0"
              max="1"
              step="0.05"
              value="1"
              style="width: 100%"
            />
          </div>
          <hr style="opacity: 0.2" />
          <!-- Song list -->
          <div
            id="dating-bgm-playlist"
            class="list-container"
            style="padding: 0; height: calc(100% - 130px)"
          >
            <!-- Song library will be dynamically generated by JS here -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="save" id="dating-bgm-close-btn" style="width: 100%">
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- Borrow money target selection modal (with scroll and avatar) -->
    <div id="borrow-money-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Who to Borrow From?</span>
        </div>
        <div
          class="modal-body"
          id="borrow-money-char-list"
          style="padding: 0; overflow-y: auto"
        >
          <!-- Borrow target list will be dynamically generated by JS here -->
        </div>
        <div class="modal-footer">
          <button
            class="cancel"
            id="borrow-money-cancel-btn"
            style="width: 100%"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <div id="dating-game-settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>Date Scene Settings</span>
        </div>
        <div class="modal-body">
          <!-- Preset management -->
          <div class="form-group">
            <label>Preset</label>
            <div class="bubble-preset-manager">
              <select
                id="dating-preset-select"
                class="form-group select"
              ></select>
              <button id="manage-dating-presets-btn" class="action-btn">
                Manage
              </button>
            </div>
          </div>

          <hr style="opacity: 0.2" />

          <!-- Sprite group selector -->
          <div class="form-group">
            <label>Select Character Sprite Group</label>
            <div class="bubble-preset-manager">
              <select id="dating-sprite-group-select" class="form-group select">
                <option value="">-- No Sprite --</option>
                <!-- Sprite groups will be dynamically filled by JS -->
              </select>
              <button id="manage-sprite-groups-btn" class="action-btn">
                Manage Sprites
              </button>
            </div>
          </div>

          <hr style="opacity: 0.2" />

          <!-- Core settings -->
          <div class="form-group">
            <label for="dating-prompt-input">Scene/Character Prompt</label>
            <textarea
              id="dating-prompt-input"
              rows="4"
              placeholder="e.g., You are a tsundere but gentle girl, flustered by the user's confession at the seaside..."
            ></textarea>
          </div>
          <div class="form-group">
            <label for="dating-style-input">Writing Style</label>
            <textarea
              id="dating-style-input"
              rows="3"
              placeholder="e.g., Please use delicate psychological descriptions and beautiful scenery depictions..."
            ></textarea>
          </div>
          <div class="form-group">
            <label>Date Background Image</label>
            <div class="bg-upload-container">
              <button
                class="form-button-secondary"
                onclick="
                  document.getElementById('dating-bg-upload-input').click()
                "
                style="margin-top: 0"
              >
                Upload Image
              </button>
              <input
                type="text"
                id="dating-bg-url-input"
                placeholder="Or paste an image URL"
                style="flex-grow: 1"
              />
            </div>
            <input
              type="file"
              id="dating-bg-upload-input"
              accept="image/*"
              hidden
            />
          </div>
          <hr style="opacity: 0.2; margin: 15px 0" />

          <div class="form-group">
            <label>Extra World Books (This Date)</label>
            <!-- Reuses main settings style -->
            <div class="custom-multiselect" id="dating-wb-multiselect">
              <div class="select-box moe-input">
                <span class="selected-options-text"
                  >-- Click to Select Extra World Views --</span
                >
                <span class="arrow-down">‚ñº</span>
              </div>
              <!-- Note: this container has a new ID to avoid conflicts -->
              <div
                id="dating-wb-checkboxes-container"
                class="checkboxes-container"
              >
                <!-- Options will be dynamically generated by JS -->
              </div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-dating-settings-btn">Cancel</button>
          <button class="save" id="save-dating-settings-btn">Apply & Save</button>
        </div>
      </div>
    </div>

    <!-- 1. Sprite group manager modal -->
    <div id="sprite-group-manager-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Manage Sprite Groups</span>
          <span
            class="action-btn"
            id="create-new-sprite-group-btn"
            style="font-size: 16px"
            >New</span
          >
        </div>
        <div
          class="modal-body"
          id="sprite-group-list-container"
          style="padding: 0"
        >
          <!-- Sprite group list will be dynamically generated by JS -->
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-sprite-group-manager-btn"
            style="width: 100%"
          >
            Done
          </button>
        </div>
      </div>
    </div>

    <!-- 2. Sprite group editor modal -->
    <div id="sprite-editor-modal" class="modal">
      <div class="modal-content" style="height: 90%">
        <div class="modal-header">
          <span id="sprite-editor-title">Edit Sprite Group</span>
        </div>
        <div class="modal-body" id="sprite-editor-body">
          <div class="form-group">
            <label for="sprite-group-name-input">Sprite Group Name</label>
            <input
              type="text"
              id="sprite-group-name-input"
              placeholder="e.g., Casual, Battle, Shy..."
            />
          </div>
          <hr style="opacity: 0.2" />
          <label>Sprite List</label>
          <div
            id="sprite-list-editor"
            style="
              display: flex;
              flex-direction: column;
              gap: 15px;
              margin-top: 10px;
            "
          >
            <!-- Individual sprite edit cards will be dynamically generated by JS -->
          </div>
          <button
            id="add-new-sprite-btn"
            class="form-button form-button-secondary"
            style="margin-top: 20px"
          >
            + Add New Sprite
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-sprite-editor-btn">Cancel</button>
          <button class="save" id="save-sprite-editor-btn">Save Sprite Group</button>
        </div>
      </div>
    </div>

    <!-- Date summary card -->
    <div id="dating-summary-overlay" class="modal">
      <div class="dating-summary-card">
        <div class="dating-summary-card-inner">
          <!-- Card front -->
          <div class="card-front">
            <img id="summary-card-avatar" src="" alt="Character Avatar" />
            <h2 id="summary-card-rating"></h2>
            <p class="summary-card-tip">Click card to view full date record</p>
            <div class="summary-card-actions">
              <button id="summary-share-btn">Share with Them</button>
              <button id="summary-close-btn">Close</button>
            </div>
          </div>
          <!-- Card back -->
          <div class="card-back">
            <div class="card-back-header">
              <span>Full Date Record</span>
              <button id="summary-flip-back-btn">Back</button>
            </div>
            <div id="summary-card-history" class="card-back-content">
              <!-- Date history will be dynamically generated by JS here -->
            </div>
          </div>
        </div>
      </div>
    </div>

    <input
      type="file"
      id="dating-summary-image-upload"
      accept="image/*"
      hidden
    />

    <div id="tukey-accounting-screen" class="screen">
      <!-- 1. Page header -->
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span id="tukey-header-title">Accounting Group Chat</span>
        <span style="width: 30px"></span>
      </div>

      <!-- 2. Page content container -->
      <div class="tukey-content">
        <!-- View 1: Wallet (core view) -->
        <div id="tukey-wallet-view" class="tukey-view">
          <div id="wallet-summary-card">
            <div class="summary-item net-assets">
              <span class="label">Net Worth</span>
              <span class="value" id="net-assets-value">¬• 0.00</span>
            </div>
            <div class="summary-details">
              <div class="summary-item">
                <span class="label">Total Assets</span>
                <span class="value" id="total-assets-value">¬• 0.00</span>
              </div>
              <div class="summary-item">
                <span class="label">Total Liabilities</span>
                <span class="value" id="total-liabilities-value">¬• 0.00</span>
              </div>
            </div>
          </div>
          <div id="wallet-accounts-list">
            <!-- Account list will be dynamically generated by JS here -->
          </div>
          <button
            id="add-new-account-fab"
            class="ls-fab-btn"
            title="Add new account"
          >
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <line
                x1="12"
                y1="5"
                x2="12"
                y2="19"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
              <line
                x1="5"
                y1="12"
                x2="19"
                y2="12"
                stroke="currentColor"
                stroke-width="3"
                stroke-linecap="round"
              />
            </svg>
          </button>
        </div>

        <div id="tukey-reports-view" class="tukey-view">
          <!-- 1. Report controls/filter area -->
          <div class="report-controls">
            <select id="report-account-filter">
              <!-- Account options will be dynamically generated by JS -->
            </select>
            <select id="report-month-filter">
              <!-- Month options will be dynamically generated by JS -->
            </select>
            <select id="report-type-filter">
              <option value="daily_details">Daily Details</option>
              <option value="monthly_summary">Monthly Summary</option>
            </select>
          </div>

          <!-- 2. Report content display area -->
          <div id="report-display-area">
            <!-- View switch container -->
            <div id="daily-report-view" class="report-view active">
              <!-- Daily details will be dynamically generated by JS here -->
              <p class="report-placeholder">Loading report...</p>
            </div>
            <div id="monthly-report-view" class="report-view">
              <!-- Monthly summary will be dynamically generated by JS here -->
              <div id="monthly-summary-card">
                <!-- Monthly total income/expense -->
              </div>
              <div class="chart-container">
                <h3>Expense Category Breakdown</h3>
                <canvas id="category-pie-chart"></canvas>
              </div>
              <div class="chart-container">
                <h3>Monthly Expense Trend</h3>
                <canvas id="expenditure-line-chart"></canvas>
              </div>
            </div>
          </div>
        </div>

        <div id="tukey-group-chat-view" class="tukey-view active">
          <!-- This container shows when there's no group chat -->
          <div id="tukey-no-group-placeholder">
            <p>You haven't created an accounting group chat yet</p>
            <button id="tukey-create-group-btn" class="form-button">
              Create Now
            </button>
          </div>

          <div id="tukey-group-chat-container" style="display: none">
            <div id="tukey-group-chat-header">
              <span id="tukey-group-name">Group Chat Name</span>
              <button id="tukey-group-settings-btn" title="Group Chat Settings">‚öôÔ∏è</button>
            </div>

            <!-- Accounting and reply history -->
            <div id="tukey-records-list">
              <!-- JS will render content here -->
            </div>

            <!-- Accounting input area -->
            <div id="tukey-record-input-area">
              <button id="tukey-add-record-btn">+</button>
            </div>

            <div id="tukey-record-input-card">
              <div class="card-header">
                <button class="close-card-btn">√ó</button>
                <div class="type-selector">
                  <button class="type-btn active" data-type="expense">
                    Expense
                  </button>
                  <button class="type-btn" data-type="income">Income</button>
                </div>
              </div>
              <div class="card-body">
                <!-- Amount and remarks input area -->
                <div class="input-fields">
                  <div class="amount-input-wrapper">
                    <span class="currency-symbol">¬•</span>
                    <input
                      type="number"
                      id="tukey-card-amount-input"
                      placeholder="0.00"
                    />
                    <!-- Selected category display area -->
                    <div id="tukey-card-selected-category">
                      <img src="" alt="" />
                      <span>Select Category</span>
                    </div>
                  </div>
                  <input
                    type="text"
                    id="tukey-card-remarks-input"
                    placeholder="Click to enter remarks..."
                  />
                </div>
                <!-- Category grid -->
                <div class="category-grid">
                  <!-- Categories will be dynamically generated by JS -->
                </div>
              </div>
              <div class="card-footer">
                <!-- Account and time selector -->
                <div class="additional-options">
                  <div class="option-item">
                    <label for="tukey-card-account-select">Account</label>
                    <select id="tukey-card-account-select">
                      <!-- Accounts will be dynamically generated by JS -->
                    </select>
                  </div>
                  <div class="option-item">
                    <label for="tukey-card-time-input">Time</label>
                    <input type="datetime-local" id="tukey-card-time-input" />
                  </div>
                </div>
                <button id="tukey-save-from-card-btn">Save</button>
              </div>
            </div>
          </div>
        </div>

        <div id="tukey-settings-view" class="tukey-view">
          <div class="form-container" style="padding-top: 20px">
            <!-- 1. Personal profile settings -->
            <div class="form-group">
              <label>My Profile</label>
              <div class="avatar-upload">
                <img
                  id="tukey-user-avatar-preview"
                  src="https://i.postimg.cc/PxZrFFFL/o-o-1.jpg"
                />
                <button
                  onclick="
                    document.getElementById('tukey-user-avatar-input').click()
                  "
                >
                  Upload My Avatar
                </button>
                <input
                  type="file"
                  id="tukey-user-avatar-input"
                  accept="image/*"
                  hidden
                />
              </div>
            </div>
            <div class="form-group">
              <label for="tukey-user-name-input">Username</label>
              <input
                type="text"
                id="tukey-user-name-input"
                placeholder="Enter your display name in group chat"
              />
            </div>
            <div class="form-group">
              <label for="tukey-user-profession-input">Profession (optional)</label>
              <input
                type="text"
                id="tukey-user-profession-input"
                placeholder="Your profession, shown to group members"
              />
            </div>

            <hr style="opacity: 0.2; margin: 20px 0" />

            <!-- 2. Sync settings -->
            <div class="form-group">
              <label for="sync-to-taobao-toggle" class="toggle-switch-label">
                <span class="toggle-switch-text">
                  Sync to Taobao Balance
                  <p
                    style="
                      font-size: 12px;
                      font-weight: normal;
                      color: #999;
                      margin-top: 5px;
                    "
                  >
                    When enabled, all accounting records will sync and affect Taobao balance and transaction details.
                  </p>
                </span>
                <input type="checkbox" id="sync-to-taobao-toggle" />
                <span class="toggle-switch-slider"></span>
              </label>
            </div>

            <hr style="opacity: 0.2; margin: 20px 0" />

            <!-- 3. Export settings -->
            <div class="form-group">
              <label>Data Export</label>
              <button
                id="export-tukey-report-btn"
                class="form-button form-button-secondary"
              >
                Export Bill as Excel
              </button>
            </div>

            <button class="form-button" id="save-tukey-settings-btn">
              Save All Settings
            </button>
          </div>
        </div>
      </div>

      <!-- 3. Bottom navigation bar -->
      <div id="tukey-bottom-nav">
        <div class="tukey-nav-item" data-view="tukey-wallet-view">
          <svg width="24" height="24" viewBox="0 0 1024 1024">
            <path
              d="M517.7 660c-4 26.6-19.2 46.3-37.3 46.3H290.1c-21.2 0-38.4-27-38.4-60.3V435.3c0-33.3 17.2-60.3 38.4-60.3h190.3c17.6 0 32.5 18.7 37 44.1"
              fill="#BAF4EA"
            ></path>
            <path
              d="M668.7 761.8H321.6c-54 0-97.9-43.9-97.9-97.9V419.6c0-54 43.9-97.9 97.9-97.9h347.1c43.8 0 82.6 29.5 94.4 71.6 4.1 14.9-4.6 30.3-19.5 34.5-14.9 4.1-30.3-4.6-34.5-19.5-5-18-21.6-30.6-40.4-30.6H321.6c-23.1 0-41.9 18.8-41.9 41.9v244.3c0 23.1 18.8 41.9 41.9 41.9h347.1c19.5 0 36.3-13.2 40.8-32.2 3.6-15 18.7-24.3 33.7-20.8 15 3.6 24.3 18.7 20.8 33.7-5 21.1-17.1 40.2-34.1 53.8-17.3 13.9-39 21.5-61.2 21.5z"
              fill="#2D5B56"
            ></path>
            <path
              d="M719.9 614.4H641c-39.9 0-72.6-32.7-72.6-72.6 0-39.9 32.7-72.6 72.6-72.6h78.9c39.9 0 72.6 32.7 72.6 72.6 0 39.9-32.7 72.6-72.6 72.6z"
              fill="#BAF4EA"
            ></path>
            <path
              d="M719.9 642.4H641c-55.5 0-100.6-45.1-100.6-100.6 0-55.5 45.1-100.6 100.6-100.6h78.9c55.5 0 100.6 45.1 100.6 100.6 0 55.4-45.2 100.6-100.6 100.6zM641 497.1c-24.6 0-44.6 20-44.6 44.6s20 44.6 44.6 44.6h78.9c24.6 0 44.6-20 44.6-44.6s-20-44.6-44.6-44.6H641z"
              fill="#2D5B56"
            ></path>
            <path
              d="M650.1 542.4m-0.4 0a0.4 0.4 0 1 0 0.8 0 0.4 0.4 0 1 0-0.8 0Z"
              fill="#FFFFFF"
            ></path>
            <path
              d="M650.1 570.8c-15.7 0-28.4-12.7-28.4-28.4s12.7-28.4 28.4-28.4 28.4 12.7 28.4 28.4-12.7 28.4-28.4 28.4z m0-56c-15.2 0-27.6 12.4-27.6 27.6s12.4 27.6 27.6 27.6 27.6-12.4 27.6-27.6-12.4-27.6-27.6-27.6z"
              fill="#2D5B56"
            ></path>
            <path
              d="M155.2 152.2c12 0 21.7 9.7 21.7 21.7s-9.7 21.7-21.7-21.7-21.7-9.7-21.7-21.7 9.7-21.7 21.7-21.7m0-40c-34 0-61.7 27.7-61.7 61.7s27.7 61.7 61.7 61.7 61.7-27.7 61.7-61.7-27.7-61.7-61.7-61.7zM162.7 956.8h-0.2c-8.3-0.1-14.9-6.9-14.8-15.2l1-69.5c0.1-8.2 6.8-14.8 15-14.8h0.2c8.3 0.1 14.9 6.9 14.8 15.2l-1 69.5c-0.1 8.2-6.8 14.8-15 14.8z"
              fill="#2D5B56"
            ></path>
            <path
              d="M212.9 907.5v0.2c-0.1 8.3-6.9 14.9-15.2 14.8l-69.5-1c-8.2-0.1-14.8-6.8-14.8-15v-0.2c0.1-8.3 6.9-14.9 15.2-14.8l69.5 1c8.3 0.2 14.8 6.9 14.8 15z"
              fill="#2D5B56"
            ></path>
            <path
              d="M895.4 905.5m-30.9 0a30.9 30.9 0 1 0 61.8 0 30.9 30.9 0 1 0-61.8 0Z"
              fill="#2D5B56"
            ></path>
            <path
              d="M121.4 613.5m-20.7 0a20.7 20.7 0 1 0 41.4 0 20.7 20.7 0 1 0-41.4 0Z"
              fill="#2D5B56"
            ></path>
            <path
              d="M861.5 115.5v30.8M861.5 156.3c-5.5 0-10-4.5-10-10v-30.8c0-5.5 4.5-10 10-10s10 4.5 10 10v30.8c0 5.5-4.5 10-10 10zM804.8 172.2h30.8M835.6 182.2h-30.8c-5.5 0-10-4.5-10-10s4.5-10 10-10h30.8c5.5 0 10 4.5 10 10s-4.5 10-10 10zM887.4 172.2h30.8M918.2 182.2h-30.8c-5.5 0-10-4.5-10-10s4.5-10 10-10h30.8c5.5 0 10 4.5 10 10s-4.5 10-10 10z"
              fill="#2D5B56"
            ></path>
            <path
              d="M821.4 212.3l21.8-21.8M821.4 222.3c-2.6 0-5.1-1-7.1-2.9-3.9-3.9-3.9-10.2 0-14.1l21.8-21.8c3.9-3.9 10.2-3.9 14.1 0 3.9 3.9 3.9 10.2 0 14.1l-21.8 21.8c-1.8 1.9-4.4 2.9-7 2.9z"
              fill="#2D5B56"
            ></path>
            <path
              d="M879.8 153.9l21.8-21.8M879.8 163.9c-2.6 0-5.1-1-7.1-2.9-3.9-3.9-3.9-10.2 0-14.1l21.8-21.8c3.9-3.9 10.2-3.9 14.1 0 3.9 3.9 3.9 10.2 0 14.1L886.9 161c-2 1.9-4.5 2.9-7.1 2.9z"
              fill="#2D5B56"
            ></path>
            <path
              d="M901.6 212.3l-21.8-21.8M901.6 222.3c-2.6 0-5.1-1-7.1-2.9l-21.8-21.8c-3.9-3.9-3.9-10.2 0-14.1 3.9-3.9 10.2-3.9 14.1 0l21.8 21.8c3.9 3.9 3.9 10.2 0 14.1-1.9 1.9-4.5 2.9-7 2.9z"
              fill="#2D5B56"
            ></path>
            <path
              d="M843.2 153.9l-21.8-21.8M843.2 163.9c-2.6 0-5.1-1-7.1-2.9l-21.8-21.8c-3.9-3.9-3.9-10.2 0-14.1 3.9-3.9 10.2-3.9 14.1 0l21.8 21.8c3.9 3.9 3.9 10.2 0 14.1-1.9 1.9-4.4 2.9-7 2.9z"
              fill="#2D5B56"
            ></path>
          </svg>
          <span>Wallet</span>
        </div>
        <div class="tukey-nav-item" data-view="tukey-reports-view">
          <svg width="24" height="24" viewBox="0 0 1024 1024">
            <path
              d="M692.24 787.29h-175.3a24.65 24.65 0 0 1 0-49.3h175.3a24.65 24.65 0 0 1 0 49.3z"
              fill="#303030"
              p-id="13093"
            ></path>
            <path
              d="M692.24 186.92v89.18H336.29v463.27h-89.34V186.92h445.29z"
              fill="#279ACC"
              p-id="13094"
            ></path>
            <path
              d="M810.83 869.58H322.21V660.12a24.65 24.65 0 0 1 49.3 0v160.16h390V318.74h-390v148.19a24.65 24.65 0 1 1-49.3 0V269.44h488.62z"
              fill="#303030"
              p-id="13095"
            ></path>
            <path
              d="M346.86 767H225.28V166.87H713.9v127.22a24.65 24.65 0 1 1-49.29 0v-77.93h-390v501.55h72.28a24.65 24.65 0 1 1 0 49.29z"
              fill="#303030"
              p-id="13096"
            ></path>
            <path
              d="M751.63 395.07m-78.65 0a78.65 78.65 0 1 0 157.3 0 78.65 78.65 0 1 0-157.3 0Z"
              fill="#279ACC"
              p-id="13097"
            ></path>
            <path
              d="M317.28 626.59a24.65 24.65 0 0 1-17.42-42.07l89.58-89.59c10.84-10.85 25-16.36 40.58-16.34a55.34 55.34 0 0 1 39.89 18l64.43 69.85 150.17-148a24.65 24.65 0 0 1 34.63 35.08l-150 148.05a49.43 49.43 0 0 1-71-1.66L433.68 530a6.42 6.42 0 0 0-4.65-2.1 5.84 5.84 0 0 0-4.73 1.91l-89.59 89.59a24.58 24.58 0 0 1-17.43 7.19z"
              fill="#303030"
              p-id="13098"
            ></path>
            <path
              d="M751.63 481.75a86.67 86.67 0 1 1 86.67-86.67 86.77 86.77 0 0 1-86.67 86.67z m0-124A37.38 37.38 0 1 0 789 395.08a37.42 37.42 0 0 0-37.37-37.38z"
              fill="#303030"
              p-id="13099"
            ></path>
          </svg>
          <span>Reports</span>
        </div>
        <div class="tukey-nav-item active" data-view="tukey-group-chat-view">
          <svg width="24" height="24" viewBox="0 0 1024 1024">
            <path
              d="M134.588 151C118.247 151 105 164.247 105 180.584v557.964c0 16.339 13.255 29.584 29.599 29.584h155.746l31.872 99.6c2.489 7.777 8.981 9.197 14.504 3.169l94.146-102.769h457.72c16.341 0 29.59-13.247 29.59-29.584V180.584c0-16.339-13.248-29.584-29.588-29.584H134.588z"
              fill="#0FC8B2"
              p-id="32320"
            ></path>
            <path
              d="M511.213 422c19.045 0 34.484 15.44 34.484 34.486s-15.44 34.483-34.484 34.483c-19.046 0-34.485-15.438-34.485-34.483 0-19.046 15.439-34.486 34.485-34.486z m-199.727 0c19.046 0 34.483 15.44 34.483 34.486s-15.437 34.483-34.483 34.483S277 475.531 277 456.486C277 437.44 292.44 422 311.486 422z m399.454 0c19.045 0 34.485 15.439 34.485 34.484 0 19.046-15.439 34.483-34.485 34.483-19.045 0-34.485-15.438-34.485-34.483 0-19.045 15.44-34.484 34.485-34.484z"
              fill="#FFFFFF"
              p-id="32321"
            ></path>
          </svg>
          <span>Group Chat</span>
        </div>
        <div class="tukey-nav-item" data-view="tukey-settings-view">
          <svg width="24" height="24" viewBox="0 0 1024 1024">
            <path
              d="M785.749333 564.770133a231.150933 231.150933 0 0 0 47.035734-258.730666l-145.476267 145.442133a41.5744 41.5744 0 0 1-58.811733 0l-55.876267-55.876267a41.5744 41.5744 0 0 1 0-58.811733l145.476267-145.476267a230.843733 230.843733 0 0 0-305.834667 305.664l-263.509333 263.406934a41.5744 41.5744 0 0 0 0 58.811733l55.842133 55.842133a41.5744 41.5744 0 0 0 58.811733 0l263.406934-263.3728a230.638933 230.638933 0 0 0 258.730666-47.069866l0.170667 0.170666z"
              fill="#FFFFFF"
              p-id="33627"
            ></path>
            <path
              d="M435.2 214.084267a264.977067 264.977067 0 0 1 297.028267-53.828267 34.133333 34.133333 0 0 1 10.001066 55.227733l-145.476266 145.442134a7.441067 7.441067 0 0 0 0 10.581333l55.876266 55.842133a7.441067 7.441067 0 0 0 10.5472 0l145.476267-145.476266a34.133333 34.133333 0 0 1 55.227733 10.069333 265.216 265.216 0 0 1-54.033066 296.96 34.474667 34.474667 0 0 1-3.208534 2.833067l-0.238933 0.170666-3.925333 3.822934a264.704 264.704 0 0 1-262.144 57.7536l-5.290667-1.8432-247.5008 247.534933a75.707733 75.707733 0 0 1-102.741333 4.027733l-4.334934-4.027733-55.876266-55.842133a75.707733 75.707733 0 0 1 0-107.1104l247.7056-247.569067-1.809067-5.2224a265.216 265.216 0 0 1 57.719467-262.075733l6.997333-7.2704z m211.285333-7.850667a196.539733 196.539733 0 0 0-163.0208 56.1152 196.983467 196.983467 0 0 0-40.072533 220.535467 34.133333 34.133333 0 0 1-6.9632 38.229333l-263.5776 263.406933a7.441067 7.441067 0 0 0 0 10.513067l55.876267 55.876267a7.441067 7.441067 0 0 0 10.5472 0l263.406933-263.406934a34.133333 34.133333 0 0 1 38.229333-6.929066 196.5056 196.5056 0 0 0 220.501334-40.072534l1.9456-1.7408 4.334933-4.5056a196.8128 196.8128 0 0 0 50.107733-156.672l-1.058133-7.304533-105.301333 105.335467a75.707733 75.707733 0 0 1-102.741334 4.027733l-4.334933-4.027733-55.876267-55.876267a75.707733 75.707733 0 0 1 0-107.076267l105.3696-105.3696-7.3728-1.058133z"
              fill="#222222"
              p-id="33628"
            ></path>
            <path
              d="M284.8768 690.858667a34.133333 34.133333 0 0 1 48.298667 48.264533l-61.781334 61.7472a34.133333 34.133333 0 1 1-48.264533-48.264533l61.781333-61.781334z"
              fill="#009898"
              p-id="33629"
            ></path>
          </svg>
          <span>Settings</span>
        </div>
      </div>
    </div>

    <!-- ... </div> Ê†áÁ≠æÊù•Ëá™ id="tukey-accounting-screen" -->

    <!-- ÂÖîkËÆ∞Ë¥¶ÂØºÂá∫ÈÄâÈ°πÊ®°ÊÄÅÊ°Ü -->
    <div id="tukey-export-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 70%">
        <div class="modal-header">
          <span>Select Account to Export</span>
        </div>
        <div class="modal-body">
          <div id="tukey-export-account-list" class="contact-picker-list">
            <!-- Ë¥¶Êà∑ÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-tukey-export-btn">Cancel</button>
          <button class="save" id="confirm-tukey-export-btn">Confirm Export</button>
        </div>
      </div>
    </div>

    <!-- 1. Êü•Â≤ó - ËßíËâ≤ÈÄâÊã©Â±èÂπï -->
    <div id="kk-char-selection-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span>Who to Check On?</span>
        <span style="width: 30px"></span>
      </div>
      <div id="kk-char-selection-list" class="list-container">
        <!-- ËßíËâ≤ÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
      </div>
    </div>

    <!-- 2. Êü•Â≤ó - ÊàøÂ±ãÊÄªËßàÂ±èÂπï -->
    <div id="kk-house-view-screen" class="screen">
      <div id="kk-house-background"></div>
      <div
        class="header"
        style="
          background: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0.6),
            transparent
          );
          border-bottom: none;
        "
      >
        <span class="back-btn" id="kk-back-from-house-view">‚Äπ</span>
        <span id="kk-house-owner-name"></span>
        <!-- Ê†áÈ¢ò‰ºöËá™Âä®Â±Ö‰∏≠ -->

        <div class="header-actions">
          <!-- ËøôÈáåÂè™‰øùÁïô‚ÄúÁªßÁª≠ÁøªÊâæ‚ÄùÂíå‚ÄúÈáçÊñ∞ÁøªÊâæ‚Äù -->
          <span class="action-btn" id="kk-continue-search-btn" title="Continue Searching">
            <svg
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <circle cx="11" cy="11" r="8"></circle>
              <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            </svg>
          </span>
          <span class="action-btn" id="kk-reset-search-btn" title="Search Again">
            <svg
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
              ></path>
              <path d="M3 3v5h5"></path>
            </svg>
          </span>
        </div>
      </div>
      <div
        id="kk-scene-toolbar"
        style="
          position: absolute;
          top: 110px;
          right: 20px;
          display: flex;
          flex-direction: column;
          gap: 16px;
          z-index: 10;
        "
      >
        <!-- Ë°£ÊüúÊåâÈíÆ -->
        <!-- ÈáçÁÇπ‰øÆÂ§çÔºöÂä†‰∫Ü box-shadow: none Á≠âÈáçÁΩÆÂ±ûÊÄßÔºåÈò≤Ê≠¢ÊóßÊ†∑ÂºèÂπ≤Êâ∞ -->
        <div
          id="kk-wardrobe-btn"
          title="View Wardrobe"
          style="
            width: 48px;
            height: 48px;
            border-radius: 50%;
            /* Âº∫Âà∂ÈáçÁΩÆÊóßÊ†∑Âºè */
            margin: 0;
            padding: 0;
            /* Ê∞¥Êô∂ÊûúÂÜªÈ£éÊ†ºÊ†∏ÂøÉ */
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.6); /* ÂîØ‰∏Ä‰øùÁïôÁöÑÈ´òÂÖâËæπÊ°Ü */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1); /* ÊüîÂíåÊäïÂΩ± */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #ff9a9e; /* Ê®±Ëä±Á≤âÂõæÊ†á */
            transition: transform 0.2s;
          "
        >
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2.5"
            stroke-linecap="round"
            stroke-linejoin="round"
            style="filter: drop-shadow(0 2px 4px rgba(255, 154, 158, 0.3))"
          >
            <path
              d="M20.38 3.46L16 2a4 4 0 0 1-8 0L3.62 3.46a2 2 0 0 0-1.34 2.23l.58 3.47a1 1 0 0 0 .99.84H6v10c0 1.1.9 2 2 2h8a2 2 0 0 0 2-2V10h2.15a1 1 0 0 0 .99-.84l.58-3.47a2 2 0 0 0-1.34-2.23z"
            ></path>
          </svg>
        </div>

        <!-- ÁõëÊéßÊåâÈíÆ -->
        <div
          id="kk-surveillance-icon"
          title="View Surveillance"
          style="
            width: 48px;
            height: 48px;
            border-radius: 50%;
            /* Âº∫Âà∂ÈáçÁΩÆÊóßÊ†∑Âºè */
            position: static;
            top: auto;
            left: auto;
            /* Ê∞¥Êô∂ÊûúÂÜªÈ£éÊ†ºÊ†∏ÂøÉ */
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #ff9a9e; /* Ê®±Ëä±Á≤âÂõæÊ†á */
            transition: transform 0.2s;
          "
        >
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2.5"
            stroke-linecap="round"
            stroke-linejoin="round"
            style="filter: drop-shadow(0 2px 4px rgba(255, 154, 158, 0.3))"
          >
            <path d="M23 7l-7 5 7 5V7z"></path>
            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
          </svg>
        </div>
      </div>

      <div id="kk-house-info-panel">
        <h2 id="kk-house-location"></h2>
        <p id="kk-house-description"></p>
        <div id="kk-house-areas">
          <!-- ÊàøÂ±ãÂå∫ÂüüÊåâÈíÆÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
        </div>
      </div>
    </div>

    <!-- 3. Êü•Â≤ó - Âå∫ÂüüÊé¢Á¥¢Â±èÂπï -->
    <div id="kk-area-view-screen" class="screen">
      <div id="kk-area-background"></div>
      <div
        class="header"
        style="
          background: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0.6),
            transparent
          );
          border-bottom: none;
        "
      >
        <span class="back-btn" id="kk-back-from-area-view">‚Äπ</span>
        <span id="kk-area-name"></span>
        <span style="width: 30px"></span>
      </div>
      <div class="kk-item-list-container">
        <h3 id="kk-area-description"></h3>
        <p class="kk-instruction-text">Click an item below to search through it:</p>
        <div id="kk-area-items-grid">
          <!-- ÂèØÁøªÊâæÁâ©ÂìÅÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
        </div>
      </div>
    </div>
    <!-- kkCheckin-ÁõëÊéßÂ±èÂπï -->
    <div id="kk-monitor-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="kk-back-from-monitor">‚Äπ</span>
        <span id="kk-monitor-title">Surveillance Center</span>
        <div class="header-actions">
          <!-- Âà∑Êñ∞ÁõëÊéßÊåâÈíÆÔºöÁªü‰∏ÄÊàêÂà∑Êñ∞ÁÆ≠Â§¥ -->
          <span
            class="action-btn"
            id="kk-refresh-monitor-btn"
            title="Refresh Surveillance Feed"
          >
            <svg
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M23 4v6h-6"></path>
              <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
          </span>
        </div>
      </div>
      <div id="kk-monitor-grid" class="list-container">
        <!-- ÁõëÊéßÁîªÈù¢Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
      </div>
    </div>

    <!-- 4. Êü•Â≤ó - ÁîµËÑëÂ±èÂπï (Ê®°ÊÄÅÊ°Ü) -->
    <div id="kk-computer-modal" class="modal">
      <div
        class="modal-content"
        style="
          width: 95%;
          height: 90%;
          max-width: 500px;
          background-color: #e0e0e0;
        "
      >
        <div class="modal-header" id="kk-computer-header">
          <span>'s Computer</span>
          <span id="close-kk-computer-modal" style="cursor: pointer">√ó</span>
        </div>
        <div class="modal-body" id="kk-computer-desktop">
          <!-- ÁîµËÑëÊ°åÈù¢ÂõæÊ†áÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
        </div>
      </div>
    </div>

    <!-- 6. Êü•Â≤ó - Êñá‰ª∂ÊµèËßàÂô®Ê®°ÊÄÅÊ°Ü -->
    <div id="kk-file-explorer-modal" class="modal" style="z-index: 1003">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Private Files</span>
        </div>
        <div class="modal-body" id="kk-file-list">
          <!-- Êñá‰ª∂ÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="close-file-explorer-modal-btn">
            Close
          </button>
        </div>
      </div>
    </div>
    <!-- KKÊü•Â≤ó - Ê≤âÊµ∏ÂºèË°£Â∏ΩÈó¥Â±èÂπï -->
    <div id="kk-wardrobe-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="kk-back-from-wardrobe">‚Äπ</span>
        <span>Their Wardrobe</span>
        <div class="header-actions">
          <!-- Êñ∞Â¢ûÔºöÊ∑ªÂä†Ë°£ÊúçÊåâÈíÆ -->
          <span
            class="action-btn"
            id="kk-wardrobe-add-btn"
            title="Add New Clothes"
            style="font-size: 24px; font-weight: 300; margin-right: 10px"
            >+</span
          >
          <span
            class="action-btn"
            id="kk-wardrobe-refresh-btn"
            title="Reset Wardrobe (Clear All)"
            >‚Üª</span
          >
        </div>
      </div>

      <!-- Ë°£Êüú‰∏ªÂå∫Âüü -->
      <div id="wardrobe-container">
        <!-- Â∑¶‰æß/È°∂ÈÉ®ÔºöÊê≠ÈÖçÈ¢ÑËßà‰∏éËßíËâ≤Á´ãÁªòÂå∫ -->
        <div id="wardrobe-preview-area">
          <img id="wardrobe-char-avatar" src="" alt="Character" />

          <!-- Êñ∞Â¢ûÔºöÁî®‰∫éÊòæÁ§∫ËßíËâ≤ÂØπË°£ÊúçÁúãÊ≥ïÁöÑÊ∞îÊ≥° (ÈªòËÆ§ÊòæÁ§∫ÊèêÁ§∫) -->
          <div
            id="wardrobe-comment-bubble"
            style="
              display: block;
              background: #fff;
              padding: 10px;
              border-radius: 12px;
              margin: 10px;
              font-size: 13px;
              color: #555;
              box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
              min-height: 40px;
              position: relative;
            "
          >
            <span class="content">Click the clothes below to see what I think~</span>
            <!-- Â∞è‰∏âËßí -->
            <div
              style="
                position: absolute;
                bottom: -6px;
                left: 20px;
                width: 0;
                height: 0;
                border-left: 6px solid transparent;
                border-right: 6px solid transparent;
                border-top: 6px solid #fff;
              "
            ></div>
          </div>

          <!-- ËøôÈáåÁöÑÊ∞îÊ≥°Áî®‰∫éÊòæÁ§∫ËØïÁ©øÂêéÁöÑÂèçÂ∫î (‰øùÁïôÂéüÊúâ) -->
          <div id="wardrobe-reaction-bubble" style="display: none">
            <div class="content"></div>
          </div>

          <!-- ÂΩìÂâçÈÄâ‰∏≠ÁöÑÊê≠ÈÖçÂ±ïÁ§∫ -->
          <div id="current-outfit-display">
            <div
              class="outfit-slot"
              data-type="Top"
              data-placeholder="Top"
            ></div>
            <div
              class="outfit-slot"
              data-type="Bottoms"
              data-placeholder="Bottom"
            ></div>
            <div
              class="outfit-slot"
              data-type="Accessories"
              data-placeholder="Accessories"
            ></div>
            <div
              class="outfit-slot"
              data-type="Special"
              data-placeholder="Special"
            ></div>
          </div>

          <button id="wardrobe-try-on-btn" class="form-button" disabled>
            Have Them Wear It
          </button>
        </div>

        <!-- Âè≥‰æß/Â∫ïÈÉ®ÔºöË°£ÊúçÂ∫ìÂ≠òÂàóË°® -->
        <div id="wardrobe-inventory-area">
          <div class="wardrobe-tabs">
            <div class="wardrobe-tab active" data-cat="Top">Tops</div>
            <div class="wardrobe-tab" data-cat="Bottoms">Bottoms</div>
            <div class="wardrobe-tab" data-cat="Accessories">Accessories</div>
            <div class="wardrobe-tab" data-cat="Special">Special</div>
          </div>
          <div id="wardrobe-grid" class="wardrobe-grid">
            <!-- Ë°£ÊúçÂç°ÁâáÁî±JSÁîüÊàê -->
          </div>
        </div>
      </div>
    </div>

    <!-- Á∫¶‰ºöÂéÜÂè≤ËÆ∞ÂΩïÁïåÈù¢ -->
    <div id="dating-history-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="dating-history-back-btn">‚Äπ</span>
        <span>Date History</span>
        <span style="width: 30px"></span>
        <!-- Âç†‰ΩçÁ¨¶Ôºå‰øùÊåÅÊ†áÈ¢òÂ±Ö‰∏≠ -->
      </div>
      <div id="dating-history-list" class="list-container">
        <!-- ÂéÜÂè≤Á∫¶‰ºöÂç°ÁâáÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
      </div>
    </div>

    <div id="create-dating-scene-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>Create Date Scene</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="scene-name-input">Scene Name</label>
            <input
              type="text"
              id="scene-name-input"
              placeholder="e.g., Moonlit Beach Walk"
            />
          </div>
          <div class="form-group">
            <label for="scene-image-url-input">Image URL (optional)</label>
            <input
              type="text"
              id="scene-image-url-input"
              placeholder="Leave blank to let AI generate an image from the scene name..."
            />
          </div>
          <div class="form-group">
            <label for="scene-cost-input">Cost (coins)</label>
            <input
              type="number"
              id="scene-cost-input"
              placeholder="e.g., 520"
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-scene-btn">Cancel</button>
          <button class="save" id="save-custom-scene-btn">Save</button>
        </div>
      </div>
    </div>

    <div id="sticker-category-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 70%">
        <div class="modal-header">
          <span>Move Sticker to Category</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Select an Existing Category</label>
            <div
              id="sticker-category-list"
              style="
                max-height: 200px;
                overflow-y: auto;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 5px;
              "
            >
              <!-- Category list will be dynamically generated by JS -->
            </div>
          </div>
          <p
            style="
              text-align: center;
              color: var(--text-secondary);
              margin: 10px 0;
            "
          >
            or
          </p>
          <div class="form-group">
            <label for="new-sticker-category-input">Create a New Category</label>
            <input
              type="text"
              id="new-sticker-category-input"
              placeholder="Enter new category name..."
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-sticker-category-btn">Cancel</button>
          <button class="save" id="confirm-sticker-category-btn">
            Confirm Move
          </button>
        </div>
      </div>
    </div>

    <div id="advanced-transfer-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>Advanced Import / Export</span>
        </div>
        <div class="modal-body">
          <h4>Select Content to Export</h4>

          <!-- App data export area -->
          <div class="form-group">
            <label>Global App Data (multi-select)</label>
            <div
              id="export-apps-list"
              style="
                max-height: 200px;
                overflow-y: auto;
                border: 1px solid var(--border-color);
                padding: 10px;
                border-radius: 8px;
              "
            >
              <!-- App Â§öÈÄâÊ°ÜÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
            </div>
          </div>

          <!-- ËßíËâ≤Êï∞ÊçÆÂØºÂá∫Âå∫ -->
          <div class="form-group">
            <label
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <span>Character Data (multi-select, QQ posts, etc.)</span>
              <label
                style="font-size: 13px; font-weight: normal; cursor: pointer"
              >
                <input
                  type="checkbox"
                  id="select-all-characters-checkbox"
                  style="vertical-align: middle; margin-right: 4px"
                />
                Select All / None
              </label>
            </label>
            <div
              id="export-characters-list"
              style="
                max-height: 200px;
                overflow-y: auto;
                border: 1px solid var(--border-color);
                padding: 10px;
                border-radius: 8px;
              "
            >
              <!-- ËßíËâ≤Â§öÈÄâÊ°ÜÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
            </div>
          </div>
          <button id="export-selected-data-btn" class="form-button">
            Export Selected
          </button>

          <hr style="margin: 20px 0" />

          <h4>Compatibility Operations</h4>
          <p style="font-size: 13px; color: #666">
            Import data from other versions, or export data in a compatible format.
          </p>

          <button
            id="import-from-330-btn"
            class="form-button"
            style="background-color: #28a745; margin-bottom: 10px"
          >
            üì• Import (v330 Compatible)
          </button>

          <button
            id="export-for-330-btn"
            class="form-button"
            style="background-color: #6f42c1"
          >
            üöÄ Export (v330 Compatible)
          </button>

          <hr style="margin: 20px 0" />

          <h4>Import Supplemental Data</h4>
          <p style="font-size: 13px; color: #666">
            Import will [supplement and overwrite] existing data without deleting other data. Use this to merge data or restore individual character backups.
          </p>
          <button
            id="import-chunked-data-btn"
            class="form-button form-button-secondary"
          >
            Select File & Import
          </button>
          <input
            id="import-chunked-data-input"
            type="file"
            accept="application/json"
            hidden
          />
        </div>
        <div class="modal-footer">
          <button class="cancel" id="close-advanced-transfer-btn">Close</button>
        </div>
      </div>
    </div>

    <input
      id="import-from-330-input"
      type="file"
      accept="application/json"
      hidden
    />

    <div id="intimacy-panel" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>Intimacy</span>
          <span
            id="close-intimacy-panel"
            class="close-btn"
            style="cursor: pointer"
            >&times;</span
          >
        </div>
        <div class="modal-body" id="intimacy-panel-body">
          <div id="intimacy-display">
            <p>Current Intimacy</p>
            <h2 id="intimacy-score-display">--</h2>
          </div>
          <div id="intimacy-details">
            <div class="detail-item">
              <span>üî• Streak Days</span>
              <span id="intimacy-streak-days">-- days</span>
            </div>
            <div class="detail-item">
              <span>üí¨ Today's Messages</span>
              <span id="intimacy-today-msgs">--</span>
            </div>
            <div class="detail-item">
              <span>üìà Total Messages</span>
              <span id="intimacy-total-msgs">--</span>
            </div>
          </div>
          <div id="intimacy-symbol-unlocks">
            <h3>Intimacy Badges</h3>
            <div id="symbol-list-container">
              <!-- JS‰ºöÂú®ËøôÈáåÁîüÊàêÊâÄÊúâÂèØËß£ÈîÅÁöÑÂæΩÁ´† -->
            </div>
          </div>
          <div id="intimacy-records">
            <h3>Unlock Records</h3>
            <div id="unlocked-symbols-record">
              <p>No records yet</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="studio-screen" class="screen">
      <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‚Äπ</span>
        <span>Studio</span>
        <div class="header-actions">
          <span
            class="action-btn"
            id="import-studio-script-btn"
            style="font-size: 14px; margin-right: 5px"
            >Import</span
          >

          <span class="action-btn" id="add-studio-script-btn">New script</span>
          <span class="action-btn" id="studio-history-btn">Record</span>
        </div>
      </div>
      <div id="studio-script-list" class="list-container">
        <!-- ÂâßÊú¨ÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
      </div>

      <input
        type="file"
        id="studio-import-input"
        accept=".json"
        style="display: none"
      />
    </div>

    <!-- 2. Â∞èÂâßÂú∫ÂâßÊú¨ÁºñËæëÂô® -->
    <div id="studio-editor-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-studio-editor">‚Äπ</span>
        <span id="studio-editor-title">Edit Script</span>
        <div class="header-actions">
          <span class="action-btn" id="ai-generate-script-btn">AI Fill</span>
          <span class="save-btn" id="save-studio-script-btn">Save</span>
        </div>
      </div>
      <div class="form-container">
        <div class="form-group">
          <label for="studio-name-input">Script Name</label>
          <input
            type="text"
            id="studio-name-input"
            placeholder="Give your script a name..."
          />
        </div>
        <div class="form-group">
          <label for="studio-background-input">Story Background</label>
          <textarea
            id="studio-background-input"
            rows="4"
            placeholder="Describe the era, location and basic setting of the story..."
          ></textarea>
        </div>
        <div class="form-group">
          <label for="studio-goal-input">Story Goal</label>
          <textarea
            id="studio-goal-input"
            rows="3"
            placeholder="Describe what counts as success, e.g., find the culprit, escape successfully..."
          ></textarea>
        </div>
        <div class="form-group">
          <label for="studio-opening-remark-input">Opening (optional)</label>
          <textarea
            id="studio-opening-remark-input"
            rows="3"
            placeholder="The opening text shown at the start of the script, to set the atmosphere or introduce the scene..."
          ></textarea>
        </div>
        <div class="form-group">
          <label for="studio-char1-identity-input">Character 1 Identity & Background</label>
          <textarea
            id="studio-char1-identity-input"
            rows="4"
            placeholder="Describe character 1's identity, relationships, secret missions, etc..."
          ></textarea>
        </div>
        <div class="form-group">
          <label for="studio-char2-identity-input">Character 2 Identity & Background</label>
          <textarea
            id="studio-char2-identity-input"
            rows="4"
            placeholder="Describe character 2's identity, relationships, secret missions, etc..."
          ></textarea>
        </div>

        <div style="display: flex; gap: 10px; margin-top: 20px">
          <button
            id="export-studio-script-btn"
            class="form-button form-button-secondary"
            style="flex: 1; margin: 0"
          >
            Export Script
          </button>

          <button
            id="delete-studio-script-btn"
            class="form-button form-button-secondary"
            style="
              background-color: #ff3b30;
              color: white;
              border-color: #ff3b30;
              flex: 1;
              margin: 0;
            "
          >
            Delete Script
          </button>
        </div>
      </div>
    </div>

    <!-- 3. Â∞èÂâßÂú∫ËßíËâ≤ÊâÆÊºîÁïåÈù¢ -->
    <div id="studio-play-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="exit-studio-play-btn">‚Äπ</span>
        <span id="studio-play-title">Script Name</span>
        <div class="header-actions">
          <span class="action-btn" id="reroll-studio-play-btn">Refresh</span>
        </div>
      </div>
      <div id="studio-play-messages" class="chat-messages">
        <!-- ÊºîÁªéËøáÁ®ãÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
      </div>
      <div id="studio-play-input-area" class="chat-input-area">
        <div class="chat-input-main-row">
          <textarea
            id="studio-play-input"
            rows="1"
            placeholder="Your action/dialogue..."
          ></textarea>
          <button id="send-studio-play-action-btn" class="action-button">
            Send
          </button>
        </div>
      </div>
    </div>

    <!-- 4. ËßíËâ≤ÈÄâÊã©Ê®°ÊÄÅÊ°Ü -->
    <div id="studio-role-selection-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Select Character & Role</span>
        </div>
        <div class="modal-body">
          <!-- ËßíËâ≤1 -->
          <div class="form-group">
            <label>Character 1</label>
            <p id="studio-role1-desc" class="role-description"></p>
            <div class="player-selection-group">
              <label
                ><input type="radio" name="player-role1" value="user" checked />
                Played by Me</label
              >
              <label
                ><input type="radio" name="player-role1" value="ai" />
                Played by AI</label
              >
            </div>
            <label
              style="
                font-size: 13px;
                color: var(--text-secondary);
                margin-top: 10px;
              "
              >Use Identity:</label
            >
            <select id="studio-role1-identity-select"></select>
          </div>

          <hr style="opacity: 0.2; margin: 15px 0" />

          <!-- ËßíËâ≤2 -->
          <div class="form-group">
            <label>Character 2</label>
            <p id="studio-role2-desc" class="role-description"></p>
            <div class="player-selection-group">
              <label
                ><input type="radio" name="player-role2" value="user" />
                Played by Me</label
              >
              <label
                ><input type="radio" name="player-role2" value="ai" />
                Played by AI</label
              >
            </div>
            <label
              style="
                font-size: 13px;
                color: var(--text-secondary);
                margin-top: 10px;
              "
              >Use Identity:</label
            >
            <select id="studio-role2-identity-select"></select>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-role-selection-btn">Cancel</button>
          <button class="save" id="confirm-role-selection-btn">Enter Script</button>
        </div>
      </div>
    </div>

    <!-- 5. ÊºîÁªéÊàêÂäü/ÁªìÊùüÊ®°ÊÄÅÊ°Ü -->
    <div id="studio-summary-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span id="studio-summary-title">Performance Complete!</span>
        </div>
        <div
          class="modal-body"
          id="studio-summary-content"
          style="white-space: pre-wrap; line-height: 1.7"
        >
          <!-- ÊïÖ‰∫ãÁõÆÊ†áÂíåÊÄªÁªìÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="generate-novel-btn">Generate Novel</button>
          <button class="save" id="close-studio-summary-btn">Close</button>
        </div>
      </div>
    </div>

    <!-- 6. Â∞èËØ¥ÂàÜ‰∫´Ê®°ÊÄÅÊ°Ü -->
    <div id="studio-novel-share-modal" class="modal">
      <div class="modal-content" style="height: 80%">
        <div class="modal-header">
          <span>Generated Novel</span>
        </div>
        <div
          class="modal-body"
          id="studio-novel-content"
          style="
            white-space: pre-wrap;
            line-height: 1.7;
            text-align: left;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
          "
        >
          <!-- Â∞èËØ¥ÂÜÖÂÆπÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="share-novel-btn">Share with Character</button>
          <button class="save" id="close-novel-share-btn">Close</button>
        </div>
      </div>
    </div>

    <!-- Â∞èÂâßÂú∫ - ÊïÖ‰∫ãËÆ∞ÂΩïÂ±èÂπï -->
    <div id="studio-history-screen" class="screen">
      <div class="header">
        <span class="back-btn" id="back-from-studio-history">‚Äπ</span>
        <span>Record</span>
        <span style="width: 30px"></span>
        <!-- Âç†‰ΩçÁ¨¶ -->
      </div>
      <div id="studio-history-list" class="list-container">
        <!-- ÊïÖ‰∫ãËÆ∞ÂΩïÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
      </div>
    </div>

    <div id="account-editor-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 85%">
        <div class="modal-header">
          <span id="account-editor-title">Add new account</span>
        </div>
        <div class="modal-body">
          <!-- Ê†∏ÂøÉ‰øÆÊîπ1ÔºöËøôÊòØÂÖ®Êñ∞ÁöÑAccount TypeÈÄâÊã©ËßÜÂõæÔºåÈªòËÆ§ÈöêËóè -->
          <div id="account-type-selection-view">
            <!-- JS‰ºöÂú®ËøôÈáåÂä®ÊÄÅÁîüÊàêÊâÄÊúâAccount Type -->
          </div>

          <!-- Ê†∏ÂøÉ‰øÆÊîπ2ÔºöÂ∞ÜÂéüÊúâÁöÑË°®ÂçïÂåÖË£πËµ∑Êù•ÔºåÈªòËÆ§ÈöêËóè -->
          <div id="account-editor-form" style="display: none">
            <div class="form-group">
              <label for="account-category-select">Account Categories</label>
              <select id="account-category-select"></select>
            </div>
            <div class="form-group">
              <label for="account-type-select">Account Type</label>
              <select id="account-type-select"></select>
            </div>
            <div class="form-group">
              <label for="account-name-input">Account Name</label>
              <input
                type="text"
                id="account-name-input"
                placeholder="e.g., Paycheck, Change"
              />
            </div>
            <div class="form-group">
              <label for="account-balance-input">Account Balance</label>
              <input
                type="number"
                id="account-balance-input"
                placeholder="0.00"
              />
            </div>
            <div class="form-group">
              <label for="account-remarks-input">Remarks (optional)</label>
              <textarea id="account-remarks-input" rows="2"></textarea>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-account-editor-btn">Cancel</button>
          <button class="save" id="save-account-btn" style="display: none">
            Save
          </button>
        </div>
      </div>
    </div>

    <!-- 1. ÂàõÂª∫/ÁÆ°ÁêÜËÆ∞Ë¥¶Áæ§ËÅäÁöÑÂºπÁ™ó (Ê∑ªÂä†Ëß£Êï£ÊåâÈíÆ) -->
    <div id="tukey-group-manager-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span id="tukey-group-manager-title">Create Accounting Group Chat</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="tukey-group-name-input">Group Name</label>
            <input
              type="text"
              id="tukey-group-name-input"
              placeholder="Name your group chat"
            />
          </div>
          <div class="form-group">
            <label>Select Members (check = add, uncheck = remove)</label>
            <div id="tukey-member-picker-list" class="contact-picker-list">
              <!-- ËßíËâ≤ÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <!-- Ëß£Êï£ÊåâÈíÆ (ÈªòËÆ§ÈöêËóè) -->
          <button
            class="form-button-secondary"
            id="tukey-disband-group-btn"
            style="
              background-color: #ffe5e5;
              color: #ff3b30;
              border-color: #ffc2d1;
              display: none;
              margin-right: auto;
            "
          >
            Disband Group
          </button>

          <button class="cancel" id="tukey-cancel-group-manager-btn">
            Cancel
          </button>
          <button class="save" id="tukey-save-group-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- 2. Áæ§ËÅäAIÂõûÂ§çËÆæÁΩÆÁöÑÂºπÁ™ó -->
    <div id="tukey-reply-settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>AI Reply Settings</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="tukey-reply-threshold-input"
              >AI replies after every ____ transactions:</label
            >
            <input
              type="number"
              id="tukey-reply-threshold-input"
              min="1"
              value="1"
            />
          </div>
          <hr style="opacity: 0.2" />
          <div class="form-group">
            <label>Select Reply Mode:</label>
            <div
              class="theme-selector"
              style="flex-direction: column; align-items: flex-start; gap: 10px"
            >
              <label
                ><input
                  type="radio"
                  name="tukey-reply-mode"
                  value="all"
                  checked
                />
                All members reply</label
              >
              <label
                ><input type="radio" name="tukey-reply-mode" value="random" />
                Random member replies</label
              >
              <label
                ><input type="radio" name="tukey-reply-mode" value="specific" />
                Specific member replies</label
              >
            </div>
          </div>
          <div id="tukey-specific-reply-options" style="display: none">
            <div class="form-group">
              <label for="tukey-random-count-input"
                >Random reply count (when "Random" selected):</label
              >
              <input
                type="number"
                id="tukey-random-count-input"
                min="1"
                value="2"
              />
            </div>
            <div class="form-group">
              <label>Specific reply members (when "Specific" selected):</label>
              <div
                id="tukey-specific-member-picker-list"
                class="contact-picker-list"
                style="max-height: 150px"
              >
                <!-- ÊàêÂëòÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
              </div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="tukey-cancel-reply-settings-btn">
            Cancel
          </button>
          <button class="save" id="tukey-save-reply-settings-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- 3. Êñ∞Âª∫/ÁºñËæëËÆ∞Ë¥¶ËÆ∞ÂΩïÁöÑÂºπÁ™ó -->
    <div id="tukey-record-editor-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 90%">
        <div class="modal-header">
          <span id="tukey-record-editor-title">Add Record</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>Type</label>
            <div class="tukey-type-selector">
              <button class="type-btn active" data-type="expense">Expense</button>
              <button class="type-btn" data-type="income">Income</button>
            </div>
          </div>
          <div class="form-group">
            <label for="tukey-record-amount-input">Amount</label>
            <input
              type="number"
              id="tukey-record-amount-input"
              placeholder="0.00"
            />
          </div>
          <div class="form-group">
            <label for="tukey-record-category-select">Category</label>
            <select id="tukey-record-category-select">
              <!-- ÂàÜÁ±ªÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
            </select>
          </div>
          <div class="form-group">
            <label for="tukey-record-account-select">Account</label>
            <select id="tukey-record-account-select">
              <!-- Ë¥¶Êà∑Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
            </select>
          </div>
          <div class="form-group">
            <label for="tukey-record-time-input">Time</label>
            <input type="datetime-local" id="tukey-record-time-input" />
          </div>
          <div class="form-group">
            <label for="tukey-record-remarks-input">Remarks (optional)</label>
            <textarea id="tukey-record-remarks-input" rows="2"></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="tukey-cancel-record-editor-btn">
            Cancel
          </button>
          <button class="save" id="tukey-save-record-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- 4. Êü•Â≤ó - ÁîµËÑëÂ±èÂπï (Ê®°ÊÄÅÊ°Ü) -->
    <div id="kk-computer-modal" class="modal">
      <div
        class="modal-content"
        style="
          width: 95%;
          height: 90%;
          max-width: 500px;
          background-color: #e0e0e0;
          background-image: url(&quot;https://i.postimg.cc/k495F4W5/profile-banner.jpg&quot;);
          background-size: cover;
          background-position: center;
        "
      >
        <div
          class="modal-header"
          id="kk-computer-header"
          style="
            background-color: rgba(0, 0, 0, 0.3);
            color: white;
            text-shadow: 0 1px 2px black;
          "
        >
          <span>'s Computer</span>
          <span id="close-kk-computer-modal" style="cursor: pointer">√ó</span>
        </div>
        <div class="modal-body" id="kk-computer-desktop">
          <!-- ÁîµËÑëÊ°åÈù¢ÂõæÊ†áÂ∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
        </div>
      </div>
    </div>

    <!-- 6. Êü•Â≤ó - Êñá‰ª∂ÊµèËßàÂô®Ê®°ÊÄÅÊ°Ü -->
    <div id="kk-file-explorer-modal" class="modal" style="z-index: 1003">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Private Files</span>
        </div>
        <div class="modal-body" id="kk-file-list">
          <!-- Êñá‰ª∂ÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="close-file-explorer-modal-btn">
            Close
          </button>
        </div>
      </div>
    </div>
    <!-- ‚ÄúkkÊü•Â≤ó‚ÄùÊñá‰ª∂Êü•ÁúãÂô®ÂºπÁ™ó-->
    <div id="kk-file-viewer-modal" class="modal" style="z-index: 1004">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="kk-file-viewer-title"></span>
          <span
            id="close-kk-file-viewer-btn"
            style="cursor: pointer; font-size: 24px"
            >&times;</span
          >
        </div>
        <div
          class="modal-body"
          style="padding: 15px; background-color: #f0f2f5; overflow-y: auto"
        >
          <!-- ‰ΩøÁî® <pre> Ê†áÁ≠æÂèØ‰ª•Êõ¥Â•ΩÂú∞‰øùÁïôÂéüÊñáÁöÑÊç¢Ë°åÂíåÊ†ºÂºè -->
          <pre
            id="kk-file-viewer-content"
            style="
              white-space: pre-wrap;
              word-wrap: break-word;
              font-family: inherit;
              font-size: 14px;
            "
          ></pre>
        </div>
      </div>
    </div>
    <!-- SteamÊ∏∏ÊàèÂ∫ìÂºπÁ™ó ‚ñº‚ñº‚ñº -->
    <div id="kk-steam-modal" class="modal" style="z-index: 1003">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Steam Game Library</span>
          <div class="header-actions">
            <span
              class="action-btn"
              id="kk-generate-more-games-btn"
              title="Generate More Games"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
            </span>
          </div>
        </div>
        <div class="modal-body" id="kk-steam-games-list">
          <!-- Ê∏∏ÊàèÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="close-kk-steam-modal-btn">Close</button>
        </div>
      </div>
    </div>

    <!-- Âø´Êç∑ÂõûÂ§çÁÆ°ÁêÜÊ®°ÊÄÅÊ°Ü -->
    <div id="quick-reply-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>Quick Replies</span>
          <div class="header-actions">
            <!-- È°∂ÈÉ®Êìç‰ΩúÊåâÈíÆ -->
            <span
              class="action-btn"
              id="import-quick-reply-btn"
              title="Import"
              style="font-size: 14px"
              >Import</span
            >
            <span
              class="action-btn"
              id="export-quick-reply-btn"
              title="Export"
              style="font-size: 14px"
              >Export</span
            >
            <span
              class="action-btn"
              id="add-quick-reply-btn"
              style="font-size: 24px"
              >+</span
            >
          </div>
        </div>
        <div
          class="modal-body"
          id="quick-reply-list"
          style="padding: 0; overflow-y: auto"
        >
          <!-- ÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
        </div>
        <div class="modal-footer">
          <button class="save" id="close-quick-reply-btn" style="width: 100%">
            Close
          </button>
        </div>
      </div>
    </div>
    <!-- ÈöêËóèÁöÑÊñá‰ª∂ÈÄâÊã©Âô® -->
    <input type="file" id="import-quick-reply-input" accept=".json" hidden />

    <!-- Êó∂Èó¥ËΩ¥/Â≠òÊ°£ÁÆ°ÁêÜÊ®°ÊÄÅÊ°Ü -->
    <div id="branching-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Timeline Manager</span>
          <div class="header-actions">
            <button
              id="create-branch-btn"
              class="action-button"
              style="font-size: 14px"
            >
              + New Save
            </button>
          </div>
        </div>
        <div
          class="modal-body"
          style="padding: 0; display: flex; flex-direction: column"
        >
          <!-- È°∂ÈÉ®Êìç‰ΩúÂå∫ -->
          <div
            style="
              padding: 15px;
              border-bottom: 1px solid var(--border-color);
              text-align: center;
            "
          >
            <button
              id="restart-chat-btn"
              class="form-button"
              style="background-color: #ff9800; color: white; margin-bottom: 0"
            >
              üîÑ Start New Story (Clear Current)
            </button>
            <p
              style="
                font-size: 12px;
                color: #999;
                margin-top: 8px;
                margin-bottom: 0;
              "
            >
              Save current progress from the top-right before starting over
            </p>
          </div>

          <!-- Â≠òÊ°£ÂàóË°® -->
          <div
            id="branch-list"
            class="list-container"
            style="flex-grow: 1; background-color: var(--secondary-bg)"
          >
            <!-- Â≠òÊ°£È°πÂ∞ÜÁî±JSÁîüÊàê -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-branching-modal-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>
    <!-- KKÊü•Â≤óÁâ©ÂìÅËØ¶ÊÉÖ‰∏ìÁî®ÂºπÁ™ó -->
    <div id="kk-item-share-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 80%">
        <div class="modal-header">
          <span id="kk-item-share-title">Item Details</span>
        </div>
        <!-- ÂÜÖÂÆπÊòæÁ§∫Âå∫ -->
        <div class="modal-body" style="padding: 15px">
          <div
            id="kk-item-share-content"
            style="
              text-align: left;
              white-space: pre-wrap;
              background: #f9f9f9;
              padding: 15px;
              border-radius: 8px;
              font-size: 14px;
              line-height: 1.6;
              border: 1px solid #eee;
              color: #333;
            "
          ></div>
        </div>
        <!-- ÊåâÈíÆÂå∫ -->
        <div class="modal-footer" style="display: flex; gap: 10px">
          <button
            class="form-button-secondary"
            id="kk-item-share-close-btn"
            style="flex: 1; margin: 0"
          >
            Close
          </button>
          <button
            class="form-button"
            id="kk-item-share-confirm-btn"
            style="
              flex: 1;
              margin: 0;
              background-color: #ff9800;
              border-color: #ff9800;
            "
          >
            üì§ Share with Them
          </button>
        </div>
      </div>
    </div>
    <!-- Áï™ËåÑÈíüÊöÇÂÅú‰ºëÊÅØËÅäÂ§©ÂºπÁ™ó -->
    <div id="pomodoro-break-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>‚òï Break Time</span>
          <span
            id="close-pomodoro-break-btn"
            style="cursor: pointer; font-size: 20px"
            >√ó</span
          >
        </div>
        <!-- Ê∂àÊÅØÂàóË°® -->
        <div class="modal-body" id="pomodoro-break-messages">
          <div
            style="
              text-align: center;
              color: #999;
              font-size: 13px;
              margin-top: 10px;
            "
          >
            Tired? Come chat with me~
          </div>
        </div>
        <!-- ËæìÂÖ•Ê°ÜÂå∫Âüü -->
        <div class="chat-input-area">
          <div class="chat-input-main-row">
            <textarea
              id="pomodoro-break-input"
              rows="1"
              placeholder="Say something..."
            ></textarea>
            <button id="pomodoro-break-send-btn" class="action-button">
              Send
            </button>
          </div>
        </div>
      </div>
    </div>
    <!-- ÊÉÖ‰æ£Â§¥ÂÉèÂ∫ìÁÆ°ÁêÜÊ®°ÊÄÅÊ°Ü -->
    <div id="couple-avatar-library-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Couple Avatar Library</span>
          <button id="add-couple-avatar-btn" class="action-button">Add</button>
        </div>
        <div class="modal-body" style="padding: 15px; background: #f5f5f5">
          <div
            id="couple-avatar-library-list"
            style="display: flex; flex-direction: column; gap: 15px"
          >
            <!-- ÊÉÖÂ§¥ÂàóË°®Â∞ÜÁî±JSÂä®ÊÄÅÁîüÊàê -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-couple-avatar-library-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>
    <!-- ÊõøÊç¢ÂéüÊù•ÁöÑ id="add-couple-avatar-modal" -->
    <div id="add-couple-avatar-modal" class="modal" style="z-index: 1002">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>Add Couple Avatar</span>
        </div>
        <div class="modal-body">
          <div
            class="moe-grid-row"
            style="
              margin-bottom: 15px;
              display: flex;
              justify-content: space-around;
            "
          >
            <!-- ‰Ω†ÁöÑÂ§¥ÂÉè -->
            <div class="form-group" style="text-align: center; width: 45%">
              <label style="font-size: 12px; color: #666">My Avatar</label>
              <div
                class="avatar-upload"
                style="width: 80px; height: 80px; margin: 5px auto"
              >
                <img
                  id="new-couple-my-avatar-preview"
                  src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png"
                  style="
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                    border-radius: 12px;
                    border: 1px dashed #ccc;
                  "
                />
                <!-- Hidden file input -->
                <input
                  type="file"
                  id="new-couple-my-avatar-input"
                  accept="image/*"
                  hidden
                />
              </div>
              <!-- ËøôÈáåÁöÑÊåâÈíÆÁé∞Âú®Êúâ ID ‰∫Ü -->
              <button
                id="upload-couple-my-btn"
                class="moe-btn-mini"
                style="width: 100%"
              >
                Upload/URL
              </button>
            </div>

            <!-- ÂØπÊñπÂ§¥ÂÉè -->
            <div class="form-group" style="text-align: center; width: 45%">
              <label style="font-size: 12px; color: #666">Their Avatar</label>
              <div
                class="avatar-upload"
                style="width: 80px; height: 80px; margin: 5px auto"
              >
                <img
                  id="new-couple-char-avatar-preview"
                  src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png"
                  style="
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                    border-radius: 12px;
                    border: 1px dashed #ccc;
                  "
                />
                <!-- Hidden file input -->
                <input
                  type="file"
                  id="new-couple-char-avatar-input"
                  accept="image/*"
                  hidden
                />
              </div>
              <!-- ËøôÈáåÁöÑÊåâÈíÆÁé∞Âú®Êúâ ID ‰∫Ü -->
              <button
                id="upload-couple-char-btn"
                class="moe-btn-mini"
                style="width: 100%"
              >
                Upload/URL
              </button>
            </div>
          </div>

          <div class="form-group">
            <label>Couple Avatar Description (Important: AI will select avatar based on this)</label>
            <textarea
              id="new-couple-desc-input"
              rows="3"
              class="moe-input"
              placeholder="e.g., Sweet hug, I'm on the left holding you..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-add-couple-avatar-btn">Cancel</button>
          <button class="save" id="save-couple-avatar-btn">Save</button>
        </div>
      </div>
    </div>
    <!-- ‚òÖ‚òÖ‚òÖ Êñ∞Â¢ûÔºöË∑Ø‰∫∫Â§¥ÂÉèÂ∫ìÁÆ°ÁêÜÂºπÁ™ó ‚òÖ‚òÖ‚òÖ -->
    <div id="passerby-avatar-manager-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Passerby Avatar Library (<span id="passerby-count">0</span>)</span>
          <div class="header-actions">
            <button
              id="bulk-add-passerby-btn"
              class="action-button"
              style="font-size: 14px"
            >
              Bulk Add
            </button>
          </div>
        </div>
        <div
          class="modal-body"
          style="padding: 15px; background-color: #f5f5f5"
        >
          <div
            id="passerby-avatar-grid"
            style="
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
              gap: 10px;
            "
          >
            <!-- JSÂä®ÊÄÅÁîüÊàê -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-passerby-manager-btn"
            style="width: 100%"
          >
            Close
          </button>
        </div>
      </div>
    </div>
    <!-- ÈöêËóèÁöÑÊñá‰ª∂‰∏ä‰º†Êéß‰ª∂ -->
    <input
      type="file"
      id="passerby-upload-input"
      accept="image/*"
      multiple
      hidden
    />

    <div id="bug-report-modal" class="modal">
      <div class="modal-content" style="height: 70%; max-height: 600px">
        <!-- Â§¥ÈÉ® -->
        <div class="modal-header">
          <span>üè© Error Station</span>
          <button
            class="nurse-btn nurse-btn-clear"
            onclick="window.clearBugReport()"
          >
            üßπ Clear
          </button>
        </div>

        <!-- Content area -->
        <div
          class="modal-body"
          style="
            padding: 15px;
            background: #fff0f6;
            display: flex;
            flex-direction: column;
          "
        >
          <p style="font-size: 12px; color: #eb2f96; margin-bottom: 5px">
            üëá If you encounter issues, copy the red text below and send it to the developer:
          </p>
          <textarea id="error-log-viewer" readonly></textarea>
        </div>

        <!-- Â∫ïÈÉ®ÊåâÈíÆ -->
        <div
          class="modal-footer"
          style="background: #fff0f6; justify-content: space-between"
        >
          <button
            class="nurse-btn nurse-btn-close"
            onclick="window.closeBugStation()"
          >
            Close
          </button>
          <button
            class="nurse-btn nurse-btn-copy"
            onclick="window.copyBugReport()"
          >
            üìã Copy Error
          </button>
        </div>
      </div>
    </div>
    <!-- [Êñ∞] ËêåÁ≥ªÁï™ËåÑÈíüÈü≥‰πêÊéßÂà∂Èù¢Êùø -->
    <div id="pomodoro-music-modal" class="modal">
      <div
        class="modal-content moe-music-modal-content"
        style="height: 65%; width: 320px; padding: 0"
      >
        <!-- Â§¥ÈÉ® -->
        <div class="moe-music-header">
          <span>‚ú® Focus Melodies ‚ú®</span>
        </div>

        <div
          class="modal-body"
          style="
            padding: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
          "
        >
          <!-- ‰∏äÂçäÈÉ®ÂàÜÔºöÂî±ÁâáÊú∫Êí≠ÊîæÂô® -->
          <div class="pomo-player-container">
            <div class="pomo-disc-wrapper">
              <div id="pomo-disc-anim" class="pomo-disc">
                <!-- Â∞ÅÈù¢Âõæ -->
                <img
                  id="pomo-music-cover"
                  src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png"
                />
              </div>
            </div>

            <div class="pomo-track-info">
              <h3 id="pomo-music-title">Not Playing</h3>
              <p id="pomo-music-artist">Click play to start focusing</p>
            </div>

            <div class="pomo-controls-row">
              <button class="pomo-ctrl-btn" id="pomo-music-prev" title="Previous">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <polygon points="19 20 9 12 19 4 19 20"></polygon>
                  <line x1="5" y1="19" x2="5" y2="5"></line>
                </svg>
              </button>

              <button class="pomo-play-btn" id="pomo-music-play">
                <!-- Êí≠ÊîæÂõæÊ†á -->
                <svg
                  id="pomo-icon-play"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                  stroke="none"
                >
                  <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
                <!-- ÊöÇÂÅúÂõæÊ†á (ÈªòËÆ§ÈöêËóè) -->
                <svg
                  id="pomo-icon-pause"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                  stroke="none"
                  style="display: none"
                >
                  <rect x="6" y="4" width="4" height="16"></rect>
                  <rect x="14" y="4" width="4" height="16"></rect>
                </svg>
              </button>

              <button class="pomo-ctrl-btn" id="pomo-music-next" title="Next">
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <polygon points="5 4 15 12 5 20 5 4"></polygon>
                  <line x1="19" y1="5" x2="19" y2="19"></line>
                </svg>
              </button>
            </div>
          </div>

          <!-- ‰∏ãÂçäÈÉ®ÂàÜÔºöÊí≠ÊîæÂàóË°® -->
          <div id="pomo-music-list" class="pomo-playlist">
            <!-- JSÁîüÊàêÂàóË°®È°π -->
          </div>
        </div>

        <div class="modal-footer" style="border: none; padding: 10px 20px 20px">
          <button
            class="save"
            id="close-pomo-music-modal"
            style="
              width: 100%;
              border-radius: 20px;
              background: #e0e0e0;
              color: #666;
              border: none;
            "
          >
            Collapse Panel
          </button>
        </div>
      </div>
    </div>
    <!-- Âú® body ÁªìÊùüÊ†áÁ≠æÂâçÔºåÂÖ∂‰ªñ modal ÁöÑÊóÅËæπÊ∑ªÂä† -->

    <!-- Lovers Space-ÁÖßÁâáËØ¶ÊÉÖ‰∏éËØÑËÆ∫ÂºπÁ™ó (ËêåÁ≥ªÂçáÁ∫ßÁâà) -->
    <div id="ls-photo-detail-modal" class="modal">
      <div class="modal-content ls-photo-modal-content">
        <!-- 1. È°∂ÈÉ®Ê†áÈ¢òÊ†è -->
        <div class="ls-photo-modal-header">
          <span>‚ú® Sweet Moments ‚ú®</span>
          <span id="ls-photo-detail-close-btn" class="close-btn">√ó</span>
        </div>

        <!-- 2. ‰∏≠Èó¥ÊªöÂä®Âå∫Âüü -->
        <div class="ls-photo-modal-body">
          <!-- ÂõæÁâáÂ±ïÁ§∫Âå∫ (Á±ª‰ººÊãçÁ´ãÂæóÈ£éÊ†º) -->
          <div class="ls-polaroid-container">
            <div class="ls-photo-wrapper">
              <img id="ls-photo-detail-img" src="" alt="Photo" />
            </div>
            <div id="ls-photo-detail-desc" class="ls-photo-desc"></div>
            <div id="ls-photo-detail-meta" class="ls-photo-date"></div>
          </div>

          <!-- ËØÑËÆ∫Âå∫Ê†áÈ¢ò -->
          <div class="ls-comments-section-title">
            <span class="icon">üí¨</span> Whispers
          </div>

          <!-- ËØÑËÆ∫ÂàóË°® -->
          <div id="ls-photo-comments-list" class="ls-comments-list">
            <!-- JSÁîüÊàêËØÑËÆ∫ -->
          </div>
        </div>

        <!-- 3. Â∫ïÈÉ®ËæìÂÖ•Ê†è -->
        <div class="ls-photo-modal-footer">
          <input
            type="text"
            id="ls-photo-comment-input"
            placeholder="Write your thoughts( ‚Ä¢ÃÄ œâ ‚Ä¢ÃÅ )‚úß..."
          />
          <button id="ls-photo-comment-send-btn">Send</button>
        </div>
      </div>
    </div>
    <!-- Lovers Space - ÂàÜ‰∫´ËØ¶ÊÉÖ‰∏ìÁî®ÂºπÁ™ó (Ver 2.0 ËêåÁ≥ªÁâà) -->
    <div id="ls-share-detail-modal" class="modal">
      <div class="modal-content ls-share-card-container">
        <!-- 1. È°∂ÈÉ®Ë£ÖÈ•∞Âå∫ -->
        <div class="ls-share-header-bg"></div>

        <!-- 2. Â§¥ÂÉè‰∏éÂæΩÁ´† (Ê†∏ÂøÉËßÜËßâ) -->
        <div class="ls-share-avatar-wrapper">
          <img id="ls-share-char-avatar" src="" class="ls-share-avatar-img" />
          <!-- Á±ªÂûãÂæΩÁ´† -->
          <div class="ls-share-badge" id="ls-share-badge-icon">üé¨</div>
        </div>

        <!-- 3. ÂÜÖÂÆπÂå∫Âüü -->
        <div class="ls-share-content-body">
          <!-- Êé®ËçêËØ≠Ê∞îÊ≥° (ÂÉèÊòØÂú®ËØ¥ËØù) -->
          <div class="ls-share-speech-bubble">
            <div class="bubble-arrow"></div>
            <p id="ls-share-thoughts">Their thoughts will be shown here...</p>
          </div>

          <!-- ‰ΩúÂìÅ‰ø°ÊÅØÂç°Áâá -->
          <div class="ls-share-info-box">
            <h3 id="ls-share-detail-title">Work Title</h3>
            <span class="ls-share-pill" id="ls-share-type-text">Movie</span>
            <div class="ls-share-divider"></div>
            <div class="ls-share-summary-text" id="ls-share-summary">
              Work summary will be shown here...
            </div>
          </div>
        </div>

        <!-- 4. Â∫ïÈÉ®ÊåâÈíÆ -->
        <div class="ls-share-footer-action">
          <button id="ls-share-detail-close-btn">Got the Recommendation (o¬¥œâ`o)Ôæâ</button>
        </div>
      </div>
    </div>
    <!-- Ëé´ÂÖ∞Ëø™È£éÂ®ÉÂ®ÉÊú∫ÂÖÖÂÄºÂºπÁ™ó -->
    <div id="claw-machine-modal" class="modal">
      <!-- ÂÆπÂô®ËÉåÊôØÊîπ‰∏∫ÈÄèÊòéÔºåÂéªÈô§ÈªòËÆ§Èò¥ÂΩ± -->
      <div
        class="modal-content"
        style="
          background: transparent;
          box-shadow: none;
          border: none;
          padding: 0;
          width: 380px;
          height: 720px;
          overflow: visible;
          display: flex;
          justify-content: center;
        "
      >
        <div id="claw-machine-body" class="morandi-style">
          <!-- ‚òÖ‚òÖ‚òÖ È°∂ÈÉ®ÂäüËÉΩÊ†èÔºöÂ∑¶ÂÖ≥Èó≠„ÄÅ‰∏≠Ê†áÈ¢ò„ÄÅÂè≥Âà∑Êñ∞ ‚òÖ‚òÖ‚òÖ -->
          <div class="machine-header-bar">
            <!-- Â∑¶‰æßÔºöÂÖ≥Èó≠ÊåâÈíÆ (ÁßªÂà∞ËøôÈáåÔºåËøúÁ¶ªÂà∑Êñ∞) -->
            <div class="action-group left">
              <button
                id="close-claw-machine"
                class="icon-btn close-header-btn"
                title="Exit Claw Machine"
              >
                ‚úï
              </button>
            </div>

            <!-- ‰∏≠Èó¥ÔºöÊ†áÈ¢ò + ËÆæÁΩÆÊåâÈíÆ -->
            <div class="title-group">
              <div class="header-title">‚ú® LUCK BOX ‚ú®</div>
              <button
                id="claw-manage-btn"
                class="icon-btn settings-btn"
                title="Manage Doll Library"
              >
                ‚öôÔ∏è
              </button>
            </div>

            <!-- Âè≥‰æßÔºöÂà∑Êñ∞ÊåâÈíÆ -->
            <div class="action-group right">
              <button
                id="claw-restart-btn"
                class="icon-btn refresh-btn"
                title="Refresh / New Batch"
              >
                ‚Üª
              </button>
            </div>
          </div>

          <!-- Ê¶ÇÁéá‰ª™Ë°®Áõò -->
          <div class="prob-dashboard">
            <div class="pie-chart-wrapper">
              <div id="prob-pie-chart" class="pie-chart"></div>
              <div class="pie-hole"></div>
            </div>
            <div id="prob-legend" class="chart-legend"></div>
          </div>

          <!-- ÁéªÁíÉ‰ªì -->
          <div class="machine-window glass-effect">
            <div class="reflection-light"></div>
            <div id="machine-claw">
              <div class="claw-line"></div>
              <div class="claw-hand">
                <div class="claw-finger left"></div>
                <div class="claw-finger right"></div>
              </div>
            </div>
            <div id="doll-pool"></div>
            <div class="machine-chute">PUT</div>
          </div>

          <!-- ÊéßÂà∂Âè∞ -->
          <div class="machine-controls glass-effect">
            <div class="control-group">
              <div class="joystick-base">
                <div id="machine-joystick" class="joystick-stick">
                  <div class="joystick-ball"></div>
                </div>
              </div>
            </div>
            <div class="display-screen">
              <span class="label">COINS</span>
              <span id="claw-machine-balance" class="value">0.00</span>
            </div>
            <div class="btn-group">
              <button id="claw-grab-btn" class="pearl-btn">GO</button>
            </div>
          </div>

          <div class="machine-base"></div>

          <!-- Ê≥®ÊÑèÔºöÂéüÊù•ÁöÑÂ∫ïÈÉ®ÊÇ¨ÊµÆÂÖ≥Èó≠ÊåâÈíÆ‰ª£Á†ÅÂ∑≤ÁªèÂà†Èô§‰∫Ü -->
        </div>
      </div>
    </div>
    <div id="doll-manager-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>Manage Doll Collection</span>
          <div class="header-actions">
            <button id="add-doll-btn" class="action-button">Add</button>
            <button
              id="reset-dolls-btn"
              class="action-button"
              style="margin-right: 5px"
            >
              Reset Default
            </button>
          </div>
        </div>
        <div class="modal-body" style="background: #f5f5f5; padding: 15px">
          <div
            id="doll-manager-grid"
            style="
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
              gap: 10px;
            "
          >
            <!-- JSÂä®ÊÄÅÁîüÊàê -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="save" id="close-doll-manager-btn" style="width: 100%">
            Done
          </button>
        </div>
      </div>
    </div>
    <!-- ÈöêËóèÁöÑÊñá‰ª∂‰∏ä‰º†Êéß‰ª∂ -->
    <input
      type="file"
      id="doll-upload-input"
      accept="image/*"
      multiple
      hidden
    />

    <div id="inner-voice-modal" class="modal">
      <!-- ÂøÉÂ£∞‰∏ªÈù¢Êùø -->
      <div
        id="inner-voice-main-panel"
        class="modal-content"
        style="
          width: 90%;
          max-width: 340px;
          height: auto;
          max-height: 80%;
          background-color: #fffafb;
          border: 1px solid #ffe4e1;
        "
      >
        <div
          class="modal-header"
          style="
            border-bottom: 1px solid #ffe4e1;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
        >
          <span
            id="close-inner-voice-modal"
            style="cursor: pointer; font-size: 24px"
            >√ó</span
          >

          <div style="display: flex; align-items: center; gap: 15px">
            <span
              id="inner-voice-edit-btn"
              style="cursor: pointer"
              title="Edit Inner Voice Panel"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M12 20h9"></path>
                <path
                  d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"
                ></path>
              </svg>
            </span>
            <span
              id="change-inner-voice-bg-btn"
              style="cursor: pointer"
              title="Change Background"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
              </svg>
            </span>
            <span id="inner-voice-history-btn" style="cursor: pointer">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="22"
                height="22"
                viewBox="0 0 24 24"
                fill="none"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
              </svg>
            </span>
          </div>
        </div>

        <div class="modal-body" style="padding: 15px">
          <!-- Â§¥ÂÉèÂíåÂêçÂ≠ó‰ø°ÊÅØÁé∞Âú®ÊòØÁã¨Á´ãÁöÑ„ÄÅÂèØÂÆö‰ΩçÁöÑÂÖÉÁ¥† -->
          <!-- ËßíËâ≤Â§¥ÂÉè -->
          <div id="inner-voice-avatar-wrapper">
            <img id="inner-voice-avatar" src="" />
            <!-- ‰∏∫Â§¥ÂÉèÊ°ÜÈ¢ÑÁïôÁöÑ‰ΩçÁΩÆ -->
            <img id="inner-voice-avatar-frame" src="" style="display: none" />
          </div>

          <!-- ËßíËâ≤ÂêçÂ≠ó -->
          <div id="inner-voice-char-info">
            <div id="inner-voice-char-name"></div>
          </div>

          <!-- È¢ÜÂÖª‰∫∫‰ø°ÊÅØÔºàÂ§¥ÂÉè+ÂêçÂ≠óÔºâ-->
          <div id="inner-voice-adopter-info">
            <img id="inner-voice-adopter-avatar" src="" />
            <span id="inner-voice-adopter-name"></span>
          </div>

          <!-- ÂøÉÂ£∞ÂÜÖÂÆπ -->
          <div
            id="inner-voice-content-area"
            style="display: flex; flex-direction: column; gap: 15px"
          >
            <div>
              <strong style="color: #e57373">Outfit:</strong>
              <p
                id="inner-voice-clothing"
                style="margin: 5px 0 0 0; line-height: 1.6; color: #555"
              ></p>
            </div>
            <div>
              <strong style="color: #81c784">Behavior:</strong>
              <p
                id="inner-voice-behavior"
                style="margin: 5px 0 0 0; line-height: 1.6; color: #555"
              ></p>
            </div>
            <div>
              <strong style="color: #64b5f6">Thoughts:</strong>
              <p
                id="inner-voice-thoughts"
                style="margin: 5px 0 0 0; line-height: 1.6; color: #555"
              ></p>
            </div>
            <div>
              <strong style="color: #ba68c8">Naughty Thoughts:</strong>
              <p
                id="inner-voice-naughty-thoughts"
                style="margin: 5px 0 0 0; line-height: 1.6; color: #555"
              ></p>
            </div>
          </div>
        </div>
      </div>

      <!-- ÂéÜÂè≤ËÆ∞ÂΩïÈù¢Êùø (‰øùÊåÅ‰∏çÂèò) -->
      <div
        id="inner-voice-history-panel"
        class="modal-content"
        style="
          width: 90%;
          max-width: 340px;
          height: 80%;
          background-color: #f5f5f5;
          display: none;
          flex-direction: column;
        "
      >
        <div
          class="modal-header"
          style="border-bottom: 1px solid #ddd; justify-content: space-between"
        >
          <span
            id="back-from-history-btn"
            style="
              cursor: pointer;
              font-size: 16px;
              font-weight: 600;
              color: var(--accent-color);
            "
            >Back</span
          >
          <span>Voice History</span>
          <span
            id="clear-all-history-btn"
            style="cursor: pointer; font-size: 14px; color: #ff3b30"
            >Clear All</span
          >
        </div>
        <div
          class="modal-body"
          id="inner-voice-history-list"
          style="padding: 0"
        >
          <!-- ÂéÜÂè≤ËÆ∞ÂΩï‰ºöÁî±JSÂä®ÊÄÅÁîüÊàêÂú®ËøôÈáå -->
        </div>
      </div>
    </div>

    <script>
      (function () {
        window.errorLogs = [];

        // === Ê†∏ÂøÉÈÄªËæëÔºöÂè™ÊäìÈîôËØØ ===
        function captureError(source, msg) {
          const time = new Date().toLocaleTimeString();
          const logLine = `‚è∞ [${time}] ${source}\n‚ùå ${msg}\n----------------------------------\n`;
          window.errorLogs.push(logLine);

          // ÂÆûÊó∂Êõ¥Êñ∞UI
          const textarea = document.getElementById("error-log-viewer");
          if (textarea) {
            textarea.value = window.errorLogs.join("");
            textarea.scrollTop = textarea.scrollHeight;
          }
        }

        // 1. Âä´ÊåÅ console.error (‰ª£Á†ÅÈáå‰∏ªÂä®ÊâìÂç∞ÁöÑÁ∫¢Â≠ó)
        const originalError = console.error;
        console.error = function (...args) {
          // Â∞ÜÂØπË±°ËΩ¨‰∏∫Â≠óÁ¨¶‰∏≤ÔºåÈò≤Ê≠¢ÊòæÁ§∫ [object Object]
          const msg = args
            .map((a) => {
              try {
                return typeof a === "object" ? JSON.stringify(a) : String(a);
              } catch (e) {
                return String(a);
              }
            })
            .join(" ");
          captureError("Console Error", msg);
          originalError.apply(console, args);
        };

        // 2. ÊçïËé∑ËøêË°åÊó∂ÁöÑÂ¥©Ê∫É (ËØ≠Ê≥ïÈîôËØØ„ÄÅÊú™ÂÆö‰πâÂèòÈáèÁ≠â)
        window.addEventListener("error", function (event) {
          captureError(
            "System Crash",
            `${event.message}\nüìçLocation: ${event.filename}:${event.lineno}`,
          );
        });

        // 3. ÊçïËé∑ Promise Êä•Èîô (APIËØ∑Ê±ÇÂ§±Ë¥•Á≠â)
        window.addEventListener("unhandledrejection", function (event) {
          let reason = event.reason;
          if (typeof reason === "object")
            reason = reason.message || JSON.stringify(reason);
          captureError("Unhandled Promise", reason);
        });
      })();

      // ÊâìÂºÄÈù¢Êùø
      window.openBugStation = function () {
        const modal = document.getElementById("bug-report-modal");
        const textarea = document.getElementById("error-log-viewer");
        const emptyTip = "‚ú® Everything is working perfectly! No errors detected. (Yay!)";

        if (window.errorLogs.length === 0) {
          textarea.value = emptyTip;
          textarea.style.color = "#52c41a"; // ÁªøËâ≤
          textarea.style.textAlign = "center";
          textarea.style.paddingTop = "50px";
        } else {
          textarea.value = window.errorLogs.join("");
          textarea.style.color = "#ff4d4f"; // Á∫¢Ëâ≤
          textarea.style.textAlign = "left";
          textarea.style.paddingTop = "15px";
        }

        modal.classList.add("visible");
      };

      // Â§çÂà∂
      window.copyBugReport = function () {
        const textarea = document.getElementById("error-log-viewer");
        if (textarea.value.includes("Everything is normal")) {
          alert("There are no errors, no need to copy~");
          return;
        }
        textarea.select();
        document.execCommand("copy");
        alert("üíâ The error message has been copied! Please send it to the developer immediately for emergency assistance!");
      };

      // Ê∏ÖÁ©∫
      window.clearBugReport = function () {
        window.errorLogs = [];
        window.openBugStation(); // Âà∑Êñ∞ÊòæÁ§∫
      };

      // ÂÖ≥Èó≠
      window.closeBugStation = function () {
        document.getElementById("bug-report-modal").classList.remove("visible");
      };
      const TAROT_DECK = [
        {
          name: "The Fool",
          upright: "Beginnings, Innocence, Spontaneity, Free Spirit",
          reversed: "Naivety, Recklessness, Risk-Taking",
        },
        {
          name: "The Magician",
          upright: "Manifestation, Resourcefulness, Power, Inspired Action",
          reversed: "Manipulation, Poor Planning, Untapped Talents",
        },
        {
          name: "The High Priestess",
          upright: "Intuition, Divine Feminine, Subconscious, Mystery",
          reversed: "Secrets, Disconnection from Intuition, Repressed Feelings",
        },
        {
          name: "The Empress",
          upright: "Fertility, Femininity, Beauty, Nature, Abundance",
          reversed: "Creative Block, Dependence on Others",
        },
        {
          name: "The Emperor",
          upright: "Authority, Father Figure, Structure, Solid Control",
          reversed: "Control Issues, Rigidity, Lack of Discipline",
        },
        {
          name: "The Hierophant",
          upright: "Spiritual Wisdom, Religious Beliefs, Tradition, Institution",
          reversed: "Personal Beliefs, Challenging Tradition, Conformity",
        },
        {
          name: "The Lovers",
          upright: "Love, Harmony, Relationships, Value Alignment, Choices",
          reversed: "Disharmony, Imbalance, Misaligned Values",
        },
        {
          name: "The Chariot",
          upright: "Control, Willpower, Victory, Assertion, Determination",
          reversed: "Lack of Control and Direction, Aggression",
        },
        {
          name: "Strength",
          upright: "Strength, Courage, Compassion, Focus, Patience",
          reversed: "Inner Strength, Self-Doubt, Low Energy",
        },
        {
          name: "The Hermit",
          upright: "Soul Searching, Introspection, Solitude, Inner Guidance",
          reversed: "Isolation, Loneliness, Withdrawal",
        },
        {
          name: "Wheel of Fortune",
          upright: "Good Luck, Karma, Life Cycles, Turning Point",
          reversed: "Bad Luck, Resistance to Change, Breaking Cycles",
        },
        {
          name: "Justice",
          upright: "Justice, Fairness, Truth, Cause and Effect, Law",
          reversed: "Unfairness, Lack of Accountability, Dishonesty",
        },
        {
          name: "The Hanged Man",
          upright: "Pause, Restrictions, Letting Go, Sacrifice, New Perspective",
          reversed: "Delays, Meaningless Sacrifice, Stagnation",
        },
        {
          name: "Death",
          upright: "Endings, Change, Transformation, Transition",
          reversed: "Resistance to Change, Inability to Move On, Stagnation",
        },
        {
          name: "Temperance",
          upright: "Balance, Moderation, Patience, Purpose",
          reversed: "Imbalance, Excess, Realignment",
        },
        {
          name: "The Devil",
          upright: "Bondage, Addiction, Negativity, Materialism",
          reversed: "Breaking Free, Release, Regaining Control",
        },
        {
          name: "The Tower",
          upright: "Sudden Change, Upheaval, Chaos, Revelation, Awakening",
          reversed: "Avoiding Disaster, Fear of Change",
        },
        {
          name: "The Star",
          upright: "Hope, Faith, Purpose, Renewal, Spirituality",
          reversed: "Lack of Faith, Despair, Lack of Focus",
        },
        {
          name: "The Moon",
          upright: "Illusion, Fear, Anxiety, Subconscious, Intuition",
          reversed: "Releasing Fear, Repressed Emotions, Inner Confusion",
        },
        {
          name: "The Sun",
          upright: "Positivity, Fun, Warmth, Success, Vitality",
          reversed: "Inner Child Issues, Over-Optimism, Sadness",
        },
        {
          name: "Judgement",
          upright: "Judgement, Rebirth, Inner Calling, Absolution",
          reversed: "Self-Doubt, Ignoring the Call",
        },
        {
          name: "The World",
          upright: "Completion, Integration, Accomplishment, Travel",
          reversed: "Seeking Personal Closure, Shortcuts, Delays",
        },
        {
          name: "Ace of Wands",
          upright: "Inspiration, New Opportunities, Growth, Potential",
          reversed: "Lack of Motivation, Missed Opportunities, Delays",
        },
        {
          name: "Two of Wands",
          upright: "Future Planning, Progress, Decisions, Leaving Home",
          reversed: "Fear of the Unknown, Lack of Planning, Fear of Change",
        },
        {
          name: "Three of Wands",
          upright: "Expansion, Growth, Foresight, Overseas Opportunities",
          reversed: "Plans Falling Through, Lack of Vision, Delays",
        },
        {
          name: "Four of Wands",
          upright: "Celebration, Harmony, Marriage, Homecoming, Stability",
          reversed: "Disharmony, Transition, Lack of Support",
        },
        {
          name: "Five of Wands",
          upright: "Conflict, Disagreement, Competition, Tension",
          reversed: "Avoiding Conflict, Respecting Differences",
        },
        {
          name: "Six of Wands",
          upright: "Success, Public Recognition, Victory, Progress",
          reversed: "Arrogance, Lack of Recognition, Punishment",
        },
        {
          name: "Seven of Wands",
          upright: "Challenge, Competition, Protection, Perseverance",
          reversed: "Giving Up, Feeling Overwhelmed, Overprotective",
        },
        {
          name: "Eight of Wands",
          upright: "Speed, Action, Air Travel, Movement, Quick Decisions",
          reversed: "Delays, Frustration, Resisting Change",
        },
        {
          name: "Nine of Wands",
          upright: "Resilience, Courage, Persistence, Boundaries",
          reversed: "Inner Struggle, Paranoia, Defensiveness",
        },
        {
          name: "Ten of Wands",
          upright: "Burden, Responsibility, Hard Work, Stress",
          reversed: "Releasing Burdens, Delegation, Letting Go",
        },
        {
          name: "Page of Wands",
          upright: "Inspiration, Ideas, Discovery, Free Spirit",
          reversed: "Unrealistic Ideas, Delays, Creative Blocks",
        },
        {
          name: "Knight of Wands",
          upright: "Energy, Passion, Desire, Action, Adventure",
          reversed: "Anger, Impulsiveness, Recklessness",
        },
        {
          name: "Queen of Wands",
          upright: "Courage, Confidence, Independence, Social Butterfly",
          reversed: "Self-Respect, Confidence, Introversion",
        },
        {
          name: "King of Wands",
          upright: "Natural Leader, Vision, Entrepreneur, Honor",
          reversed: "Impulsive, Hasty, Ruthless",
        },
        {
          name: "Ace of Cups",
          upright: "Love, New Relationship, Compassion, Creativity",
          reversed: "Self-Love, Intuition, Repressed Emotions",
        },
        {
          name: "Two of Cups",
          upright: "Unified Love, Partnership, Mutual Attraction",
          reversed: "Breakup, Disharmony, Distrust",
        },
        {
          name: "Three of Cups",
          upright: "Celebration, Friendship, Creativity, Collaboration",
          reversed: "Independence, Solitude, 'Third Party'",
        },
        {
          name: "Four of Cups",
          upright: "Contemplation, Disconnection, Apathy, Re-Evaluation",
          reversed: "Withdrawal, Isolation, Missed Opportunities",
        },
        {
          name: "Five of Cups",
          upright: "Regret, Failure, Disappointment, Pessimism",
          reversed: "Personal Setback, Self-Forgiveness, Moving On",
        },
        {
          name: "Six of Cups",
          upright: "Revisiting the Past, Childhood Memories, Innocence, Joy",
          reversed: "Living in the Past, Unwilling to Forgive, Lack of Playfulness",
        },
        {
          name: "Seven of Cups",
          upright: "Opportunities, Choices, Fantasy, Illusion",
          reversed: "Clarity, Fantasy, Too Many Choices",
        },
        {
          name: "Eight of Cups",
          upright: "Disappointment, Walking Away, Withdrawal, Escapism",
          reversed: "Trying Something New, Apathy, Fear of Change",
        },
        {
          name: "Nine of Cups",
          upright: "Contentment, Satisfaction, Gratitude, Wish Fulfillment",
          reversed: "Dissatisfaction, Materialism, Discontent",
        },
        {
          name: "Ten of Cups",
          upright: "Divine Love, Harmonious Relationships, Family, Alignment",
          reversed: "Disconnection, Misalignment, Strained Relationships",
        },
        {
          name: "Page of Cups",
          upright: "Creative Opportunity, Intuitive Message, Curiosity",
          reversed: "New Ideas, Doubt, Creative Blocks",
        },
        {
          name: "Knight of Cups",
          upright: "Creativity, Romance, Charm, Imagination",
          reversed: "Unrealistic, Jealousy, Moodiness",
        },
        {
          name: "Queen of Cups",
          upright: "Compassionate, Caring, Intuitive, Calm",
          reversed: "Inner Feelings, Self-Care, Self-Love, Empathy",
        },
        {
          name: "King of Cups",
          upright: "Emotional Balance, Compassion, Diplomacy",
          reversed: "Self-Compassion, Inner Truth, Emotional Instability",
        },
        {
          name: "Ace of Swords",
          upright: "Breakthrough, New Ideas, Mental Clarity, Success",
          reversed: "Inner Clarity, Rethinking an Idea, Confusion",
        },
        {
          name: "Two of Swords",
          upright: "Difficult Choice, Unknown Consequences, Stalemate",
          reversed: "Indecision, Confusion, Information Overload",
        },
        {
          name: "Three of Swords",
          upright: "Heartbreak, Sorrow, Rejection, Separation",
          reversed: "Releasing Pain, Optimism, Forgiveness",
        },
        {
          name: "Four of Swords",
          upright: "Rest, Relaxation, Meditation, Recovery",
          reversed: "Exhaustion, Burnout, Stagnation",
        },
        {
          name: "Five of Swords",
          upright: "Conflict, Disagreement, Competition, Defeat",
          reversed: "Reconciliation, Forgiving the Past",
        },
        {
          name: "Six of Swords",
          upright: "Transition, Change, Rite of Passage, Letting Go",
          reversed: "Personal Transition, Resistance to Change, Unfinished Business",
        },
        {
          name: "Seven of Swords",
          upright: "Betrayal, Deception, Shortcuts, Sneakiness",
          reversed: "Imposter Syndrome, Deception, Secrecy",
        },
        {
          name: "Eight of Swords",
          upright: "Negative Thoughts, Self-Imposed Restrictions, Imprisonment",
          reversed: "Self-Limiting Beliefs, Release, Open-Mindedness",
        },
        {
          name: "Nine of Swords",
          upright: "Anxiety, Worry, Fear, Depression, Nightmares",
          reversed: "Inner Turmoil, Deep Fear, Releasing Worry",
        },
        {
          name: "Ten of Swords",
          upright: "Painful Ending, Deep Betrayal, Loss",
          reversed: "Recovery, Resisting an Ending, Inability to Let Go",
        },
        {
          name: "Page of Swords",
          upright: "New Ideas, Curiosity, Pursuit of Truth",
          reversed: "Self-Talk, Jack of All Trades, Hasty",
        },
        {
          name: "Knight of Swords",
          upright: "Ambitious, Action-Oriented, Pursuing Goals",
          reversed: "Restless, Impulsive, Burnout",
        },
        {
          name: "Queen of Swords",
          upright: "Independent, Unbiased Judgment, Clear Boundaries",
          reversed: "Overly Emotional, Easily Influenced, Harsh",
        },
        {
          name: "King of Swords",
          upright: "Mental Clarity, Wisdom, Authority, Truth",
          reversed: "Quiet Strength, Inner Truth, Abuse of Power",
        },
        {
          name: "Ace of Pentacles",
          upright: "Manifestation, New Financial Opportunity, Prosperity",
          reversed: "Lost Opportunity, Lack of Planning and Foresight",
        },
        {
          name: "Two of Pentacles",
          upright: "Multitasking, Adaptability, Time Management",
          reversed: "Reprioritizing, Overcommitment",
        },
        {
          name: "Three of Pentacles",
          upright: "Teamwork, Collaboration, Learning, Implementation",
          reversed: "Disharmony, Team Conflict, Poor Planning",
        },
        {
          name: "Four of Pentacles",
          upright: "Saving, Security, Conservatism, Scarcity Mindset",
          reversed: "Overspending, Greed, Self-Protection",
        },
        {
          name: "Five of Pentacles",
          upright: "Financial Loss, Poverty, Isolation, Worry",
          reversed: "Recovering from Financial Loss, Spiritual Poverty",
        },
        {
          name: "Six of Pentacles",
          upright: "Giving, Receiving, Sharing Wealth, Generosity",
          reversed: "Selfishness, Debt, One-Sided Giving",
        },
        {
          name: "Seven of Pentacles",
          upright: "Long-Term Vision, Sustainable Results, Investment",
          reversed: "Lack of Long-Term Vision, Limited Success",
        },
        {
          name: "Eight of Pentacles",
          upright: "Apprenticeship, Repetition, Mastery, Skill Development",
          reversed: "Self-Development, Perfectionism, Misalignment",
        },
        {
          name: "Nine of Pentacles",
          upright: "Abundance, Luxury, Self-Sufficiency, Financial Independence",
          reversed: "Self-Worth, Overinvestment in Work",
        },
        {
          name: "Ten of Pentacles",
          upright: "Wealth, Financial Security, Family, Legacy",
          reversed: "Financial Failure, Burden, Loss of Legacy",
        },
        {
          name: "Page of Pentacles",
          upright: "Manifestation, Financial Opportunity, Skill Development",
          reversed: "Lack of Progress, Procrastination, Learning New Skills",
        },
        {
          name: "Knight of Pentacles",
          upright: "Hard Work, Productivity, Routine, Conservative",
          reversed: "Self-Discipline, Boredom, Feeling 'Stuck'",
        },
        {
          name: "Queen of Pentacles",
          upright: "Nurturing, Practical, Financial Security, Work-Life Balance",
          reversed: "Financial Independence, Self-Care, Work-Life Imbalance",
        },
        {
          name: "King of Pentacles",
          upright: "Wealth, Business, Leadership, Security, Discipline",
          reversed: "Financial Incompetence, Outdated, Stubborn",
        },
      ];


const BUILT_IN_SCRIPTS = [
  {
    id: "built_in_1",
    name: "Office Mystery",
    storyBackground:
      "Late at night, the top internet company 'Bit Infinity' is still brightly lit. The notoriously harsh project director, Wang Qiang, is found dead at his desk from drug poisoning. Police initially identify five employees who were still in the office that night as suspects. Each of them seems to have been closely connected to the victim. In this steel forest where ambition and code intertwine, whose secrets will remain buried forever, and whose hands are stained with guilt?",

    roles: [
      {
        name: "Li Si",
        description:
          "A newly promoted genius programmer. Highly skilled, but introverted and not good at expressing himself.",
        storyline: `Today is the final deadline for the project launch. Director Wang forced me to work overtime until late at night.
**8:00 PM**: Director Wang called me into his office and berated me over a trivial bug. He even tore up my performance review, saying I was ‚Äúunqualified.‚Äù I was shaking with anger and had a huge argument with him before slamming the door and leaving.
**8:30 PM**: Back at my desk, I grew angrier the more I thought about it. I drafted a resignation letter but didn‚Äôt send it.
**9:00 PM**: I went to the pantry to get some water. Passing by the director‚Äôs office, I saw HR manager Chen Jing carrying a cup of coffee inside. I didn‚Äôt think much of it at the time.
**9:30 PM**: I got hungry and ordered takeout. While waiting, I saw designer Sun Wei sneak out from the direction of the pantry, clutching something in his hand.
**10:00 PM**: My food arrived. After eating, I continued fixing bugs until the scream announcing the discovery of the body interrupted me.`,
        tasks:
          "1. Hide the fact that you had a fierce argument with Director Wang and that he labeled you as 'unqualified.'\n2. Your primary goal is self-preservation. Find evidence that someone else entered the office after you left.\n3. You suspect Chen Jing and Sun Wei. Try to uncover their suspicious behavior.",
        isKiller: false,
      },

      {
        name: "Zhao Na",
        description:
          "Marketing department manager. Highly capable and ambitious ‚Äî a classic career-driven woman.",
        storyline: `I didn‚Äôt need to work overtime tonight, but I stayed voluntarily to prepare an important bidding proposal.
**7:30 PM**: While organizing documents in my office, I accidentally discovered evidence that Wang Qiang had embezzled project funds. I drafted an anonymous report email to headquarters.
**8:10 PM**: I heard intense arguing next door ‚Äî it sounded like Li Si arguing with Wang Qiang.
**8:45 PM**: I needed his signature on some documents. When I entered his office, he was drinking coffee and looked pale. He signed impatiently. I noticed an unlabeled medicine bottle on his desk.
**9:15 PM**: Back in my office, I hesitated about sending the report. Worried about the company‚Äôs reputation, I ultimately didn‚Äôt send it.
**10:15 PM**: As I was leaving work, I passed the director‚Äôs office. The door was slightly ajar and it was quiet inside. I didn‚Äôt go in and left the company.`,
        tasks:
          "1. Your top priority is to find the real killer, clear your name, and prevent the company scandal from being exposed.\n2. Hide the fact that you discovered his embezzlement and drafted a report.\n3. The medicine bottle on his desk is an important clue ‚Äî guide others to notice it.",
        isKiller: false,
      },

      {
        name: "Sun Wei",
        description:
          "Senior UI designer and Wang Qiang‚Äôs long-time subordinate. Appears respectful on the surface.",
        storyline: `I hated Wang Qiang! He withheld the team‚Äôs bonus and pocketed most of it himself.
**9:00 PM**: I stayed late under the excuse of overtime, actually planning to sneak into his office to find evidence.
**9:20 PM**: I slipped into his office. He was slumped over the desk, apparently asleep, next to a barely touched cup of coffee. I searched his drawer and found a bonus distribution sheet proving he embezzled 70% of the funds. I took photos.
**9:30 PM**: As I left, I ran into Li Si near the pantry and quickly hid my phone.
**After 10:00 PM**: I stayed at my desk, planning how to use this evidence to ruin him.`,
        tasks:
          "1. Hide the fact that you snuck into the director‚Äôs office and secretly photographed evidence.\n2. His death benefits you ‚Äî redirect suspicion toward others, especially Li Si.\n3. Protect the photo evidence in your phone at all costs.",
        isKiller: false,
      },

      {
        name: "Chen Jing",
        description:
          "HR manager. Appears gentle and good at handling relationships.",
        storyline: `I was secretly involved with Wang Qiang. He promised to divorce his wife and marry me. Recently, I found out he planned to abandon me for a wealthy woman. Worse, he kept intimate photos and videos of us on his phone.
**8:45 PM**: Knowing he drinks coffee nightly, I prepared strong sleeping pills and crushed them into powder.
**9:00 PM**: I made him coffee and poured all the sleeping pills into it. He drank a large sip without suspicion.
**9:10 PM**: I left and watched from outside until he collapsed.
**9:20 PM**: I returned to delete the photos from his phone but couldn‚Äôt find it. Then I realized he had stopped breathing. In panic, I accidentally knocked a diamond necklace off his desk into my handbag.
**9:40 PM**: I fled back to my desk and pretended to work.`,
        tasks: `„ÄêCore Mission„Äë
Hide the fact that you accidentally poisoned Wang Qiang with sleeping pills. You are the only true killer.

„ÄêAction Guide„Äë
1. Frame others using what you saw and heard.
2. The necklace in your bag is a ticking time bomb ‚Äî explain it or dispose of it.
3. Mislead everyone into voting for the wrong suspect.`,
        isKiller: true,
      },

      {
        name: "Zhou Yi",
        description:
          "Night security guard. Honest-looking but observant.",
        storyline: `As the guard, I patrol the building.
**8:10 PM**: I heard arguing from the director‚Äôs office.
**9:00 PM**: I saw Chen Jing enter with coffee.
**9:20 PM**: I saw Sun Wei sneak inside.
**9:40 PM**: I saw Chen Jing exit looking pale.
**10:30 PM**: During routine inspection, I found the body and called the police.`,
        tasks:
          "1. Provide honest and accurate timeline testimony.\n2. You find Chen Jing suspicious ‚Äî share your doubts.\n3. Ensure the truth comes out without damaging the company further.",
        isKiller: false,
      },
    ],

    truth:
      "The killer is Chen Jing. She poisoned Wang Qiang‚Äôs coffee with excessive sleeping pills intending only to knock him out and delete incriminating photos. The overdose accidentally caused his death. In panic, she unknowingly took the necklace meant for the wealthy woman.",
  },
        // --- „ÄêÂÖ®Êñ∞ÂâßÊú¨1ÔºöÊ∑±Êµ∑ÈÅó‰π¶„Äë ---
       {
  id: "built_in_2",
  name: "Deep Sea Testament",
  storyBackground:
    "On the isolated Echo Island, renowned marine biologist Dr. Li is found dead inside her locked study. A printed suicide note lies on the desk. Cause of death: cyanide poisoning. A sudden storm cuts off all communication with the outside world, trapping four remaining people on the island: her prized student, a long-time rival, a quiet technician, and an uninvited journalist.",

  roles: [
    {
      name: "Gao Yuan",
      description: "Dr. Li‚Äôs brilliant but ambitious student.",
      storyline: `I always believed my mentor stole my research results.
**7:00 PM**: We argued in the lab. She admitted referencing my data but refused to credit me publicly.
**8:00 PM**: Back in my room, I remotely deleted key experimental data that benefited her publication.
**9:00 PM**: At the cafeteria, I saw technician Chen Mo adjusting surveillance equipment.
**9:45 PM**: I saw journalist Zhang Lai pacing outside Dr. Li‚Äôs study.`,
      tasks:
        "1. Hide your academic conflict and data deletion.\n2. Clear your suspicion.\n3. Redirect suspicion toward others.",
      isKiller: false,
    },

    {
      name: "Lin Xue",
      description: "A rival marine scientist competing for the same research grant.",
      storyline: `We were competing for an international grant.
**7:30 PM**: I asked her to share data. She refused.
**8:30 PM**: I heard a strange electrical flicker ‚Äî brief power outage.
**9:10 PM**: I saw Gao Yuan emerging nervously from the server room.
**10:00 PM**: Passing the study, I smelled faint almond scent (cyanide), but assumed it was lab chemicals.`,
      tasks:
        "1. Her death benefits your grant application ‚Äî clear suspicion.\n2. Hide that she rejected you.\n3. Reveal the almond smell clue.",
      isKiller: false,
    },

    {
      name: "Chen Mo",
      description: "Station technician, introverted and secretly in love with Dr. Li.",
      storyline: `I control all equipment and surveillance.
**8:30 PM**: Gao Yuan asked me to cause a one-minute blackout. I agreed reluctantly.
**9:00 PM**: I saw Dr. Li lock herself in the study, looking sad.
**9:20 PM**: I caught Zhang Lai trying to pick the study lock.
**10:30 PM**: I used a spare key and found her body.`,
      tasks:
        "1. Hide your role in the blackout.\n2. Explain why you have a spare key.\n3. You suspect Zhang Lai.",
      isKiller: false,
    },

    {
      name: "Zhang Lai",
      description: "Investigative journalist secretly on the island.",
      storyline: `I came to investigate academic fraud.
**9:00 PM**: I photographed her through the window writing something important.
**9:20 PM**: I tried to unlock the door but was caught.
**9:50 PM**: Zooming in on photos, I saw she was writing a suicide note. I also captured a small remote device on her desk.`,
      tasks:
        "1. Hide your journalist identity.\n2. Use your photos carefully.\n3. Find the killer fast ‚Äî you're the main suspect.",
      isKiller: true,
    },
  ],

  truth:
    "The killer is Zhang Lai. He installed a remote poison gas device in the study‚Äôs ventilation system to incapacitate Dr. Li if she refused to cooperate. Mistaking her suicide note as his opportunity, he activated the device, releasing excessive cyanide gas and accidentally killing her.",
},
        // --- „ÄêÂÖ®Êñ∞ÂâßÊú¨2ÔºöÂè§Â†°È≠ÖÂΩ±„Äë ---
        {
  id: "built_in_3",
  name: "Phantom of the Castle",
  storyBackground:
    "In a remote fog-covered castle, a wealthy and eccentric Count is found dead inside his locked study, a vintage letter opener embedded in his chest. A violent storm destroys the only bridge connecting the castle to the outside world, trapping everyone inside: the Count‚Äôs young wife, his resentful nephew, his debt-ridden personal doctor, and a mysterious medium invited for a s√©ance.",

  roles: [
    {
      name: "Anna",
      description:
        "The Count‚Äôs young and beautiful wife, rumored to have married him for his fortune.",
      storyline: `I can‚Äôt stand this loveless marriage anymore. I‚Äôm in love with Edward, and we planned to elope.
**8:00 PM**: Edward and I secretly met in the garden to finalize our escape plan. I told him about a hidden passage leading to the study.
**9:00 PM**: The Count summoned me to his study and threatened to remove me from his will.
**9:30 PM**: I returned to my room to pack my jewelry. I heard a brief scream downstairs.
**10:00 PM**: I used the hidden passage to enter the study, intending to steal the will. But when I stepped out from behind the fireplace, I found him already dead in a pool of blood. I panicked and left silently.`,
      tasks:
        "1. Hide your affair and elopement plan.\n2. Hide the fact that you entered the crime scene via the secret passage.\n3. Clear your suspicion as quickly as possible.",
      isKiller: false,
    },

    {
      name: "Edward",
      description:
        "The Count‚Äôs nephew and legal heir, rebellious and constantly at odds with him.",
      storyline: `I desperately needed money, but the old man refused to help.
**8:00 PM**: Anna told me about the hidden passage to the study.
**8:30 PM**: I saw Dr. Martin entering the study in a hurry.
**9:10 PM**: I planned to use the hidden passage, but I heard strange noises inside and backed off.
**9:40 PM**: I met Madame Roland in the corridor. She warned me that bloodshed would occur tonight.`,
      tasks:
        "1. Hide your theft intentions and knowledge of the hidden passage.\n2. The Count‚Äôs death benefits you most ‚Äî redirect suspicion elsewhere.\n3. Find evidence that supports your innocence.",
      isKiller: false,
    },

    {
      name: "Dr. Martin",
      description:
        "The Count‚Äôs personal physician, highly skilled but buried in gambling debt.",
      storyline: `I owed the Count a huge sum of money. He held my medical license as collateral.
**8:30 PM**: I begged him for more time; he humiliated me.
**9:00 PM**: I prepared strong sedatives, intending to drug him and steal back my license.
**9:20 PM**: I overheard Anna arguing with him.
**After 9:40 PM**: I saw no one else enter the study, but I was too afraid to act.`,
      tasks:
        "1. Hide your debt and the Count‚Äôs threats.\n2. Hide your preparation of sedatives.\n3. Prove someone else had the opportunity to commit the crime.",
      isKiller: false,
    },

    {
      name: "Madame Roland",
      description:
        "A renowned medium secretly exposed as a fraud, invited to conduct a s√©ance.",
      storyline: `I am a fraud. The Count discovered my secret and blackmailed me.
**9:10 PM**: He threatened to expose me if the s√©ance failed.
**9:30 PM**: In panic and rage, I grabbed the letter opener from the desk and stabbed him from behind.
**9:35 PM**: I locked the study door from the inside and escaped through the hidden passage behind the bookshelf. A piece of my lace sleeve tore off in the tunnel.
**9:40 PM**: I encountered Edward and warned him about bloodshed to mask my panic.`,
      tasks:
        "1. You are the killer. Hide everything and frame others.\n2. Use superstition to confuse and mislead.\n3. Take advantage of others‚Äô motives to redirect suspicion.",
      isKiller: true,
    },
  ],

  clues: [
    {
      owner: "Anna",
      description:
        "A one-way train ticket to Paris for tomorrow morning hidden inside your jewelry box.",
    },
    {
      owner: "Edward",
      description:
        "A pawn receipt in your pocket for an antique pocket watch belonging to the Count‚Äôs family.",
    },
    {
      owner: "Dr. Martin",
      description:
        "A nearly full bottle of powerful sedatives in your medical kit, along with a note demanding repayment of ¬£100,000 within one week.",
    },
    {
      owner: "Madame Roland",
      description:
        "A noticeable tear in the lace sleeve of your gown, as if it had been snagged on something.",
      isKey: true,
    },
    {
      owner: "Public",
      description:
        "A hidden button behind the fireplace that rotates a bookshelf, revealing a secret passage leading to the upper hallway.",
    },
    {
      owner: "Public",
      description:
        "A small piece of black lace fabric found on the floor inside the secret passage.",
    },
    {
      owner: "Public",
      description:
        "On the Count‚Äôs desk lies an open book titled 'Mediums and Fraud,' with Madame Roland‚Äôs name circled in red ink.",
    },
  ],

  truth:
    "The killer is Madame Roland. After being blackmailed by the Count, she stabbed him in fear and rage. She locked the study door from the inside and escaped through the hidden passage, staging a locked-room murder. However, a torn piece of her lace sleeve was left behind in the passage, becoming the crucial evidence that exposed her.",
}

      ];

      /**
       * „ÄêÂÖ®Êñ∞„Äë‰ªé‰∏Ä‰∏™Â∑≤È¢ÜÂÆåÁöÑÁ∫¢ÂåÖ‰∏≠ÊâæÂá∫‚ÄúÊâãÊ∞îÁéã‚Äù
       * @param {object} packet - Â∑≤È¢ÜÂÆåÁöÑÁ∫¢ÂåÖÊ∂àÊÅØÂØπË±°
       * @returns {object|null} - ËøîÂõûÊâãÊ∞îÁéãÁöÑ‰ø°ÊÅØ { name, amount }ÔºåÊàñ null
       */
      function findLuckyKing(packet) {
        const claimedBy = packet.claimedBy || {};
        const claimedEntries = Object.entries(claimedBy);

        // Â¶ÇÊûúÁ∫¢ÂåÖÊòØ‚ÄúÊãºÊâãÊ∞î‚ÄùÁ±ªÂûãÔºåÂπ∂‰∏îÊúâË∂ÖËøá1‰∏™‰∫∫È¢ÜÂèñ
        if (packet.packetType === "lucky" && claimedEntries.length > 1) {
          let luckyKing = { name: "", amount: -1 };
          claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
              luckyKing = { name, amount };
            }
          });
          return luckyKing;
        }
        return null; // Â¶ÇÊûú‰∏çÊª°Ë∂≥Êù°‰ª∂ÔºåÂàôÊ≤°ÊúâÊâãÊ∞îÁéã
      }

      // ‚ñ≤‚ñ≤‚ñ≤ Êñ∞‰ª£Á†ÅÁ≤òË¥¥ÁªìÊùü ‚ñ≤‚ñ≤‚ñ≤
      window.state = {
        chats: {},
        activeChatId: null,
        globalSettings: {},
        apiConfig: {},
        userStickers: [],
        worldBooks: [],
        personaPresets: [],
        qzoneSettings: {},
        activeAlbumId: null,
      };

      const defaultAvatar = "https://i.postimg.cc/PxZrFFFL/o-o-1.jpg";
      const defaultMyGroupAvatar = "https://i.postimg.cc/cLPP10Vm/4.jpg";
      const defaultGroupMemberAvatar = "https://i.postimg.cc/VkQfgzGJ/1.jpg";
      const defaultGroupAvatar =
        "https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg";

      const GEMINI_API_URL =
        "https://generativelanguage.googleapis.com/v1beta/models";
      // geminiÂ¶ÇÊûúÊòØÂ§ö‰∏™ÂØÜÈí•, ÈÇ£‰πàÈöèÊú∫Ëé∑Âèñ‰∏Ä‰∏™
      function getRandomValue(str) {
        // Ê£ÄÊü•Â≠óÁ¨¶‰∏≤ÊòØÂê¶ÂåÖÂê´ÈÄóÂè∑
        if (str.includes(",")) {
          // Áî®ÈÄóÂè∑ÂàÜÈöîÂ≠óÁ¨¶‰∏≤Âπ∂ÁßªÈô§Â§ö‰ΩôÁ©∫Ê†º
          const arr = str.split(",").map((item) => item.trim());
          // ÁîüÊàêÈöèÊú∫Á¥¢Âºï (0 Âà∞ arr.length-1)
          const randomIndex = Math.floor(Math.random() * arr.length);
          // ËøîÂõûÈöèÊú∫ÂÖÉÁ¥†
          return arr[randomIndex];
        }
        // Ê≤°ÊúâÈÄóÂè∑ÂàôÁõ¥Êé•ËøîÂõûÂéüÂ≠óÁ¨¶‰∏≤
        return str;
      }
      function isImage(text, content) {
        let currentImageData = content.image_url.url;
        // ÊèêÂèñBase64Êï∞ÊçÆÔºàÂéªÊéâÂâçÁºÄÔºâ
        const base64Data = currentImageData.split(",")[1];
        // Ê†πÊçÆÂõæÁâáÁ±ªÂûãËé∑ÂèñMIMEÁ±ªÂûã
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
          { text: `${text.text}The user sent you a picture.` },
          {
            inline_data: {
              mime_type: mimeType,
              data: base64Data,
            },
          },
        ];
      }

      function extractArray(text) {
        // Ê≠£ÂàôË°®ËææÂºèÊ®°ÂºèÔºöÂåπÈÖçÂºÄÂ§¥ÁöÑÊó∂Èó¥Êà≥ÈÉ®ÂàÜÂíåÂêéÁª≠ÁöÑJSONÊï∞ÁªÑ
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
          const timestampPart = `(Timestamp: ${match[1]}) `;
          const jsonPart = match[2].trim();

          try {
            // Â∞ùËØïËß£ÊûêJSONÈÉ®ÂàÜ
            const parsedJson = JSON.parse(jsonPart);
            // È™åËØÅËß£ÊûêÁªìÊûúÊòØÂê¶‰∏∫Êï∞ÁªÑ
            if (Array.isArray(parsedJson)) {
              return [timestampPart, parsedJson[0]];
            }
          } catch (error) {
            // Ëß£ÊûêÂ§±Ë¥•ÔºåËøîÂõûÂéüÂßãÊñáÊú¨
          }
        }

        // ‰∏çÂåπÈÖçÊ†ºÂºèÊàñËß£ÊûêÂ§±Ë¥•Êó∂ËøîÂõûÂéüÂÄº
        return text;
      }
      function transformChatData(item) {
        let type = {
          send_and_recall: "recalled a message",
          update_status: "updated status",
          change_music: "changed the song",
          create_memory: "created a memory",
          create_countdown: "created an appointment/countdown",
          text: "sent a text message",
          sticker: "sent a sticker",
          ai_image: "sent an image",
          voice_message: "sent a voice message",
          transfer: "initiated a transfer",
          waimai_request: "sent a food delivery request",
          waimai_response: {
            paid: "responded to food delivery - accepted",
            rejected: "responded to food delivery - rejected",
          },
          video_call_request: "initiated a video call",
          video_call_response: {
            accept: "responded to video call - accepted",
            reject: "responded to video call - rejected",
          },
          qzone_post: {
            shuoshuo: "posted a status update",
            text_image: "posted a text + image",
          },
          qzone_comment: "commented on a post",
          qzone_like: "liked a post",
          pat_user: "patted the user",
          block_user: "blocked the user",
          friend_request_response: "responded to friend request",
          change_avatar: "changed profile picture",
          share_link: "shared a link",
          accept_transfer: "responded to transfer - accepted",
          decline_transfer: "responded to transfer - declined/refunded",
          quote_reply: "replied with a quote",
          text: "",
        };
        let res = extractArray(item.content);

        if (Array.isArray(res)) {
          let obj = res[1];
          let itemType = obj.type;
          let time = res[0];
          let text = type[itemType];
          if (text) {
            if (itemType === "sticker") {
              return [{ text: `${time}[${text}]Meaning:${obj.meaning}` }];
            } else if (itemType === "send_and_recall") {
              return [{ text: `${time}[${text}] ${obj.content}` }];
            } else if (itemType === "update_status") {
              return [
                {
                  text: `${time}[${text}] ${obj.status_text}(${obj.is_busy ? "Busy/Away" : "Free"})`,
                },
              ];
            } else if (itemType === "change_music") {
              return [
                {
                  text: `${time}[${text}] ${obj.change_music}Song title:${obj.song_name}`,
                },
              ];
            } else if (itemType === "create_memory") {
              return [{ text: `${time}[${text}] ${obj.description}` }];
            } else if (itemType === "create_countdown") {
              return [{ text: `${time}[${text}] ${obj.title}(${obj.date})` }];
            } else if (itemType === "ai_image") {
              return [
                { text: `${time}[${text}] Image Description:${obj.description}` },
              ];
            } else if (itemType === "voice_message") {
              return [{ text: `${time}[${text}] ${obj.content}` }];
            } else if (itemType === "transfer") {
              return [
                {
                  text: `${time}[${text}] Amount: ${obj.amount} Note: ${obj.amount}`,
                },
              ];
            } else if (itemType === "waimai_request") {
              return [
                {
                  text: `${time}[${text}] Amount: ${obj.amount} Item: ${obj.productInfo}`,
                },
              ];
            } else if (itemType === "waimai_response") {
              return [
                {
                  text: `${time}[${text[obj.status]}] ${obj.status === "paid" ? "Accepted" : "Rejected"}`,
                },
              ];
            } else if (itemType === "video_call_request") {
              return [{ text: `${time}[${text}]` }];
            } else if (itemType === "video_call_request") {
              return [
                {
                  text: `${time}[${text[obj.decision]}] ${obj.decision === "accept" ? "Accepted" : "Rejected"}`,
                },
              ];
            } else if (itemType === "qzone_post") {
              return [
                {
                  text: `${time}[${text[obj.postType]}] ${
                    obj.postType === "shuoshuo"
                      ? `${obj.content}`
                      : `Image Description: ${obj.hiddenContent} ${obj.publicText ? `Caption: ${obj.publicText}` : ""}`
                  }`,
                },
              ];
            } else if (itemType === "qzone_comment") {
              return [
                {
                  text: `${time}[${text}] Commented Post ID: ${obj.postId} Comment Content: ${obj.commentText}`,
                },
              ];
            } else if (itemType === "qzone_like") {
              return [{ text: `${time}[${text}] Liked Post ID: ${obj.postId}` }];
            } else if (itemType === "pat_user") {
              return [
                { text: `${time}[${text}] ${obj.suffix ? obj.suffix : ""}` },
              ];
            } else if (itemType === "block_user") {
              return [{ text: `${time}[${text}]` }];
            } else if (itemType === "friend_request_response") {
              return [
                {
                  text: `${time}[${text}] Result: ${obj.decision === "accept" ? "Accepted" : "Rejected"}`,
                },
              ];
            } else if (itemType === "change_avatar") {
              return [{ text: `${time}[${text}] Avatar Name: ${obj.name}` }];
            } else if (itemType === "share_link") {
              return [
                {
                  text: `${time}[${text}] Article Title: ${obj.title} Summary: ${obj.description} Source: ${obj.source_name} Content: ${obj.content}`,
                },
              ];
            } else if (itemType === "accept_transfer") {
              return [{ text: `${time}[${text}]` }];
            } else if (itemType === "accept_transfer") {
              return [{ text: `${time}[${text}]` }];
            } else if (itemType === "quote_reply") {
              return [
                { text: `${time}[${text}] Quoted Content: ${obj.reply_content}` },
              ];
            } else if (itemType === "text") {
              return [{ text: `${time}${obj.content}` }];
            }
          }


          // (‰æãÂ¶ÇÔºåÂÆÉÊòØ‰∏Ä‰∏™Êï∞ÁªÑÔºåÊàñËÄÖ‰∏Ä‰∏™AIËøîÂõûÁöÑ„ÄÅÊàë‰ª¨‰∏çËÆ§ËØÜÁöÑJSONÂØπË±°)
          if (typeof res !== "string") {
            // Êàë‰ª¨Â∞±Âº∫Âà∂‰ΩøÁî®ÊúÄÂéüÂßã„ÄÅÊúÄÂÆâÂÖ®ÁöÑ item.content Â≠óÁ¨¶‰∏≤
            res = item.content;
          }

          return [{ text: String(res || "") }];
        }
      }

      /**
       * „ÄêÂ∑≤‰øÆÂ§ç Gemini Áõ¥ËøûÈóÆÈ¢ò„ÄëÊûÑÂª∫ Gemini API ËØ∑Ê±ÇÊï∞ÊçÆ
       * ‰øÆÂ§çÂÜÖÂÆπÔºö
       * 1. Ëá™Âä®ÂêàÂπ∂ËøûÁª≠ÁöÑÁõ∏ÂêåËßíËâ≤Ê∂àÊÅØ (Ëß£ÂÜ≥ context ‰∏¢Â§±Âíå 400 ÈîôËØØ)
       * 2. Êô∫ËÉΩÂéªÈáç System Prompt (Ëß£ÂÜ≥ÈáçÂ§çÁîüÊàêÂíåÂøΩÁï•Áî®Êà∑ËæìÂÖ•)
       * 3. Á°Æ‰øù contents ‰∏ç‰∏∫Á©∫ (Ëß£ÂÜ≥ÂäüËÉΩÊÄß 400 ÈîôËØØ)
       */
      window.toGeminiRequestData = function (
        model,
        apiKey,
        systemInstruction,
        messagesForDecision,
        isGemini,
        temperature,
      ) {
        if (!isGemini) {
          return undefined;
        }

        let roleType = {
          user: "user",
          assistant: "model",
          system: "user", // System Ê∂àÊÅØÂú® Gemini ‰∏≠ÈÄöÂ∏∏‰Ωú‰∏∫ User Ê∂àÊÅØÁöÑ‰∏ÄÈÉ®ÂàÜÊàñ SystemInstruction
        };

        // --- 1. È¢ÑÂ§ÑÁêÜÊ∂àÊÅØÂàóË°® ---
        let processedMessages = [...messagesForDecision];
        let finalSystemInstruction = systemInstruction;

        // Âú∫ÊôØAÔºöËÅäÂ§©Ê®°Âºè
        // Â¶ÇÊûúÊ∂àÊÅØÂàóË°®ÂæàÈïøÔºå‰∏îÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÁöÑÂÜÖÂÆπÁ≠â‰∫é System Instruction
        // ËØ¥ÊòéËøôÊòØ triggerAiResponse Ëá™Âä®ËøΩÂä†ÁöÑÔºåÊàë‰ª¨ÈúÄË¶ÅÊääÂÆÉÁßªÈô§ÔºåÈò≤Ê≠¢ÈáçÂ§çÂíåË¶ÜÁõñÁî®Êà∑ËæìÂÖ•
        if (finalSystemInstruction && processedMessages.length > 1) {
          const lastMsg = processedMessages[processedMessages.length - 1];
          if (
            lastMsg.role === "system" &&
            lastMsg.content === finalSystemInstruction
          ) {
            processedMessages.pop();
          }
        }
        // Âú∫ÊôØBÔºöÂäüËÉΩÁîüÊàêÊ®°Âºè (Â¶ÇÊü•ÊâãÊú∫„ÄÅÁîüÊàêÂõæÁâáÊèèËø∞)
        // ËøôÁßçÊÉÖÂÜµ‰∏ã messagesForDecision ÈÄöÂ∏∏Âè™ÂåÖÂê´‰∏ÄÊù°‰∏é System Instruction Áõ∏ÂêåÁöÑÊ∂àÊÅØ
        // ‰∏∫‰∫ÜÈÅøÂÖç contents ‰∏∫Á©∫ (ÂØºËá¥400)ÔºåÊàë‰ª¨Ê∏ÖÁ©∫ systemInstruction Â≠óÊÆµÔºåËÆ©ËøôÊù°Ê∂àÊÅØ‰Ωú‰∏∫ÂîØ‰∏ÄÁöÑ User Ê∂àÊÅØÂèëÈÄÅ
        else if (processedMessages.length === 1 && finalSystemInstruction) {
          if (processedMessages[0].content === finalSystemInstruction) {
            finalSystemInstruction = ""; // Ê∏ÖÁ©∫Á≥ªÁªüÊåá‰ª§Ôºå‰æùÈù† contents ÈáåÁöÑÊ∂àÊÅØ
          }
        }

        // --- 2. ÊûÑÂª∫ contents Êï∞ÁªÑ (Ê†∏ÂøÉÔºöÂêàÂπ∂ËøûÁª≠ËßíËâ≤) ---
        const contents = [];
        let currentTurn = null;

        processedMessages.forEach((item) => {
          const targetRole = roleType[item.role] || "user";

          // Â§ÑÁêÜÊ∂àÊÅØÂÜÖÂÆπÔºåÂÖºÂÆπÂ§öÊ®°ÊÄÅ (ÂõæÁâá) ÂíåÁ∫ØÊñáÊú¨
          let parts = [];
          if (Array.isArray(item.content)) {
            // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÂõæÁâá
            const hasImage = item.content.some(
              (sub) => sub.type === "image_url",
            );
            if (hasImage) {
              parts = isImage(item.content[0], item.content[1]);
            } else {
              // Á∫ØÊñáÊú¨Êï∞ÁªÑËΩ¨Â≠óÁ¨¶‰∏≤
              parts = [{ text: JSON.stringify(item.content) }];
            }
          } else {
            // ÊôÆÈÄöÂ≠óÁ¨¶‰∏≤
            const textVal = String(item.content || "");
            if (textVal.trim() === "") return; // Ë∑≥ËøáÁ©∫Ê∂àÊÅØ
            parts = [{ text: textVal }];
          }

          if (parts.length === 0) return;

          // „ÄêÂÖ≥ÈîÆÈÄªËæë„ÄëÂ¶ÇÊûúÂΩìÂâçÊ∂àÊÅØËßíËâ≤‰∏é‰∏ä‰∏ÄÊù°Áõ∏ÂêåÔºåÂàôÂêàÂπ∂Âà∞‰∏ä‰∏ÄÊù°ÁöÑ parts ‰∏≠
          // ËøôËÆ© Gemini ËÉΩÂ§üÂêåÊó∂ÁúãÂà∞ [Áî®Êà∑ËæìÂÖ•] Âíå [Á≥ªÁªüË°•ÂÖÖÁöÑContext]ÔºåËÄå‰∏ç‰ºöÊääÂÆÉ‰ª¨ÂΩìÊàê‰∏§ËΩÆÂØπËØù
          if (currentTurn && currentTurn.role === targetRole) {
            currentTurn.parts.push(...parts);
          } else {
            // Âê¶ÂàôÔºåÂºÄÂßãÊñ∞ÁöÑ‰∏ÄËΩÆ
            if (currentTurn) contents.push(currentTurn);
            currentTurn = {
              role: targetRole,
              parts: [...parts],
            };
          }
        });

        // Êé®ÂÖ•ÊúÄÂêé‰∏ÄËΩÆ
        if (currentTurn) contents.push(currentTurn);

        // --- 3. ÊúÄÂêéÁöÑÂÖúÂ∫ïÊ£ÄÊü• ---
        // Gemini Ë¶ÅÊ±Ç contents ‰∏çËÉΩ‰∏∫Á©∫„ÄÇÂ¶ÇÊûúÁªèËøáËøáÊª§Âêé‰∏∫Á©∫ÔºåÂøÖÈ°ªË°•Êïë„ÄÇ
        if (contents.length === 0) {
          if (finalSystemInstruction) {
            // Â¶ÇÊûúÊúâÁ≥ªÁªüÊåá‰ª§ÔºåÂ∞±ÊääÂÆÉÊå™Âà∞ contents Èáå‰Ωú‰∏∫ User Ê∂àÊÅØ
            contents.push({
              role: "user",
              parts: [{ text: finalSystemInstruction }],
            });
            finalSystemInstruction = ""; // ÈÅøÂÖçÈáçÂ§ç
          } else {
            // ÂÆûÂú®Ê≤°‰∏úË•øÂèë‰∫ÜÔºåÂèë‰∏™Á©∫Ê†ºÈò≤Ê≠¢Êä•Èîô (ÊûÅÁΩïËßÅÊÉÖÂÜµ)
            contents.push({ role: "user", parts: [{ text: " " }] });
          }
        }

        // --- 4. ÁªÑË£ÖËØ∑Ê±Ç‰Ωì ---
        const body = {
          contents: contents,
          generationConfig: {
            temperature: parseFloat(temperature) || 0.8,
          },
        };

        // Âè™ÊúâÂΩì systemInstruction ‰∏ç‰∏∫Á©∫Êó∂ÊâçÊ∑ªÂä†ËØ•Â≠óÊÆµ
        if (finalSystemInstruction && finalSystemInstruction.trim()) {
          body.systemInstruction = {
            parts: [{ text: finalSystemInstruction }],
          };
        }

        // Apply CORS proxy if configured
        // Supports two formats:
        //   Reverse proxy (Cloudflare Worker): "https://my-worker.workers.dev"
        //     ‚Üí replaces Gemini domain, e.g. https://my-worker.workers.dev/v1beta/models/...
        //   Prepend proxy (corsproxy.io etc): "https://corsproxy.io/?"
        //     ‚Üí prepends + encodes, e.g. https://corsproxy.io/?https%3A%2F%2F...
        const _geminiBase = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`;
        const _apiCorsProxy = (localStorage.getItem("api-cors-proxy") || "").trim();
        let _geminiUrl;
        if (!_apiCorsProxy) {
          _geminiUrl = _geminiBase;
        } else if (_apiCorsProxy.endsWith("?") || _apiCorsProxy.endsWith("=")) {
          // Prepend-style proxy (corsproxy.io, etc.)
          _geminiUrl = _apiCorsProxy + encodeURIComponent(_geminiBase);
        } else {
          // Reverse proxy (Cloudflare Worker) ‚Äî replace domain
          _geminiUrl = _geminiBase.replace(
            "https://generativelanguage.googleapis.com",
            _apiCorsProxy.replace(/\/+$/, "")
          );
        }

        return {
          url: _geminiUrl,
          data: {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(body),
          },
        };
      };
      document.addEventListener("DOMContentLoaded", () => {
        // ===================================================================
        // 1. All variables and constants definition
        // ===================================================================
        // Global variables and constants related to pet value decay
        const PET_DECAY_INTERVAL = 60 * 60 * 1000; // Decay every 60 minutes
        const PET_DECAY_AMOUNT = {
          // ÊØèÊ¨°Ë°∞ÂáèÁöÑÊï∞ÂÄº
          hunger: 5,
          happiness: 3,
        };
        let petDecayTimer = null; // Áî®‰∫éÁÆ°ÁêÜË°∞ÂáèËÆ°Êó∂Âô®ÁöÑÂÖ®Â±ÄÂèòÈáè
        let pieChartInstance = null;
        let lineChartInstance = null;

        const CHAR_PHONE_APPS = [
          {
            id: "chat",
            name: "Chat",
            screen: "character-chat-list-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#4CAF50"><path d="M12 2C6.48 2 2 6.48 2 12c0 2.94 1.28 5.58 3.34 7.42c-.22 1.4-.89 3.1-1.25 3.82c-.36.72.48 1.39 1.05.94c.82-.67 2.43-1.88 3.3-2.58C9.44 21.78 10.68 22 12 22c5.52 0 10-4.48 10-10S17.52 2 12 2zm3.5 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5zm-7 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>`,
          },
          {
            id: "cart",
            name: "Shopping Cart",
            screen: "character-shopping-cart-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#F44336"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2s-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2s2-.9 2-2s-.9-2-2-2zm-15-14h3.27l.94 2H20c.69 0 1.25.56 1.25 1.25c0 .09-.02.18-.04.27l-3.58 6.49c-.25.44-.73.74-1.26.74H8.52l-.94-2H4.27V4H2V2h3.27z"/></svg>`,
          },
          {
            id: "memos",
            name: "Memo",
            screen: "character-memos-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#FFC107"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>`,
          },
          {
            id: "browser",
            name: "Browser",
            screen: "character-browser-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#2196F3"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1.5-12.5l3 7.5 7.5-3-7.5-3z"/></svg>`,
          },
          {
            id: "album",
            name: "Albums",
            screen: "character-album-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#8BC34A"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>`,
          },
          {
            id: "bank",
            name: "Wallet",
            screen: "character-bank-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#E91E63"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>`,
          },
          {
            id: "trajectory",
            name: "Journey",
            screen: "character-trajectory-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#795548"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>`,
          },
          {
            id: "app_usage",
            name: "App Usage",
            screen: "character-app-usage-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#607D8B"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8s8 3.58 8 8s-3.58 8-8 8zm.5-13H11v6l5.25 3.15l.75-1.23l-4.5-2.67z"/></svg>`,
          },
          {
            id: "diary",
            name: "Diary",
            screen: "character-diary-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#009688"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83l3.75 3.75 1.83-1.83z"/></svg>`,
          },
          // ËøôÂ∞±ÊòØÊàë‰ª¨Êñ∞Âä†ÁöÑApp
          {
            id: "appearance",
            name: "Wallpaper",
            screen: "character-phone-appearance-screen",
            svg: `<svg viewBox="0 0 24 24" fill="#9C27B0"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1.17 14.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34-5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32L11.41 8.5c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34 5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.4-.4-.4-1.04 0-1.41l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.2.2.31.45.31.71 0 .26-.11.51-.31.71l-1.41 1.41z"/></svg>`,
          },
        ];

        const BLOCKED_API_SITES = [
          "api.pisces.ink",
          "aiapi.qzz.io",
          "api520.pro",
          "api521.pro",
          "api522.pro",
        ];

        // --- Â∑≤‰øÆÊ≠£ ---

        // --- ‰øÆÊ≠£ÁªìÊùü ---
        let isUserStickerSelectionMode = false;
        let activeStickerCategoryId = "uncategorized";
        let userStickerCategories = []; // Áî®‰∫éÁºìÂ≠òÁî®Êà∑ÁöÑÊâÄÊúâÂàÜÁ±ª

        let isCharStickerSelectionMode = false;
        let selectedCharStickers = new Set();

        let selectedUserStickers = new Set();
        let isLocked = false;
        let newLockscreenWallpaperBase64 = null;
        let newGlobalBgBase64 = null; // Áî®‰∫éÊöÇÂ≠òÊñ∞ÁöÑÂÖ®Â±ÄËÅäÂ§©ËÉåÊôØ
        let newAppWallpaperBase64 = null;
        window.state.musicState = {
          isActive: false,
          activeChatId: null,
          isPlaying: false,
          playlist: [],
          currentIndex: -1,
          playMode: "order",
          totalElapsedTime: 0,
          timerId: null,

          parsedLyrics: [], // ÂΩìÂâçÊ≠åÊõ≤Ëß£ÊûêÂêéÁöÑÊ≠åËØçÊï∞ÁªÑ
          currentLyricIndex: -1, // ÂΩìÂâçÈ´ò‰∫ÆÁöÑÊ≠åËØçË°åÁ¥¢Âºï
        };

        let isWorldBookEditMode = false;
        let selectedWorldBooks = new Set();

        let lyricsBarSettings = {
          fontSize: 14,
          bgOpacity: 0,
          fontColor: "#FFFFFF",
          showOnClose: true, // „ÄêÈóÆÈ¢ò4ÈúÄË¶Å„ÄëÈªòËÆ§ÂºÄÂêØ
        };

        const audioPlayer = document.getElementById("audio-player");
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let isInnerVoiceHistoryOpen = false; // Áî®‰∫éË∑üË∏™ÂéÜÂè≤Èù¢ÊùøÊòØÂê¶ÊâìÂºÄ

        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;
        let activeCharPhonePresetId = null; // Áî®‰∫éËøΩË∏™ËßíËâ≤ÊâãÊú∫Â§ñËßÇÈ¢ÑËÆæÁöÑÈÄâÊã©
        let activeCharacterPhoneId = null;
        let waimaiTimers = {}; // Áî®‰∫éÂ≠òÂÇ®Â§ñÂçñÂÄíËÆ°Êó∂
        let editingSpriteGroupId = null;
        let activeMessageTimestamp = null;

        let currentReplyContext = null; // <--- Êñ∞Â¢ûËøôË°åÔºåÁî®Êù•Â≠òÂÇ®ÂΩìÂâçÊ≠£Âú®ÂºïÁî®ÁöÑÊ∂àÊÅØ‰ø°ÊÅØ
        let currentSearchKeyword = ""; // Áî®‰∫éÂú®ÊêúÁ¥¢ÁªìÊûú‰∏≠È´ò‰∫ÆÂÖ≥ÈîÆËØç
        let activePostId = null; // <-- Êñ∞Â¢ûÔºöÁî®‰∫éÂ≠òÂÇ®ÂΩìÂâçÊìç‰ΩúÁöÑÂä®ÊÄÅID

        // ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÁΩëÁªúËØ∑Ê±ÇÂáΩÊï∞
        if (typeof Http_Get_External === "undefined") {
          window.Http_Get_External = function (url) {
            return new Promise((resolve) => {
              fetch(url)
                .then((res) => res.json().catch(() => res.text()))
                .then(resolve)
                .catch(() => resolve(null));
            });
          };
        }
        async function Http_Get(url) {
          return await Http_Get_External(url);
        }

        // Ê£ÄÊü•Èü≥È¢ëÈìæÊé•ÊòØÂê¶ÁúüÁöÑÂèØ‰ª•Êí≠Êîæ
        function checkAudioAvailability(url) {
          return new Promise((resolve) => {
            const tester = new Audio();
            tester.addEventListener("loadedmetadata", () => resolve(true), {
              once: true,
            });
            tester.addEventListener("error", () => resolve(false), {
              once: true,
            });
            tester.src = url;
          });
        }

        /**
         * ÁßªÈô§ÊâÄÊúâ‰ª£ÁêÜÔºåÁõ¥Êé•ËØ∑Ê±Ç‰Ω†ÊâæÂà∞ÁöÑ vkeys.cn API
         */
        async function searchNeteaseMusic(name, singer) {
          try {
            let searchTerm = name.replace(/\s/g, "");
            if (singer) {
              searchTerm += ` ${singer.replace(/\s/g, "")}`;
            }

            const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;

            console.log("Trying direct request:", apiUrl); // Add a log line for easier debugging

            const response = await fetch(apiUrl);

            if (!response.ok) {
              throw new Error(
                `API request failed with status ${response.status}: ${response.statusText}`,
              );
            }

            const result = await response.json();

            if (
              result.code !== 200 ||
              !result.data ||
              result.data.length === 0
            ) {
              console.log("vkeys API returned no results:", result);
              return [];
            }

            return result.data
              .map((song) => ({
                name: song.song,
                artist: song.singer,
                id: song.id,
                cover:
                  song.cover ||
                  "https://i.postimg.cc/pT2xKzP-album-cover-placeholder.png",
                source: "netease",
              }))
              .slice(0, 15);
          } catch (e) {
            // If it still fails, please screenshot the full red error message in the browser F12 console
            console.error("[vkeys API Direct] Search failed:", e);
            await showCustomAlert(
              "Netease direct API connection failed",
              `If the browser console (F12) shows a CORS error, it means this API blocks direct access. Error: ${e.message}`,
            );
            return [];
          }
        }
        /**
         * [NEW] Search songs from GD Music Station (aggregated search)
         */
        async function searchGdstudioMusic(name) {
          try {
            const searchTerm = name.replace(/\s/g, "");
            // Request Netease and QQ Music sources at the same time, then merge results
            const [neteaseResults, tencentResults] = await Promise.all([
              Http_Get(
                `https://music-api.gdstudio.xyz/api.php?btwaf=9018895&types=search&source=netease&name=${encodeURIComponent(
                  searchTerm,
                )}&count=10&pages=1`,
              ),
              Http_Get(
                `https://music-api.gdstudio.xyz/api.php?btwaf=9018895&types=search&source=tencent&name=${encodeURIComponent(
                  searchTerm,
                )}&count=10&pages=1`,
              ),
            ]);

            const combined = [
              ...(neteaseResults || []),
              ...(tencentResults || []),
            ];

            if (!combined.length) return [];

            // Deduplicate and format results
            const uniqueSongs = new Map();
            combined.forEach((song) => {
              if (song && song.id && !uniqueSongs.has(song.id)) {
                uniqueSongs.set(song.id, {
                  name: song.name,
                  artist:
                    song.artist?.map((a) => a.name).join(" / ") ||
                    song.artist?.[0] ||
                    "Unknown Artist",
                  id: song.id,
                  // pic_id is for fetching album art, id is for fetching the song and lyrics
                  pic_id: song.pic_id || song.album?.id,
                  lyric_id: song.lyric_id || song.id,
                  cover:
                    song.pic ||
                    "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png",
                  // The source here is for GD API internal use; we use a new field to label the API provider
                  originalSource: song.source,
                  apiProvider: "gdstudio", // Mark this as a result from GD Music Station
                });
              }
            });

            return Array.from(uniqueSongs.values());
          } catch (e) {
            console.error("[GD Music Station] Search API failed:", e);
            return [];
          }
        }

        /**
         * Search songs from QQ Music
         */
        async function searchTencentMusic(name) {
          try {
            name = name.replace(/\s/g, "");
            const result = await Http_Get(
              `https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`,
            );
            if (!result?.data?.length) return [];
            return result.data
              .map((song) => ({
                name: song.song,
                artist: song.singer,
                id: song.id,
                cover:
                  song.cover ||
                  "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png",
                source: "tencent", // Mark source
              }))
              .slice(0, 5); // Only take top 5 results
          } catch (e) {
            console.error("QQ Music search API failed:", e);
            return [];
          }
        }

        async function addSongFromSearch() {
          const source = await showSearchSourceSelector();
          if (!source) return;

          const searchTerm = await showCustomPrompt(
            "Search Songs",
            "Please enter Song Name or Song Name - Artist",
          );
          if (!searchTerm || !searchTerm.trim()) return;

          await showCustomAlert("Please wait...", "Searching for song resources...");

          let musicName = searchTerm.trim();
          let singerName = "";
          if (searchTerm.includes("-") || searchTerm.includes("‚Äì")) {
            const parts = searchTerm.split(/[-‚Äì]/);
            musicName = parts[0].trim();
            singerName = parts.slice(1).join(" ").trim();
          }

          let combinedResults = [];

          // ‚ñº‚ñº‚ñº Modified/New section starts ‚ñº‚ñº‚ñº
          if (source === "gdstudio") {
            // If "GD Music Station" is selected, call our new function
            combinedResults = await searchGdstudioMusic(musicName);
          } else if (source === "all") {
            // Aggregated search (vkeys API)
            const [neteaseResults, tencentResults] = await Promise.all([
              searchNeteaseMusic(musicName, singerName),
              searchTencentMusic(musicName),
            ]);
            combinedResults = [...neteaseResults, ...tencentResults];
          } else if (source === "netease") {
            // Netease only (vkeys API)
            combinedResults = await searchNeteaseMusic(musicName, singerName);
          } else if (source === "tencent") {
            // QQ Music only (vkeys API)
            combinedResults = await searchTencentMusic(musicName);
          }
          // ‚ñ≤‚ñ≤‚ñ≤ Modified/New section ends ‚ñ≤‚ñ≤‚ñ≤

          if (combinedResults.length === 0) {
            await showCustomAlert(
              "No Results",
              "Sorry, no matching songs were found in the selected source.",
            );
            return;
          }

          const modal = document.getElementById("music-search-results-modal");
          const listEl = document.getElementById("search-results-list");
          listEl.innerHTML = "";

          combinedResults.forEach((song) => {
            const item = document.createElement("div");
            item.className = "search-result-item";
            item.dataset.songJson = JSON.stringify(song);

            // ‚ñº‚ñº‚ñº ‰øÆÊîπ/Êñ∞Â¢ûÈÉ®ÂàÜÂºÄÂßã ‚ñº‚ñº‚ñº
            // Ê†πÊçÆ API Êèê‰æõÂïÜÊòæÁ§∫‰∏çÂêåÁöÑÊù•Ê∫êÊ†áÁ≠æ
      
  let sourceLabel = "";
            if (song.apiProvider === "gdstudio") {
              sourceLabel = "GD Music Station";
            } else if (song.source === "netease") {
              sourceLabel = "NetEase Cloud";
            } else if (song.source === "tencent") {
              sourceLabel = "QQ Music";
            }

            item.innerHTML = `
                        <div class="title">${song.name}</div>
                        <div class="artist">${song.artist} <span class="source">${sourceLabel}</span></div>
                    `;
            // ‚ñ≤‚ñ≤‚ñ≤ End of modified/new section ‚ñ≤‚ñ≤‚ñ≤
            listEl.appendChild(item);
          });

          modal.classList.add("visible");
        }

        async function handleSearchResultClick(songData) {
          const modal = document.getElementById("music-search-results-modal");
          modal.classList.remove("visible");

          await showCustomAlert(
            "Please wait...",
            `Fetching playback link for "${songData.name}"...`,
          );

          let playableResult = null;
          // Compatible with two source fields
          let finalSource = songData.originalSource || songData.source;

          // --- Core logic branch: call different interfaces based on apiProvider ---
          if (songData.apiProvider === "gdstudio") {
            // ‚ñº‚ñº‚ñº Core modification: Change btwaf from 9018895 to 20639888! ‚ñº‚ñº‚ñº
            const gdApiUrl = `https://music-api.gdstudio.xyz/api.php?btwaf=20639888&types=url&source=${finalSource}&id=${songData.id}&br=320`;
            // ‚ñ≤‚ñ≤‚ñ≤ Core modification ends ‚ñ≤‚ñ≤‚ñ≤

            const result = await Http_Get(gdApiUrl);
            console.log("GD Music Station link retrieval returned:", result); // Add logs for easy debugging

            // Compatible with two possible return formats of GD API and check if URL is empty
            const songUrl = (result?.url || result?.data?.url || "").trim();

            if (songUrl && (await checkAudioAvailability(songUrl))) {
              playableResult = {
                url: songUrl,
                id: songData.id,
                source: finalSource,
                apiProvider: "gdstudio",
              };
            } else {
              console.warn("GD Music Station link retrieval failed or link is invalid:", result);
            }
          } else {
            // --- This is your original logic using vkeys.cn, keep it as is ---
            const primaryApiUrl =
              finalSource === "netease"
                ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
                : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
            let primaryResult = await Http_Get(primaryApiUrl);
            if (
              primaryResult?.data?.url &&
              (await checkAudioAvailability(primaryResult.data.url))
            ) {
              playableResult = {
                url: primaryResult.data.url,
                id: songData.id,
                source: finalSource,
              };
            }
            if (!playableResult) {
              await showCustomAlert(
                "Please wait...",
                "Failed to retrieve the primary source, attempting to use a fallback source...",
              );
              const fallbackSource =
                finalSource === "netease" ? "tencent" : "netease";
              const fallbackResults =
                fallbackSource === "tencent"
                  ? await searchTencentMusic(songData.name)
                  : await searchNeteaseMusic(songData.name, songData.artist);

              if (fallbackResults.length > 0) {
                const fallbackApiUrl =
                  fallbackSource === "netease"
                    ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}`
                    : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;
                const fallbackResult = await Http_Get(fallbackApiUrl);
                if (
                  fallbackResult?.data?.url &&
                  (await checkAudioAvailability(fallbackResult.data.url))
                ) {
                  playableResult = {
                    url: fallbackResult.data.url,
                    id: fallbackResults[0].id,
                    source: fallbackSource,
                  };
                  finalSource = fallbackSource;
                }
              }
            }
          }

          if (!playableResult) {
            await showCustomAlert(
              "Failed to retrieve",
              "Unable to retrieve a valid playback link for this song. The song may require VIP access or be region-restricted.",
            );
            return;
          }

          // Ëé∑ÂèñÊ≠åËØç (Áé∞Âú®‰ºöÊ†πÊçÆ apiProvider Ë∞ÉÁî®Ê≠£Á°ÆÁöÑÊé•Âè£)
          const lrcContent =
            (await getLyricsForSong(
              playableResult.id,
              playableResult.source,
              playableResult.apiProvider,
            )) || "";

          // Ëé∑Âèñ‰∏ìËæëÂõæ (Âè™Êúâ GD Ê∫êÊâçÈúÄË¶ÅÈ¢ùÂ§ñËé∑Âèñ)
          let coverUrl = songData.cover;
          if (playableResult.apiProvider === "gdstudio" && songData.pic_id) {
            const picApiUrl = `https://music-api.gdstudio.xyz/api.php?btwaf=20639888&types=pic&source=${playableResult.source}&id=${songData.pic_id}&size=500`;
            const picResult = await Http_Get(picApiUrl);
            if (picResult && picResult.url) {
              coverUrl = picResult.url;
            }
          }

          // ÊûÑÂª∫Ê∞∏‰πÖ‰øùÂ≠òÁöÑÊ≠åÊõ≤ÂØπË±°
          const newSong = {
            name: songData.name,
            artist: songData.artist,
            src: playableResult.url,
            cover: coverUrl,
            isLocal: false,
            lrcContent: lrcContent,
            isTemporary: false,
            addedTimestamp: Date.now(),
            musicId: playableResult.id,
            musicSource: finalSource,
            apiProvider: playableResult.apiProvider,
          };

          state.musicState.playlist.push(newSong);

          await saveGlobalPlaylist();

          updatePlaylistUI();

 if (state.musicState.currentIndex === -1) {
            state.musicState.currentIndex =
              state.musicState.playlist.length - 1;
            loadSong(state.musicState.currentIndex);
          } else {
            await showCustomAlert(
              "Added successfully",
              `"${songData.name}" has been saved, and will be automatically updated if the link becomes invalid.`,
            );
          }

          try {
            if (state.activeChatId) {
              const chat = state.chats[state.activeChatId];
              if (chat) {
                const hiddenMessage = {
                  role: "system",
                  content: `[System Note: User added song "${songData.name}" to the list.]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);
                await db.chats.put(chat);
              }
            }
          } catch (e) {}
        }

        async function getLyricsForSong(songId, source, apiProvider) {
          let url = "";
          // ‚ñº‚ñº‚ñº Modification/Addition Start ‚ñº‚ñº‚ñº
          if (apiProvider === "gdstudio") {
            // If it's a result from GD Music Station, use GD's lyric API
            url = `https://music-api.gdstudio.xyz/api.php?btwaf=20639888&types=lyric&source=${source}&id=${songId}`;
          } else {
            // Otherwise, use the original vkeys interface
            url =
              source === "netease"
                ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}`
                : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;
          }

          const response = await Http_Get(url);

          // Compatible with return formats of both APIs
          const responseData = response?.data || response;

          if (responseData) {
            const lrc = responseData.lrc || responseData.lyric || "";
            const tlyric = responseData.tlyric || responseData.trans || "";
            return tlyric ? lrc + "\n" + tlyric : lrc;
          }
          // ‚ñ≤‚ñ≤‚ñ≤ Modification/Addition End ‚ñ≤‚ñ≤‚ñ≤
          return "";
        }

        /**
         * Displays the search source selection pop-up and returns the user's choice
         * @returns {Promise<string|null>} Returns 'all', 'netease', 'tencent', or null
         */
        function showSearchSourceSelector() {
          return new Promise((resolve) => {
            const modal = document.getElementById(
              "music-source-selector-modal",
            );
            const confirmBtn = document.getElementById(
              "confirm-source-select-btn",
            );
            const cancelBtn = document.getElementById(
              "cancel-source-select-btn",
            );

            // Display the pop-up
            modal.classList.add("visible");

            // Define the click event for the confirm button
            const onConfirm = () => {
              const selectedSource = document.querySelector(
                'input[name="search-source"]:checked',
              ).value;
              cleanup();
              resolve(selectedSource); // Return the user's choice
            };

            // Define the click event for the cancel button
            const onCancel = () => {
              cleanup();
              resolve(null); // User canceled, return null
            };

            // Ê∏ÖÁêÜÂáΩÊï∞ÔºåÁî®‰∫éÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨Âπ∂ÈöêËóèÂºπÁ™ó
            const cleanup = () => {
              modal.classList.remove("visible");
              confirmBtn.removeEventListener("click", onConfirm);
              cancelBtn.removeEventListener("click", onCancel);
            };

            // ÁªëÂÆö‰∫ã‰ª∂
            confirmBtn.addEventListener("click", onConfirm);
            cancelBtn.addEventListener("click", onCancel);
          });
        }

        /**
         * Ê†πÊçÆÊ≠åÂêçÂíåÊ≠åÊâãËá™Âä®ÊêúÁ¥¢Âπ∂Êí≠ÊîæÊ≠åÊõ≤
         * @param {string} name - Ê≠åÊõ≤Âêç
         * @param {string} artist - Ê≠åÊâãÂêç
         */
        async function searchAndPlaySong(name, artist) {
          // ÂºπÂá∫ÊèêÁ§∫ÔºåÂëäËØâÁî®Êà∑Êàë‰ª¨Ê≠£Âú®ÂÅö‰ªÄ‰πà
          await showCustomAlert(
            "Please wait...",
            `AI has shared the song "${name}" for you and is currently searching for playback resources...`,
          );

          let songData = null;

          // Á≠ñÁï•1Ôºö‰ºòÂÖàÁî®ÁΩëÊòì‰∫ëÊêúÁ¥¢ (ÈÄöÂ∏∏ÁªìÊûúÊõ¥ÂáÜ)
          const neteaseResults = await searchNeteaseMusic(name, artist);
          if (neteaseResults.length > 0) {
            songData = neteaseResults[0]; // Â¶ÇÊûúÊâæÂà∞‰∫ÜÔºåÂ∞±Áî®Á¨¨‰∏Ä‰∏™ÁªìÊûú
          }
          // Á≠ñÁï•2ÔºöÂ¶ÇÊûúÁΩëÊòì‰∫ëÊâæ‰∏çÂà∞ÔºåÂÜçÁî®QQÈü≥‰πêÊêú‰∏ÄÊ¨°
          else {
            const tencentResults = await searchTencentMusic(name);
            if (tencentResults.length > 0) {
              songData = tencentResults[0]; // Áî®QQÈü≥‰πêÁöÑÁ¨¨‰∏Ä‰∏™ÁªìÊûú
            }
          }

          // Â¶ÇÊûú‰∏§‰∏™Âπ≥Âè∞ÈÉΩÊ≤°ÊâæÂà∞ÔºåÂ∞±ÂëäËØâÁî®Êà∑Âπ∂ÈÄÄÂá∫
if (!songData) {
            await showCustomAlert(
              "Song Not Found",
              `Sorry, no playable resources for "${name}" could be found on NetEase Cloud Music or QQ Music.`,
            );
            return;
          }

          // By this point, we have the basic information for a song (id, source, name, artist)
          // The logic below is to call the API to get the real playback link

          const apiUrl =
            songData.source === "netease"
              ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
              : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;

          const result = await Http_Get(apiUrl);

          // Check if the obtained link is actually playable
          if (
            !result?.data?.url ||
            !(await checkAudioAvailability(result.data.url))
          ) {
            await showCustomAlert(
              "Failed to Retrieve",
              `Found "${name}", but could not get a valid playback link.`,
            );
            return;
          }

          // Get lyrics
          const lrcContent =
            (await getLyricsForSong(songData.id, songData.source)) || "";

          // Prepare the new song object, ready to be added to the playlist
          const newSong = {
            name: songData.name,
            artist: songData.artist,
            src: result.data.url, // Use the real, playable URL we just obtained!
            cover: songData.cover,
            isLocal: false,
            lrcContent: lrcContent,
            isTemporary: true, // Mark as a temporary song, may expire after 24 hours
            addedTimestamp: Date.now(),
          };

          // Check if this song is already in the playlist
          const existingIndex = state.musicState.playlist.findIndex(
            (t) => t.name === newSong.name && t.artist === newSong.artist,
          );
          if (existingIndex !== -1) {
            // If it is, play it directly
            playSong(existingIndex);
          } else {
            // If not, add it to the end of the list and then play
            state.musicState.playlist.push(newSong);
            updatePlaylistUI(); // Refresh the playlist UI
            playSong(state.musicState.playlist.length - 1);
          }

          // If the "Listen Together" feature is off, turn it on automatically
          if (!state.musicState.isActive) {
            startListenTogetherSession(state.activeChatId);
          } else {
            // If it's already on, just display the player window
            document
              .getElementById("music-player-overlay")
              .classList.add("visible");
          }
        }

        let photoViewerState = {
          isOpen: false,
          photos: [], // Stores all photo URLs for the current album
          currentIndex: -1, // Index of the photo currently being viewed
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set();

        let simulationIntervalId = null;

        let currentFrameSelection = { type: null, url: "", target: null };

        let notificationTimeout;
        
        const THEME_CSS_TEMPLATE = `
			/*
			  EPhone ÁæéÂåñ‰ª£Á†ÅÊ®°Êùø
			  ‰ΩøÁî®ÊñπÊ≥ï:
			  1. ‰øÆÊîπ‰∏ãÈù¢ÁöÑÈ¢úËâ≤‰ª£Á†ÅÊàñÂõæÁâáURL„ÄÇ
			  2. ‰∏çÈúÄË¶Å‰øÆÊîπÁöÑÈÉ®ÂàÜÂèØ‰ª•Âà†Èô§Êàñ‰øùÊåÅ‰∏çÂèò„ÄÇ
			  3. È¢úËâ≤‰ª£Á†ÅÊ†ºÂºè‰∏∫ #RRGGBB (‰æãÂ¶Ç #FFFFFF ÊòØÁôΩËâ≤)„ÄÇ
			  4. ÂõæÁâáURLÈúÄË¶ÅÊòØÁΩëÁªúÁõ¥Èìæ„ÄÇ
			*/

			/* === 1. ÊâãÊú∫Â£≥‰∏éÂàòÊµ∑È¢úËâ≤ === */
			#phone-frame {
			  background-color: #f0f0f0; /* ÊâãÊú∫Â£≥È¢úËâ≤ */
			}
			.notch {
			  background-color: #1a1a1a; /* È°∂ÈÉ®‚ÄúÂàòÊµ∑‚ÄùÈ¢úËâ≤ */
			}
			        #clock-container {  color: white;  }


			/* === 1.5. ÂÖ®Â±Ä‰∏ªÈ¢òËâ≤ (ÈáçË¶ÅÔºÅ) === */
			/* Ëøô‰∏™È¢úËâ≤ÂÜ≥ÂÆö‰∫ÜÂ§ßÈÉ®ÂàÜÊåâÈíÆ„ÄÅÈìæÊé•ÂíåÈ´ò‰∫ÆÊñáÊú¨ÁöÑÈ¢úËâ≤„ÄÇ*/
			:root {
			  --accent-color: #007bff; /* ÈªòËÆ§ÊòØËìùËâ≤ */
			}

			/* === 2. Replace image buttons at the top and bottom of the chat interface === */
	/* ‚ÄúListen Together‚Äù button (normal state) */
	#listen-together-btn img[src*="8kYShvrJ/90-UI-2.png"] {
	  content: url('Paste your "normal state" image URL here');
	}
	/* ‚ÄúListen Together‚Äù button (playing state) */
	#listen-together-btn img[src*="D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png"] {
	  content: url('Paste your "playing state" image URL here');
	}
	/* ‚ÄúChat Settings‚Äù button */
	#chat-settings-btn img {
	  content: url('https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png');
	}
	/* ‚ÄúTrigger API Reply‚Äù button */
	#wait-reply-btn img {
	  content: url('https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png');
	}
	/* ‚ÄúSend‚Äù button (use image instead of default button style) */
	#send-btn {
	  background-image: url('Paste your send button image URL here');
	  background-size: contain;
	  background-repeat: no-repeat;
	  background-position: center;
	  width: 50px; /* Adjust width according to your image */
	}


			/* ‚ÄúÈáçÊñ∞ÁîüÊàêÂõûÂ§ç‚ÄùÊåâÈíÆ */
			#reroll-btn {
			    background-color: rgba(255, 255, 255, 0.6);
			    color: var(--text-primary); /* ‰ΩøÁî®ÂÖ®Â±Ä‰∏ªÈ¢òÁöÑ‰∏ªÊñáÊú¨È¢úËâ≤ */
			}

			/* === 3. È°∂ÈÉ®Ê†è‰∏éÂ∫ïÈÉ®Ê†èÈ¢úËâ≤ === */
			.header, .qzone-header {
			  background-color: rgba(240, 240, 240, 0.8); /* È°∂ÈÉ®Ê†èËÉåÊôØËâ≤ (Â∏¶‰∏ÄÁÇπÈÄèÊòé) */
			  color: #333333; /* È°∂ÈÉ®Ê†èÊñáÂ≠óÈ¢úËâ≤ */
			}
			#chat-list-bottom-nav {
			  background-color: rgba(245, 245, 245, 0.85); /* Â∫ïÈÉ®ÂØºËà™Ê†èËÉåÊôØËâ≤ */
			}
			.nav-item {
			  color: #8a8a8a; /* Â∫ïÈÉ®ÂØºËà™Ê†èÊú™ÈÄâ‰∏≠È°πÁöÑÈ¢úËâ≤ */
			}
			.nav-item.active {
			  color: #007bff; /* Â∫ïÈÉ®ÂØºËà™Ê†èÈÄâ‰∏≠È°πÁöÑÈ¢úËâ≤ */
			}

			/* === 4. ÂêÑÁïåÈù¢ËÉåÊôØËâ≤ === */
			#chat-list-screen, #qzone-screen .qzone-content, #memories-view {
			  background-color: #f0f2f5 !important; /* ÂàóË°®È°µ‰∏ªËÉåÊôØËâ≤ */
			}

			/* === 5. ËÅäÂ§©ËæìÂÖ•Âå∫Â∫ïÈÉ®ÂäüËÉΩÊ†èSVGÂõæÊ†áÊõøÊç¢ === */
			/* ÊèêÁ§∫: ‰Ω†ÈúÄË¶ÅÂ∞Ü‰Ω†ÁöÑSVG‰ª£Á†ÅËΩ¨Êç¢‰∏∫URLÁºñÁ†ÅÊ†ºÂºè„ÄÇ
			   ÂèØ‰ª•‰ΩøÁî®Âú®Á∫øÂ∑•ÂÖ∑ÊêúÁ¥¢ "SVG to Data URI" Êù•ÂÆåÊàêËΩ¨Êç¢„ÄÇ
			   ÁÑ∂ÂêéÊõøÊç¢Êéâ‰∏ãÈù¢ÁöÑ url('...') ÈÉ®ÂàÜ„ÄÇ */

			.chat-action-icon-btn {
			  background-color: rgba(255, 255, 255, 0.5); /* ÂõæÊ†áÊåâÈíÆÁöÑËÉåÊôØËâ≤ */
			  border: 1px solid rgba(0,0,0,0.05); /* ÂõæÊ†áÊåâÈíÆÁöÑËæπÊ°Ü */
			}

			/* Ë°®ÊÉÖÈù¢Êùø(+)ÊåâÈíÆ */
			#open-sticker-panel-btn svg { display: none; /* ÈöêËóèÂéüÂßãSVG */ }
			#open-sticker-panel-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* ÂèëÈÄÅÁÖßÁâá(Êóß)ÊåâÈíÆ */
			#send-photo-btn svg { display: none; /* ÈöêËóèÂéüÂßãSVG */ }
			#send-photo-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* ‰∏ä‰º†ÂõæÁâá(Êñ∞)ÊåâÈíÆ */
			#upload-image-btn svg { display: none; }
			#upload-image-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: black;"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* ËΩ¨Ë¥¶(Ôø•)ÊåâÈíÆ */
			#transfer-btn svg { display: none; }
			#transfer-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* ËØ≠Èü≥ÊåâÈíÆ */
			#voice-message-btn svg { display: none; }
			#voice-message-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* Â§ñÂçñÊåâÈíÆ */
			#send-waimai-request-btn svg { display: none; }
			#send-waimai-request-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* ËßÜÈ¢ëÈÄöËØùÊåâÈíÆ */
			#video-call-btn svg { display: none; }
			#video-call-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* Áæ§ËßÜÈ¢ëÈÄöËØùÊåâÈíÆ */
			#group-video-call-btn svg { display: none; }
			#group-video-call-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* ÊäïÁ•®ÊåâÈíÆ */
			#send-poll-btn svg { display: none; }
			#send-poll-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* ÂàÜ‰∫´ÈìæÊé•ÊåâÈíÆ */
			#share-link-btn svg { display: none; }
			#share-link-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}

			/* ÂèëÈÄÅÂÆö‰ΩçÊåâÈíÆ (Â∑≤‰øÆÂ§ç) */
			#send-location-btn svg { display: none; } /* ÈöêËóèÊåâÈíÆÂÜÖÈÉ®ÂéüÂßãÁöÑSVGÂõæÊ†á */
			#send-location-btn {
			  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>');
			  background-size: 60%;
			  background-position: center;
			  background-repeat: no-repeat;
			}


			/* === 6. Êõ¥Â§öÁïåÈù¢ËÉåÊôØËâ≤ === */
			/* ÈÄÇÁî®‰∫éÊâÄÊúâËÆæÁΩÆ„ÄÅÁºñËæë„ÄÅÈÄâÊã©Á≠â‰∫åÁ∫ßÈ°µÈù¢ */
			#api-settings-screen,
			#font-settings-screen,
			#wallpaper-screen,
			#world-book-screen,
			#world-book-editor-screen,
			#contact-picker-screen,
			#member-management-screen,
			#album-screen,
			#album-photos-screen,
			#call-history-screen,
			#chat-search-screen,
			#browser-screen {
			  /* ËøôÈáå‰∏çÂÜçËÆæÁΩÆËÉåÊôØËâ≤ÔºåËÆ©ÂÆÉËá™ÁÑ∂ÁªßÊâøÂ§úÈó¥Ê®°ÂºèÁöÑÈ¢úËâ≤ */
			}


			/* === 7. ÂõûÂøÜÂç°ÁâáÁæéÂåñ === */
			.memory-card {
			  background-color: #fffaf0 !important; /* Âç°Áâá‰∏ªËÉåÊôØËâ≤ */
			  border-left-color: #ffb74d !important; /* Â∑¶‰æßË£ÖÈ•∞Êù°È¢úËâ≤ */
			  box-shadow: 0 2px 6px rgba(0,0,0,0.07) !important;
			}
			.memory-card .header .author {
			  color: #d98100 !important; /* ‰ΩúËÄÖ/Ê†áÈ¢òÊñáÂ≠óÈ¢úËâ≤ */
			}
			.memory-card .header .date {
			  color: #a1887f !important; /* Êó•ÊúüÊñáÂ≠óÈ¢úËâ≤ */
			}
			.memory-card .content {
			  color: #5d4037 !important; /* ÂÜÖÂÆπÊñáÂ≠óÈ¢úËâ≤ */
			}
			`;

        const DEFAULT_APP_ICONS = {
          "world-book": "https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg",
          qq: "https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg",
          "api-settings": "https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg",
          wallpaper: "https://i.postimg.cc/T1j03pQr/IMG-6440.jpg",
          font: "https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg",
          "check-phone": "https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg",
          weibo: "https://i.postimg.cc/PqBY5wBq/weibo-icon.png",
          forum: "https://i.postimg.cc/pr0T3WfC/douban-icon.png",
          "lovers-space": "https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png",
          "game-hall": "https://i.postimg.cc/P5gL5z2g/game-controller-icon.png",
          "x-social": "https://i.postimg.cc/8P1H0vQ8/x-logo.png",
          taobao: "https://i.postimg.cc/k47tXg1j/taologo.png",
          "date-a-live": "https://i.postimg.cc/Kjdss1j9/1761142686734.png",
          "tukey-accounting": "https://i.postimg.cc/k4fZKVXP/tu-tu.png",
          "kk-checkin": "https://i.postimg.cc/MGwrL0nf/kitty.png",
          studio: "https://i.postimg.cc/W3sLz11s/clapperboard-icon.png",
        };

        const DEFAULT_APP_LABELS = {
          qq: "QQ",
          "world-book": "World Book",
          "api-settings": "API Settings",
          wallpaper: "Wallpaper",
          font: "Font",
          "check-phone": "Check Phone",
          weibo: "Weibo",
          forum: "Forum",
          "lovers-space": "Lovers Space",
          "game-hall": "Game Hall",
          "x-social": "X Social",
          taobao: "Taobao",
          "date-a-live": "Date-A-Live",
          "tukey-accounting": "Tukey Account",
          "kk-checkin": "kkCheckin",
          studio: "Studio",
        };
        const STICKER_REGEX =
          /^(data:image\/)|(https?:\/\/.*?\.(?:png|jpg|jpeg|gif|webp|svg|bmp|ico|tiff))|(https?:\/\/.*(?:catbox|postimg|imgbb|sinaimg|telegraph|wx[1-4])\..*)/i;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = {
          hasShown40: false,
          hasShown20: false,
          hasShown10: false,
        };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement("style");
        dynamicFontStyle.id = "dynamic-font-style";
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById("custom-modal-overlay");
        const modalTitle = document.getElementById("custom-modal-title");
        const modalBody = document.getElementById("custom-modal-body");
        const modalConfirmBtn = document.getElementById("custom-modal-confirm");
        const modalCancelBtn = document.getElementById("custom-modal-cancel");
        let modalResolve;

        function showCustomModal() {
          modalOverlay.classList.add("visible");
        }

        function hideCustomModal() {
          modalOverlay.classList.remove("visible");
          modalConfirmBtn.classList.remove("btn-danger");
          if (modalResolve) modalResolve(null);
        }

window.showCustomConfirm = function (title, message, options = {}) {
          return new Promise((resolve) => {
            modalResolve = resolve;
            modalTitle.textContent = title;
            modalBody.innerHTML = `<p>${message}</p>`;
            modalCancelBtn.style.display = "block";
            modalConfirmBtn.textContent = "Confirm";
            if (options.confirmButtonClass)
              modalConfirmBtn.classList.add(options.confirmButtonClass);
            modalConfirmBtn.onclick = () => {
              resolve(true);
              hideCustomModal();
            };
            modalCancelBtn.onclick = () => {
              resolve(false);
              hideCustomModal();
            };
            showCustomModal();
          });
        };

        window.showCustomAlert = function (title, message) {
          return new Promise((resolve) => {
            // 1. As long as the system wants to display a pop-up, the first thing is to turn off the loading animation!
            const loadingOverlay =
              document.getElementById("generation-overlay");
            if (loadingOverlay) {
              loadingOverlay.classList.remove("visible");
            }

            // 2. Normal pop-up logic
            modalResolve = resolve;
            modalTitle.textContent = title;
            modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
            modalCancelBtn.style.display = "none";
            modalConfirmBtn.textContent = "OK";

            // 3. Forcibly increase the pop-up layer to ensure it is above everything else
            document.getElementById("custom-modal-overlay").style.zIndex =
              "9999";

            modalConfirmBtn.onclick = () => {
              modalCancelBtn.style.display = "block";
              modalConfirmBtn.textContent = "Confirm";
              document.getElementById("custom-modal-overlay").style.zIndex = ""; // Restore layer level
              resolve(true);
              hideCustomModal();
            };
            showCustomModal();
          });
        };

        /**
         * „ÄêÂÖ®Êñ∞„Äë‰∏Ä‰∏™‰∏ìÈó®Ê∏ÖÈô§HTMLÊ†áÁ≠æÂíå‰ª£Á†ÅÁöÑÂáΩÊï∞
         * @param {string} text - ÂåÖÂê´HTMLÊàñ‰ª£Á†ÅÁöÑÂéüÂßãÊñáÊú¨
         * @returns {string} - Ê∏ÖÁêÜÂêéÁöÑÁ∫ØÊñáÊú¨
         */
        function stripHtmlAndCode(text) {
          if (!text || typeof text !== "string") {
            return ""; // Â¶ÇÊûúËæìÂÖ•‰∏∫Á©∫Êàñ‰∏çÊòØÂ≠óÁ¨¶‰∏≤ÔºåËøîÂõûÁ©∫Â≠óÁ¨¶‰∏≤
          }
          // 1. ÁßªÈô§ÊâÄÊúâHTMLÊ†áÁ≠æ (‰æãÂ¶Ç <b>, <div>)
          let cleanedText = text.replace(/<\/?[^>]+(>|$)/g, "");

          //2. Remove all Markdown code blocks (e.g., `code` or `code`).
          cleanedText = cleanedText.replace(/```[\s\S]*?```/g, ""); // Remove multi-line code blocks
          cleanedText = cleanedText.replace(/`[^`]*`/g, ""); // Remove inline code

          // 3. Â∞ÜHTMLÂÆû‰Ωì (‰æãÂ¶Ç &lt; &gt;) ËΩ¨Êç¢ÂõûÊ≠£Â∏∏Â≠óÁ¨¶ (< >)
          const tempDiv = document.createElement("div");
          tempDiv.innerHTML = cleanedText;

          return tempDiv.textContent || tempDiv.innerText || "";
        }

        window.showCustomPrompt = function (
          title,
          placeholder,
          initialValue = "",
          type = "text",
          extraHtml = "",
        ) {
          return new Promise((resolve) => {
            modalResolve = resolve;
            modalTitle.textContent = title;
            const inputId = "custom-prompt-input";

            const inputHtml =
              type === "textarea"
                ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
                : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;

            modalBody.innerHTML = extraHtml + inputHtml;
            const input = document.getElementById(inputId);

            modalBody.querySelectorAll(".format-btn").forEach((btn) => {
              btn.addEventListener("click", () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                  try {
                    const templateObj = JSON.parse(templateStr);
                    // ‰ΩøÁî® null, 2 ÂèÇÊï∞ËÆ©JSONÂ≠óÁ¨¶‰∏≤Ê†ºÂºèÂåñÔºåÂ∏¶Áº©ËøõÔºåÊõ¥ÊòìËØª
                    input.value = JSON.stringify(templateObj, null, 2);
                    input.focus();
                  } catch (e) {
                    console.error("Failed to parse format template:", e);
                  }
                }
              });
            });

            modalConfirmBtn.onclick = () => {
              resolve(input.value);
              hideCustomModal();
            };
            modalCancelBtn.onclick = () => {
              resolve(null);
              hideCustomModal();
            };
            document.getElementById("custom-modal-overlay").style.zIndex =
              "10005";
            showCustomModal();
            setTimeout(() => input.focus(), 100);
          });
        };

        /**
         * „ÄêÂÖ®Êñ∞„Äë‰ªé‰∏Ä‰∏™Êï∞ÁªÑ‰∏≠ÈöèÊú∫Ëé∑Âèñ‰∏Ä‰∏™ÂÖÉÁ¥†
         * @param {Array} arr - ÁõÆÊ†áÊï∞ÁªÑ
         * @returns {*} - Êï∞ÁªÑ‰∏≠ÁöÑ‰∏Ä‰∏™ÈöèÊú∫ÂÖÉÁ¥†
         */
        function getRandomItem(arr) {
          // ÂÆâÂÖ®Ê£ÄÊü•ÔºåÂ¶ÇÊûúÊï∞ÁªÑ‰∏∫Á©∫Êàñ‰∏çÂ≠òÂú®ÔºåËøîÂõûÁ©∫Â≠óÁ¨¶‰∏≤
          if (!arr || arr.length === 0) return "";
          // ËøîÂõû‰∏Ä‰∏™ÈöèÊú∫Á¥¢ÂºïÂØπÂ∫îÁöÑÂÖÉÁ¥†
          return arr[Math.floor(Math.random() * arr.length)];
        }

        // ===================================================================
        // 2. Êï∞ÊçÆÂ∫ìÁªìÊûÑÂÆö‰πâ
        // ===================================================================

        // main-app.js
        // === ‰øÆÊîπÂºÄÂßãÔºöÂä®ÊÄÅÊï∞ÊçÆÂ∫ì‰∏éÈ™åËØÅ ===
        var db; // Â£∞ÊòéÂÖ®Â±ÄÂèòÈáèÔºå‰ΩÜ‰∏çÂàùÂßãÂåñ
        const APP_SECRET = "EPHONE_2026_SUPER_SECRET_KEY_V1"; // ÂøÖÈ°ª‰∏éÊú∫Âô®‰∫∫‰∏ÄËá¥

        // HMAC-SHA256 È™åËØÅÂáΩÊï∞
        function verifyLogin(uid, pwd) {
          if (!uid || !pwd) return false;

          // 1. ËÆ°ÁÆó HMAC-SHA256 (ÂæóÂà∞ÂéüÂßãÊï∞ÊçÆ)
          const rawHash = CryptoJS.HmacSHA256(uid.trim(), APP_SECRET);

          // 2. ËΩ¨‰∏∫ Base64 Â≠óÁ¨¶‰∏≤ (Â§©ÁÑ∂ÂåÖÂê´Â§ßÂ∞èÂÜôÂ≠óÊØçÂíåÊï∞Â≠ó)
          let base64 = CryptoJS.enc.Base64.stringify(rawHash);

          // 3. Êà™ÂèñÂâç 12 ‰Ωç (Â¢ûÂä†ÈïøÂ∫¶)
          let generated = base64.substring(0, 12);

          // 4. Âº∫Âà∂ÊèíÂÖ•ÁâπÊÆäÁ¨¶Âè∑ (Â¢ûÂº∫Â§çÊùÇÂ∫¶)
          // Â∞ÜÂ≠óÁ¨¶‰∏≤ËΩ¨‰∏∫Êï∞ÁªÑËøõË°åÊõøÊç¢
          let chars = generated.split("");
          chars[2] = "@"; // Á¨¨3‰ΩçÂº∫Âà∂Âèò‰∏∫ @
          chars[7] = "!"; // Á¨¨8‰ΩçÂº∫Âà∂Âèò‰∏∫ !

          // ÈáçÊñ∞ÁªÑÂêà
          const correctPassword = chars.join("");

          // console.log("The correct password should be:", correctPassword); // For debugging purposes, you can comment it out for production deployment.
          return pwd.trim() === correctPassword;
        }

        // Âä®ÊÄÅÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìÂáΩÊï∞
        function initDatabase(userId) {
          // Êï∞ÊçÆÂ∫ìÂêçÂ∏¶‰∏äÁî®Êà∑IDÔºåÂÆûÁé∞ÊØè‰∏™‰∫∫Êï∞ÊçÆÈöîÁ¶ª
          db = new Dexie("GeminiChatDB");
          db.version(62).stores({
            // ÁâàÊú¨Âè∑‰ªé 51 ÂçáÁ∫ßÂà∞ 52
            chats:
              "&id, isGroup, groupId, ownerId, isPinned, characterPhoneData, latestInnerVoice, innerVoiceHistory, loversSpaceData.emotionDiaries, settings.summary, settings.weiboNickname, settings.innerVoiceHideHeaderBorder, settings.innerVoiceAdopterLabelFormat, interactionStats, unlockedSymbols, settings.selectedIntimacyBadge",
            apiConfig: "&id",
            globalSettings: "&id, activeThemeId",
            userStickers: "&id, url, name, categoryId",
            userStickerCategories: "++id, &name",
            charStickers: "&id, url, name",
            worldBooks: "&id, name, categoryId",
            worldBookCategories: "++id, name",
            musicLibrary: "&id",
            personaPresets: "&id",
            qzoneSettings: "&id",
            qzonePosts: "++id, authorId, timestamp",
            qzoneAlbums: "++id, name, createdAt",
            qzonePhotos: "++id, albumId",
            favorites: "++id, type, timestamp, originalTimestamp",
            qzoneGroups: "++id, name",
            memories: "++id, chatId, timestamp, type, targetDate",
            callRecords: "++id, chatId, timestamp, customName",
            customAvatarFrames: "&id, name, url",
            themes: "++id, name, css",
            apiPresets: "++id, name, proxyUrl",
            bubbleStylePresets: "++id, name, css",
            fontPresets: "&id, name, url",
            homeScreenPresets: "++id, name",
            weiboPosts: "++id, authorId, timestamp",
            forumGroups: "++id, name, worldview, *categories",
            forumPosts:
              "++id, groupId, timestamp, *categories, seriesId, lengthType, chapterIndex",
            forumComments: "++id, postId, timestamp",
            forumCategories: "++id, name",
            forumSeries:
              "++id, groupId, isFollowed, updatedAt, bookshelfAddedAt",
            forumChapters: "++id, seriesId, chapterIndex, createdAt, postId",
            tarotReadings: "++id, timestamp",
            pomodoroSessions: "++id, chatId, startTime",
            scriptKillScripts: "++id, name, isBuiltIn",
            taobaoProducts: "++id, name, category",
            taobaoOrders: "++id, productId, timestamp",
            taobaoCart: "++id, productId",
            userWalletTransactions: "++id, timestamp",
            charPhonePresets: "++id, name",
            ludoQuestionBanks: "++id, name",
            ludoQuestions: "++id, bankId, text, type",
            datingScenes: "&uid, imageUrl",
            datingPresets: "++id, name, settings.spriteGroupId",
            datingSpriteGroups: "++id, name",
            datingSprites: "++id, groupId, description, url",
            datingHistory: "++id, characterId, timestamp",
            offlinePresets: "++id, name",
            elemeFoods: "++id, name, category",
            elemeOrders: "++id, recipientId, timestamp",
            studioScripts: "++id, name",
            studioHistory: "++id, timestamp",
            tukeyAccounts: "++id, category, type", // ËøôÊòØ‰Ω†Â∑≤ÊúâÁöÑÔºå‰øùÊåÅ‰∏çÂèò
            tukeyAccountingGroups: "&id", // ËÆ∞Ë¥¶Áæ§ËÅäËÆæÁΩÆ (id, name, members, replySettings)
            tukeyAccountingRecords:
              "++id, groupId, timestamp, isRepliedTo, accountId",
            tukeyAccountingReplies: "++id, recordId, charId", // AIÁöÑÂõûÂ§çËÆ∞ÂΩï
            tukeyUserSettings: "&id",
            tukeyCustomConfig: "&id",
            auroraBooks: "++id, title, content, addedAt",
            passerbyAvatars: "++id, url",
            clawMachineDolls: "++id, url",
          });
          // Âà∞ËøôÈáåÂä†‰∏ãÈù¢‰∏âË°å
          window.db = db;
console.log(`[System] Database for user ${userId} has been loaded`);
        }
        // === ‰øÆÊîπÁªìÊùü ===

        // ===================================================================
        // 3. ÊâÄÊúâÂäüËÉΩÂáΩÊï∞ÂÆö‰πâ
        // ===================================================================

        /**
         * ÂàáÊç¢ËØ≠Èü≥Ê∂àÊÅØÁöÑÊñáÂ≠óÊòæÁ§∫/ÈöêËóè
         * @param {HTMLElement} bubble - Ë¢´ÁÇπÂáªÁöÑËØ≠Èü≥Ê∂àÊÅØÁöÑ .message-bubble ÂÖÉÁ¥†
         */
        function toggleVoiceTranscript(bubble) {
          if (!bubble) return;

          const transcriptEl = bubble.querySelector(".voice-transcript");
          if (!transcriptEl) return;

          // Ê†∏ÂøÉÈÄªËæëÔºöÁõ¥Êé•Ê£ÄÊü•ÊñáÂ≠óÂå∫ÂüüÂΩìÂâçÊòØ‰∏çÊòØÊòæÁ§∫Áä∂ÊÄÅ
          const isCurrentlyExpanded = transcriptEl.style.display === "block";

          if (isCurrentlyExpanded) {
            // Â¶ÇÊûúÊòØÂ±ïÂºÄÁöÑÔºåÂ∞±Áõ¥Êé•Êî∂Ëµ∑Êù•
            transcriptEl.style.display = "none";
          } else {
            // Â¶ÇÊûúÊòØÊî∂Ëµ∑ÁöÑÔºåÂ∞±ÊâßË°åÂ±ïÂºÄÊµÅÁ®ã

            // 1. ÂÖàÊòæÁ§∫‰∏Ä‰∏™‚ÄúÊ≠£Âú®ËΩ¨ÂÜô‚ÄùÁöÑÊèêÁ§∫ÔºåÁªôÁî®Êà∑Âç≥Êó∂ÂèçÈ¶à
            transcriptEl.textContent = "Converting to text...";
            transcriptEl.style.display = "block";

            // 2. Ê®°Êãü‰∏Ä‰∏™Áü≠ÊöÇÁöÑ‚ÄúËØÜÂà´‚ÄùËøáÁ®ã
            setTimeout(() => {
              // ÂÜçÊ¨°Ê£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶ËøòÂú®È°µÈù¢‰∏äÔºåÈò≤Ê≠¢Áî®Êà∑ÂàáÊç¢ËÅäÂ§©ÂØºËá¥ÈîôËØØ
              if (document.body.contains(transcriptEl)) {
                // Ëé∑ÂèñÂπ∂ÊòæÁ§∫ÁúüÊ≠£ÁöÑËΩ¨ÂÜôÊñáÂ≠ó
                const voiceText = bubble.dataset.voiceText || "(Unrecognized)";
                transcriptEl.textContent = voiceText;
              }
            }, 300); // 300ÊØ´ÁßíÁöÑÂª∂ËøüÔºåÊÑüËßâÊõ¥ÁÅµÊïè
          }
        }

        /**
         * „ÄêV2Êô∫ËÉΩÁâà„ÄëÂ∫îÁî®ÊåáÂÆöÁöÑ‰∏ªÈ¢òÔºåÂπ∂Êô∫ËÉΩÂà∑Êñ∞ÂΩìÂâçÊâìÂºÄÁöÑ‰ªª‰ΩïÁïåÈù¢
         * @param {string} theme - 'light' or 'dark'
         */
        function applyTheme(theme) {
          const phoneScreen = document.getElementById("phone-screen");
          const toggleSwitch = document.getElementById("theme-toggle-switch");

          const isDark = theme === "dark";

          // Ê†∏ÂøÉÊìç‰ΩúÔºö‰∏∫ÊâãÊú∫Â±èÂπïÊ∑ªÂä†ÊàñÁßªÈô§ .dark-mode Á±ª
          phoneScreen.classList.toggle("dark-mode", isDark);

          // ÂêåÊ≠•ÂºÄÂÖ≥ÁöÑÁä∂ÊÄÅ
          if (toggleSwitch) {
            toggleSwitch.checked = isDark;
          }

          // ‰øùÂ≠òÁî®Êà∑ÁöÑÈÄâÊã©
          localStorage.setItem("ephone-theme", theme);

          // ‰∏çÂÜçÂè™ÂÖ≥ÂøÉËÅäÂ§©ÁïåÈù¢ÔºåËÄåÊòØÊâæÂá∫ÂΩìÂâçÁ©∂Á´üÊòØÂì™‰∏™ÁïåÈù¢Â§Ñ‰∫éÊøÄÊ¥ªÁä∂ÊÄÅ
          const activeScreen = document.querySelector(".screen.active");
          if (!activeScreen) return; // Â¶ÇÊûúÊâæ‰∏çÂà∞ÔºåÂ∞±ÈÄÄÂá∫

          // Ê†πÊçÆÂΩìÂâçÊøÄÊ¥ªÁöÑÁïåÈù¢IDÔºåË∞ÉÁî®ÂÆÉ‰∏ìÂ±ûÁöÑÂà∑Êñ∞ÂáΩÊï∞
          switch (activeScreen.id) {
            case "chat-interface-screen":
              if (state.activeChatId) {
                renderChatInterface(state.activeChatId);
              }
              break;
            case "wallpaper-screen":
              // Â§ñËßÇËÆæÁΩÆÈ°µ‰πüÈúÄË¶ÅÈáçÊñ∞Ê∏≤ÊüìÊù•Â∫îÁî®Êñ∞‰∏ªÈ¢ò
              renderWallpaperScreen();
              break;
            case "font-settings-screen":
              // Â≠ó‰ΩìÈ¢ÑËÆæÈ°µÂêåÊ†∑ÈúÄË¶Å
              renderFontPresets();
              break;
            // Â¶ÇÊûúÊú™Êù•ËøòÊúâÂÖ∂‰ªñÈ°µÈù¢ÈúÄË¶ÅÈÄÇÈÖçÔºåÂú®ËøôÈáåÊ∑ªÂä† case Âç≥ÂèØ
          }
        }

        /**
         * ÂΩìÁî®Êà∑ÁÇπÂáªÂºÄÂÖ≥Êó∂ÔºåÂàáÊç¢ÂΩìÂâçÁöÑ‰∏ªÈ¢ò
         */
        function toggleTheme() {
          const toggleSwitch = document.getElementById("theme-toggle-switch");
          // Áõ¥Êé•Ê†πÊçÆÂºÄÂÖ≥ÁöÑÈÄâ‰∏≠Áä∂ÊÄÅÊù•ÂÜ≥ÂÆöÊñ∞‰∏ªÈ¢ò
          const newTheme = toggleSwitch.checked ? "dark" : "light";
          applyTheme(newTheme);
        }
        /**
         * „ÄêÂÖ®Êñ∞„ÄëÂú®Â∫îÁî®ÂêØÂä®Êó∂ÔºåÈ¢ÑÂä†ËΩΩÊâÄÊúâÂ∑≤‰øùÂ≠òÁöÑÂ≠ó‰ΩìÈ¢ÑËÆæ
         */
        async function loadAllFontPresetsOnStartup() {
          console.log("Preloading all font presets...");
          const presets = await db.fontPresets.toArray();
          if (presets && presets.length > 0) {
            presets.forEach((preset) => {
              // Êàë‰ª¨Â§çÁî®Â∑≤ÊúâÁöÑ loadFontForPreview ÂáΩÊï∞Êù•Âä†ËΩΩÊØè‰∏™Â≠ó‰Ωì
              loadFontForPreview(preset);
            });
            console.log(`Successfully preloaded ${presets.length} font presets.`);
          }
        }

        /**
         * Ê∏≤ÊüìÂ≠ó‰ΩìÈ¢ÑËÆæÁöÑ10‰∏™Âç°ÊßΩ
         */
        async function renderFontPresets() {
          const container = document.getElementById("font-preset-container");
          container.innerHTML = ""; // Ê∏ÖÁ©∫ÊóßÂÜÖÂÆπ

          // 1. ‰ªéÊï∞ÊçÆÂ∫ìËØªÂèñÊâÄÊúâÂ∑≤‰øùÂ≠òÁöÑÈ¢ÑËÆæÔºåÂπ∂Á°Æ‰øùÂÆÉÊòØ‰∏Ä‰∏™Êï∞ÁªÑ
          const presets = (await db.fontPresets.toArray()) || [];

          // Êàë‰ª¨‰∏çÂÜç‰æùËµñ presets ÁöÑÈïøÂ∫¶Êù•Âæ™ÁéØÔºåËÄåÊòØÊó†Êù°‰ª∂Âú∞Âæ™ÁéØ10Ê¨°ÔºåÂàõÂª∫10‰∏™Âç°ÊßΩ„ÄÇ
          for (let i = 0; i < 10; i++) {
            const slot = document.createElement("div");
            slot.className = "font-preset-slot";

            // 3. Âú®Âæ™ÁéØÂÜÖÈÉ®ÔºåÂÜçÂà§Êñ≠ÂΩìÂâçÁ¥¢Âºï i ÊòØÂê¶Âú®Â∑≤‰øùÂ≠òÁöÑ presets Êï∞ÁªÑ‰∏≠ÊúâÂØπÂ∫îÁöÑÊï∞ÊçÆ„ÄÇ
            const preset = presets[i];

            if (preset) {
              // Â¶ÇÊûúËøô‰∏™Âç°ÊßΩÊúâÊï∞ÊçÆÔºåÂ∞±Ê∏≤ÊüìÊàê‚ÄúÂ∑≤Â°´ÂÖÖ‚ÄùÁöÑÊ†∑Âºè
              slot.innerHTML = `
			                <div class="font-preview-text" data-preset-id="${preset.id}">Abc ‰Ω†Â•Ω</div>
			                <div class="font-preset-info">Name: ${preset.name}</div>
			                <div class="font-preset-actions">
			                    <button class="preset-btn apply-btn" data-preset-id="${preset.id}">Apply</button>
			                    <button class="preset-btn delete-btn delete" data-preset-id="${preset.id}">Delete</button>
			                </div>
			            `;
            } else {
              // Â¶ÇÊûúËøô‰∏™Âç°ÊßΩÂú®Êï∞ÊçÆÂ∫ì‰∏≠Ê≤°ÊúâÂØπÂ∫îÁöÑÊï∞ÊçÆÔºåÂ∞±Ê∏≤ÊüìÊàê‚ÄúÁ©∫Âç°ÊßΩ‚ÄùÁöÑÊ†∑Âºè
              slot.classList.add("empty");
              slot.innerHTML = `
			                <div class="font-preset-info">Slot ${i + 1} is empty</div>
			                <div class="font-preset-actions">
			                    <button class="preset-btn secondary upload-url-btn" data-slot-index="${i}">Upload via URL</button>
			                    <button class="preset-btn secondary upload-local-btn" data-slot-index="${i}">Upload from Local</button>
			                </div>
			            `;
            }
            // 4. Â∞ÜÂàõÂª∫Â•ΩÁöÑÂç°ÊßΩÔºàÊó†ËÆ∫Á©∫ÁöÑËøòÊòØÊª°ÁöÑÔºâÊ∑ªÂä†Âà∞ÂÆπÂô®‰∏≠
            container.appendChild(slot);
          }

          // 5. È¢ÑËßàÂ≠ó‰ΩìÂíåÁªëÂÆö‰∫ã‰ª∂ÁöÑÈÄªËæë‰øùÊåÅ‰∏çÂèò
          presets.forEach((preset) => {
            if (preset) {
              loadFontForPreview(preset);
            }
          });

          addFontPresetButtonListeners();
        }

        /**
         * ‰∏∫Âçï‰∏™È¢ÑËÆæÂä†ËΩΩÂ≠ó‰Ωì‰ª•‰æõÈ¢ÑËßà
         * @param {object} preset - Â≠ó‰ΩìÈ¢ÑËÆæÂØπË±° {id, name, url}
         */
        function loadFontForPreview(preset) {
          const styleId = `font-style-${preset.id}`;
          if (document.getElementById(styleId)) return;

          const style = document.createElement("style");
          style.id = styleId;

          // Áõ¥Êé•ÂàõÂª∫‰∏ÄÊù°È´ò‰ºòÂÖàÁ∫ßÁöÑCSSËßÑÂàôÊù•Â∫îÁî®Â≠ó‰Ωì
          style.innerHTML = `
			        @font-face {
			            font-family: 'preset-${preset.id}';
			            src: url('${preset.url}');
			            font-display: swap;
			        }

			        .font-preview-text[data-preset-id="${preset.id}"] {
			            font-family: 'preset-${preset.id}', sans-serif !important;
			        }
			    `;

          document.head.appendChild(style);
        }

        /**
         * ‰∏∫È¢ÑËÆæÂç°ÊßΩ‰∏≠ÁöÑÊâÄÊúâÊåâÈíÆÁªü‰∏ÄÊ∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨Âô®
         */
        function addFontPresetButtonListeners() {
          document.querySelectorAll(".upload-url-btn").forEach((btn) => {
            btn.onclick = () =>
              handleUploadFontUrl(parseInt(btn.dataset.slotIndex));
          });
          document.querySelectorAll(".upload-local-btn").forEach((btn) => {
            btn.onclick = () =>
              handleUploadFontLocal(parseInt(btn.dataset.slotIndex));
          });
          document.querySelectorAll(".apply-btn").forEach((btn) => {
            btn.onclick = () => applyFontPreset(btn.dataset.presetId);
          });
          document.querySelectorAll(".delete-btn").forEach((btn) => {
            btn.onclick = () => deleteFontPreset(btn.dataset.presetId);
          });
        }

        /**
         * Â§ÑÁêÜÈÄöËøáURL‰∏ä‰º†Â≠ó‰Ωì
         * @param {number} slotIndex - Âç°ÊßΩÁöÑÁ¥¢Âºï (0-4)
         */
        async function handleUploadFontUrl(slotIndex) {
          const url = await showCustomPrompt(
            "Font URL",
            "Please enter the font's web link (.ttf, .otf, etc.)",
          );
          if (!url || !url.trim().startsWith("http")) {
            if (url !== null) alert("Please enter a valid URL!");
            return;
          }
          const name = await showCustomPrompt(
            "Font Name",
            "Please enter a name for this font",
          );
          if (!name || !name.trim()) {
            if (name !== null) alert("Name cannot be empty!");
            return;
          }
          await saveFontPreset(slotIndex, name.trim(), url.trim());
        }

        /**
         * Â§ÑÁêÜÈÄöËøáÊú¨Âú∞Êñá‰ª∂‰∏ä‰º†Â≠ó‰Ωì
         * @param {number} slotIndex - Âç°ÊßΩÁöÑÁ¥¢Âºï (0-4)
         */
        function handleUploadFontLocal(slotIndex) {
          const input = document.getElementById("font-preset-local-upload");
          input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const name = await showCustomPrompt(
              "Font Name",
              "Please enter a name for this font",
              file.name.replace(/\.[^/.]+$/, ""),
            );
            if (!name || !name.trim()) {
              if (name !== null) alert("Name cannot be empty!");
              return;
            }

            // ‰ΩøÁî®FileReaderÂ∞ÜÂ≠ó‰ΩìÊñá‰ª∂ËΩ¨‰∏∫Base64 Data URL
            const reader = new FileReader();
            reader.onload = async (event) => {
              await saveFontPreset(slotIndex, name.trim(), event.target.result);
            };

            reader.readAsDataURL(file);
          };
          input.click(); // Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©Ê°Ü
        }
        async function saveFontPreset(slotIndex, name, url) {
          try {
            const presets = await db.fontPresets.toArray();
            const newPreset = { id: "font_" + Date.now(), name, url };
            presets.splice(slotIndex, 0, newPreset);

            // Â∞Ü slice(0, 5) ‰øÆÊîπ‰∏∫ slice(0, 10)
            const presetsToSave = presets.slice(0, 10);

            await db.transaction("rw", db.fontPresets, async () => {
              await db.fontPresets.clear();
              await db.fontPresets.bulkPut(presetsToSave);
            });

            await renderFontPresets();
            alert(`Font "${name}" has been successfully saved to slot ${slotIndex + 1}!`);
          } catch (error) {
            console.error("Failed to save font preset:", error);
            alert(
              `Failed to save font, data has been automatically rolled back, your previous font data is safe. Error: ${error.message}`,
            );
            await renderFontPresets();
          }
        }

        /**
         * Âà†Èô§‰∏Ä‰∏™Â≠ó‰ΩìÈ¢ÑËÆæ
         * @param {string} presetId - Ë¶ÅÂà†Èô§ÁöÑÈ¢ÑËÆæÁöÑID
         */
        async function deleteFontPreset(presetId) {
          const preset = await db.fontPresets.get(presetId);
          if (!preset) return;
          const confirmed = await showCustomConfirm(
            "Confirm Deletion",
            `Are you sure you want to delete the font "${preset.name}"?`,
            {
              confirmButtonClass: "btn-danger",
            },
          );
          if (confirmed) {
            await db.fontPresets.delete(presetId);

            // Remove the corresponding preview style from the DOM
            const styleTag = document.getElementById(`font-style-${presetId}`);
            if (styleTag) styleTag.remove();

            await renderFontPresets();
          }
        }

        /**
         * Apply a font preset as the global font
         * @param {string} presetId - The ID of the preset to apply
         */
        async function applyFontPreset(presetId) {
          const preset = await db.fontPresets.get(presetId);
          if (preset) {
            // Call your existing global font application function
            applyCustomFont(preset.url, false);
            // Save to global settings
            state.globalSettings.fontUrl = preset.url;
            await db.globalSettings.put(state.globalSettings);
            alert(`The global font has been changed to "${preset.name}"!`);
          }
        }

        /**
         * Handle user-selected character card files
         * @param {File} file - The file object selected by the user
         */
        async function handleCharacterImport(file) {
          if (!file) return;

          try {
            let characterData;
            let avatarBase64;

            if (file.name.toLowerCase().endsWith(".png")) {
              // If it's a PNG file, call the PNG parsing function
              const result = await parseCharPng(file);
              characterData = result.characterData;
              avatarBase64 = result.avatarBase64;
            } else if (file.name.toLowerCase().endsWith(".json")) {
              // If it's a JSON file, call the JSON parsing function
              characterData = await parseCharJson(file);
              // JSON cards usually don't contain images, so we provide a default avatar
              avatarBase64 = defaultAvatar;
            } else {
              alert("Unsupported file format. Please select a .png or .json file.");
              return;
            }

            if (characterData) {
              // After successfully parsing the data, call the creation function
              await createCharacterFromData(characterData, avatarBase64);
            }
          } catch (error) {
            console.error("Failed to import character card:", error);
            alert(`Failed to import character card: ${error.message}`);
          }
        }

        /**
         * Parse SillyTavern's PNG character card, completely solving Chinese garbled characters through byte-level operations.
         * @param {File} file - PNG file
         * @returns {Promise<{characterData: object, avatarBase64: string}>}
         */
        async function parseCharPng(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              const arrayBuffer = e.target.result;
              const dataView = new DataView(arrayBuffer);

              if (
                dataView.getUint32(0) !== 0x89504e47 ||
                dataView.getUint32(4) !== 0x0d0a1a0a
              ) {
                return reject(new Error("The file is not a valid PNG image."));
              }

              let offset = 8;
              let characterJson = null;

              while (offset < dataView.byteLength) {
                const length = dataView.getUint32(offset);
                const type = String.fromCharCode(
                  dataView.getUint8(offset + 4),
                  dataView.getUint8(offset + 5),
                  dataView.getUint8(offset + 6),
                  dataView.getUint8(offset + 7),
                );

                if (type === "tEXt") {
                  const chunkData = new Uint8Array(
                    arrayBuffer,
                    offset + 8,
                    length,
                  );

                  // 1. ÂÖàÁî®‰∏Ä‰∏™ÁÆÄÂçïÁöÑÁºñÁ†ÅÂ∞ÜÂ≠óËäÇËΩ¨‰∏∫Â≠óÁ¨¶‰∏≤Ôºå‰ª•‰æøÊü•ÊâæÂÖ≥ÈîÆÂ≠ó "chara"
                  let text = "";
                  for (let i = 0; i < chunkData.length; i++) {
                    text += String.fromCharCode(chunkData[i]);
                  }

                  // 2. Ê£ÄÊü•ÂÖ≥ÈîÆÂ≠óÊòØÂê¶Â≠òÂú®
                  const keyword = "chara" + String.fromCharCode(0);
                  if (text.startsWith(keyword)) {
                    // 3. ÊèêÂèñÂá∫ÂÖ≥ÈîÆÂ≠óÂêéÈù¢ÁöÑ Base64 ÁºñÁ†ÅÁöÑÂ≠óÁ¨¶‰∏≤
                    const base64Data = text.substring(keyword.length);
                    try {
                      // 4. ‰ΩøÁî® atob() Ëß£Á†Å Base64ÔºåÂæóÂà∞‰∏Ä‰∏™‚Äú‰∫åËøõÂà∂Â≠óÁ¨¶‰∏≤‚Äù
                      const binaryString = atob(base64Data);

                      // 5. Â∞ÜËøô‰∏™‚Äú‰∫åËøõÂà∂Â≠óÁ¨¶‰∏≤‚ÄùÈáçÊñ∞ËΩ¨Êç¢‰∏∫ÂéüÂßãÁöÑ UTF-8 Â≠óËäÇÊï∞ÁªÑ
                      const bytes = new Uint8Array(binaryString.length);
                      for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                      }

                      // 6. ‰ΩøÁî® TextDecoder Â∞ÜËøô‰∏™Á∫ØÂáÄÁöÑ UTF-8 Â≠óËäÇÊï∞ÁªÑËß£Á†Å‰∏∫Ê≠£Á°ÆÁöÑÂ≠óÁ¨¶‰∏≤
                      const decodedJsonString = new TextDecoder("utf-8").decode(
                        bytes,
                      );

                      // 7. Ëß£ÊûêÊúÄÁªàÁöÑJSONÂ≠óÁ¨¶‰∏≤
                      characterJson = JSON.parse(decodedJsonString);
                      break;
                    } catch (e) {
                      return reject(
                        new Error(
                          "Failed to parse the character data embedded in the image. The data may be corrupted.",
                        ),
                      );
                    }
                  }
                }

                if (type === "IEND") break;
                offset += 12 + length;
              }

              if (characterJson) {
                const imageReader = new FileReader();
                imageReader.onload = (imgEvent) => {
                  resolve({
                    characterData: characterJson,
                    avatarBase64: imgEvent.target.result,
                  });
                };
                imageReader.onerror = () =>
                  reject(new Error("Failed to read image as avatar."));
                imageReader.readAsDataURL(file);
              } else {
                reject(
                  new Error("No SillyTavern character data found in this PNG image."),
                );
              }
            };
            reader.onerror = () => reject(new Error("Failed to read PNG file."));
            reader.readAsArrayBuffer(file);
          });
        }

        /**
         * „Äê‰øÆÊ≠£Áâà„ÄëËß£ÊûêJSONËßíËâ≤Âç°ÔºåÂº∫Âà∂‰ΩøÁî®UTF-8ÁºñÁ†Å
         * @param {File} file - JSON file
         * @returns {Promise<object>}
         */
        async function parseCharJson(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                // ÂÖàËØªÂèñ‰∏∫ArrayBufferÔºåÂÜçÁî®TextDecoderÊåáÂÆöUTF-8Ëß£Á†Å
                const arrayBuffer = e.target.result;
                const textDecoder = new TextDecoder("utf-8");
                const jsonString = textDecoder.decode(arrayBuffer);
                const data = JSON.parse(jsonString);
                // ÂÖºÂÆπ‰∏§ÁßçÂèØËÉΩÁöÑÊ†ºÂºè
                resolve(data.data || data);
              } catch (error) {
                reject(new Error("Failed to parse JSON file. Please check the file format or encoding."));
              }
            };
            reader.onerror = () => reject(new Error("Failed to read JSON file."));
            // ËØªÂèñ‰∏∫ArrayBufferËÄå‰∏çÊòØText
            reader.readAsArrayBuffer(file);
          });
        }

        /**
         * Ê†πÊçÆËß£ÊûêÂá∫ÁöÑÊï∞ÊçÆÂàõÂª∫Êñ∞ËßíËâ≤Âíå‰∏ñÁïå‰π¶„ÄÇ
         * Ëøô‰∏™ÁâàÊú¨Â∞Ü‰ºòÂÖàÊü•ÊâæÊÇ®Êèê‰æõÁöÑ character_book Ê†áÂáÜÊ†ºÂºè„ÄÇ
         * @param {object} data - ‰ªéÂç°ÁâáËß£ÊûêÂá∫ÁöÑÊúÄÂéüÂßãÁöÑJSONÊï∞ÊçÆ
         * @param {string} avatarBase64 - ËßíËâ≤ÁöÑÂ§¥ÂÉèÂõæÁâá (Base64)
         */
        async function createCharacterFromData(data, avatarBase64) {
          // Ê≠•È™§ 1: Á°ÆÂÆöÊ†∏ÂøÉËßíËâ≤Êï∞ÊçÆ (‰∏çÂèò)
          const charData = data.data || data;
          const characterName = charData.name
            ? charData.name.trim()
            : "Unnamed Character";

          // Ê≠•È™§ 2: ÂàõÂª∫Êñ∞ÁöÑËÅäÂ§©ÂØπË±° (‰∏çÂèò)
          const newChatId = "chat_" + Date.now();

          const newChat = {
            id: newChatId,
            name: characterName,
            isGroup: false,
            isPinned: false,
            history: [],
            unreadCount: 0,
            musicData: { totalTime: 0 },
            npcLibrary: [],
            relationship: {
              status: "friend",
              blockedTimestamp: null,
              applicationReason: "",
            },
            status: { text: "Online", lastUpdate: Date.now(), isBusy: false },
            weiboDms: [],
            loversSpaceData: null,
            settings: {
              aiPersona: charData.description || "This character has no description.",
              myPersona: "Who am I?",
              maxMemory: 10,
              aiAvatar: avatarBase64,
              myAvatar: defaultAvatar,
              background: "",
              theme: "default",
              fontSize: 13,
              customCss: "",
              linkedWorldBookIds: [],
              aiAvatarLibrary: [],
              stickerLibrary: [],
              summary: {
                enabled: false,
                mode: "auto",
                count: 20,
                prompt:
                  "Using Vietnamese language to summarize the core events and information of the following conversation from a third-person perspective, objectively, calmly, and without any emotional bias. Do not engage in any role-playing or add any subjective comments.",
                lastSummaryIndex: -1,
              },
              linkedMemories: [],
              offlineMode: {
                enabled: false,
                prompt: "",
                style: "",
                wordCount: 300,
                presets: [],
              },
              timePerceptionEnabled: true,
              customTime: "",
              isCoupleAvatar: false,
              coupleAvatarDescription: "",
              weiboProfession: "",
              weiboInstruction: "",
              visualVideoCallEnabled: false,
              charVideoImage: "",
              userVideoImage: "",
              videoCallVoiceAccess: false,
              petAdopted: false,
              pet: null,
            },
            characterPhoneData: {
              lastGenerated: null,
              chats: {},
              shoppingCart: [],
              memos: [],
              browserHistory: [],
              photoAlbum: [],
              bank: { balance: 0, transactions: [] },
              trajectory: [],
              appUsage: [],
              diary: [],
            },
          };

          await db.chats.put(newChat);
          state.chats[newChatId] = newChat;

          // ÈáçÊûÑ‰∏ñÁïå‰π¶Êü•ÊâæÈÄªËæë
          console.log("Checking World Book data...");
          let worldBookFound = false;

          // Á≠ñÁï•‰∏ÄÔºö„ÄêÊúÄÈ´ò‰ºòÂÖàÁ∫ß„ÄëÊü•ÊâæÊèê‰æõÁöÑ character_book Ê†áÂáÜÊ†ºÂºè
          if (
            charData.character_book &&
            charData.character_book.entries &&
            Array.isArray(charData.character_book.entries) &&
            charData.character_book.entries.length > 0
          ) {
            console.log(
              `Detected the latest character_book format (${charData.character_book.entries.length} entries), starting import...`,
            );
            const newCategory = { name: characterName };
            const newCategoryId = await db.worldBookCategories.add(newCategory);

            await saveWorldBookEntriesFromArray(
              charData.character_book.entries,
              newCategoryId,
            );
            worldBookFound = true;
          }

          // Á≠ñÁï•‰∫åÔºöÂÖºÂÆπÊóßÁöÑ world_entries Ê†ºÂºè
          else if (
            charData.world_entries &&
            Array.isArray(charData.world_entries) &&
            charData.world_entries.length > 0
          ) {
            console.log(
              `Detected the old world_entries format (${charData.world_entries.length} entries), starting import...`,
            );
            const newCategory = { name: characterName };
            const newCategoryId = await db.worldBookCategories.add(newCategory);
            await saveWorldBookEntriesFromArray(
              charData.world_entries,
              newCategoryId,
            );
            worldBookFound = true;
          }

          // Á≠ñÁï•‰∏âÔºöÂÖºÂÆπÊõ¥ÊóßÁöÑ data.world Ê†ºÂºè
          else if (
            data.world &&
            typeof data.world === "string" &&
            data.world.trim()
          ) {
            console.log("Detected outer world field format, starting import...");
            const newCategory = { name: characterName };
            const newCategoryId = await db.worldBookCategories.add(newCategory);
            await parseAndSaveWorldBooks(data.world, newCategoryId);
            worldBookFound = true;
          }

          // Á≠ñÁï•ÂõõÔºöÊúÄÂêéÁöÑÂÖºÂÆπÊâãÊÆµ world_info
          else if (
            charData.world_info &&
            typeof charData.world_info === "string" &&
            charData.world_info.trim()
          ) {
            console.log("Detected old world_info field format, starting import...");
            const newCategory = { name: characterName };
            const newCategoryId = await db.worldBookCategories.add(newCategory);
            await parseAndSaveWorldBooks(charData.world_info, newCategoryId);
            worldBookFound = true;
          }

          if (!worldBookFound) {
            console.log("Diagnosis: No recognizable World Book fields found in this character card.");
          }

          // Step 4: Refresh UI (unchanged)
          await renderChatList();
          await showCustomAlert(
            "Import Successful!",
            `Character "${characterName}" has been successfully created!`,
          );
        }

        /**
         * ‰ªéSillyTavernÁöÑ world_entries Êàñ character_book.entries Êï∞ÁªÑÁõ¥Êé•ÂàõÂª∫‰∏ñÁïå‰π¶
         * @param {Array<object>} entriesArray - ÂåÖÂê´‰∏ñÁïå‰π¶Êù°ÁõÆÁöÑÊï∞ÁªÑ
         * @param {number} categoryId - Ëøô‰∫õ‰∏ñÁïå‰π¶ÊâÄÂ±ûÁöÑÂàÜÁ±ªID
         */
        async function saveWorldBookEntriesFromArray(entriesArray, categoryId) {
          const newBooks = [];

          for (const entry of entriesArray) {
            // ‰ºòÂÖà‰ΩøÁî® comment Â≠óÊÆµ‰Ωú‰∏∫Ê†áÈ¢òÔºåÂ¶ÇÊûúÂÆÉÂ≠òÂú®‰∏î‰∏ç‰∏∫Á©∫„ÄÇ
            // Âê¶ÂàôÔºåÂÜçÂ∞ùËØï‰ΩøÁî® keys Êï∞ÁªÑ„ÄÇ
            // Â¶ÇÊûúÈÉΩÊ≤°ÊúâÔºåÂ∞±Áªô‰∏Ä‰∏™ÈªòËÆ§ÂêçÂ≠ó„ÄÇ
            const entryName =
              entry.comment && entry.comment.trim()
                ? entry.comment.trim()
                : entry.keys && entry.keys.length > 0
                  ? entry.keys.join(", ")
                  : "Unnamed Entry";

            // Ê£ÄÊü•Êù°ÁõÆÊòØÂê¶ÊúâÊïà (ÊúâÂêçÂ≠ó„ÄÅÊúâÂÜÖÂÆπÔºåÂπ∂‰∏îÊòØÂêØÁî®ÁöÑ)
            // (typeof entry.enabled === 'undefined' || entry.enabled) ÊòØ‰∏∫‰∫ÜÂÖºÂÆπÊ≤°Êúâ enabled Â≠óÊÆµÁöÑÂç°Áâá
            if (
              entryName !== "Unnamed Entry" &&
              entry.content &&
              (typeof entry.enabled === "undefined" || entry.enabled)
            ) {
              newBooks.push({
                id: "wb_" + Date.now() + Math.random(),
                name: entryName, // ‰ΩøÁî®Êàë‰ª¨Êô∫ËÉΩËé∑ÂèñÂà∞ÁöÑÂêçÂ≠ó
                content: entry.content,
                categoryId: categoryId,
              });
            }
          }

          if (newBooks.length > 0) {
            await db.worldBooks.bulkAdd(newBooks);
            // Á°Æ‰øù state.worldBooks ‰πüË¢´Êõ¥Êñ∞Ôºå‰ª•‰æøUIËÉΩÁ´ãÂç≥ÊòæÁ§∫
            const allBooks = await db.worldBooks.toArray();
            state.worldBooks = allBooks;
            console.log(
              `Successfully imported ${newBooks.length} World Book entries into category ID: ${categoryId}`,
            );
          }
        }

        function getEventCoords(e) {
          // Â¶ÇÊûúÊòØËß¶Êë∏‰∫ã‰ª∂ÔºåÂ∞±‰ªé e.touches[0] Ëé∑Âèñ
          if (e.touches && e.touches[0]) {
            return { x: e.touches[0].pageX, y: e.touches[0].pageY };
          }
          // Âê¶ÂàôÔºåÂ∞±ÊòØÈº†Ê†á‰∫ã‰ª∂ÔºåÁõ¥Êé•‰ªé e Ëé∑Âèñ
          return { x: e.pageX, y: e.pageY };
        }

        function showScreen(screenId) {
          if (
            !document
              .getElementById("logistics-screen")
              .classList.contains("active")
          ) {
            logisticsUpdateTimers.forEach((timerId) => clearTimeout(timerId));
            logisticsUpdateTimers = [];
          }

          if (screenId === "chat-list-screen") {
            renderChatList();
            switchToChatListView("messages-view");
          }
          if (screenId === "api-settings-screen") {
            renderApiSettings();
          }
          if (screenId === "wallpaper-screen") {
            renderWallpaperScreen();
          }
          if (screenId === "world-book-screen") {
            renderWorldBookScreen();
          }

          document
            .querySelectorAll(".screen")
            .forEach((s) => s.classList.remove("active"));
          const screenToShow = document.getElementById(screenId);
          if (screenToShow) {
            screenToShow.classList.add("active");
          }

          if (screenId === "chat-interface-screen") {
            updateListenTogetherIcon(state.activeChatId);
          }

          if (screenId === "font-settings-screen") {
            document.getElementById("font-preview").style.fontFamily = "";
            applyCustomFont(state.globalSettings.fontUrl || "", true);
            renderFontPresets();
          }
          if (screenId === "persona-manager-screen") {
            renderPersonaManager();
          }
        }
        window.showScreen = showScreen; // Á°Æ‰øù showScreen Ëá™Â∑±‰πüÊòØÂÖ®Â±ÄÁöÑ

        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
          const chatListScreen = document.getElementById("chat-list-screen");
          const views = {
            "messages-view": document.getElementById("messages-view"),
            "qzone-screen": document.getElementById("qzone-screen"),
            "favorites-view": document.getElementById("favorites-view"),
            "memories-view": document.getElementById("memories-view"), // <-- Êñ∞Â¢ûËøô‰∏ÄË°å
          };
          const mainHeader = document.getElementById("main-chat-list-header");
          const mainBottomNav = document.getElementById("chat-list-bottom-nav"); // Ëé∑Âèñ‰∏ªÂØºËà™Ê†è

          if (isFavoritesSelectionMode) {
            document.getElementById("favorites-edit-btn").click();
          }

          // ÈöêËóèÊâÄÊúâËßÜÂõæ
          Object.values(views).forEach((v) => v.classList.remove("active"));
          // ÊòæÁ§∫ÁõÆÊ†áËßÜÂõæ
          if (views[viewId]) {
            views[viewId].classList.add("active");
          }

          // Êõ¥Êñ∞Â∫ïÈÉ®ÂØºËà™Ê†èÈ´ò‰∫Æ
          document
            .querySelectorAll("#chat-list-bottom-nav .nav-item")
            .forEach((item) => {
              item.classList.toggle("active", item.dataset.view === viewId);
            });

          // Áªü‰∏ÄÁÆ°ÁêÜÊâÄÊúâUIÂÖÉÁ¥†ÁöÑÊòæÈöê
          if (viewId === "messages-view") {
            mainHeader.style.display = "flex";
            mainBottomNav.style.display = "flex";
          } else {
            mainHeader.style.display = "none";
            mainBottomNav.style.display = "none";
          }

          if (viewId !== "memories-view") {
            activeCountdownTimers.forEach((timerId) => clearInterval(timerId));
            activeCountdownTimers = [];
          }

          // Ê†πÊçÆËßÜÂõæIDÊâßË°åÁâπÂÆöÁöÑÊ∏≤Êüì/Êõ¥Êñ∞ÈÄªËæë
          switch (viewId) {
            case "qzone-screen":
              views["qzone-screen"].style.backgroundColor = "#f0f2f5";
              updateUnreadIndicator(0);
              renderQzoneScreen();
              renderQzonePosts();
              break;
            case "favorites-view":
              views["favorites-view"].style.backgroundColor = "#f9f9f9";
              renderFavoritesScreen();
              break;
            case "messages-view":
              // Â¶ÇÊûúÈúÄË¶ÅÔºåÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†ËøîÂõûÊ∂àÊÅØÂàóË°®Êó∂Ë¶ÅÊâßË°åÁöÑÈÄªËæë
              break;
          }
        }

        function renderQzoneScreen() {
          if (state && state.qzoneSettings) {
            const settings = state.qzoneSettings;
            document.getElementById("qzone-nickname").textContent =
              settings.nickname;
            document.getElementById("qzone-avatar-img").src = settings.avatar;
            document.getElementById("qzone-banner-img").src = settings.banner;
          }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
          if (db && state.qzoneSettings) {
            await db.qzoneSettings.put(state.qzoneSettings);
          }
        }

        function formatPostTimestamp(timestamp) {
          if (!timestamp) return "";
          const now = new Date();
          const date = new Date(timestamp);
          const diffSeconds = Math.floor((now - date) / 1000);
          const diffMinutes = Math.floor(diffSeconds / 60);
          const diffHours = Math.floor(diffMinutes / 60);
          if (diffMinutes < 1) return "Just now";
          if (diffMinutes < 60) return `${diffMinutes} minutes ago`;
          if (diffHours < 24) return `${diffHours} hours ago`;
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          const hours = String(date.getHours()).padStart(2, "0");
          const minutes = String(date.getMinutes()).padStart(2, "0");
          if (now.getFullYear() === year) {
            return `${month}-${day} ${hours}:${minutes}`;
          } else {
            return `${year}-${month}-${day} ${hours}:${minutes}`;
          }
        }

        async function renderQzonePosts() {
          const postsListEl = document.getElementById("qzone-posts-list");
          if (!postsListEl) return;

          const [posts, favorites] = await Promise.all([
            db.qzonePosts.orderBy("timestamp").reverse().toArray(),
            db.favorites.where("type").equals("qzone_post").toArray(),
          ]);

          const favoritedPostIds = new Set(
            favorites.map((fav) => fav.content.id),
          );

          postsListEl.innerHTML = "";

          if (posts.length === 0) {
            postsListEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">It\'s empty here, be the first to post a status!</p>';
            return;
          }

          const userSettings = state.qzoneSettings;

          // 1. Before rendering all posts, we first create a set of all AI character names for quick lookup.
          const allAiCharacterNames = new Set(
            Object.values(state.chats)
              .filter((chat) => !chat.isGroup)
              .map((chat) => chat.name),
          );

          posts.forEach((post) => {
            const postContainer = document.createElement("div");
            postContainer.className = "qzone-post-container";
            postContainer.dataset.postId = post.id;

            const postEl = document.createElement("div");
            postEl.className = "qzone-post-item";

            let authorAvatar = "",
              authorNickname = "",
              commentAvatar = userSettings.avatar;

            if (post.authorId === "user") {
              authorAvatar = userSettings.avatar;
              authorNickname = userSettings.nickname;
            } else if (state.chats[post.authorId]) {
              const authorChat = state.chats[post.authorId];
              authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
              authorNickname = authorChat.name;
            } else {
              authorAvatar = defaultAvatar;
              authorNickname = "{{char}}";
            }

            let contentHtml = "";
            const publicTextHtml = post.publicText
              ? `<div class="post-content">${post.publicText.replace(/\n/g, "<br>")}</div>`
              : "";

            if (post.type === "shuoshuo") {
              contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(
                /\n/g,
                "<br>",
              )}</div>`;
            } else if (post.type === "image_post" && post.imageUrl) {
              contentHtml = publicTextHtml
                ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>`
                : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === "text_image") {
              contentHtml = publicTextHtml
                ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>`
                : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            } else if (post.type === "realimag") {
              // RealImagÁúüÂÆûÂõæÁâáÂä®ÊÄÅÊ∏≤ÊüìÔºàÊîØÊåÅÂ§öÂõæÂ∏ÉÂ±ÄÔºâ
              const imageUrls =
                post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

              if (imageUrls.length > 0) {
                const imageCount = imageUrls.length;
                let imagesHtml = "";

                // ‰ΩøÁî®Áªü‰∏ÄÁöÑÂ§öÂõæÂ∏ÉÂ±ÄÔºàÂåÖÊã¨ÂçïÂº†ÂõæÁâáÔºâ
                imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
                imageUrls.forEach((url, index) => {
                  imagesHtml += `<img src="${url}" class="realimag-image" alt="Image ${
                    index + 1
                  }" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='Image failed to load.';">`;
                });
                imagesHtml += "</div>";

                contentHtml = publicTextHtml
                  ? `${publicTextHtml}${imagesHtml}`
                  : imagesHtml;
              }
            } else if (post.type === "naiimag") {
              // NovelAIÂõæÁâáÂä®ÊÄÅÊ∏≤ÊüìÔºàÊîØÊåÅÂ§öÂõæÂ∏ÉÂ±ÄÔºåÊúÄÂ§ö2Âº†Ôºâ
              const imageUrls =
                post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

              if (imageUrls.length > 0) {
                const imageCount = imageUrls.length;
                let imagesHtml = "";

                // ‰ΩøÁî®Áªü‰∏ÄÁöÑÂ§öÂõæÂ∏ÉÂ±ÄÔºàÂåÖÊã¨ÂçïÂº†ÂõæÁâáÔºâ
                imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
                imageUrls.forEach((url, index) => {
                  imagesHtml += `<img src="${url}" class="naiimag-image" alt="Image ${
                    index + 1
                  }" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='Image failed to load.';">`;
                });
                imagesHtml += "</div>";

                contentHtml = publicTextHtml
                  ? `${publicTextHtml}${imagesHtml}`
                  : imagesHtml;
              }
            }

            let likesHtml = "";
            if (post.likes && post.likes.length > 0) {
              likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join(
                "„ÄÅ",
              )} ËßâÂæóÂæàËµû</span></div>`;
            }

            let commentsHtml = "";
            if (post.comments && post.comments.length > 0) {
              // 2. ‰øÆÊîπËøôÈáåÁöÑËøáÊª§ÈÄªËæë
              const commentsToShow =
                post.areCommentsVisible === false
                  ? post.comments.filter(
                      (comment) =>
                        // Êù°‰ª∂1: ËØÑËÆ∫ËÄÖÊòØ‰Ω†Ëá™Â∑±
                        comment.commenterName === userSettings.nickname ||
                        // Êù°‰ª∂2: ËØÑËÆ∫ËÄÖÁöÑÂêçÂ≠óÂú®Êàë‰ª¨ÂàöÊâçÂàõÂª∫ÁöÑAIËßíËâ≤ÂêçÂ≠óÂàóË°®Èáå
                        allAiCharacterNames.has(comment.commenterName),
                    )
                  : post.comments; // Â¶ÇÊûúÂºÄÂÖ≥ÊòØÂºÄÁöÑÔºåÂ∞±ÊòæÁ§∫ÊâÄÊúâËØÑËÆ∫

              if (commentsToShow.length > 0) {
                commentsHtml = '<div class="post-comments-container">';
                commentsToShow.forEach((comment) => {
                  const originalIndex = post.comments.indexOf(comment);
                  let replyHtml = "";
                  if (comment.replyTo) {
                    replyHtml = `<span class="reply-text">Reply</span> <span class="reply-target-name">${comment.replyTo}</span>`;
                  }
                  commentsHtml += `
                                        <div class="comment-item" data-commenter-name="${comment.commenterName}">
                                            <span class="commenter-name">${comment.commenterName}</span>${replyHtml}:
                                            <span class="comment-text"> ${comment.text}</span>
                                            <span class="comment-delete-btn" data-comment-index="${originalIndex}">√ó</span>
                                        </div>`;
                });
                commentsHtml += "</div>";
              }
            }

            const commentsAndFooterHtml = `
                            ${commentsHtml}
                            <div class="post-footer">
                                <div class="comment-section">
                                    <img src="${commentAvatar}" class="comment-avatar">
                                    <input type="text" class="comment-input" placeholder="Friendly comments are the starting point of communication">
                                    <div class="at-mention-popup"></div>
                                </div>
                                <button class="comment-send-btn">Send</button>
                            </div>
                        `;

            const userNickname = state.qzoneSettings.nickname;
            const isLikedByUser =
              post.likes && post.likes.includes(userNickname);
            const isFavoritedByUser = favoritedPostIds.has(post.id);

            postEl.innerHTML = `
                            <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(
                              post.timestamp,
                            )}</span></div>
                                <div class="post-actions-btn">‚Ä¶</div>
                            </div>
                            <div class="post-main-content">${contentHtml}</div>
                            <div class="post-feedback-icons">
                                <span class="action-icon like ${
                                  isLikedByUser ? "active" : ""
                                }"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                                <span class="action-icon favorite ${
                                  isFavoritedByUser ? "active" : ""
                                }"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                                <span class="action-icon summon-npc" data-post-id="${post.id}" data-author-id="${
                                  post.authorId
                                }" title="Summon NPC Comment"><svg viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></span>
                                </div>
                            ${likesHtml}
                            ${commentsAndFooterHtml}
                        `;

            const deleteAction = document.createElement("div");
            deleteAction.className = "qzone-post-delete-action";
            deleteAction.innerHTML = "<span>Delete</span>";
            postContainer.appendChild(postEl);
            postContainer.appendChild(deleteAction);
            const commentSection =
              postContainer.querySelector(".comment-section");
            if (commentSection) {
              commentSection.addEventListener("touchstart", (e) =>
                e.stopPropagation(),
              );
              commentSection.addEventListener("mousedown", (e) =>
                e.stopPropagation(),
              );
            }
            postsListEl.appendChild(postContainer);
            const commentInput = postContainer.querySelector(".comment-input");
            if (commentInput) {
              const popup = postContainer.querySelector(".at-mention-popup");
              commentInput.addEventListener("input", () => {
                const value = commentInput.value;
                const atMatch = value.match(/@([\p{L}\w]*)$/u);
                if (atMatch) {
                  const namesToMention = new Set();
                  const authorNickname =
                    postContainer.querySelector(".post-nickname")?.textContent;
                  if (authorNickname) namesToMention.add(authorNickname);
                  postContainer
                    .querySelectorAll(".commenter-name")
                    .forEach((nameEl) => {
                      namesToMention.add(nameEl.textContent.replace(":", ""));
                    });
                  namesToMention.delete(state.qzoneSettings.nickname);
                  popup.innerHTML = "";
                  if (namesToMention.size > 0) {
                    const searchTerm = atMatch[1];
                    namesToMention.forEach((name) => {
                      if (
                        name.toLowerCase().includes(searchTerm.toLowerCase())
                      ) {
                        const item = document.createElement("div");
                        item.className = "at-mention-item";
                        item.textContent = name;
                        item.addEventListener("mousedown", (e) => {
                          e.preventDefault();
                          const newText =
                            value.substring(0, atMatch.index) + `@${name} `;
                          commentInput.value = newText;
                          popup.style.display = "none";
                          commentInput.focus();
                        });
                        popup.appendChild(item);
                      }
                    });
                    popup.style.display =
                      popup.children.length > 0 ? "block" : "none";
                  } else {
                    popup.style.display = "none";
                  }
                } else {
                  popup.style.display = "none";
                }
              });
              commentInput.addEventListener("blur", () => {
                setTimeout(() => {
                  popup.style.display = "none";
                }, 200);
              });
            }
          });
        }

        async function renderFollowingFeed() {
          const feedListEl = document.getElementById(
            "weibo-following-feed-list",
          );
          if (!feedListEl) return;

          // 1. ‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÊâÄÊúâÂä®ÊÄÅ
          const allPosts = await db.qzonePosts
            .orderBy("timestamp")
            .reverse()
            .toArray();

          // 2. Á≠õÈÄâÂá∫‰ΩúËÄÖ‰∏çÊòØ 'user' ÁöÑÂä®ÊÄÅ
          const followingPosts = allPosts.filter(
            (post) => post.authorId !== "user",
          );

          feedListEl.innerHTML = ""; // Ê∏ÖÁ©∫ÊóßÂÜÖÂÆπ

          if (followingPosts.length === 0) {
            feedListEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">‰Ω†ÂÖ≥Ê≥®ÁöÑ‰∫∫ËøòÊ≤°ÊúâÂèëÂ∏É‰ªª‰ΩïÂä®ÊÄÅÂì¶„ÄÇ</p>';
            return;
          }

          // 3. ÈÅçÂéÜÁ≠õÈÄâÂêéÁöÑÂä®ÊÄÅÔºåÂπ∂Ê∏≤ÊüìÂÆÉ‰ª¨
          //    „ÄêÊèêÁ§∫„ÄëËøôÈáåÂàõÂª∫Âçï‰∏™Âä®ÊÄÅHTMLÁöÑÈÄªËæëÔºåÂèØ‰ª•ÂÆåÂÖ®Â§çÂà∂ `renderQzonePosts` ÂáΩÊï∞ÈáåÁöÑ forEach Âæ™ÁéØÂÜÖÈÉ®ÁöÑ‰ª£Á†Å„ÄÇ
          //    ‰Ω†Âè™ÈúÄË¶ÅÊääÁõÆÊ†áÂÆπÂô®‰ªé `postsListEl` change to `feedListEl` Âç≥ÂèØ„ÄÇ
          followingPosts.forEach((post) => {});
        }

        function displayFilteredFavorites(items) {
          const listEl = document.getElementById("favorites-list");
          listEl.innerHTML = "";

          if (items.length === 0) {
            const searchTerm = document.getElementById(
              "favorites-search-input",
            ).value;
            const message = searchTerm
              ? "No related collections found."
              : "Your favorites list is empty, <br>go to posts or chats to favorite content you like!";
            listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
            return;
          }

          for (const item of items) {
            const card = document.createElement("div");
            card.className = "favorite-item-card";
            card.dataset.favid = item.id;

            let headerHtml = "",
              contentHtml = "",
              sourceText = "",
              footerHtml = "";

            if (item.type === "qzone_post") {
              const post = item.content;
              sourceText = "From Post";
              let authorAvatar = defaultAvatar,
                authorNickname = "Unknown User";

              if (post.authorId === "user") {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
              } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
              }

              headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;

              const publicTextHtml = post.publicText
                ? `<div class="post-content">${post.publicText.replace(/\n/g, "<br>")}</div>`
                : "";
              if (post.type === "shuoshuo") {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, "<br>")}</div>`;
              } else if (post.type === "image_post" && post.imageUrl) {
                contentHtml = publicTextHtml
                  ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>`
                  : `<img src="${post.imageUrl}" class="chat-image">`;
              } else if (post.type === "text_image") {
                contentHtml = publicTextHtml
                  ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>`
                  : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
              } else if (post.type === "realimag") {
                // RealImagÁúüÂÆûÂõæÁâáÂä®ÊÄÅÊ∏≤ÊüìÔºàÊîØÊåÅÂ§öÂõæÂ∏ÉÂ±ÄÔºâ
                const imageUrls =
                  post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

                if (imageUrls.length > 0) {
                  const imageCount = imageUrls.length;
                  let imagesHtml = "";

                  // ‰ΩøÁî®Áªü‰∏ÄÁöÑÂ§öÂõæÂ∏ÉÂ±ÄÔºàÂåÖÊã¨ÂçïÂº†ÂõæÁâáÔºâ
                  imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
                  imageUrls.forEach((url, index) => {
                    imagesHtml += `<img src="${url}" class="realimag-image" alt="Image${
                      index + 1
                    }" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='Image failed to load.';">`;
                  });
                  imagesHtml += "</div>";

                  contentHtml = publicTextHtml
                    ? `${publicTextHtml}${imagesHtml}`
                    : imagesHtml;
                }
              } else if (post.type === "naiimag") {
                // NovelAIÂõæÁâáÂä®ÊÄÅÊ∏≤ÊüìÔºàÊîØÊåÅÂ§öÂõæÂ∏ÉÂ±ÄÔºåÊúÄÂ§ö2Âº†Ôºâ
                const imageUrls =
                  post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

                if (imageUrls.length > 0) {
                  const imageCount = imageUrls.length;
                  let imagesHtml = "";

                  // ‰ΩøÁî®Áªü‰∏ÄÁöÑÂ§öÂõæÂ∏ÉÂ±ÄÔºàÂåÖÊã¨ÂçïÂº†ÂõæÁâáÔºâ
                  imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
                  imageUrls.forEach((url, index) => {
                    imagesHtml += `<img src="${url}" class="naiimag-image" alt="Image ${
                      index + 1
                    }" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='Image failed to load.';">`;
                  });
                  imagesHtml += "</div>";

                  contentHtml = publicTextHtml
                    ? `${publicTextHtml}${imagesHtml}`
                    : imagesHtml;
                }
              }

              // 1. ÊûÑÈÄ†ÁÇπËµûÂå∫ÂüüÁöÑHTML
              let likesHtml = "";
              // Ê£ÄÊü• post ÂØπË±°‰∏≠ÊòØÂê¶Â≠òÂú® likes Êï∞ÁªÑÂπ∂‰∏î‰∏ç‰∏∫Á©∫
              if (post.likes && post.likes.length > 0) {
                // Â¶ÇÊûúÂ≠òÂú®ÔºåÂ∞±ÂàõÂª∫ÁÇπËµûÂå∫ÂüüÁöÑ div
                likesHtml = `
			                    <div class="post-likes-section">
			                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
			                        <span>${post.likes.join("„ÄÅ")} ËßâÂæóÂæàËµû</span>
			                    </div>`;
              }

              // 2. ÊûÑÈÄ†ËØÑËÆ∫Âå∫ÂüüÁöÑHTML
              let commentsHtml = "";
              // Ê£ÄÊü• post ÂØπË±°‰∏≠ÊòØÂê¶Â≠òÂú® comments Êï∞ÁªÑÂπ∂‰∏î‰∏ç‰∏∫Á©∫
              if (post.comments && post.comments.length > 0) {
                // Â¶ÇÊûúÂ≠òÂú®ÔºåÂ∞±ÂàõÂª∫ËØÑËÆ∫ÂÆπÂô®ÔºåÂπ∂ÈÅçÂéÜÊØè‰∏ÄÊù°ËØÑËÆ∫
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach((comment) => {
                  commentsHtml += `
			                        <div class="comment-item">
			                            <span class="commenter-name">${comment.commenterName}:</span>
			                            <span class="comment-text">${comment.text}</span>
			                        </div>`;
                });
                commentsHtml += "</div>";
              }

              // 3. Â∞ÜÁÇπËµûÂíåËØÑËÆ∫ÁöÑHTMLÁªÑÂêàÂà∞ footerHtml ‰∏≠
              footerHtml = `${likesHtml}${commentsHtml}`;
            } else if (item.type === "chat_message") {
              const msg = item.content;
              const chat = state.chats[item.chatId];
              if (!chat) continue;

              sourceText = `From chat with ${chat.name}`;
              const isUser = msg.role === "user";
              let senderName, senderAvatar;

              if (isUser) {
                // Áî®Êà∑Ê∂àÊÅØÁöÑÈÄªËæë‰øùÊåÅ‰∏çÂèò
                senderName = chat.isGroup
                  ? chat.settings.myNickname || "Me"
                  : "Me";
                senderAvatar =
                  chat.settings.myAvatar ||
                  (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
                //...
              } else {
                // AI/ÊàêÂëòÊ∂àÊÅØ
                if (chat.isGroup) {
                  const member = chat.members.find(
                    (m) => m.originalName === msg.senderName,
                  );

                  // Â¶ÇÊûúÊâæÂà∞‰∫ÜÊàêÂëò‰ø°ÊÅØÔºåÂ∞±Áî®‰ªñÁöÑ‚ÄúÁæ§ÊòµÁß∞‚ÄùÔºõÂ¶ÇÊûúÊ≤°ÊâæÂà∞ÔºàÊØîÂ¶ÇÊàêÂëòË¢´Ë∏¢‰∫ÜÔºâÔºåÂ∞±ËøòÊòØÁî®Ê∂àÊÅØÈáåÁöÑÂêçÂ≠ó‰Ωú‰∏∫Â§áÁî®„ÄÇ
                  senderDisplayName = member
                    ? member.groupNickname
                    : msg.senderName || "Unknown member";

                  senderAvatar = member
                    ? member.avatar
                    : defaultGroupMemberAvatar;
                } else {
                  // ÂçïËÅäÁöÑÈÄªËæë‰øùÊåÅ‰∏çÂèò
                  senderName = chat.name;
                  senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                }
              }

              // ÂêéÁª≠ÊãºÊé• headerHtml Âíå contentHtml ÁöÑÈÄªËæëÈÉΩ‰øùÊåÅ‰∏çÂèò
              headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;

              if (
                typeof msg.content === "string" &&
                STICKER_REGEX.test(msg.content)
              ) {
                contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
              } else if (
                Array.isArray(msg.content) &&
                msg.content[0]?.type === "image_url"
              ) {
                contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
              } else {
                const messageText = String(msg.content || "");
                // ‰æ¶ÊµãÊ†ºÂºèÔºö[sticker:ÂêçÂ≠ó]
                const stickerMatch = messageText.match(
                  /\[sticker:\s*(.+?)\s*\]/i,
                );

                if (stickerMatch) {
                  // Â¶ÇÊûúÂåπÈÖçÊàêÂäüÔºåÊèêÂèñÂá∫ÂêçÂ≠ó
                  const stickerName = stickerMatch[1].trim();
                  // Âú®ÊâÄÊúâÂèØËÉΩÁöÑË°®ÊÉÖÂ∫ìÈáåÊü•ÊâæÔºàÁî®Êà∑ÁöÑ„ÄÅËßíËâ≤ÁöÑ‰∏ìÂ±û„ÄÅËßíËâ≤ÁöÑÈÄöÁî®Ôºâ
                  const allStickers = [
                    ...state.userStickers,
                    ...state.charStickers,
                    ...(chat.settings.stickerLibrary || []),
                  ];
                  const foundSticker = allStickers.find(
                    (s) => s.name === stickerName,
                  );

                  if (foundSticker) {
                    // Â¶ÇÊûúÊâæÂà∞‰∫ÜÔºåÂ∞±ÊòæÁ§∫ÂõæÁâáÔºÅ
                    bubble.classList.add("is-sticker");
                    contentHtml = `<img src="${foundSticker.url}" alt="${foundSticker.name}" class="sticker-image">`;
                  } else {
                    // Â¶ÇÊûúÊ≤°ÊâæÂà∞ÔºàÊØîÂ¶ÇAIËá™Â∑±Áºñ‰∫Ü‰∏™ÂêçÂ≠óÔºâÔºåÂ∞±ËøòÊòØÊåâÊôÆÈÄöÊñáÂ≠óÊòæÁ§∫
                    contentHtml = messageText.replace(/\n/g, "<br>");
                  }
                } else {
                  // Â¶ÇÊûú‰∏çÂåπÈÖçÔºåÂ∞±ÊòØÊôÆÈÄöÁöÑÊñáÊú¨Ê∂àÊÅØ
                  contentHtml = messageText.replace(/\n/g, "<br>");
                }
              }
            }

            card.innerHTML = `
			            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
			            <div class="fav-card-content">${contentHtml}</div>
			            ${footerHtml}`;

            listEl.appendChild(card);
          }
        }

        /**
         * Ë¥üË¥£ÂáÜÂ§áÊï∞ÊçÆÂπ∂Ëß¶ÂèëÊ∏≤Êüì
         */
        async function renderFavoritesScreen() {
          // 1. ‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÊúÄÊñ∞Êï∞ÊçÆÂπ∂ÁºìÂ≠ò
          allFavoriteItems = await db.favorites
            .orderBy("timestamp")
            .reverse()
            .toArray();

          // 2. Ê∏ÖÁ©∫ÊêúÁ¥¢Ê°ÜÂπ∂ÈöêËóèÊ∏ÖÈô§ÊåâÈíÆ
          const searchInput = document.getElementById("favorites-search-input");
          const clearBtn = document.getElementById(
            "favorites-search-clear-btn",
          );
          searchInput.value = "";
          clearBtn.style.display = "none";

          // 3. ÊòæÁ§∫ÊâÄÊúâÊî∂ËóèÈ°π
          displayFilteredFavorites(allFavoriteItems);
        }

        function resetCreatePostModal() {
          document.getElementById("post-public-text").value = "";
          document.getElementById("post-image-preview").src = "";
          document.getElementById("post-image-description").value = "";
          document
            .getElementById("post-image-preview-container")
            .classList.remove("visible");
          document.getElementById("post-image-desc-group").style.display =
            "none";
          document.getElementById("post-local-image-input").value = "";
          document.getElementById("post-hidden-text").value = "";

          const imageModeBtn = document.getElementById("switch-to-image-mode");
          const textImageModeBtn = document.getElementById(
            "switch-to-text-image-mode",
          );
          const imageModeContent =
            document.getElementById("image-mode-content");
          const textImageModeContent = document.getElementById(
            "text-image-mode-content",
          );

          imageModeBtn.classList.add("active");
          textImageModeBtn.classList.remove("active");
          imageModeContent.classList.add("active");
          textImageModeContent.classList.remove("active");
        }

        async function exportBackup() {
          try {
            const backupData = {
              version: 1,
              timestamp: Date.now(),
            };

            const [
              chats,
              worldBooks,
              userStickers,
              charStickers,
              apiConfig,
              globalSettings,
              personaPresets,
              musicLibrary,
              qzoneSettings,
              qzonePosts,
              qzoneAlbums,
              qzonePhotos,
              favorites,
              qzoneGroups,
              memories,
              worldBookCategories,
              callRecords,
              customAvatarFrames,
              themes,
              apiPresets,
              bubbleStylePresets,
              fontPresets,
              homeScreenPresets,
              datingScenes,
              datingPresets,
              datingSpriteGroups,
              datingSprites,
              datingHistory,
              pomodoroSessions,
              ludoQuestionBanks,
              ludoQuestions,
              scriptKillScripts,
              taobaoProducts,
              taobaoOrders,
              taobaoCart,
              userWalletTransactions,
              userStickerCategories,
            ] = await Promise.all([
              db.chats.toArray(),
              db.worldBooks.toArray(),
              db.userStickers.toArray(),
              db.charStickers.toArray(), // <--- Êñ∞Â¢ûÁöÑËøô‰∏ÄË°åÔºÅ
              db.apiConfig.get("main"),
              db.globalSettings.get("main"),
              db.personaPresets.toArray(),
              db.musicLibrary.get("main"),
              db.qzoneSettings.get("main"),
              db.qzonePosts.toArray(),
              db.qzoneAlbums.toArray(),
              db.qzonePhotos.toArray(),
              db.favorites.toArray(),
              db.qzoneGroups.toArray(),
              db.memories.toArray(),
              db.worldBookCategories.toArray(),
              db.callRecords.toArray(),
              db.customAvatarFrames.toArray(),
              db.themes.toArray(),
              db.apiPresets.toArray(),
              db.bubbleStylePresets.toArray(),
              db.fontPresets.toArray(),
              db.homeScreenPresets.toArray(),
              db.datingScenes.toArray(),
              db.datingPresets.toArray(),
              db.datingSpriteGroups.toArray(),
              db.datingSprites.toArray(),
              db.datingHistory.toArray(),
              db.pomodoroSessions.toArray(),
              db.ludoQuestionBanks.toArray(),
              db.ludoQuestions.toArray(),
              db.scriptKillScripts.toArray(),
              db.taobaoProducts.toArray(),
              db.taobaoOrders.toArray(),
              db.taobaoCart.toArray(),
              db.userWalletTransactions.toArray(),
              db.userStickerCategories.toArray(),
            ]);

            Object.assign(backupData, {
              chats,
              worldBooks,
              userStickers,
              charStickers,
              apiConfig,
              globalSettings,
              personaPresets,
              musicLibrary,
              qzoneSettings,
              qzonePosts,
              qzoneAlbums,
              qzonePhotos,
              favorites,
              qzoneGroups,
              memories,
              worldBookCategories,
              callRecords,
              customAvatarFrames,
              themes,
              apiPresets,
              bubbleStylePresets,
              fontPresets,
              homeScreenPresets,
              datingScenes,
              datingPresets,
              datingSpriteGroups,
              datingSprites,
              datingHistory,
              pomodoroSessions,
              ludoQuestionBanks,
              ludoQuestions,
              scriptKillScripts,
              taobaoProducts,
              taobaoOrders,
              taobaoCart,
              userWalletTransactions,
              userStickerCategories,
            });

            backupData.homeScreenState = {
              // --- 1. Profile Card ---
              "profile-banner-img":
                document.getElementById("profile-banner-img")?.src || "",
              "profile-avatar-img":
                document.getElementById("profile-avatar-img")?.src || "",
              homeAvatarFrame:
                document.getElementById("profile-avatar-frame")?.src || "",
              "profile-username":
                document.getElementById("profile-username")?.textContent ||
                "Your Nickname",
              "profile-sub-username":
                document.getElementById("profile-sub-username")?.textContent ||
                "@your_id",
              "profile-bio":
                document.getElementById("profile-bio")?.textContent ||
                "Click here to edit your bio",
              "profile-location":
                document.getElementById("profile-location")?.innerHTML || "",

              // --- 2. First Page Widgets (unchanged) ---
              "widget-bubble-1":
                document.getElementById("widget-bubble-1")?.textContent ||
                "Click to edit text",
              "widget-image-1":
                document.getElementById("widget-image-1")?.src || "",
              "widget-subtext-1":
                document.getElementById("widget-subtext-1")?.textContent ||
                "Click to edit text",
              "widget-bubble-2":
                document.getElementById("widget-bubble-2")?.textContent ||
                "Click to edit text",
              "widget-image-2":
                document.getElementById("widget-image-2")?.src || "",
              "widget-subtext-2":
                document.getElementById("widget-subtext-2")?.textContent ||
                "Click to edit text",

              // --- 3. Second Page: Left Combo (Image + Bubble) ---
              "widget-image-3":
                document.getElementById("widget-image-3")?.src || "",
              "second-page-bubble":
                document.getElementById("second-page-bubble")?.textContent ||
                "Click to edit text",
              "flat-capsule-bubble":
                document.getElementById("flat-capsule-bubble")?.textContent ||
                "Editable",
              "circular-bubble":
                document.getElementById("circular-bubble")?.textContent ||
                "Text",

              // --- 4. Second Page: Transparent Music Widget (Core Feature) ---
              "music-rect-img":
                document.getElementById("music-rect-img")?.src || "",
              "music-record-img":
                document.getElementById("music-record-img")?.src || "",
              "music-text-line":
                document.getElementById("music-text-line")?.textContent ||
                "Click to edit song title",

              // --- 5. Second Page: Month/Avatar Combo Widget (Core Feature) ---
              "widget-month-display":
                document.getElementById("widget-month-display")?.textContent ||
                "12",
              "new-widget-avatar":
                document.getElementById("new-widget-avatar")?.src || "",
              "new-widget-text-1":
                document.getElementById("new-widget-text-1")?.textContent ||
                "Editable text",
              "new-widget-text-2":
                document.getElementById("new-widget-text-2")?.textContent ||
                "Editable text",
              "new-widget-text-3":
                document.getElementById("new-widget-text-3")?.textContent ||
                "Editable text",

              // --- Global Settings ---
              appIcons: { ...state.globalSettings.appIcons },
              appLabels: { ...state.globalSettings.appLabels },
              wallpaper: state.globalSettings.wallpaper,
              lockscreenWallpaper: state.globalSettings.lockscreenWallpaper,
            };

            const blob = new Blob([JSON.stringify(backupData, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const link = Object.assign(document.createElement("a"), {
              href: url,
              download: `EPhone-Full-Backup-${new Date().toISOString().split("T")[0]}.json`,
            });
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            await showCustomAlert("Export Successful", "All data has been successfully exported!");
          } catch (error) {
            console.error("Error exporting data:", error);
            await showCustomAlert(
              "Export Failed",
              `An error occurred: ${error.message}`,
            );
          }
        }

        let githubBackupTimer = null;

        /**
         * Ëé∑ÂèñÂÆåÊï¥ÁöÑÂ§á‰ªΩÊï∞ÊçÆÂØπË±° (‰∏çËß¶Âèë‰∏ãËΩΩ)
         */
        async function getFullBackupData() {
          const backupData = {
            version: 1,
            timestamp: Date.now(),
            deviceCode: getDeviceCode(), // ËÆ∞ÂΩïÊù•Ê∫êËÆæÂ§á
          };

          // Ëé∑ÂèñÊâÄÊúâÊï∞ÊçÆË°®
          const [
            chats,
            worldBooks,
            userStickers,
            charStickers,
            apiConfig,
            globalSettings,
            personaPresets,
            musicLibrary,
            qzoneSettings,
            qzonePosts,
            qzoneAlbums,
            qzonePhotos,
            favorites,
            qzoneGroups,
            memories,
            worldBookCategories,
            callRecords,
            customAvatarFrames,
            themes,
            apiPresets,
            bubbleStylePresets,
            fontPresets,
            homeScreenPresets,
            datingScenes,
            datingPresets,
            datingSpriteGroups,
            datingSprites,
            datingHistory,
            pomodoroSessions,
            ludoQuestionBanks,
            ludoQuestions,
            scriptKillScripts,
            taobaoProducts,
            taobaoOrders,
            taobaoCart,
            userWalletTransactions,
            userStickerCategories,
          ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.charStickers.toArray(),
            db.apiConfig.get("main"),
            db.globalSettings.get("main"),
            db.personaPresets.toArray(),
            db.musicLibrary.get("main"),
            db.qzoneSettings.get("main"),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray(),
            db.worldBookCategories.toArray(),
            db.callRecords.toArray(),
            db.customAvatarFrames.toArray(),
            db.themes.toArray(),
            db.apiPresets.toArray(),
            db.bubbleStylePresets.toArray(),
            db.fontPresets.toArray(),
            db.homeScreenPresets.toArray(),
            db.datingScenes.toArray(),
            db.datingPresets.toArray(),
            db.datingSpriteGroups.toArray(),
            db.datingSprites.toArray(),
            db.datingHistory.toArray(),
            db.pomodoroSessions.toArray(),
            db.ludoQuestionBanks.toArray(),
            db.ludoQuestions.toArray(),
            db.scriptKillScripts.toArray(),
            db.taobaoProducts.toArray(),
            db.taobaoOrders.toArray(),
            db.taobaoCart.toArray(),
            db.userWalletTransactions.toArray(),
            db.userStickerCategories.toArray(),
          ]);

          // ÁªÑË£ÖÊï∞ÊçÆ
          Object.assign(backupData, {
            chats,
            worldBooks,
            userStickers,
            charStickers,
            apiConfig,
            globalSettings,
            personaPresets,
            musicLibrary,
            qzoneSettings,
            qzonePosts,
            qzoneAlbums,
            qzonePhotos,
            favorites,
            qzoneGroups,
            memories,
            worldBookCategories,
            callRecords,
            customAvatarFrames,
            themes,
            apiPresets,
            bubbleStylePresets,
            fontPresets,
            homeScreenPresets,
            datingScenes,
            datingPresets,
            datingSpriteGroups,
            datingSprites,
            datingHistory,
            pomodoroSessions,
            ludoQuestionBanks,
            ludoQuestions,
            scriptKillScripts,
            taobaoProducts,
            taobaoOrders,
            taobaoCart,
            userWalletTransactions,
            userStickerCategories,
          });

          // ËøôÈáåÁúÅÁï•‰∫Ü homeScreenState ÁöÑËØ¶ÁªÜÊäìÂèñÔºåÂõ†‰∏∫ÂÆÉ‰æùËµñ DOM ÂÖÉÁ¥†Ôºå
          // Ëá™Âä®Â§á‰ªΩÊó∂ÂèØËÉΩ‰∏çÂú®‰∏ªÂ±èÂπï„ÄÇ‰∏∫‰∫ÜÂÆâÂÖ®Ëµ∑ËßÅÔºåËøôÈáå‰ªÖ‰øùÂ≠ò globalSettings ÈáåÁöÑ widgetData„ÄÇ
          // Â¶ÇÊûúÈúÄË¶ÅÂÆåÊï¥ËøòÂéüUIÂ∏ÉÂ±ÄÔºåÊúÄÂ•ΩÂè™Âú®ÊâãÂä®ÂØºÂá∫Êó∂ÂåÖÂê´ homeScreenState„ÄÇ

          return JSON.stringify(backupData, null, 2);
        }

        // ÊîØÊåÅÂ§ßÊñá‰ª∂Ëá™Âä®ÂàÜÁâá‰∏ä‰º† + Ëá™Âä®ÂéªÈô§ÊïèÊÑüKeyÈò≤Ê≠¢Êä•Èîô
        async function uploadBackupToGitHub(isAuto = false) {
          let { githubToken, githubUsername, githubRepo, githubPath } =
            state.apiConfig;

          // 1. Âü∫Á°ÄÊ£ÄÊü•
          if (!githubToken || !githubUsername || !githubRepo) {
            if (!isAuto) alert("Please fill in the GitHub configuration in the API settings!");
            return;
          }
          githubToken = githubToken.trim();
          githubUsername = githubUsername.trim();
          githubRepo = githubRepo
            .trim()
            .replace(/\/$/, "")
            .split("/")
            .pop()
            .replace(".git", "");
          githubPath = (githubPath || "ephone_backup.json").trim();

          if (!isAuto)
            await showCustomAlert("Preparing...", "Packing and calculating file size...");

          try {
            // 2. Get the raw JSON data string
            const rawJsonContent = await getFullBackupData();

            // GitHub will reject files containing API keys, so they must be cleared before uploading
            const backupObj = JSON.parse(rawJsonContent);

            if (backupObj.apiConfig) {
              // Clear OpenAI/API Key
              backupObj.apiConfig.apiKey = "";
              // Clear GitHub Token (most important, must be cleared to avoid secret detected error)
              backupObj.apiConfig.githubToken = "";
              // Clear Minimax Key
              backupObj.apiConfig.minimaxApiKey = "";
            }

            // Convert back to JSON string
            const jsonContent = JSON.stringify(backupObj, null, 2);

            // 3. ËΩ¨Êàê Base64 (Ëß£ÂÜ≥‰∏≠Êñá‰π±Á†Å)
            const fullBase64 = btoa(unescape(encodeURIComponent(jsonContent)));

            // ËÆ°ÁÆó Base64 Â§ßÂ∞è (Â≠óËäÇ)
            const totalSize = fullBase64.length;
            // ËÆæÂÆöÂàÜÁâáÈòàÂÄºÔºö45MB
            const CHUNK_SIZE = 45 * 1024 * 1024;

            const totalChunks = Math.ceil(totalSize / CHUNK_SIZE);

            console.log(
              `[GitHub] File size: ${(totalSize / 1024 / 1024).toFixed(2)} MB, Chunks: ${totalChunks}`,
            );

            // If there's only 1 chunk, use regular upload; if multiple, use chunked upload
            if (totalChunks === 1) {
              await uploadSingleFile(
                githubUsername,
                githubRepo,
                githubPath,
                githubToken,
                fullBase64,
                isAuto,
              );
            } else {
              if (!isAuto)
                await showCustomAlert(
                  "Large file",
                  `The file will be uploaded in ${totalChunks} parts, please be patient...`,
                );

              for (let i = 0; i < totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, totalSize);
                const chunkContent = fullBase64.substring(start, end);

                const partName = `${githubPath}.${String(i + 1).padStart(3, "0")}`;

                if (!isAuto) {
                  console.log(`Uploading chunk ${i + 1}/${totalChunks} ...`);
                }

                await uploadSingleFile(
                  githubUsername,
                  githubRepo,
                  partName,
                  githubToken,
                  chunkContent,
                  isAuto,
                  true,
                );
              }

              const infoContent = btoa(
                `{"total_parts": ${totalChunks}, "timestamp": ${Date.now()}}`,
              );
              await uploadSingleFile(
                githubUsername,
                githubRepo,
                `${githubPath}.meta`,
                githubToken,
                infoContent,
                true,
                true,
              );
            }

            console.log("GitHub backup completed!");
            if (!isAuto) {
              await showCustomAlert(
                "Upload successful",
                `The backup has been uploaded. (For security, the API keys have been automatically removed from the cloud backup. Please remember to re-enter them when restoring.)`,
              );
            }
          } catch (error) {
            console.error("GitHub backup failed:", error);
            // If still reporting Bad credentials, prompt the user to check the Token
            if (error.message.includes("Bad credentials")) {
              if (!isAuto)
                await showCustomAlert(
                  "Authentication failed",
                  'GitHub Token is invalid or expired. Please regenerate the Token and ensure the "repo" permission is checked.',
                );
            } else {
              if (!isAuto) await showCustomAlert("Upload failed", error.message);
            }
          }
        }

        async function restoreBackupFromGitHub() {
          let { githubToken, githubUsername, githubRepo, githubPath } =
            state.apiConfig;

          // 1. Basic check
          if (!githubToken || !githubUsername || !githubRepo) {
            alert("Please fill in the GitHub configuration in the API settings first!");
            return;
          }

                    // 2. Confirm operation
          const confirmed = await showCustomConfirm(
            "‚ö†Ô∏è High Risk Warning",
            "You are about to download a backup from GitHub and „ÄêOVERWRITE„Äë all current data!\n\nIf the backup on GitHub is outdated, your current new data will be permanently lost.\n\nAre you sure you want to continue?",
            { confirmButtonClass: "btn-danger" },
          );
          if (!confirmed) return;

          githubToken = githubToken.trim();
          githubUsername = githubUsername.trim();
          githubRepo = githubRepo
            .trim()
            .replace(/\/$/, "")
            .split("/")
            .pop()
            .replace(".git", "");
          githubPath = (githubPath || "ephone_backup.json").trim();

          await showCustomAlert(
            "Connecting...",
            "Checking backup file on GitHub...",
          );

          try {
            let finalBase64String = "";

            // 3. Strategy A: Check if a chunk index file (.meta) exists
            const metaUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/contents/${githubPath}.meta`;
            let metaData = null;

            try {
              const metaRes = await fetch(metaUrl, {
                headers: { Authorization: `token ${githubToken}` },
              });
              if (metaRes.ok) {
                const metaJson = await metaRes.json();
                const metaContentStr = atob(
                  metaJson.content.replace(/\s/g, ""),
                );
                metaData = JSON.parse(metaContentStr);
              }
            } catch (e) {
              console.log("Meta file not found, switching to single-file mode.");
            }

            // 4. Branch handling: chunked download vs single-file download
            if (metaData && metaData.total_parts) {
              // === Chunk mode (for very large files) ===
              const totalParts = metaData.total_parts;
              const modalTitle = document.getElementById("custom-modal-title");

              for (let i = 1; i <= totalParts; i++) {
                if (modalTitle)
                  modalTitle.textContent = `Downloading chunk ${i}/${totalParts}...`;

                const partName = `${githubPath}.${String(i).padStart(3, "0")}`;
                // Get SHA info for the chunk file
                const partInfoUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/contents/${partName}`;

                const partInfoRes = await fetch(partInfoUrl, {
                  headers: { Authorization: `token ${githubToken}` },
                });

                if (!partInfoRes.ok)
                  throw new Error(`Failed to retrieve info for chunk ${partName}`);

                const partJson = await partInfoRes.json();

                // Always use Blob API to fetch content to avoid CORS issues with download_url
                // Whether chunked or single file, if SHA exists, use Blob API
                const blobUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/git/blobs/${partJson.sha}`;
                const blobRes = await fetch(blobUrl, {
                  headers: { Authorization: `token ${githubToken}` },
                });

                if (!blobRes.ok)
                  throw new Error(`Failed to download content of chunk ${partName}`);

                const blobJson = await blobRes.json();
                finalBase64String += blobJson.content.replace(/\s/g, "");
              }
              console.log("All chunks downloaded and merged successfully.");
            } else {
              // === Single-file mode ===
              // 1. First get file metadata (retrieve SHA)
              const singleUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/contents/${githubPath}`;
              const res = await fetch(singleUrl, {
                headers: { Authorization: `token ${githubToken}` },
              });

              if (!res.ok) {
                if (res.status === 404)
                  throw new Error("Backup file not found! Please check the file name.");
                throw new Error(`Download failed: ${res.status}`);
              }

              const json = await res.json();

              if (json.content) {
                // Êñá‰ª∂ËæÉÂ∞è (<1MB)ÔºåAPI Áõ¥Êé•ËøîÂõû‰∫Ü content
                finalBase64String = json.content.replace(/\s/g, "");
              } else if (json.sha) {
                // Êñá‰ª∂ËæÉÂ§ß (>1MB)ÔºåAPI Ê≤°Êúâ contentÔºå‰ΩÜÊúâ sha
                // ‰ΩøÁî® Blob API Ëé∑ÂèñÂÜÖÂÆπÔºàÂÆÉÊîØÊåÅ CORS Âíå TokenÔºâ
                console.log("File exceeds 1MB, downloading via Blob API...");
                if (document.getElementById("custom-modal-title")) {
                  document.getElementById("custom-modal-title").textContent =
                    "Downloading large file via Blob API...";
                }

                const blobUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/git/blobs/${json.sha}`;
                const blobRes = await fetch(blobUrl, {
                  headers: { Authorization: `token ${githubToken}` },
                });

                if (!blobRes.ok)
                  throw new Error(`Blob API request failed: ${blobRes.status}`);

                const blobJson = await blobRes.json();
                finalBase64String = blobJson.content.replace(/\s/g, "");
              } else {
                throw new Error(
                  "Unable to retrieve file content: GitHub API did not return content or sha",
                );
              }
            }

            // 5. Decoding and restoration
            if (document.getElementById("custom-modal-title")) {
              document.getElementById("custom-modal-title").textContent =
                "Parsing data (this may take a few seconds)...";
            }

            // a. Base64 -> binary string
            const binaryString = atob(finalBase64String);

            // b. binary string -> Uint8Array -> UTF-8 string
            // (This step is to solve the Chinese garbled problem)
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            const decoder = new TextDecoder("utf-8");
            const jsonString = decoder.decode(bytes);

            // c. Pre-check JSON
            try {
              JSON.parse(jsonString);
            } catch (parseErr) {
              throw new Error(
                `JSON parsing failed (file may be incomplete): ${parseErr.message}`,
              );
            }

            // d. Import
            const virtualFile = new File([jsonString], "github_restore.json", {
              type: "application/json",
            });
            hideCustomModal();
            await importBackup(virtualFile);
          } catch (error) {
            console.error("Restore failed:", error);
            // Â¶ÇÊûúÊòØ 403 ÈîôËØØÔºåÈÄöÂ∏∏ÊòØ Token ÊùÉÈôêÈóÆÈ¢ò
            let extraMsg = "";
            if (
              error.message.includes("403") ||
              error.message.includes("Failed to fetch")
            ) {
              extraMsg =
                "\n\n(Tip: This may be a network issue, or your GitHub Token does not have sufficient permissions to access the private repository.)";
            }
            await showCustomAlert(
              "Restore failed",
              `Error message: ${error.message}${extraMsg}`,
            );
          }
        }

        /**
         * Helper function: Upload a single file to GitHub
         * Enhanced version: Supports obtaining SHA for overwriting files and handling 404 cases
         */
        async function uploadSingleFile(
          user,
          repo,
          path,
          token,
          contentBase64,
          isAuto,
        ) {
          const apiUrl = `https://api.github.com/repos/${user}/${repo}/contents/${path}`;

          // 1. Try to get the existing SHA (for overwriting)
          let sha = null;
          try {
            // This fetch may fail due to network issues, so we add try-catch
            const getRes = await fetch(apiUrl, {
              method: "GET",
              headers: { Authorization: `token ${token}` },
            });
            if (getRes.ok) {
              const json = await getRes.json();
              sha = json.sha;
            }
          } catch (e) {
            console.warn(
              `[Github] Failed to get file SHA (might be a new file): ${path}`,
              e,
            );
            // Ignore errors when getting SHA, assume it's a new file and continue to upload
          }

          // 2. Prepare upload request body
          const body = {
            message: `Backup ${new Date().toLocaleString()}`,
            content: contentBase64,
          };
          if (sha) body.sha = sha;

          // 3. Execute upload (PUT)
          const res = await fetch(apiUrl, {
            method: "PUT",
            headers: {
              Authorization: `token ${token}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify(body),
          });

          if (!res.ok) {
            const errText = await res.text();
            let errMsg = `Status ${res.status}`;
            try {
              const errJson = JSON.parse(errText);
              errMsg = errJson.message || errMsg;
            } catch (e) {}
            throw new Error(`GitHub API Error: ${errMsg}`);
          }
        }

        /**
         * Manage auto backup timer (modified: supports custom time and mode)
         */
        function handleAutoBackupTimer() {
          // Clear old timer
          if (githubBackupTimer) {
            clearInterval(githubBackupTimer);
            githubBackupTimer = null;
          }

          // If auto backup is enabled
          if (state.apiConfig && state.apiConfig.githubAutoBackup) {
            // Get interval time, default is 30 minutes
            const intervalMinutes = state.apiConfig.githubBackupInterval || 30;
            console.log(`GitHub auto backup enabled (every ${intervalMinutes} minutes)`);

            githubBackupTimer = setInterval(
              () => {
                // Get backup mode, default is full
                const mode = state.apiConfig.githubBackupMode || "full";

                if (mode === "stream") {
                  // Pass true to indicate this is an auto backup
                  uploadBackupToGitHubStream(true);
                } else {
                  uploadBackupToGitHub(true);
                }
              },
              intervalMinutes * 60 * 1000,
            );
          }
        }

        async function importBackup(file) {
          if (!file) return;

          const confirmed = await showCustomConfirm(
            "Severe Warning!",
            "Importing a backup will completely overwrite all your current data, including chats, settings, etc. This action is irreversible! Are you sure you want to continue?",
            { confirmButtonClass: "btn-danger" },
          );

          if (!confirmed) return;

          try {
            const text = await file.text();
            const data = JSON.parse(text);

            await db.transaction("rw", db.tables, async () => {
              // 1. Clear all existing tables
              for (const table of db.tables) {
                await table.clear();
              }

              // Check each item in the backup file, only import if the corresponding table exists in the current database

              // Import array-type data
              const arrayTables = [
                "chats",
                "worldBooks",
                "userStickers",
                "charStickers",
                "personaPresets", // <--- Âú®ËøôÈáåÂä†ÂÖ•‰∫Ü 'charStickers'
                "qzonePosts",
                "qzoneAlbums",
                "qzonePhotos",
                "favorites",
                "qzoneGroups",
                "memories",
                "worldBookCategories",
                "callRecords",
                "customAvatarFrames",
                "themes",
                "apiPresets",
                "bubbleStylePresets",
                "fontPresets",
                "homeScreenPresets",
              ];

              // ‰∏ñÁïå‰π¶Ê†ºÂºèÂÖºÂÆπËΩ¨Êç¢‰ª£Á†Å
              for (const tableName of arrayTables) {
                if (Array.isArray(data[tableName]) && db[tableName]) {
                  let itemsToPut = data[tableName];

                  // ÂΩìÂ§ÑÁêÜ‰∏ñÁïå‰π¶Ë°®Ê†ºÊó∂ÔºåÊâßË°åÁâπÂà´ÁöÑËΩ¨Êç¢Êìç‰Ωú
                  if (tableName === "worldBooks") {
                    console.log("Checking and converting world book data format for compatibility...");
                    itemsToPut.forEach((book) => {
                      // Â¶ÇÊûú content ÊòØÊï∞ÁªÑ (Âà´‰∫∫ÁöÑÊ†ºÂºè)ÔºåÂàôÂ∞ÜÂÖ∂ËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤ (ÊàëÁöÑÊ†ºÂºè)
                      if (Array.isArray(book.content)) {
                        console.log(
                          `Detected array format world book: "${book.name}", converting to string...`,
                        );

                        // Convert each entry object in the array to a formatted string
                        const convertedEntries = book.content.map((entry) => {
                          const stringParts = [];
                          if (entry.comment) {
                            stringParts.push(`[Comment: ${entry.comment}]`);
                          }
                          if (entry.keys && entry.keys.length > 0) {
                            stringParts.push(
                              `[Keywords: ${entry.keys.join(", ")}]`,
                            );
                          }
                          stringParts.push(entry.content); // Main content of the entry
                          return stringParts.join("\n"); // Separate each entry internally with a newline
                        });

                        // Â∞ÜÊâÄÊúâËΩ¨Êç¢ÂêéÁöÑÊù°ÁõÆÂ≠óÁ¨¶‰∏≤Áî®‰∏Ä‰∏™ÊòéÊòæÁöÑÂàÜÈöîÁ¨¶ËøûÊé•Ëµ∑Êù•
                        book.content = convertedEntries.join("\n\n---\n\n");
                      }
                    });
                  }

                  // ËøáÊª§Âπ∂‰øùÂ≠òÊï∞ÊçÆ (ËøôÈÉ®ÂàÜÈÄªËæë‰øùÊåÅ‰∏çÂèò)
                  const validItems = itemsToPut.filter(
                    (item) =>
                      item &&
                      (typeof item.id === "undefined" ||
                        typeof item.id === "string" ||
                        typeof item.id === "number"),
                  );
                  if (validItems.length > 0) {
                    console.log(
                      `Importing ${validItems.length} items into table: ${tableName}...`,
                    );
                    await db[tableName].bulkPut(validItems);
                  }
                } else {
                  console.log(
                    `Skipping import: ${tableName} (does not exist in backup file or current database)`,
                  );
                }
              }

              // Import object-type data (usually settings)
              const objectTables = [
                "apiConfig",
                "globalSettings",
                "musicLibrary",
                "qzoneSettings",
              ];
              for (const tableName of objectTables) {
                if (data[tableName] && db[tableName]) {
                  console.log(`Importing settings: ${tableName}...`);
                  await db[tableName].put(data[tableName]);
                }
              }
            });

            // The logic for importing home screen styles remains unchanged, as it does not directly operate on multiple database tables
            if (data.homeScreenState) {
              const settings = (await db.globalSettings.get("main")) || {
                id: "main",
              };
              settings.widgetData = data.homeScreenState;
              if (data.homeScreenState.wallpaper)
                settings.wallpaper = data.homeScreenState.wallpaper;
              if (data.homeScreenState.lockscreenWallpaper)
                settings.lockscreenWallpaper =
                  data.homeScreenState.lockscreenWallpaper;
              if (data.homeScreenState.appIcons)
                settings.appIcons = data.homeScreenState.appIcons;
              await db.globalSettings.put(settings);
              console.log("Successfully imported home screen style data.");
            }

            await showCustomAlert(
              "Import Successful",
              "All data has been successfully restored! The app will refresh to apply all changes.",
            );

            setTimeout(() => {
              window.location.reload();
            }, 1500);
          } catch (error) {
            console.error("Error importing data:", error);
            await showCustomAlert(
              "Import Failed",
              `The file format is incorrect or the data is corrupted: ${error.message}`,
            );
          }
        }

        function applyCustomFont(fontUrl, isPreviewOnly = false) {
          if (!fontUrl) {
            // If no font URL is provided (e.g., restoring default), clear the styles
            dynamicFontStyle.innerHTML = "";
            document.getElementById("font-preview").style.fontFamily = "";
            return;
          }

          // This is a unified internal name
          const fontName = "custom-user-font";

          // This defines the font style rules
          const newStyle = `
			        @font-face {
			          font-family: '${fontName}';
			          src: url('${fontUrl}');
			          font-display: swap;
			        }`;

          if (isPreviewOnly) {
            // If it's just a preview, this logic remains unchanged
            const previewStyle =
              document.getElementById("preview-font-style") ||
              document.createElement("style");
            previewStyle.id = "preview-font-style";
            previewStyle.innerHTML = newStyle;
            if (!document.getElementById("preview-font-style"))
              document.head.appendChild(previewStyle);
            document.getElementById("font-preview").style.fontFamily =
              `'${fontName}', 'bulangni', sans-serif`;
          } else {
            // If it's a global application, define the font and tell the entire body to use it
            dynamicFontStyle.innerHTML = `
			            ${newStyle}
			            body {
			              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
			            }`;
          }
        }

        async function resetToDefaultFont() {
          // 1. Clear global font styles
          dynamicFontStyle.innerHTML = "";

          // 2. Update and save settings
          state.globalSettings.fontUrl = "";
          await db.globalSettings.put(state.globalSettings);

          // 3. Explicitly restore the global preview area's font to default
          const globalPreview = document.getElementById("font-preview");
          globalPreview.style.fontFamily = ""; // Remove inline styles

          // 4. Apply an empty font setting to ensure all areas are restored
          applyCustomFont("", true);

          alert("Default font has been restored.");
        }

        async function loadAllDataFromDB() {
          const [
            chatsArr,
            apiConfig,
            globalSettings,
            userStickers,
            charStickers,
            worldBooks,
            musicLib,
            personaPresets,
            qzoneSettings,
            initialFavorites,
            apiPresets,
            bubbleStylePresets,
            datingScenes, // <--- Newly added here
            localUserStickerCategories,
            offlinePresetsFromDB,
          ] = await Promise.all([
            db.chats.toArray(),
            db.apiConfig.get("main"),
            db.globalSettings.get("main"),
            db.userStickers.toArray(),
            db.charStickers.toArray(),
            db.worldBooks.toArray(),
            db.musicLibrary.get("main"),
            db.personaPresets.toArray(),
            db.qzoneSettings.get("main"),
            db.favorites.orderBy("timestamp").reverse().toArray(),
            db.apiPresets.toArray(),
            db.bubbleStylePresets.toArray(),
            db.datingScenes.toArray(), // <--- Newly added here
            db.userStickerCategories.toArray(),
            db.offlinePresets.toArray(),
          ]);
          state.offlinePresets = offlinePresetsFromDB || [];
          state.chats = chatsArr.reduce((acc, chat) => {
            if (!chat.checkpoints) {
              chat.checkpoints = [];
            }

            // For old group chat data, ensure the sticker library is present
            if (
              chat.isGroup &&
              (!chat.settings || !chat.settings.stickerLibrary)
            ) {
              if (!chat.settings) chat.settings = {}; // Just in case settings is missing
              chat.settings.stickerLibrary = [];
              console.log(
                `For old group chat "${chat.name}", the sticker library (stickerLibrary) property has been added.`,
              );
            }
            // For old single chat data, ensure the sticker library is present
            if (
              !chat.isGroup &&
              (!chat.settings || !chat.settings.stickerLibrary)
            ) {
              if (!chat.settings) chat.settings = {}; // Just in case settings is missing
              chat.settings.stickerLibrary = [];
              console.log(
                `For old single chat "${chat.name}", the sticker library (stickerLibrary) property has been added.`,
              );
            }

            if (typeof chat.unreadCount === "undefined") {
              chat.unreadCount = 0; // If this chat object doesn't have an unreadCount property, initialize it to 0
            }

            // For old data: add an empty string for innerVoiceBackground if it's missing
            if (typeof chat.innerVoiceBackground === "undefined") {
              chat.innerVoiceBackground = "";
            }

            // ‚òÖ‚òÖ‚òÖ This is the newly added compatibility code! ‚òÖ‚òÖ‚òÖ
            if (
              chat.settings &&
              typeof chat.settings.innerVoiceAdopterLabelFormat === "undefined"
            ) {
              chat.settings.innerVoiceAdopterLabelFormat = "Adopter: {{user}}";
            }
            // ‚òÖ‚òÖ‚òÖ Newly added compatibility code ends ‚òÖ‚òÖ‚òÖ

            // Check if it's a group chat and its member objects use the old `name` structure
            if (
              chat.isGroup &&
              chat.members &&
              chat.members.length > 0 &&
              chat.members[0].name
            ) {
              console.log(
                `Detected old group chat data for "${chat.name}", migrating...`,
              );
              chat.members.forEach((member) => {
                // If this member object doesn't have originalName, it's old data
                if (typeof member.originalName === "undefined") {
                  member.originalName = member.name; // Use the old name as originalName
                  member.groupNickname = member.name; // Also create an initial groupNickname
                  delete member.name; // Remove the old, ambiguous name field
                  needsUpdate = true; // Mark for database update
                }
              });
              console.log(`Migration completed for "${chat.name}"`);
            }

            // Ê£ÄÊü•1ÔºöÂ¶ÇÊûúÊòØ‰∏Ä‰∏™ÂçïËÅäÔºåÂπ∂‰∏îÊ≤°Êúâ status Â±ûÊÄß
            if (!chat.isGroup && !chat.status) {
              // Â∞±‰∏∫ÂÆÉË°•‰∏ä‰∏Ä‰∏™ÈªòËÆ§ÁöÑ status ÂØπË±°
              chat.status = {
                text: "Online",
                lastUpdate: Date.now(),
                isBusy: false,
              };
              console.log(`This adds the status attribute to the old character "${chat.name}".`);
            }

            // Check 2: Compatibility with the latest "relationship" feature
            if (!chat.isGroup && !chat.relationship) {
              // If it's a single chat and doesn't have a relationship object, add a default one
              chat.relationship = {
                status: "friend",
                blockedTimestamp: null,
                applicationReason: "",
              };
              console.log(`This adds the relationship attribute to the old character "${chat.name}".`);
            }

            if (
              !chat.isGroup &&
              (!chat.settings || !chat.settings.aiAvatarLibrary)
            ) {
              if (!chat.settings) chat.settings = {}; // Just in case settings is missing
              chat.settings.aiAvatarLibrary = [];
              console.log(
                `This adds the aiAvatarLibrary attribute to the old character "${chat.name}".`,
              );
            }

            // Compatibility with old data: add default summary settings for chats without them
            if (!chat.settings.summary) {
              chat.settings.summary = {
                enabled: false,
                mode: "auto",
                count: 20,
                prompt:
                  "Using Vietnamese language to summarize the core events and information of the following conversation from a third-person perspective, objectively and calmly, without any emotional bias. Do not engage in any role-playing or add subjective comments.",
                lastSummaryIndex: -1, // -1 indicates never summarized
              };
            }

            // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºö‰∏∫Ê≤°ÊúâNPCÂ∫ìÁöÑÂçïËÅäËßíËâ≤Ê∑ªÂä†Á©∫ÁöÑNPCÂ∫ì
            if (!chat.isGroup && !chat.npcLibrary) {
              chat.npcLibrary = [];
              console.log(`Completed the npcLibrary property for legacy character "${chat.name}".`);
            }

            // Compatibility with old data: add default Weibo settings for single chat characters without them
            if (
              !chat.isGroup &&
              (!chat.settings.weiboProfession ||
                typeof chat.settings.weiboInstruction === "undefined")
            ) {
              chat.settings.weiboProfession = "";
              chat.settings.weiboInstruction = "";
              console.log(`This adds the Weibo settings attribute to the old character "${chat.name}".`);
            }

            if (!chat.musicData) chat.musicData = { totalTime: 0 };
            if (
              chat.settings &&
              chat.settings.linkedWorldBookId &&
              !chat.settings.linkedWorldBookIds
            ) {
              chat.settings.linkedWorldBookIds = [
                chat.settings.linkedWorldBookId,
              ];
              delete chat.settings.linkedWorldBookId;
            }

            // Compatibility with old data: add default value for chats without isPinned attribute
            if (typeof chat.isPinned === "undefined") {
              chat.isPinned = false;
            }

            // Ensure all characters' phone data is initialized and fixed
            if (!chat.isGroup) {
              // Á¨¨‰∏ÄÊ≠•ÔºöÁ°Æ‰øùÊúÄÂ§ñÂ±ÇÁöÑ characterPhoneData ÂØπË±°Â≠òÂú®
              if (!chat.characterPhoneData) {
                chat.characterPhoneData = {}; // Â¶ÇÊûú‰∏çÂ≠òÂú®ÔºåÂ∞±ÂàõÂª∫‰∏Ä‰∏™Á©∫ÁöÑ
              }

              // Á¨¨‰∫åÊ≠•ÔºöÈÄê‰∏ÄÊ£ÄÊü•Âπ∂Ë°•ÂÖ®ÊâÄÊúâAPPÁöÑÊï∞ÊçÆÁªìÊûÑ
              // ËøôÊ†∑Êó†ËÆ∫ËßíËâ≤Â§öËÄÅÔºåÈÉΩËÉΩÁ°Æ‰øùÊâÄÊúâÂ≠óÊÆµÈÉΩÂ≠òÂú®
              if (!chat.characterPhoneData.widgets)
                chat.characterPhoneData.widgets = {};
              if (!chat.characterPhoneData.lastGenerated)
                chat.characterPhoneData.lastGenerated = null;
              if (!chat.characterPhoneData.chats)
                chat.characterPhoneData.chats = {};
              if (!chat.characterPhoneData.shoppingCart)
                chat.characterPhoneData.shoppingCart = [];
              if (!chat.characterPhoneData.memos)
                chat.characterPhoneData.memos = [];
              if (!chat.characterPhoneData.browserHistory)
                chat.characterPhoneData.browserHistory = [];
              if (!chat.characterPhoneData.photoAlbum)
                chat.characterPhoneData.photoAlbum = [];
              if (!chat.characterPhoneData.bank)
                chat.characterPhoneData.bank = { balance: 0, transactions: [] };
              if (!chat.characterPhoneData.trajectory)
                chat.characterPhoneData.trajectory = [];
              if (!chat.characterPhoneData.appUsage)
                chat.characterPhoneData.appUsage = [];
              if (!chat.characterPhoneData.diary)
                chat.characterPhoneData.diary = [];
              if (!chat.characterPhoneData.appWallpaper) {
                chat.characterPhoneData.appWallpaper = "";
              }
            }

            // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºå‰∏∫Ê≤°ÊúâÂêéÂè∞Ê¥ªÂä®ËÆæÁΩÆÁöÑÁæ§ËÅäÊ∑ªÂä†ÈªòËÆ§ÂÄº
            if (
              chat.isGroup &&
              (!chat.settings ||
                typeof chat.settings.backgroundActivity === "undefined")
            ) {
              if (!chat.settings) chat.settings = {}; // ‰ª•Èò≤‰∏á‰∏ÄËøûsettingsÈÉΩÊ≤°Êúâ
              chat.settings.backgroundActivity = {
                enabled: false,
                interval: 120, // ÈªòËÆ§120Áßí
                lastActivityTimestamp: 0,
              };
            }

            // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºö‰∏∫Ê≤°ÊúâÊÉÖ‰æ£Â§¥ÂÉèËÆæÁΩÆÁöÑËßíËâ≤Ê∑ªÂä†ÈªòËÆ§ÂÄº
            if (typeof chat.settings.isCoupleAvatar === "undefined") {
              chat.settings.isCoupleAvatar = false;
              chat.settings.coupleAvatarDescription = "";
            }

            // 1. ‰∏∫ÊâÄÊúâËßíËâ≤ÔºàÂåÖÊã¨Êñ∞ÊóßÊï∞ÊçÆÔºâÁ°Æ‰øùÊúâ petAdopted Ê†áÂøó
            if (
              !chat.isGroup &&
              typeof chat.settings.petAdopted === "undefined"
            ) {
              // Â¶ÇÊûú pet ÂØπË±°Â∑≤Â≠òÂú®ÔºåËØ¥ÊòéÊòØËÄÅÁî®Êà∑ÔºåÈªòËÆ§Â∑≤È¢ÜÂÖª
              if (chat.settings.pet && chat.settings.pet.type !== "None") {
                chat.settings.petAdopted = true;
              } else {
                // Â¶ÇÊûúÊ≤°Êúâ pet ÂØπË±°ÔºåËØ¥ÊòéÊòØÊñ∞Áî®Êà∑Êàñ‰πãÂâçÂ∞±Ê≤°Áî®ÂÆ†Áâ©ÔºåÈªòËÆ§Êú™È¢ÜÂÖª
                chat.settings.petAdopted = false;
              }
              console.log(
                `‰∏∫ËßíËâ≤ "${chat.name}" ÂàùÂßãÂåñ‰∫ÜÂÆ†Áâ©È¢ÜÂÖªÁä∂ÊÄÅ: ${chat.settings.petAdopted}`,
              );
            }

            // 2. ÂÖºÂÆπÊóßÁöÑ pet ÂØπË±°ÔºåÁ°Æ‰øùÊñ∞Â≠óÊÆµÂ≠òÂú®ÔºàËøôÊÆµ‰ª£Á†ÅÂíå‰πãÂâç‰∏ÄÊ†∑Ôºå‰øùÁïôÂç≥ÂèØÔºâ
            if (!chat.isGroup && chat.settings.pet) {
              if (typeof chat.settings.pet.persona === "undefined") {
                chat.settings.pet.persona =
                  "A cute little pet, full of curiosity about the world.";
              }
              if (!chat.settings.pet.petChatHistory) {
                chat.settings.pet.petChatHistory = [];
              }
              if (!chat.settings.pet.status) {
                chat.settings.pet.status = {
                  hunger: 100,
                  happiness: 100,
                  intimacyToUser: 50,
                  intimacyToChar: 50,
                  lastUpdated: Date.now(),
                };
              } else {
                if (
                  typeof chat.settings.pet.status.intimacyToUser === "undefined"
                )
                  chat.settings.pet.status.intimacyToUser = 50;
                if (
                  typeof chat.settings.pet.status.intimacyToChar === "undefined"
                )
                  chat.settings.pet.status.intimacyToChar = 50;
                if (typeof chat.settings.pet.status.lastUpdated === "undefined")
                  chat.settings.pet.status.lastUpdated = Date.now();
              }
            }

            // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºö‰∏∫Ê≤°ÊúâËÆ∞ÂøÜ‰∫íÈÄöËÆæÁΩÆÁöÑËÅäÂ§©Ê∑ªÂä†‰∏Ä‰∏™Á©∫ÁöÑÊï∞ÁªÑ
            if (!chat.settings.linkedMemories) {
              chat.settings.linkedMemories = [];
            }

            // ‰∏∫ÊóßÊï∞ÊçÆÊ∑ªÂä†ÈªòËÆ§ÁöÑËÆ∞ÂøÜÊù°Êï∞ËÆæÁΩÆ
            if (typeof chat.settings.linkMemoryDepth === "undefined") {
              chat.settings.linkMemoryDepth = 5;
            }

            // ÂÖºÂÆπÁ∫ø‰∏ãÊ®°ÂºèËÆæÁΩÆ
            if (!chat.settings.offlineMode) {
              chat.settings.offlineMode = {
                enabled: false,
                prompt: "",
                style: "",
                wordCount: 300,
                presets: [],
              };
            }

            if (!chat.isGroup) {
              // Âè™‰∏∫ÂçïËÅäËßíËâ≤Ê∑ªÂä†
              if (!chat.characterPhoneData) {
                chat.characterPhoneData = {}; // ‰ª•Èò≤‰∏á‰∏ÄËøû characterPhoneData ÈÉΩÊ≤°Êúâ
              }
              if (!chat.characterPhoneData.wallpaper) {
                chat.characterPhoneData.wallpaper = ""; // ÂàùÂßãÂåñÂ£ÅÁ∫∏‰∏∫Á©∫
              }
              if (!chat.characterPhoneData.appIcons) {
                chat.characterPhoneData.appIcons = {}; // ÂàùÂßãÂåñAppÂõæÊ†á‰∏∫Á©∫ÂØπË±°
              }
            }
            // ‰∏∫ÊóßËßíËâ≤Êï∞ÊçÆÂÖºÂÆπÂæÆÂçöÁã¨Á´ãËÆæÁΩÆ
            if (!chat.isGroup) {
              if (!chat.settings.weiboNickname) {
                chat.settings.weiboNickname = chat.name; // ÈªòËÆ§‰ΩøÁî®ËßíËâ≤Âêç‰Ωú‰∏∫ÂæÆÂçöÊòµÁß∞
              }
              if (!chat.settings.weiboAvatar) {
                chat.settings.weiboAvatar = chat.settings.aiAvatar; // ÈªòËÆ§‰ΩøÁî®AIÂ§¥ÂÉè
              }
              if (!chat.settings.weiboAvatarFrame) {
                chat.settings.weiboAvatarFrame =
                  chat.settings.aiAvatarFrame || ""; // ÈªòËÆ§‰ΩøÁî®AIÂ§¥ÂÉèÊ°Ü
              }
              if (!chat.settings.weiboBackground) {
                chat.settings.weiboBackground =
                  "https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg"; // Áªô‰∏Ä‰∏™ÈªòËÆ§ËÉåÊôØ
              }
              // weiboProfession Âíå weiboInstruction ‰πãÂâçÂ∑≤ÁªèÂÖºÂÆπËøá‰∫ÜÔºåËøôÈáå‰∏çÁî®ÈáçÂ§ç
            }
            // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºö‰∏∫Ê≤°ÊúâÂæÆÂçöËÆæÁΩÆÁöÑÂçïËÅäËßíËâ≤Ê∑ªÂä†Á©∫ÁöÑÂæÆÂçöËÆæÁΩÆ
            if (
              !chat.isGroup &&
              (!chat.settings.weiboProfession ||
                typeof chat.settings.weiboInstruction === "undefined")
            ) {
              chat.settings.weiboProfession = "";
              chat.settings.weiboInstruction = "";
              console.log(`‰∏∫ÊóßËßíËâ≤ "${chat.name}" Ë°•ÂÖ®‰∫ÜÂæÆÂçöËÆæÁΩÆÂ±ûÊÄß„ÄÇ`);
            }

            // ‰∏∫ÊóßËßíËâ≤Êï∞ÊçÆÂÖºÂÆπÂæÆÂçöÁ≤â‰∏ù/ÂÖ≥Ê≥®Êï∞
            if (
              !chat.isGroup &&
              (typeof chat.settings.weiboFansCount === "undefined" ||
                typeof chat.settings.weiboFollowingCount === "undefined")
            ) {
              const initialStats = getInitialWeiboStats(chat);
              chat.settings.weiboFansCount = initialStats.fans;
              chat.settings.weiboFollowingCount = initialStats.following;
              console.log(`‰∏∫ÊóßËßíËâ≤ "${chat.name}" ÂàùÂßãÂåñ‰∫ÜÂæÆÂçöÊï∞ÊçÆ„ÄÇ`);
            }

            if (
              !chat.isGroup &&
              (!chat.settings ||
                typeof chat.settings.minimaxVoiceId === "undefined")
            ) {
              if (!chat.settings) chat.settings = {};
              chat.settings.minimaxVoiceId = ""; // ÈªòËÆ§‰∏∫Á©∫
              console.log(
                `‰∏∫ÊóßËßíËâ≤ "${chat.name}" Ë°•ÂÖ®‰∫Ü minimaxVoiceId Â±ûÊÄß„ÄÇ`,
              );
            }

            // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºö‰∏∫Ê≤°ÊúâÁÅ´Ëä±ËÆæÁΩÆÁöÑËÅäÂ§©Ê∑ªÂä†ÈªòËÆ§ÂÄº
            if (!chat.settings.streak) {
              chat.settings.streak = {
                enabled: false,
                initialDays: 0, // „ÄêÊñ∞„ÄëÁî®Êà∑Â°´ÂÜôÁöÑÂàùÂßãÂ§©Êï∞
                currentDays: 0, // ÂΩìÂâçÁöÑÁÅ´Ëä±Â§©Êï∞
                extinguishThreshold: 1, // „ÄêÊñ∞„ÄëÁÜÑÁÅ≠ÈòàÂÄºÔºåÈªòËÆ§1Â§©
                lastInteractionDate: null, // ‰∏äÊ¨°‰∫íÂä®Êó•Êúü
              };
              console.log(
                `‰∏∫ËßíËâ≤ "${chat.name}" Ë°•ÂÖ®‰∫ÜÂ¢ûÂº∫ÁâàÁÅ´Ëä±(streak)ËÆæÁΩÆ„ÄÇ`,
              );
            } else if (
              typeof chat.settings.streak.extinguishThreshold === "undefined"
            ) {
              // ÂÖºÂÆπ‰Ω†‰∏ä‰∏™ÁâàÊú¨ÁöÑÊï∞ÊçÆÔºå‰∏∫ÂÆÉ‰ª¨‰πüÂä†‰∏äÁÜÑÁÅ≠ÈòàÂÄº
              chat.settings.streak.extinguishThreshold = 1;
              console.log(`‰∏∫ËßíËâ≤ "${chat.name}" ÁöÑÊóßÁÅ´Ëä±ËÆæÁΩÆÊ∑ªÂä†‰∫ÜÁÜÑÁÅ≠ÈòàÂÄº„ÄÇ`);
            }

            // ÂÖºÂÆπÊóßÁöÑÁæ§ËÅäÊï∞ÊçÆÔºå‰∏∫ÂÆÉ‰ª¨Ê∑ªÂä†Áæ§‰∏ª„ÄÅÁÆ°ÁêÜÂëòÂíåÂ§¥Ë°îÂ±ûÊÄß
            if (chat.isGroup) {
              if (typeof chat.settings.groupAnnouncement === "undefined") {
                chat.settings.groupAnnouncement = "";
              }

              // Â¶ÇÊûúÊ≤°ÊúâownerIdÔºåÂàôÈªòËÆ§ÂàõÂª∫ËÄÖÔºà‰πüÂ∞±ÊòØ‰Ω†Ôºâ‰∏∫Áæ§‰∏ª
              if (!chat.ownerId) {
                chat.ownerId = "user"; // Êàë‰ª¨ÂÅáËÆæÁî®Êà∑ÁöÑID‰∏∫ 'user'
              }
              // ÈÅçÂéÜÊâÄÊúâÊàêÂëòÔºå‰∏∫‰ªñ‰ª¨Ê∑ªÂä†Êñ∞Â±ûÊÄß
              if (chat.members && Array.isArray(chat.members)) {
                chat.members.forEach((member) => {
                  if (typeof member.isAdmin === "undefined") {
                    member.isAdmin = false; // ÈªòËÆ§‰∏çÊòØÁÆ°ÁêÜÂëò
                  }
                  if (typeof member.groupTitle === "undefined") {
                    member.groupTitle = ""; // ÈªòËÆ§Ê≤°ÊúâÂ§¥Ë°î
                  }
                });
              }
              // ‰∏∫Áî®Êà∑Ëá™Â∑±‰πüÊ∑ªÂä†ÁÆ°ÁêÜÂëòÂíåÂ§¥Ë°îÁöÑÈªòËÆ§Â±ûÊÄß
              if (chat.settings) {
                if (typeof chat.settings.isUserAdmin === "undefined") {
                  chat.settings.isUserAdmin = false;
                }
                if (typeof chat.settings.myGroupTitle === "undefined") {
                  chat.settings.myGroupTitle = "";
                }
              }
            }

            // Âú® loadAllDataFromDB ÂáΩÊï∞ÁöÑ forEach Âæ™ÁéØÂÜÖÔºåacc[chat.id] = chat; ‰πãÂâçÊ∑ªÂä†Ôºö

            // ‰∏∫ÊóßÊï∞ÊçÆÂÖºÂÆπÂøÉÂ£∞Èù¢ÊùøÊ†∑ÂºèËÆæÁΩÆ
            if (!chat.settings.innerVoiceStyles) {
              chat.settings.innerVoiceStyles = {
                clothingColor: "#f0a1a8",
                behaviorColor: "#81c784",
                thoughtsColor: "#64b5f6",
                naughtyColor: "#ba68c8",
                cardBgColor: "#ffffff",
                cardOpacity: 0.7,
              };
            }
            // ‰∏∫ÊóßÊï∞ÊçÆÂÖºÂÆπÂõæÊ†áÈ¢úËâ≤ËÆæÁΩÆ
            if (
              chat.settings.innerVoiceStyles &&
              typeof chat.settings.innerVoiceStyles.iconColor === "undefined"
            ) {
              chat.settings.innerVoiceStyles.iconColor = "#ff8a80"; // ÈªòËÆ§Á≤âÁ∫¢Ëâ≤
            }

            // ÂÖºÂÆπ‰∫≤ÂØÜÂÄºÁ≥ªÁªüÔºö‰∏∫ÊóßÊï∞ÊçÆÊ∑ªÂä†‰∫íÂä®ÁªüËÆ°ÂíåÂ∑≤Ëß£ÈîÅÂæΩÁ´†
            if (!chat.interactionStats) {
              chat.interactionStats = {};
            }
            if (!chat.unlockedSymbols) {
              chat.unlockedSymbols = [];
            }

            // ÂÖºÂÆπ‰∫≤ÂØÜÂÄºÁ≥ªÁªüÔºö‰∏∫ÊóßÊï∞ÊçÆÊ∑ªÂä†‰Ω©Êà¥ÂæΩÁ´†ÁöÑÂ≠óÊÆµ
            if (
              chat.settings &&
              typeof chat.settings.selectedIntimacyBadge === "undefined"
            ) {
              chat.settings.selectedIntimacyBadge = ""; // ÈªòËÆ§‰∏∫Á©∫Ôºå‰∏ç‰Ω©Êà¥
            }

            if (!chat.isGroup && chat.settings) {
              if (typeof chat.settings.language_boost === "undefined") {
                chat.settings.language_boost = null; // ÈªòËÆ§‰∏∫null
              }
              if (typeof chat.settings.speed === "undefined") {
                chat.settings.speed = 1.0; // ÈªòËÆ§‰∏∫1.0
              }
            }
            // ‰∏∫ÊóßÊï∞ÊçÆË°•ÂÖ®ÊÉÖ‰æ£Â§¥ÂÉèÂ∫ì
            if (!chat.isGroup && !chat.settings.coupleAvatarLibrary) {
              chat.settings.coupleAvatarLibrary = [];
              console.log(
                `‰∏∫ÊóßËßíËâ≤ "${chat.name}" Ë°•ÂÖ®‰∫ÜÊÉÖ‰æ£Â§¥ÂÉèÂ∫ì(coupleAvatarLibrary)Â±ûÊÄß„ÄÇ`,
              );
            }
            acc[chat.id] = chat;
            return acc;
          }, {});

          state.apiConfig = apiConfig || {
            id: "main",
            proxyUrl: "",
            apiKey: "",
            model: "",
            temperature: 0.8, // Êñ∞Â¢ûÔºö‰∏∫Ê∏©Â∫¶ËÆæÁΩÆ‰∏Ä‰∏™ÈªòËÆ§ÂÄº 0.8
            minimaxGroupId: "",
            minimaxApiKey: "",
            minimaxProvider: "cn",
            minimaxSpeechModel: "speech-01-turbo",
            pollinationsApiKey: "", // <--- Êñ∞Â¢ûËøô‰∏ÄË°å
          };

          // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºåÂ¶ÇÊûúÂä†ËΩΩÁöÑËÆæÁΩÆÈáåÊ≤°ÊúâÊ∏©Â∫¶Ôºå‰πüÁªô‰∏Ä‰∏™ÈªòËÆ§ÂÄº
          if (typeof state.apiConfig.temperature === "undefined") {
            state.apiConfig.temperature = 0.8;
          }

          state.globalSettings = globalSettings || {
            id: "main",
            quickReplies: ["Hello", "Continue", "Interesting"],
            ringtoneUrl: "https://files.catbox.moe/3w7gla.mp3",
            notificationSoundUrl: "https://files.catbox.moe/k369mf.mp3", // <-- Âú®ËøôÈáåÊñ∞Â¢ûËøô‰∏ÄË°å
            widgetData: {},
            wallpaper: "linear-gradient(135deg, #89f7fe, #66a6ff)",
            lockscreenWallpaper: "linear-gradient(135deg, #764ba2, #667eea)",
            password: "",
            fontUrl: "",
            enableBackgroundActivity: false,
            backgroundActivityInterval: 60,
            blockCooldownHours: 1,
            appIcons: { ...DEFAULT_APP_ICONS },
            appLabels: {},
            ringtoneUrl: "https://files.catbox.moe/3w7gla.mp3",
            notificationSoundUrl: "https://files.catbox.moe/k369mf.mp3",
            widgetData: {}, // „ÄêÊ†∏ÂøÉ‰øÆÊîπ„ÄëÂú®ËøôÈáåÊñ∞Â¢û‰∏Ä‰∏™Á©∫ÂØπË±°ÔºåÁî®Êù•Â≠òÊîæ‰Ω†ÁöÑËá™ÂÆö‰πâÂÜÖÂÆπ
            // Âú® state.globalSettings ÁöÑÂàùÂßãÂåñÂØπË±°ÈáåÊ∑ªÂä†Ôºö
            homeAvatarFrame: "", // ‰∏∫‰∏ªÂ±èÂπïÂ§¥ÂÉèÊ°ÜÊ∑ªÂä†ÈªòËÆ§Á©∫ÂÄº

            globalChatBackground: "",
            homeIconWidgetTextColor: "#FFFFFF", // <-- ‰øÆÊîπËøôÈáåÁöÑÂêçÂ≠ó
            imageCompressionQuality: 0.7,
            userBalance: 520,
            activePersonaId: null,

            homeAvatarFrame: "", // ‰∏∫‰∏ªÂ±èÂπïÂ§¥ÂÉèÊ°ÜÊ∑ªÂä†ÈªòËÆ§Á©∫ÂÄº
          };
          // Á°Æ‰øùÂç≥‰Ωø‰ªéÊóßÊï∞ÊçÆÂ∫ìÂä†ËΩΩÔºåËøô‰∏™Â±ûÊÄß‰πüÂ≠òÂú®
          if (typeof state.globalSettings.activePersonaId === 'undefined')
            state.globalSettings.activePersonaId = null;
          if (!state.globalSettings.widgetData) {
            state.globalSettings.widgetData = {};
          }

          if (!state.globalSettings.homeIconWidgetTextColor) {
            // <-- ‰øÆÊîπËøôÈáåÁöÑÂêçÂ≠ó
            state.globalSettings.homeIconWidgetTextColor = "#FFFFFF";
          }
          // ÂÖºÂÆπÂ≠ó‰ΩìÈò¥ÂΩ±ËÆæÁΩÆ
          if (
            typeof state.globalSettings.removeHomeFontShadow === "undefined"
          ) {
            state.globalSettings.removeHomeFontShadow = false;
          }

          // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºöÂ¶ÇÊûúÂä†ËΩΩÁöÑËÆæÁΩÆÈáåÊ≤°ÊúâappLabelsÔºåÂ∞±ÁªôÂÆÉ‰∏Ä‰∏™Á©∫ÂØπË±°
          if (!state.globalSettings.appLabels) {
            state.globalSettings.appLabels = {};
          }

          if (
            typeof state.globalSettings.imageCompressionQuality === "undefined"
          ) {
            state.globalSettings.imageCompressionQuality = 0.7;
          }

          // Âä†ËΩΩÊ≠åËØçÊ†èËÆæÁΩÆÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®Âàô‰ΩøÁî®ÈªòËÆ§ÂÄº
          lyricsBarSettings =
            state.globalSettings.lyricsBarSettings || lyricsBarSettings;
          // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºöÂàùÂßãÂåñÂø´Êç∑ÂõûÂ§ç (ÈªòËÆ§‰∏∫Á©∫)
          if (!state.globalSettings.quickReplies) {
            state.globalSettings.quickReplies = [];
          }

          // ÂêàÂπ∂Â∑≤‰øùÂ≠òÁöÑÂõæÊ†áÂíåÈªòËÆ§ÂõæÊ†áÔºåÈò≤Ê≠¢Êõ¥Êñ∞ÂêéÊóßÊï∞ÊçÆ‰∏¢Â§±Êñ∞ÂõæÊ†á
          state.globalSettings.appIcons = {
            ...DEFAULT_APP_ICONS,
            ...(state.globalSettings.appIcons || {}),
          };

          state.userStickers = userStickers || [];
          userStickerCategories = localUserStickerCategories || [];
          state.charStickers = charStickers || [];
          state.worldBooks = worldBooks || [];
          currentDatingScenes = datingScenes || [];
          // Âä†ËΩΩÊí≠ÊîæÂàóË°®Âπ∂Ê≥®ÂÖ•‚ÄúÈöêÂΩ¢‚Äù‰øùÊ¥ªÈü≥È¢ë
          window.state.musicState.playlist = musicLib?.playlist || [];

          const keepAliveUrl = "https://files.catbox.moe/7jn7bp.mp3";

          // Ê£ÄÊü•ÂàóË°®‰∏≠ÊòØÂê¶Â∑≤ÁªèÊúâËøô‰∏™Èü≥È¢ë‰∫Ü
          const existingKeepAliveIndex =
            window.state.musicState.playlist.findIndex(
              (t) => t.src === keepAliveUrl,
            );

          // Â¶ÇÊûúÂ∑≤ÁªèÂ≠òÂú®ÔºåÂÖàÂà†ÊéâÊóßÁöÑÔºåÁ°Æ‰øùÂÆÉÊ∞∏ËøúÂú®Á¨¨‰∏Ä‰Ωç‰∏î‰ø°ÊÅØÊúÄÊñ∞
          if (existingKeepAliveIndex > -1) {
            window.state.musicState.playlist.splice(existingKeepAliveIndex, 1);
          }

          // ÂàõÂª∫‰øùÊ¥ª‰∏ìÁî®ÂØπË±°
          const keepAliveTrack = {
            name: "„ÄêBackground Keep-Alive Mode„Äë(Silent)",
            artist: "Tap to play to keep running in background",
            src: keepAliveUrl,
            // Use the API Settings icon as cover
            cover:
              "https://i.postimg.cc/y8YfDNNr/D9FD94FC0A3523D02D9EE3A7B0F57396.png",
            isLocal: false,
            lrcContent:
              "[00:00.00]‚ö†Ô∏è Background keep-alive running...\n[00:02.00]This audio is silent\n[00:05.00]Used to prevent API request interruption\n[99:99.99]End",
            isTemporary: false,
            addedTimestamp: Date.now(),
            // ‚òÖ‚òÖ‚òÖ Core flag: this is a keep-alive track ‚òÖ‚òÖ‚òÖ
            isKeepAlive: true,
          };


          // Âº∫Âà∂ÊèíÂà∞Êí≠ÊîæÂàóË°®ÁöÑÁ¨¨ 0 ‰Ωç
          window.state.musicState.playlist.unshift(keepAliveTrack);

          state.personaPresets = personaPresets || [];
          // Orphan-check: clear activePersonaId if its persona was deleted
          if (state.globalSettings.activePersonaId) {
            const _apExists = state.personaPresets.some(p => p.id === state.globalSettings.activePersonaId);
            if (!_apExists) {
              state.globalSettings.activePersonaId = null;
              db.globalSettings.put(state.globalSettings);
            }
          }
          state.apiPresets = apiPresets || [];
          state.bubbleStylePresets = bubbleStylePresets || [];

          state.qzoneSettings = qzoneSettings || {
            id: "main",
            nickname: "{{user}}",
            avatar: "https://files.catbox.moe/q6z5fc.jpeg",
            banner: "https://files.catbox.moe/r5heyt.gif",
            weiboAvatar: "https://files.catbox.moe/q6z5fc.jpeg",
            weiboNickname: "Your nickname",
            weiboFansCount: "0",
            weiboBackground:
              "https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg",

            weiboUserProfession: "Tap to set profession",
            weiboUserPersona: "An ordinary Weibo user.",
            weiboUserPersonaPresets: [],
          };
          // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºåÂ¶ÇÊûúÂä†ËΩΩËøõÊù•ÁöÑÊï∞ÊçÆÊ≤°ÊúâËøô‰∫õÊñ∞Â≠óÊÆµÔºåÂ∞±Ë°•‰∏äÈªòËÆ§ÂÄº
          if (!state.qzoneSettings.weiboAvatar)
            state.qzoneSettings.weiboAvatar =
              state.qzoneSettings.avatar ||
              "https://files.catbox.moe/q6z5fc.jpeg";
          if (!state.qzoneSettings.weiboNickname)
            state.qzoneSettings.weiboNickname =
              state.qzoneSettings.nickname || "Your nickname";
          if (!state.qzoneSettings.weiboFansCount)
            state.qzoneSettings.weiboFansCount = "0";
          if (!state.qzoneSettings.weiboBackground)
            state.qzoneSettings.weiboBackground =
              "https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg";

          if (!state.qzoneSettings.weiboUserProfession)
            state.qzoneSettings.weiboUserProfession = "Tap to set profession";
          if (!state.qzoneSettings.weiboUserPersona)
            state.qzoneSettings.weiboUserPersona = "An ordinary Weibo user.";
          if (!state.qzoneSettings.weiboUserPersonaPresets)
            state.qzoneSettings.weiboUserPersonaPresets = [];

          if (!state.qzoneSettings.weiboAvatarFrame)
            state.qzoneSettings.weiboAvatarFrame = "";

          allFavoriteItems = initialFavorites || [];

          if (
            typeof state.globalSettings.notificationSoundUrl === "undefined"
          ) {
            state.globalSettings.notificationSoundUrl =
              "https://files.catbox.moe/k369mf.mp3";
          }
        }

        async function saveGlobalPlaylist() {
          // 1. Âú®‰øùÂ≠òÂâçÔºåÂÖà‰ªéÂΩìÂâçÊí≠ÊîæÂàóË°®‰∏≠ËøáÊª§ÊéâÊâÄÊúâË¢´Ê†áËÆ∞‰∏∫ isTemporary ÁöÑÊ≠åÊõ≤
          const permanentPlaylist = state.musicState.playlist.filter(
            (track) => !track.isTemporary,
          );

          // 2. Âè™Â∞ÜËøô‰∏™‚ÄúÊ∞∏‰πÖÊí≠ÊîæÂàóË°®‚Äù‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì‰∏≠
          await db.musicLibrary.put({
            id: "main",
            playlist: permanentPlaylist,
          });
          console.log("Permanent playlist has been saved to the database.");
        }

        function formatTimestamp(timestamp) {
          if (!timestamp) return "";
          const date = new Date(timestamp);
          const hours = String(date.getHours()).padStart(2, "0");
          const minutes = String(date.getMinutes()).padStart(2, "0");
          return `${hours}:${minutes}`;
        }
        /**
         * ÊòæÁ§∫Á≥ªÁªü/Â∫îÁî®ÂÜÖÈÄöÁü•
         * @param {string} chatId - ËÅäÂ§©ID
         * @param {string} messageContent - Ê∂àÊÅØÂÜÖÂÆπ
         * @param {string} specificAvatarUrl - [Êñ∞Â¢ûÂèÇÊï∞] ÊåáÂÆöÁöÑÂÖ∑‰ΩìÂ§¥ÂÉèURLÔºàÁî®‰∫éÁæ§ËÅäÊòæÁ§∫ÂèëË®Ä‰∫∫Â§¥ÂÉèÔºâ
         */
        async function showNotification(
          chatId,
          messageContent,
          specificAvatarUrl = null,
        ) {
          // Êí≠ÊîæÈü≥Êïà
          playNotificationSound();

          // Ê∏ÖÈô§ÊóßÁöÑÂ∫îÁî®ÂÜÖÈ°∂ÈÉ®Ê®™ÂπÖËÆ°Êó∂Âô®
          clearTimeout(notificationTimeout);

          const chat = state.chats[chatId];
          if (!chat) return;

          // 1. ÂáÜÂ§áÈÄöÁü•Êï∞ÊçÆ
          // ÈÄªËæë‰øÆÊîπÔºöÂ¶ÇÊûú‰º†ÂÖ•‰∫Ü specificAvatarUrlÔºåÂ∞±Áõ¥Êé•Áî®ÔºõÂê¶ÂàôÊåâÂéüÈÄªËæëÔºàÁæ§Áî®Áæ§Â§¥ÂÉèÔºåÂçïËÅäÁî®AIÂ§¥ÂÉèÔºâ
          let avatarUrl = specificAvatarUrl;

          if (!avatarUrl) {
            avatarUrl = chat.isGroup
              ? chat.settings.groupAvatar || defaultGroupAvatar
              : chat.settings.aiAvatar || defaultAvatar;
          }

          const notifName =
            !chat.isGroup && chat.settings.remarkName
              ? chat.settings.remarkName
              : chat.name;

          // 2. Ê£ÄÊµãÊòØÂê¶ÈúÄË¶ÅÂèëÈÄÅÁ≥ªÁªüÂºπÁ™ó (ÂéüÁîüÈÄöÁü•)
          const isSystemNotifyEnabled =
            state.globalSettings.enableSystemNotifications === true;
          const hasPermission =
            "Notification" in window && Notification.permission === "granted";

          if (isSystemNotifyEnabled && hasPermission) {
            const isChatActive =
              document.getElementById("chat-interface-screen") &&
              document
                .getElementById("chat-interface-screen")
                .classList.contains("active") &&
              state.activeChatId === chatId;

            if (document.hidden || !isChatActive) {
              const options = {
                body: messageContent,
                icon: avatarUrl, // ËøôÈáå‰πü‰ºöËá™Âä®‰ΩøÁî®Ê≠£Á°ÆÁöÑÂ§¥ÂÉè
                tag: chatId,
                renotify: true,
                silent: true,
                badge:
                  "https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg",
              };

              try {
                if ("serviceWorker" in navigator) {
                  const reg = await navigator.serviceWorker.getRegistration();
                  if (reg) {
                    await reg.showNotification(notifName, options);
                  } else {
                    new Notification(notifName, options);
                  }
                } else {
                  new Notification(notifName, options);
                }
              } catch (e) {
                console.error("System notification failed:", e.message);
              }
            }
          }

          // 3. In-app top banner (web popup)
          const bar = document.getElementById("notification-bar");
          const avatarImg = document.getElementById("notification-avatar");

          // Set the image
          if (avatarImg) avatarImg.src = avatarUrl;

          const contentDiv = document.getElementById("notification-content");
          if (contentDiv) {
            contentDiv.querySelector(".name").textContent = notifName;
            contentDiv.querySelector(".message").textContent = messageContent;
          }

          if (bar) {
            const newBar = bar.cloneNode(true);
            bar.parentNode.replaceChild(newBar, bar);

            newBar.addEventListener("click", () => {
              openChat(chatId);
              newBar.classList.remove("visible");
            });

            newBar.classList.add("visible");
            notificationTimeout = setTimeout(() => {
              newBar.classList.remove("visible");
            }, 4000);
          }
        }

        /**
         * ÊòæÁ§∫‰∏Ä‰∏™ÂåÖÂê´Â§ö‰∏™ÈÄâÈ°πÁöÑÊìç‰ΩúËèúÂçïÊ®°ÊÄÅÊ°Ü
         * ËøôÊòØËÆ©ÂõæÁâáÁºñËæëÊó∂ËÉΩÂ§üÈÄâÊã©‚ÄúÊú¨Âú∞‰∏ä‰º†‚ÄùÊàñ‚ÄúURL‚ÄùÁöÑÂÖ≥ÈîÆÂáΩÊï∞ÔºÅ
         * @param {string} title - Ê®°ÊÄÅÊ°ÜÁöÑÊ†áÈ¢ò
         * @param {Array<object>} options -  An array of button options, e.g., [{ text: 'Button text', value: 'Return value' }]
         * @returns {Promise<string|null>} - ËøîÂõûÁî®Êà∑ÁÇπÂáªÊåâÈíÆÁöÑvalueÔºåÂ¶ÇÊûúÂèñÊ∂àÂàôËøîÂõûnull
         */
        function showChoiceModal(title, options) {
          return new Promise((resolve) => {
            // Â§çÁî®‰Ω†Áé∞ÊúâÁöÑËá™ÂÆö‰πâÊ®°ÊÄÅÊ°Ü
            const modal = document.getElementById("preset-actions-modal");
            const footer = modal.querySelector(".custom-modal-footer");

            // Ê∏ÖÁ©∫ÊóßÊåâÈíÆÂπ∂Âä®ÊÄÅÂàõÂª∫Êñ∞ÊåâÈíÆ
            footer.innerHTML = "";

            options.forEach((option) => {
              const button = document.createElement("button");
              button.textContent = option.text;
              button.onclick = () => {
                modal.classList.remove("visible");
                resolve(option.value); // ËøîÂõûË¢´ÁÇπÂáªÊåâÈíÆÁöÑÂÄº
              };
              footer.appendChild(button);
            });

            // Ê∑ªÂä†‰∏Ä‰∏™Ê†áÂáÜÁöÑÂèñÊ∂àÊåâÈíÆ
            const cancelButton = document.createElement("button");
            cancelButton.textContent = "Cancel";
            cancelButton.style.marginTop = "8px";
            cancelButton.style.borderRadius = "8px";
            cancelButton.style.backgroundColor = "#f0f0f0";
            cancelButton.onclick = () => {
              modal.classList.remove("visible");
              resolve(null); // Áî®Êà∑ÂèñÊ∂àÔºåËøîÂõû null
            };
            footer.appendChild(cancelButton);
            modal.style.zIndex = "10005";
            modal.classList.add("visible");
          });
        }

        /**
         * „ÄêÂÖ®Êñ∞ÈáçÊûÑ„ÄëÊ£ÄÊü•Âπ∂Âà†Èô§ÊâÄÊúâÂ§±ÊïàÁöÑAPIÊ≠åÊõ≤
         * Ê†∏ÂøÉÈÄªËæëÔºö‰∏çÂÜç‰æùËµñ‰ªª‰ΩïÊ†áÁ≠æÔºåÁõ¥Êé•Ê†πÊçÆÈìæÊé•ÁâπÂæÅËØÜÂà´ÈúÄË¶ÅÊ£ÄÊü•ÁöÑÊ≠åÊõ≤„ÄÇ
         */
        async function deleteExpiredSearchedSongs() {
          await showCustomAlert(
            "Please wait...",
            "Checking the validity of all online songs in the playlist...",
          );

          // 1. ‰∏çÂÜçÂØªÊâæ isTemporary Ê†áÁ≠æ
          // ËÄåÊòØÁõ¥Êé•ÊâæÂá∫ÊâÄÊúâ src ÈìæÊé•Êù•Ëá™‰∫é API ÊúçÂä°Âô®ÁöÑÊ≠åÊõ≤„ÄÇ
          // ËøôÊòØ‰∏Ä‰∏™ÁªùÂØπÂèØÈù†ÁöÑËØÜÂà´ÊñπÊ≥ïÔºåÊó†ËÆ∫ÂÆÉÊúâÊ≤°ÊúâË¢´Ê≠£Á°Æ‰øùÂ≠ò„ÄÇ
          const songsToCheck = state.musicState.playlist.filter(
            (track) => track.src && track.src.includes("api.vkeys.cn"),
          );

          if (songsToCheck.length === 0) {
            await showCustomAlert("Notice", "There are no online songs in the playlist that need to be checked.");
            return;
          }

          const songsToDelete = [];
          const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;

          // 2. ÂØπÊØè‰∏ÄÈ¶ñËØÜÂà´Âá∫ÁöÑÊ≠åÊõ≤ÔºåËøõË°å‰∏•Ê†ºÁöÑ‚Äú‰ΩìÊ£Ä‚Äù
          await Promise.all(
            songsToCheck.map(async (track) => {
              // Êù°‰ª∂1ÔºöÊ£ÄÊü•ÈìæÊé•Êú¨Ë∫´ÊòØÂê¶Â∑≤ÁªèÂ§±ÊïàÔºàÊó†Ê≥ïÊí≠ÊîæÔºâ
              const isUrlInvalid = !(await checkAudioAvailability(track.src));

              // Êù°‰ª∂2ÔºöÊ£ÄÊü•Ê∑ªÂä†Êó∂Èó¥ÊòØÂê¶Ë∂ÖËøá24Â∞èÊó∂Ôºà‰Ωú‰∏∫ÂèåÈáç‰øùÈô©Ôºâ
              const isOlderThan24h =
                track.addedTimestamp &&
                track.addedTimestamp < twentyFourHoursAgo;

              if (isUrlInvalid || isOlderThan24h) {
    songsToDelete.push(track);
    console.log(
        `Marked for deletion: ${track.name} (Reason: ${isUrlInvalid ? "Invalid link" : ""} ${isOlderThan24h ? "Exceeds 24 hours" : ""})`
    );
}

            }),
          );

          // 3. Ê†πÊçÆÊ£ÄÊü•ÁªìÊûúËøõË°åÂèçÈ¶àÂíåÊìç‰Ωú (ËøôÈÉ®ÂàÜÈÄªËæë‰∏çÂèò)
          if (songsToDelete.length === 0) {
            await showCustomAlert(
              "Check Complete",
              "All online songs in the playlist are currently valid.",
            );
            return;
          }

          const confirmed = await showCustomConfirm(
            "Confirm Cleanup",
            `Detected ${songsToDelete.length} expired online songs. Are you sure you want to remove them from the playlist?`,
            { confirmButtonClass: "btn-danger" },
          );

          if (!confirmed) return;

          // ÊâßË°åÂà†Èô§...
          const currentTrack =
            state.musicState.currentIndex > -1
              ? state.musicState.playlist[state.musicState.currentIndex]
              : null;
          state.musicState.playlist = state.musicState.playlist.filter(
            (track) => !songsToDelete.includes(track),
          );
          const newIndex = currentTrack
            ? state.musicState.playlist.findIndex(
                (t) =>
                  t.src === currentTrack.src && t.name === currentTrack.name,
              )
            : -1;

          if (newIndex === -1) {
            if (state.musicState.isPlaying) {
              audioPlayer.pause();
              audioPlayer.src = "";
            }
            state.musicState.isPlaying = false;
            if (state.musicState.playlist.length > 0) {
              playSong(0);
            } else {
              state.musicState.currentIndex = -1;
              updatePlayerUI();
            }
          } else {
            state.musicState.currentIndex = newIndex;
            updatePlayerUI();
          }

          await saveGlobalPlaylist();
          updatePlaylistUI();
          await showCustomAlert(
            "Cleanup Complete",
            `${songsToDelete.length} expired online songs have been removed from the playlist.`,
          );
        }

        /**
         * Êõ¥Êñ∞ÊâÄÊúâÊó∂ÈíüÔºàÁä∂ÊÄÅÊ†èÂíåÈîÅÂ±èÔºâ
         */
        function updateClock() {
          const now = new Date();
          const timeString = now.toLocaleTimeString("en-GB", {
            hour: "2-digit",
            minute: "2-digit",
          });
          const dateString = now.toLocaleDateString("en-GB", { 
            weekday: "long",
            month: "long",
            day: "numeric",
          });

          // Êõ¥Êñ∞Áä∂ÊÄÅÊ†èÊó∂Èíü (Ëøô‰∏™ÂÖÉÁ¥†‰∏ÄÁõ¥Â≠òÂú®)
          const statusBarTime = document.getElementById("status-bar-time");
          if (statusBarTime) {
            statusBarTime.textContent = timeString;
          }

          // Êõ¥Êñ∞ÈîÅÂ±èÊó∂Èíü (Âè™ÊúâÂΩìÈîÅÂ±èÂÖÉÁ¥†Â≠òÂú®Êó∂ÊâçÊõ¥Êñ∞ÔºåÈÅøÂÖçÊä•Èîô)
          const lockTime = document.getElementById("lock-main-time");
          const lockDate = document.getElementById("lock-main-date");
          if (lockTime) {
            lockTime.textContent = timeString;
          }
          if (lockDate) {
            lockDate.textContent = dateString;
          }
        }

        /**
         * Ëß£ÊûêAIËøîÂõûÁöÑ„ÄÅÂèØËÉΩÊ†ºÂºè‰∏çËßÑËåÉÁöÑÂìçÂ∫îÂÜÖÂÆπ
         * @param {string} content - AIËøîÂõûÁöÑÂéüÂßãÂ≠óÁ¨¶‰∏≤
         * @returns {Array} - ‰∏Ä‰∏™Ê†áÂáÜÂåñÁöÑÊ∂àÊÅØÂØπË±°Êï∞ÁªÑ
         */
        function parseAiResponse(content) {
          const trimmedContent = content.trim();

          // ÊñπÊ°à1Ôºö„ÄêÊúÄ‰ºòÂÖà„ÄëÂ∞ùËØï‰Ωú‰∏∫Ê†áÂáÜÁöÑ„ÄÅÂçï‰∏ÄÁöÑJSONÊï∞ÁªÑËß£Êûê
          // ËøôÊòØÊúÄÁêÜÊÉ≥„ÄÅÊúÄÈ´òÊïàÁöÑÊÉÖÂÜµ
          if (trimmedContent.startsWith("[") && trimmedContent.endsWith("]")) {
            try {
              const parsed = JSON.parse(trimmedContent);
              if (Array.isArray(parsed)) {
                console.log("Parsing successful: Standard JSON array format.");
                return parsed;
              }
            } catch (e) {
              // Â¶ÇÊûúËß£ÊûêÂ§±Ë¥•ÔºåËØ¥ÊòéÂÆÉËôΩÁÑ∂ÁúãËµ∑Êù•ÂÉè‰∏™Êï∞ÁªÑÔºå‰ΩÜÂÜÖÈÉ®Ê†ºÂºèÊúâÈóÆÈ¢ò„ÄÇ
              // Ê≠§Êó∂Êàë‰ª¨‰∏çÊä•ÈîôÔºåËÄåÊòØÁªßÁª≠Â∞ùËØï‰∏ãÈù¢ÁöÑ‚ÄúÂº∫ÂäõËß£Êûê‚ÄùÊñπÊ°à„ÄÇ
              console.warn("Standard JSON array parsing failed, attempting strong parsing...");
            }
          }

          // ÊñπÊ°à2Ôºö„ÄêÂº∫ÂäõËß£Êûê„Äë‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÔºå‰ªéÊ∑∑‰π±ÁöÑÂ≠óÁ¨¶‰∏≤‰∏≠ÊèêÂèñÂá∫ÊâÄÊúâÁã¨Á´ãÁöÑJSONÂØπË±°
          // ËøôËÉΩÂÆåÁæéËß£ÂÜ≥ÊÇ®ÈÅáÂà∞ÁöÑ "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" ËøôÁßçÊ†ºÂºè
          const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

          if (jsonMatches) {
            const results = [];
            for (const match of jsonMatches) {
              try {
                // Â∞ùËØïËß£ÊûêÊØè‰∏Ä‰∏™Ë¢´Êàë‰ª¨‚ÄúÊè™‚ÄùÂá∫Êù•ÁöÑJSONÂ≠óÁ¨¶‰∏≤
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
              } catch (e) {
                // Â¶ÇÊûúÊüê‰∏™ÁâáÊÆµ‰∏çÊòØÊúâÊïàÁöÑJSONÔºåÂ∞±ÂøΩÁï•ÂÆÉÔºåÁªßÁª≠Â§ÑÁêÜ‰∏ã‰∏Ä‰∏™
                console.warn("Skip an invalid JSON fragment:", match);
              }
            }

            // Â¶ÇÊûúÊàë‰ª¨ÊàêÂäüÊèêÂèñÂá∫‰∫ÜËá≥Â∞ë‰∏Ä‰∏™ÊúâÊïàÁöÑJSONÂØπË±°ÔºåÂ∞±ËøîÂõûËøô‰∏™ÁªìÊûú
            if (results.length > 0) {
              console.log("Parsing successful: Strong extraction mode.");
              return results;
            }
          }

          // ÊñπÊ°à3Ôºö„ÄêÊúÄÁªàÂ§áÁî®„ÄëÂ¶ÇÊûú‰ª•‰∏äÊâÄÊúâÊñπÊ≥ïÈÉΩÂ§±Ë¥•‰∫ÜÔºåËØ¥ÊòéAIËøîÂõûÁöÑÂèØËÉΩÂ∞±ÊòØÁ∫ØÊñáÊú¨
          // Êàë‰ª¨Â∞ÜÂéüÂßãÁöÑ„ÄÅÊú™Â§ÑÁêÜÁöÑÂÜÖÂÆπÔºåÂåÖË£ÖÊàê‰∏Ä‰∏™Ê†áÂáÜÁöÑÊñáÊú¨Ê∂àÊÅØÂØπË±°ËøîÂõûÔºåÁ°Æ‰øùÁ®ãÂ∫è‰∏ç‰ºöÂ¥©Ê∫É
          console.error("All parsing methods failed! Returning raw text.");
          return [{ type: "text", content: content }];
        }
        /**
         * ‚ÄúÊãâÂèñ‚ÄùÂπ∂Â°´ÂÖÖMinimaxËØ≠Èü≥Ê®°ÂûãÁöÑ‰∏ãÊãâÊ°Ü
         */
        function fetchMinimaxSpeechModels() {
          const modelSelect = document.getElementById(
            "minimax-speech-model-select",
          );
          if (!modelSelect) return;
          modelSelect.innerHTML = ""; // Clear old options

          // Full list of models obtained from the document
          const models = [
            "speech-2.6-hd",
            "speech-2.6-turbo",
            "speech-02-hd",
            "speech-02-turbo",
            "speech-01-hd",
            "speech-01-turbo",
          ];

          models.forEach((modelId) => {
            const option = document.createElement("option");
            option.value = modelId;
            option.textContent = modelId;
            modelSelect.appendChild(option);
          });

          // Automatically select the currently saved model, or use a recommended default if none is set
          modelSelect.value =
            state.apiConfig.minimaxSpeechModel || "speech-01-turbo";

          alert("Minimax speech model list has been updated!");
        }
        // NovelAI settings related functions (load, save, reset)
        // NovelAI settings related functions
        function loadNovelAISettings() {
          const settings = getNovelAISettings();
          document.getElementById("nai-resolution").value = settings.resolution;
          document.getElementById("nai-steps").value = settings.steps;
          document.getElementById("nai-cfg-scale").value = settings.cfg_scale;
          document.getElementById("nai-sampler").value = settings.sampler;
          document.getElementById("nai-seed").value = settings.seed;
          document.getElementById("nai-uc-preset").value = settings.uc_preset;
          document.getElementById("nai-quality-toggle").checked =
            settings.quality_toggle;
          document.getElementById("nai-smea").checked = settings.smea;
          document.getElementById("nai-smea-dyn").checked = settings.smea_dyn;
          document.getElementById("nai-default-positive").value =
            settings.default_positive;
          document.getElementById("nai-default-negative").value =
            settings.default_negative;
          document.getElementById("nai-cors-proxy").value = settings.cors_proxy;
          document.getElementById("nai-custom-proxy-url").value =
            settings.custom_proxy_url || "";

          // Show/hide custom proxy input field
          const customProxyGroup = document.getElementById(
            "nai-custom-proxy-group",
          );
          customProxyGroup.style.display =
            settings.cors_proxy === "custom" ? "block" : "none";
        }

        function saveNovelAISettings() {
          // Save API Key and model settings
          const novelaiEnabled =
            document.getElementById("novelai-switch").checked;
          const novelaiModel = document.getElementById("novelai-model").value;
          const novelaiApiKey = document
            .getElementById("novelai-api-key")
            .value.trim();

          localStorage.setItem("novelai-enabled", novelaiEnabled);
          localStorage.setItem("novelai-model", novelaiModel);
          localStorage.setItem("novelai-api-key", novelaiApiKey);

          // Save advanced parameter settings
          const settings = {
            resolution: document.getElementById("nai-resolution").value,
            steps: parseInt(document.getElementById("nai-steps").value),
            cfg_scale: parseFloat(
              document.getElementById("nai-cfg-scale").value,
            ),
            sampler: document.getElementById("nai-sampler").value,
            seed: parseInt(document.getElementById("nai-seed").value),
            uc_preset: parseInt(document.getElementById("nai-uc-preset").value),
            quality_toggle:
              document.getElementById("nai-quality-toggle").checked,
            smea: document.getElementById("nai-smea").checked,
            smea_dyn: document.getElementById("nai-smea-dyn").checked,
            default_positive: document.getElementById("nai-default-positive")
              .value,
            default_negative: document.getElementById("nai-default-negative")
              .value,
            cors_proxy: document.getElementById("nai-cors-proxy").value,
            custom_proxy_url: document.getElementById("nai-custom-proxy-url")
              .value,
          };

          localStorage.setItem("novelai-settings", JSON.stringify(settings));
        }

        function resetNovelAISettings() {
          localStorage.removeItem("novelai-settings");
          loadNovelAISettings();
          alert("Default settings have been restored!");
        }

        function getNovelAISettings() {
          const defaultSettings = {
            resolution: "1024x1024",
            steps: 28,
            cfg_scale: 5,
            sampler: "k_euler_ancestral",
            seed: -1,
            uc_preset: 1,
            quality_toggle: true,
            smea: true,
            smea_dyn: false,
            default_positive:
              "masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style",
            default_negative:
              "lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry",
            cors_proxy: "https://corsproxy.io/?",
            custom_proxy_url: "",
          };

          const saved = localStorage.getItem("novelai-settings");
          if (saved) {
            try {
              return { ...defaultSettings, ...JSON.parse(saved) };
            } catch (e) {
              return defaultSettings;
            }
          }
          return defaultSettings;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PIXAI IMAGE GENERATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        /** Get PixAI settings (with defaults) */
        function getPixAISettings() {
          const defaultSettings = {
            resolution: "768x1280",
            steps: 28,
            cfg_scale: 5,
            seed: -1,
            default_positive:
              "masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style",
            default_negative:
              "lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry",
            cors_proxy: "https://corsproxy.io/?",
            custom_proxy_url: "",
          };
          const saved = localStorage.getItem("pixai-settings");
          if (saved) {
            try { return { ...defaultSettings, ...JSON.parse(saved) }; }
            catch (e) { return defaultSettings; }
          }
          return defaultSettings;
        }

        /** Load PixAI settings into the settings modal */
        function loadPixAISettings() {
          const s = getPixAISettings();
          document.getElementById("pai-resolution").value = s.resolution;
          document.getElementById("pai-steps").value = s.steps;
          document.getElementById("pai-cfg-scale").value = s.cfg_scale;
          document.getElementById("pai-seed").value = s.seed;
          document.getElementById("pai-default-positive").value = s.default_positive;
          document.getElementById("pai-default-negative").value = s.default_negative;
          document.getElementById("pai-cors-proxy").value = s.cors_proxy;
          document.getElementById("pai-custom-proxy-url").value = s.custom_proxy_url || "";
          document.getElementById("pai-custom-proxy-group").style.display =
            s.cors_proxy === "custom" ? "block" : "none";
        }

        /** Save PixAI settings from the modal to localStorage */
        function savePixAISettings() {
          localStorage.setItem("pixai-api-key",
            document.getElementById("pixai-api-key").value.trim());
          localStorage.setItem("pixai-model",
            document.getElementById("pixai-model").value);
          const settings = {
            resolution: document.getElementById("pai-resolution").value,
            steps: parseInt(document.getElementById("pai-steps").value),
            cfg_scale: parseFloat(document.getElementById("pai-cfg-scale").value),
            seed: parseInt(document.getElementById("pai-seed").value),
            default_positive: document.getElementById("pai-default-positive").value,
            default_negative: document.getElementById("pai-default-negative").value,
            cors_proxy: document.getElementById("pai-cors-proxy").value,
            custom_proxy_url: document.getElementById("pai-custom-proxy-url").value,
          };
          localStorage.setItem("pixai-settings", JSON.stringify(settings));
          document.getElementById("pixai-settings-modal").style.display = "none";
        }

        /** Switch visible provider section */
        function switchImageGenProvider(provider) {
          localStorage.setItem("image-gen-provider", provider);
          document.getElementById("novelai-provider-section").style.display =
            provider === "novelai" ? "" : "none";
          document.getElementById("pixai-provider-section").style.display =
            provider === "pixai" ? "" : "none";
          document.querySelectorAll(".img-gen-tab").forEach(t =>
            t.classList.toggle("active", t.dataset.provider === provider));
        }

        /**
         * Build a proxied URL from a base URL and cors proxy setting.
         * @param {string} baseUrl
         * @param {string} corsProxy
         * @param {string} customProxyUrl
         */
        function buildPixAIProxiedUrl(baseUrl, corsProxy, customProxyUrl) {
          if (!corsProxy || corsProxy === "") return baseUrl;
          const proxy = corsProxy === "custom" ? (customProxyUrl || "") : corsProxy;
          return proxy + encodeURIComponent(baseUrl);
        }

        /**
         * Core PixAI image generation with async polling.
         * Returns a base64 data URL string.
         */
        async function generatePixAIImage(prompt, negativePrompt, settings, modelId) {
          const apiKey = localStorage.getItem("pixai-api-key") || "";
          if (!apiKey) throw new Error("Please configure PixAI API Key first!");
          if (!prompt) throw new Error("Please enter a prompt!");

          const corsProxy = settings.cors_proxy === "custom"
            ? (settings.custom_proxy_url || "")
            : (settings.cors_proxy || "https://corsproxy.io/?");

          const [width, height] = (settings.resolution || "768x1280")
            .split("x").map(Number);

          const requestBody = { parameters: {
            prompts: prompt,
            negativePrompts: negativePrompt || "",
            modelId: modelId || "1935090615918113018",
            width,
            height,
            batchSize: 1,
            samplingSteps: settings.steps || 28,
            cfgScale: settings.cfg_scale || 5,
          }};
          if (settings.seed && settings.seed > 0) {
            requestBody.parameters.seed = settings.seed;
          }

          // 1. Create task
          const createUrl = buildPixAIProxiedUrl(
            "https://api.pixai.art/v1/task", corsProxy, settings.custom_proxy_url);
          const createResp = await fetch(createUrl, {
            method: "POST",
            headers: { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" },
            body: JSON.stringify(requestBody),
          });
          if (!createResp.ok) {
            const errText = await createResp.text().catch(() => createResp.status);
            throw new Error(`PixAI create task failed (${createResp.status}): ${errText}`);
          }
          const taskData = await createResp.json();
          const taskId = taskData.id;
          if (!taskId) throw new Error("PixAI: No task ID returned");

          // 2. Poll until completed
          const pollBaseUrl = `https://api.pixai.art/v1/task/${taskId}`;
          const maxPolls = 80; // 80 * 1.5s = 2 min
          for (let i = 0; i < maxPolls; i++) {
            await new Promise(r => setTimeout(r, 1500));
            const pollUrl = buildPixAIProxiedUrl(
              pollBaseUrl, corsProxy, settings.custom_proxy_url);
            const pollResp = await fetch(pollUrl, {
              headers: { "Authorization": `Bearer ${apiKey}` },
            });
            if (!pollResp.ok) throw new Error(`PixAI poll failed (${pollResp.status})`);
            const pollData = await pollResp.json();

            if (pollData.status === "completed") {
              const imageUrl = pollData.outputs?.mediaUrls?.[0];
              if (!imageUrl) throw new Error("PixAI: No image URL in completed response");
              // Fetch image and convert to base64
              const proxyImgUrl = buildPixAIProxiedUrl(
                imageUrl, corsProxy, settings.custom_proxy_url);
              const imgResp = await fetch(proxyImgUrl);
              if (!imgResp.ok) throw new Error("PixAI: Failed to fetch generated image");
              const blob = await imgResp.blob();
              return await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              });
            } else if (pollData.status === "failed" || pollData.status === "cancelled") {
              throw new Error(`PixAI task ${pollData.status}`);
            }
            // waiting / running ‚Üí continue polling
          }
          throw new Error("PixAI: Timeout ‚Äî image generation took too long (>2 min)");
        }

        /**
         * Generate PixAI image for a character chat (mirrors generateNovelAIImageForCharacter).
         */
        async function generatePixAIImageForCharacter(chatId, customPrompt = "") {
          const modelId = localStorage.getItem("pixai-model") || "1935090615918113018";
          const settings = getPixAISettings();
          const prompts = getCharacterNAIPrompts(chatId); // reuse existing function
          let finalPrompt = prompts.positive;
          if (customPrompt) finalPrompt = customPrompt + ", " + prompts.positive;
          const negativePrompt = prompts.negative || settings.default_negative;
          return await generatePixAIImage(finalPrompt, negativePrompt, settings, modelId);
        }

        /** Test generation handler for the PixAI test modal */
        async function pixaiTestGenerate() {
          const prompt = document.getElementById("pai-test-prompt").value.trim();
          if (!prompt) { alert("Please enter a prompt!"); return; }

          const settings = getPixAISettings();
          const negativePrompt = document.getElementById("pai-test-negative").value.trim()
            || settings.default_negative;
          const modelId = localStorage.getItem("pixai-model") || "1935090615918113018";

          const statusDiv = document.getElementById("pai-test-status");
          const resultDiv = document.getElementById("pai-test-result");
          const errorDiv = document.getElementById("pai-test-error");
          const generateBtn = document.getElementById("pai-generate-btn");

          statusDiv.style.display = "block";
          resultDiv.style.display = "none";
          errorDiv.style.display = "none";
          generateBtn.disabled = true;
          generateBtn.textContent = "Generating‚Ä¶";

          try {
            const imageDataUrl = await generatePixAIImage(prompt, negativePrompt, settings, modelId);
            document.getElementById("pai-result-image").src = imageDataUrl;
            resultDiv.style.display = "block";
            statusDiv.style.display = "none";
          } catch (err) {
            errorDiv.textContent = "‚ùå " + err.message;
            errorDiv.style.display = "block";
            statusDiv.style.display = "none";
          } finally {
            generateBtn.disabled = false;
            generateBtn.textContent = "Generate Image";
          }
        }

        // Expose to global scope
        window.switchImageGenProvider = switchImageGenProvider;
        window.pixaiTestGenerate = pixaiTestGenerate;
        window.generatePixAIImageForCharacter = generatePixAIImageForCharacter;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // END PIXAI IMAGE GENERATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        /**
         * Get the NAI prompt configuration for a given character ID
         * @param {string} chatId - Chat/Character ID
         * @returns {Object} Object containing positive and negative prompts
         */
        function getCharacterNAIPrompts(chatId) {
          // Get system default settings
          const systemSettings = getNovelAISettings();

          // If no character ID is specified or the character does not exist, return system settings
          if (!chatId || !state.chats[chatId]) {
            console.log("‚ö†Ô∏è NAI prompts: No character, using system settings");
            return {
              positive: systemSettings.default_positive,
              negative: systemSettings.default_negative,
              source: "system",
            };
          }

          const chat = state.chats[chatId];
          const naiSettings = chat.settings.naiSettings || {};

          // If the character is selected, use the character's settings; if the system is selected, use the system's settings
          if (naiSettings.promptSource === "character") {
            console.log("‚úÖ NAI prompts: Using character settings");
            console.log(
              "Positive:",
              naiSettings.characterPositivePrompt || "(empty)",
            );
            console.log(
              "   Negative:",
              naiSettings.characterNegativePrompt || "(empty)",
            );

            return {
              positive: naiSettings.characterPositivePrompt || "",
              negative: naiSettings.characterNegativePrompt || "",
              source: "character",
            };
          } else {
            console.log("‚úÖ NAI prompts: Using system settings");
            console.log("   Positive:", systemSettings.default_positive || "(empty)");
            console.log("   Negative:", systemSettings.default_negative || "(empty)");

            return {
              positive: systemSettings.default_positive,
              negative: systemSettings.default_negative,
              source: "system",
            };
          }
        }

        /**
         * ‰∏∫ÊåáÂÆöËßíËâ≤ÁîüÊàêNovelAIÂõæÂÉèÔºàÂ∞ÜÊù•ËÅäÂ§©Ë∞ÉÁî®Êó∂‰ΩøÁî®Ôºâ
         * @param {string} chatId - ËÅäÂ§©/ËßíËâ≤ID
         * @param {string} customPrompt - ÂèØÈÄâÁöÑËá™ÂÆö‰πâÊ≠£Èù¢ÊèêÁ§∫ËØçÔºàÂ¶ÇÊûúÊèê‰æõÂàôËøΩÂä†Âà∞ÈÖçÁΩÆÁöÑÊèêÁ§∫ËØçÂêéÔºâ
         * @returns {Promise<string>} ËøîÂõûÁîüÊàêÁöÑÂõæÂÉèBase64Êï∞ÊçÆURL
         */
        async function generateNovelAIImageForCharacter(
          chatId,
          customPrompt = "",
        ) {
          const apiKey = document
            .getElementById("novelai-api-key")
            .value.trim();
          const model = document.getElementById("novelai-model").value;

          if (!apiKey) {
            throw new Error("Please configure NovelAI API Key firstÔºÅ");
          }

          // Get the character's prompt configuration
          const prompts = getCharacterNAIPrompts(chatId);

          // Construct the final prompt (append custom prompt if provided)
          let finalPrompt = prompts.positive;
          if (customPrompt) {
            finalPrompt = customPrompt + ", " + prompts.positive;
          }

          const negativePrompt = prompts.negative;

          console.log(
            `üìù Using ${prompts.source === "character" ? "character-specific" : "system"} prompt configuration`,
          );
          console.log("Positive:", finalPrompt);
          console.log("Negative:", negativePrompt);

          const settings = getNovelAISettings();

          // The image generation logic will be implemented here
          // This function is reserved for future use when calling NAI image generation in chat
          return null;
        }

        // Generate NovelAI image main function (full version)
        async function generateNovelAIImage() {
          const apiKey = document
            .getElementById("novelai-api-key")
            .value.trim();
          const model = document.getElementById("novelai-model").value;
          const prompt = document
            .getElementById("nai-test-prompt")
            .value.trim();

          if (!apiKey) {
            alert("Please configure NovelAI API Key firstÔºÅ");
            return;
          }

          if (!prompt) {
            alert("Please enter a promptÔºÅ");
            return;
          }

          const settings = getNovelAISettings();
          const negativePrompt = document
            .getElementById("nai-test-negative")
            .value.trim();

          const statusDiv = document.getElementById("nai-test-status");
          const resultDiv = document.getElementById("nai-test-result");
          const errorDiv = document.getElementById("nai-test-error");
          const generateBtn = document.getElementById("nai-generate-btn");

          statusDiv.style.display = "block";
          resultDiv.style.display = "none";
          errorDiv.style.display = "none";
          generateBtn.disabled = true;
          generateBtn.textContent = "Generating...";

          try {
            const [width, height] = settings.resolution.split("x").map(Number);

            // V4/V4.5 and V3 use different request body formats
            let requestBody;

            if (model.includes("nai-diffusion-4")) {
              // V4/V4.5 use new format (params_version: 3)
              requestBody = {
                input: prompt,
                model: model,
                action: "generate",
                parameters: {
                  params_version: 3, // V4 must use version 3
                  width: width,
                  height: height,
                  scale: settings.cfg_scale,
                  sampler: settings.sampler,
                  steps: settings.steps,
                  seed:
                    settings.seed === -1
                      ? Math.floor(Math.random() * 9999999999)
                      : settings.seed,
                  n_samples: 1,
                  ucPreset: settings.uc_preset,
                  qualityToggle: settings.quality_toggle,
                  autoSmea: false,
                  dynamic_thresholding: false,
                  controlnet_strength: 1,
                  legacy: false,
                  add_original_image: true,
                  cfg_rescale: 0,
                  noise_schedule: "karras", // V4 uses karras
                  legacy_v3_extend: false,
                  skip_cfg_above_sigma: null,
                  use_coords: false,
                  legacy_uc: false,
                  normalize_reference_strength_multiple: true,
                  inpaintImg2ImgStrength: 1,
                  characterPrompts: [],
                  // V4 specific prompt format
                  v4_prompt: {
                    caption: {
                      base_caption: prompt,
                      char_captions: [],
                    },
                    use_coords: false,
                    use_order: true,
                  },
                  // V4 specific negative prompt format
                  v4_negative_prompt: {
                    caption: {
                      base_caption: negativePrompt,
                      char_captions: [],
                    },
                    legacy_uc: false,
                  },
                  negative_prompt: negativePrompt,
                  deliberate_euler_ancestral_bug: false,
                  prefer_brownian: true,
                  // Note: Does not include the stream parameter, uses standard ZIP response instead of msgpack stream
                },
              };
            } else {
              // V3 and earlier versions use old format
              requestBody = {
                input: prompt,
                model: model,
                action: "generate",
                parameters: {
                  width: width,
                  height: height,
                  scale: settings.cfg_scale,
                  sampler: settings.sampler,
                  steps: settings.steps,
                  seed:
                    settings.seed === -1
                      ? Math.floor(Math.random() * 9999999999)
                      : settings.seed,
                  n_samples: 1,
                  ucPreset: settings.uc_preset,
                  qualityToggle: settings.quality_toggle,
                  sm: settings.smea,
                  sm_dyn: settings.smea_dyn,
                  dynamic_thresholding: false,
                  controlnet_strength: 1,
                  legacy: false,
                  add_original_image: false,
                  cfg_rescale: 0,
                  noise_schedule: "native",
                  negative_prompt: negativePrompt,
                },
              };
            }

            console.log("üì§ Sending request to NovelAI API");
            console.log("üìä Using model:", model);
            console.log("üìã Request body:", JSON.stringify(requestBody, null, 2));

            // Select different API endpoints based on the model
            let apiUrl;

            // V4/V4.5 models use streaming endpoint
            if (model.includes("nai-diffusion-4")) {
              // V4/V4.5 default to streaming endpoint
              apiUrl = "https://image.novelai.net/ai/generate-image-stream";
            } else {
              // V3 and earlier versions use standard endpoint
              apiUrl = "https://image.novelai.net/ai/generate-image";
            }

            let corsProxy = settings.cors_proxy;

            // If a custom proxy is selected, use the custom URL
            if (corsProxy === "custom") {
              corsProxy = settings.custom_proxy_url || "";
            }

            // If a proxy is set, prepend it to the API URL
            if (corsProxy && corsProxy !== "") {
              apiUrl = corsProxy + encodeURIComponent(apiUrl);
            }

            // Chrome-specific handling: avoid non-ISO-8859-1 characters in headers
            const isChrome =
              /Chrome/.test(navigator.userAgent) &&
              !/Edg/.test(navigator.userAgent);
            let fetchOptions = {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + apiKey,
              },
              body: JSON.stringify(requestBody),
            };

            // ÈíàÂØπChromeÊµèËßàÂô®ÔºöÁ°Æ‰øùÊâÄÊúâheaderÂÄºÈÉΩÊòØÁ∫ØASCII
            if (isChrome) {
              console.log("üîß Chrome browser detected; headers compatibility handling enabled.");
              const cleanHeaders = {};
              for (const [key, value] of Object.entries(fetchOptions.headers)) {
                // Á°Æ‰øùheaderÂÄºÂè™ÂåÖÂê´ASCIIÂ≠óÁ¨¶ÔºàISO-8859-1ÂÖºÂÆπÔºâ
                cleanHeaders[key] = value.replace(/[^\x00-\xFF]/g, "");
              }
              fetchOptions.headers = cleanHeaders;
            }

            const response = await fetch(apiUrl, fetchOptions);

            console.log("Response status:", response.status);
            console.log("Response headers:", [...response.headers.entries()]);

           if (!response.ok) {
    const errorText = await response.text();
    console.error("API error response:", errorText);
    throw new Error(`API request failed (${response.status}): ${errorText}`);
}


            // NovelAI APIËøîÂõûÁöÑÊòØZIPÊñá‰ª∂ÔºåÈúÄË¶ÅËß£Âéã
            const contentType = response.headers.get("content-type");
            console.log("Content-Type:", contentType);

            // Ê£ÄÊü•ÊòØÂê¶‰∏∫ SSE ÊµÅÂºèÂìçÂ∫î
            let zipBlob;
            if (contentType && contentType.includes("text/event-stream")) {
              console.log("Detected SSE streaming response, starting to parse...");
              statusDiv.textContent = "Receiving streaming data...";

              // Read the entire stream
              const text = await response.text();
              console.log("Received SSE data, size:", text.length);

              // Parse SSE format, extract the last data: line
              const lines = text.trim().split("\n");
              let base64Data = null;

              for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith("data: ") && line !== "data: [DONE]") {
                  const dataContent = line.substring(6); // Remove 'data: ' prefix

                  // Try to parse JSON
                  try {
                    const jsonData = JSON.parse(dataContent);

                    // V4.5 streaming endpoint: event_type "final" contains the final image
                    if (jsonData.event_type === "final" && jsonData.image) {
                      base64Data = jsonData.image;
                      console.log("‚úÖ Found final event image data");
                      break;
                    }

                    // Compatibility with other formats
                    if (jsonData.data) {
                      base64Data = jsonData.data;
                      console.log("Extracted image data from JSON.data");
                      break;
                    }
                    if (jsonData.image) {
                      base64Data = jsonData.image;
                      console.log("Extracted image data from JSON.image");
                      break;
                    }
                  } catch (e) {
                    // If not JSON, treat as base64 data
                    base64Data = dataContent;
                    console.log("Directly using base64 data");
                    break;
                  }
                }
              }

              if (!base64Data) {
                throw new Error("Unable to extract image data from SSE response");
              }

              // V4.5 streaming endpoint returns PNG base64, not ZIP
              // Check if it's PNG (starts with iVBORw0KGgo) or JPEG (starts with /9j/)
              const isPNG = base64Data.startsWith("iVBORw0KGgo");
              const isJPEG = base64Data.startsWith("/9j/");

              if (isPNG || isJPEG) {
                console.log("‚úÖ Detected direct image base64 data (PNG/JPEG)");
                // Convert base64 to Blob
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }
                const imageBlob = new Blob([bytes], {
                  type: isPNG ? "image/png" : "image/jpeg",
                });
                console.log("‚úÖ Image Blob created successfully, size:", imageBlob.size);

                // Directly display the image
                const imageUrl = URL.createObjectURL(imageBlob);
                document.getElementById("nai-result-image").src = imageUrl;
                statusDiv.style.display = "none";
                resultDiv.style.display = "block";
                console.log("‚úÖ Image displayed successfully! üé®");
                return;
              }

              // Otherwise, treat as ZIP
              console.log("Treating as ZIP file...");
              const binaryString = atob(base64Data);
              const bytes = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
              }
              zipBlob = new Blob([bytes]);
              console.log("ZIP Blob size:", zipBlob.size);
            } else {
              // Non-streaming response, read directly
              zipBlob = await response.blob();
              console.log(
                "Received data, type:",
                zipBlob.type,
                "size:",
                zipBlob.size,
              );
            }

            // NovelAI always returns ZIP format, needs to be extracted
            try {
              // Check if JSZip is loaded
              if (typeof JSZip === "undefined") {
                throw new Error("JSZip library not loaded, please refresh the page and try again");
              }

              statusDiv.textContent = "Extracting image...";

              // Extract ZIP file
              const zip = await JSZip.loadAsync(zipBlob);
              console.log("ZIP file contents:", Object.keys(zip.files));

              // Find the first image file (usually image_0.png)
              let imageFile = null;
              for (let filename in zip.files) {
                if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                  imageFile = zip.files[filename];
                  console.log("Found image file:", filename);
                  break;
                }
              }

              if (!imageFile) {
                throw new Error("No image found in ZIP file");
              }

              // Extract image data
              const imageBlob = await imageFile.async("blob");
              console.log("Extracted image size:", imageBlob.size);

              // Create image URL and display
              const imageUrl = URL.createObjectURL(imageBlob);
              console.log("Generated image URL:", imageUrl);

              document.getElementById("nai-result-image").src = imageUrl;
              statusDiv.style.display = "none";
              resultDiv.style.display = "block";
            } catch (zipError) {
              console.error("ZIP extraction failed:", zipError);
              // If extraction fails, try to display as image directly
              console.log("Attempting to display as image directly...");

              if (zipBlob.type.startsWith("image/")) {
                const imageUrl = URL.createObjectURL(zipBlob);
                document.getElementById("nai-result-image").src = imageUrl;
                statusDiv.style.display = "none";
                resultDiv.style.display = "block";
              } else {
                throw new Error("Failed to process image format: " + zipError.message);
              }
            }
          } catch (error) {
            console.error("NovelAI generation failed:", error);
            statusDiv.style.display = "none";
            errorDiv.style.display = "block";
            errorDiv.textContent = "Generation failed: " + error.message;
          } finally {
            generateBtn.disabled = false;
            generateBtn.textContent = "Generate Image";
          }
        }

        function renderApiSettings() {
          // 1. Update API related input fields
          document.getElementById("proxy-url").value =
            state.apiConfig.proxyUrl || "";
          document.getElementById("api-key").value =
            state.apiConfig.apiKey || "";

          // Load CORS proxy setting
          const savedApiProxy = localStorage.getItem("api-cors-proxy") || "";
          const apiProxySelect = document.getElementById("api-cors-proxy");
          if (savedApiProxy === "" || savedApiProxy === "https://corsproxy.io/?") {
            apiProxySelect.value = savedApiProxy;
          } else {
            apiProxySelect.value = "custom";
            document.getElementById("api-custom-proxy-url").value = savedApiProxy;
            document.getElementById("api-custom-proxy-group").style.display = "block";
          }

          // --- Minimax settings ---
          document.getElementById("minimax-group-id").value =
            state.apiConfig.minimaxGroupId || "";
          document.getElementById("minimax-api-key").value =
            state.apiConfig.minimaxApiKey || "";
          document.getElementById("minimax-provider-select").value =
            state.apiConfig.minimaxProvider || "cn";

          // 2: Minimax speech model dropdown echo
          const speechModelSelect = document.getElementById(
            "minimax-speech-model-select",
          );
          if (speechModelSelect) {
            // Get the saved model, default to speech-01-turbo if not available
            const savedSpeechModel =
              state.apiConfig.minimaxSpeechModel || "speech-01-turbo";

            // Check if the option exists in the dropdown
            let optionExists = Array.from(speechModelSelect.options).some(
              (opt) => opt.value === savedSpeechModel,
            );

            // If not, create a new option and add it
            if (!optionExists && savedSpeechModel) {
              const option = document.createElement("option");
              option.value = savedSpeechModel;
              option.textContent = savedSpeechModel;
              speechModelSelect.appendChild(option);
            }

            // Select it
            speechModelSelect.value = savedSpeechModel;
          }
          // Main conversation model echo (new version: directly assign to input)
          const modelInput = document.getElementById("model-select");
          if (modelInput) {
            modelInput.value = state.apiConfig.model || "gpt-4";
          }
          // Reset auxiliary dropdown to hidden state (because the list fetched after page refresh is cleared)
          const modelPicker = document.getElementById("fetched-model-list");
          if (modelPicker) {
            modelPicker.style.display = "none";
          }

          // --------------------------------

          // Load NovelAI configuration
          const novelaiEnabled =
            localStorage.getItem("novelai-enabled") === "true";
          const novelaiModel =
            localStorage.getItem("novelai-model") || "nai-diffusion-4-5-full";
          const novelaiApiKey = localStorage.getItem("novelai-api-key") || "";
          document.getElementById("novelai-switch").checked = novelaiEnabled;
          document.getElementById("novelai-model").value = novelaiModel;
          document.getElementById("novelai-api-key").value = novelaiApiKey;
          document.getElementById("novelai-details").style.display =
            novelaiEnabled ? "block" : "none";
          document.getElementById("pollinations-api-key").value =
            state.apiConfig.pollinationsApiKey || "";

          // 2. Êõ¥Êñ∞ÂêéÂè∞Ê¥ªÂä®Áõ∏ÂÖ≥ÁöÑÂºÄÂÖ≥ÂíåËæìÂÖ•Ê°Ü
          document.getElementById("background-activity-switch").checked =
            !!state.globalSettings.enableBackgroundActivity;

          document.getElementById("background-interval-input").value =
            state.globalSettings.backgroundActivityInterval || 60;
          document.getElementById("block-cooldown-input").value =
            state.globalSettings.blockCooldownHours || 1;

          // 3. Ê∏≤ÊüìÈ¢ÑËÆæÂíåÈ¢ëÁéáÁöÑ‰∏ãÊãâÊ°Ü
          renderApiPresetSelector();
          renderBackgroundFrequencySelector();
          // --- Âä†ËΩΩ GitHub Â§á‰ªΩËÆæÁΩÆ ---
          document.getElementById("github-token").value =
            state.apiConfig.githubToken || "";
          document.getElementById("github-username").value =
            state.apiConfig.githubUsername || "";
          document.getElementById("github-repo").value =
            state.apiConfig.githubRepo || "";
          document.getElementById("github-path").value =
            state.apiConfig.githubPath || "ephone_backup.json";
          document.getElementById("github-auto-backup-switch").checked =
            !!state.apiConfig.githubAutoBackup;
          document.getElementById("github-backup-mode").value =
            state.apiConfig.githubBackupMode || "full";
          document.getElementById("github-backup-interval").value =
            state.apiConfig.githubBackupInterval || 30;

          // Ê∏≤ÊüìÊ∏©Â∫¶ÊªëÂùóÁöÑUI
          const tempSlider = document.getElementById("temperature-slider");
          const tempValueDisplay = document.getElementById("temperature-value");

          const currentTemp = state.apiConfig.temperature || 0.8;
          tempSlider.value = currentTemp;
          tempValueDisplay.textContent = parseFloat(currentTemp).toFixed(1);

          tempSlider.addEventListener("input", () => {
            tempValueDisplay.textContent = parseFloat(tempSlider.value).toFixed(
              1,
            );
          });

          const qualitySlider = document.getElementById("image-quality-slider");
          const qualityValue = document.getElementById("image-quality-value");
          const currentQuality =
            state.globalSettings.imageCompressionQuality || 0.7;

          if (qualitySlider && qualityValue) {
            qualitySlider.value = currentQuality;
            qualityValue.textContent = parseFloat(currentQuality).toFixed(1);

            qualitySlider.addEventListener("input", () => {
              qualityValue.textContent = parseFloat(
                qualitySlider.value,
              ).toFixed(1);
            });
          }
          const sysNotifSwitch = document.getElementById(
            "system-notification-switch",
          );

          // ‚òÖ‚òÖ‚òÖ„Äê‰øÆÊîπÁÇπ2ÔºöÈáçÂÜôÂºÄÂÖ≥Âä†ËΩΩ‰∏é‰∫§‰∫íÈÄªËæë„Äë‚òÖ‚òÖ‚òÖ
          const oldSysSwitch = document.getElementById(
            "system-notification-switch",
          );
          if (oldSysSwitch) {
            // 1. ‰ΩøÁî®ÂÖãÈöÜÂ§ßÊ≥ïÔºåÂΩªÂ∫ïÁßªÈô§ÊâÄÊúâ‰πãÂâçÂèØËÉΩÈáçÂ§çÁªëÂÆöÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®
            const newSysSwitch = oldSysSwitch.cloneNode(true);
            oldSysSwitch.parentNode.replaceChild(newSysSwitch, oldSysSwitch);

            // 2. ËØªÂèñ‰øùÂ≠òÁöÑÁä∂ÊÄÅ
            const savedNotifState =
              state.globalSettings.enableSystemNotifications;
            const hasPerm =
              "Notification" in window && Notification.permission === "granted";

            // 3. Êô∫ËÉΩÂà§Êñ≠ÂºÄÂÖ≥Áä∂ÊÄÅÔºö
            // - Â¶ÇÊûúÊúâ‰øùÂ≠òÁöÑËÆ∞ÂΩïÔºåÂ∞±‰∏•Ê†ºÂê¨ËÆ∞ÂΩïÁöÑÔºàÊòØtrueÂ∞±ÊòØtrueÔºåÊòØfalseÂ∞±ÊòØfalseÔºâ
            // - Â¶ÇÊûú‰ªéÊ≤°‰øùÂ≠òËøáÔºàundefinedÔºâÔºå‰ΩÜÊµèËßàÂô®Â∑≤ÁªèÊúâÊùÉÈôêÔºåÈªòËÆ§ÂºÄÂêØ
            if (typeof savedNotifState !== "undefined") {
              newSysSwitch.checked = savedNotifState;
            } else {
              newSysSwitch.checked = hasPerm;
            }

            // 4. ÁªëÂÆöÊñ∞ÁöÑ„ÄÅÂîØ‰∏ÄÁöÑÁÇπÂáª‰∫ã‰ª∂
            newSysSwitch.addEventListener("change", async (e) => {
              if (e.target.checked) {
                // --- Áî®Êà∑ÊÉ≥ÂºÄÂêØ ---
                if (!("Notification" in window)) {
                  alert("Sorry, this device does not support system notifications.");
                  e.target.checked = false;
                } else if (Notification.permission === "granted") {
                  // Â∑≤ÊúâÊùÉÈôêÔºåÁõ¥Êé•ÂºÄÂêØÊàêÂäü
                  new Notification("EPhone", {
                    body: "System notifications are enabled! Don't forget to click the „ÄêSave„Äë button at the bottom.",

                  });
                } else if (Notification.permission !== "denied") {
                  // ËØ∑Ê±ÇÊùÉÈôê
                  const permission = await Notification.requestPermission();
                  if (permission === "granted") {
                    new Notification("EPhone", {
                      body: "Permission granted! Please click „ÄêSave„Äë.",
                    });
                  } else {
                    e.target.checked = false;
                    alert("Permission denied, unable to enable.");
                  }
                } else {
                  // ‰πãÂâçË¢´Ê∞∏‰πÖÊãíÁªù
                  e.target.checked = false;
                  alert(
                    "Permission has been denied. Please go to your phone/browser settings to manually enable notification permissions.",
                  );
                }
              } else {
              }
            });
          }
          const checkPermBtn = document.getElementById(
            "check-notification-perm-btn",
          );
          if (checkPermBtn) {
            const newBtn = checkPermBtn.cloneNode(true);
            checkPermBtn.parentNode.replaceChild(newBtn, checkPermBtn);

            newBtn.addEventListener("click", async () => {
              if (!("Notification" in window)) {
                alert(
                  '‚ùå Your browser/environment does not support the Notification API.\n(If you are on iOS, you must click "Add to Home Screen" to run as a PWA for support)',
                );
                return;
              }

              const permission = Notification.permission;

              if (permission === "granted") {
                try {
                  const title = "Permission Test";
                  const options = { body: "Congratulations! System notifications are working correctly." };

                  // --- Ê†∏ÂøÉ‰øÆÂ§çÔºö‰ºòÂÖà‰ΩøÁî® ServiceWorker ---
                  if ("serviceWorker" in navigator) {
                    const reg = await navigator.serviceWorker.getRegistration();
                    if (reg) {
                      // ÂÆâÂçì Chrome ÂøÖÈ°ªËµ∞ËøôÈáå
                      await reg.showNotification(title, options);
                    } else {
                      // Â¶ÇÊûúÊ≤°ÊúâËé∑ÂèñÂà∞ SWÔºåÂ∞ùËØïÊ≥®ÂÜå‰∏Ä‰∏™Á©∫ÁöÑÂπ∂ÂèëÈÄÅ
                      try {
                        // Â∞ùËØïÁé∞Âú∫Ê≥®ÂÜå‰∏Ä‰∏™‰∏¥Êó∂ÁöÑ
                        const emptyWorkerContent =
                          "self.addEventListener('install', () => self.skipWaiting());";
                        const blob = new Blob([emptyWorkerContent], {
                          type: "text/javascript",
                        });
                        const workerUrl = URL.createObjectURL(blob);
                        const newReg =
                          await navigator.serviceWorker.register(workerUrl);
                        await newReg.showNotification(title, options);
                      } catch (e) {
                        // ÂÆûÂú®‰∏çË°åÔºåÈôçÁ∫ßÂ∞ùËØïÊóßÊñπÊ≥ïÔºàÂú®ÂÆâÂçì‰∏äËøôÊ≠•‰ºöÊäõÈîôÔºå‰ΩÜË¢´Â§ñÂ±ÇcatchÊçïËé∑Ôºâ
                        new Notification(title, options);
                      }
                    }
                  } else {
                    // iOS Êàñ PC Browser
                    new Notification(title, options);
                  }

                  alert(
                    "‚úÖ Permission Status: Granted (granted)\n\nThe system attempted to send a test notification. Please check your phone's notification bar.\nIf you didn't receive it, please check if your phone's system 'Notification Management' has blocked the browser/app.",
                  );
                } catch (e) {
                  alert(
                    `‚ö†Ô∏è Permission shows as granted, but sending failed.\nError message: ${e.message}`,
                  );
                }
              } else if (permission === "denied") {
                alert(
                  "üö´ Permission Status: Denied (denied)\n\nReason: You previously clicked 'Deny' or the system default is deny.\n\nSolution:\n1. Please click the lock icon or settings in the browser address bar.\n2. Find the 'Notifications' permission and reset it to 'Ask' or 'Allow'.\n3. Refresh the page and try again.",
                );
              } else if (permission === "default") {
                alert(
                  "‚ùì Permission Status: Not Asked (default)\n\nPlease click the switch on the right and click 'Allow' in the browser popup.",
                );
              }
            });
          }
          // ‚ñº‚ñº‚ñº Âú® check-notification-perm-btn ÁöÑÁõëÂê¨Âô®ÂêéÈù¢ÔºåÊ∑ªÂä†ËøôÊÆµ‰ª£Á†Å ‚ñº‚ñº‚ñº

          const testNotifBtn = document.getElementById(
            "test-system-notification-btn",
          );
          if (testNotifBtn) {
            // Remove old listener (by cloning)
            const newBtn = testNotifBtn.cloneNode(true);
            testNotifBtn.parentNode.replaceChild(newBtn, testNotifBtn);

            newBtn.addEventListener("click", async () => {
              if (!("Notification" in window)) return alert("Device does not support notifications");
              if (Notification.permission !== "granted")
                return alert("Please click the button on the left to grant notification permission first!");

              const title = "Test Message";
              const options = {
                body: "If you see this message, it means the Android popup fix is successful!",
                icon: "https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg",
              };

              try {
                if ("serviceWorker" in navigator) {
                  const reg = await navigator.serviceWorker.getRegistration();
                  if (reg) {
                    await reg.showNotification(title, options);
                    console.log("Test: Sent successfully via SW");
                  } else {
                    alert(
                      "Error: ServiceWorker not registered, unable to send notifications on Android. Please refresh the page and try again.",
                    );
                    // For debugging purposes, try sending directly to see the error
                    // new Notification(title, options);
                  }
                } else {
                  new Notification(title, options);
                }
              } catch (e) {
                alert("Test sending failed: " + e.message);
              }
            });
          }

          calculateTotalImageSize();
        }

        /**
         * Render the background activity role selection and frequency settings UI
         */
        function renderBackgroundFrequencySelector() {
          const container = document.getElementById(
            "background-activity-char-list",
          );
          const detailsContainer = document.getElementById(
            "background-activity-details",
          );
          const masterSwitch = document.getElementById(
            "background-activity-switch",
          );

          // Based on the master switch state, decide whether to show detailed settings
          detailsContainer.style.display = masterSwitch.checked
            ? "block"
            : "none";

          container.innerHTML = ""; // Clear old list
          const singleChats = Object.values(state.chats).filter(
            (chat) => !chat.isGroup,
          );

          if (singleChats.length === 0) {
            container.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary);">No roles available for configuration</p>';
            return;
          }

          const config = state.globalSettings.backgroundActivityConfig || {};

          singleChats.forEach((chat) => {
            const freq = config[chat.id] || "none"; // Get the current role's frequency setting
            let badgeHtml = "";
            if (freq !== "none") {
              const freqText = { low: "Low", medium: "Medium", high: "High" }[freq];
              badgeHtml = `<span class="char-freq-badge ${freq}">${freqText}</span>`;
            }

            const item = document.createElement("div");
            item.className = "char-list-item";
            item.innerHTML = `
			            <input type="checkbox" class="bg-char-checkbox" data-chat-id="${chat.id}">
			            <span class="char-name">${chat.name}</span>
			            ${badgeHtml}
			        `;
            container.appendChild(item);
          });
        }

        window.renderApiSettingsProxy = renderApiSettings;

        async function renderChatList() {
          const chatListEl = document.getElementById("chat-list");
          chatListEl.innerHTML = "";

          // 1. Get all chats and group data
          const allChats = Object.values(state.chats);
          const allGroups = await db.qzoneGroups.toArray();

          if (allChats.length === 0) {
            chatListEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">Click the "+" icon in the upper right corner or the group icon to add a chat.</p>';
            return;
          }

          // 2. Clearly separate chats into "pinned" and "unpinned" groups
          const pinnedChats = allChats.filter((chat) => chat.isPinned);
          const unpinnedChats = allChats.filter((chat) => !chat.isPinned);

          // 3. For pinned chats, sort only by the latest message timestamp
          pinnedChats.sort(
            (a, b) =>
              (b.history.slice(-1)[0]?.timestamp || 0) -
              (a.history.slice(-1)[0]?.timestamp || 0),
          );

          // 4. „Äê‰ºòÂÖàÊ∏≤Êüì„ÄëÊâÄÊúâÁΩÆÈ°∂ÁöÑËÅäÂ§©
          pinnedChats.forEach((chat) => {
            const item = createChatListItem(chat);
            chatListEl.appendChild(item);
          });

          // 5. „ÄêÊé•‰∏ãÊù•Â§ÑÁêÜÊú™ÁΩÆÈ°∂ÁöÑËÅäÂ§©„ÄëÂ∫îÁî®‰πãÂâçÁöÑÂàÜÁªÑÈÄªËæë
          // ‰∏∫ÊØè‰∏™ÂàÜÁªÑÊâæÂà∞ÂÖ∂ÂÜÖÈÉ®ÊúÄÊñ∞ÁöÑÊ∂àÊÅØÊó∂Èó¥Êà≥ (Âè™Âú®Êú™ÁΩÆÈ°∂ËÅäÂ§©‰∏≠Êü•Êâæ)
          allGroups.forEach((group) => {
            const latestChatInGroup = unpinnedChats
              .filter((chat) => chat.groupId === group.id) // ÊâæÂà∞Â±û‰∫éËøô‰∏™ÁªÑÁöÑËÅäÂ§©
              .sort(
                (a, b) =>
                  (b.history.slice(-1)[0]?.timestamp || 0) -
                  (a.history.slice(-1)[0]?.timestamp || 0),
              )[0]; // ÊéíÂ∫èÂêéÂèñÁ¨¨‰∏Ä‰∏™

            group.latestTimestamp = latestChatInGroup
              ? latestChatInGroup.history.slice(-1)[0]?.timestamp || 0
              : 0;
          });

          // Ê†πÊçÆÂàÜÁªÑÁöÑÊúÄÊñ∞Êó∂Èó¥Êà≥ÔºåÂØπÂàÜÁªÑÊú¨Ë∫´ËøõË°åÊéíÂ∫è
          allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

          // 6. ÈÅçÂéÜÊéíÂ∫èÂêéÁöÑÂàÜÁªÑÔºåÊ∏≤ÊüìÂÖ∂‰∏≠ÁöÑ„ÄêÊú™ÁΩÆÈ°∂„ÄëÂ•ΩÂèã
          allGroups.forEach((group) => {
            const groupChats = unpinnedChats
              .filter((chat) => !chat.isGroup && chat.groupId === group.id)
              .sort(
                (a, b) =>
                  (b.history.slice(-1)[0]?.timestamp || 0) -
                  (a.history.slice(-1)[0]?.timestamp || 0),
              );

            if (groupChats.length === 0) return; // Â¶ÇÊûúËøô‰∏™ÂàÜÁªÑÈáåÊ≤°ÊúâÊú™ÁΩÆÈ°∂ÁöÑÂ•ΩÂèãÔºåÂ∞±Ë∑≥Ëøá

            const groupContainer = document.createElement("div");
            groupContainer.className = "chat-group-container";

            // Âà†Èô§‰∫Ü collapsed Á±ªÔºåËøôÊ†∑ÈªòËÆ§Â∞±ÊòØÂ±ïÂºÄÁöÑ‰∫Ü
            groupContainer.innerHTML = `
			            <div class="chat-group-header">
			                <span class="arrow">‚ñº</span>
			                <span class="group-name">${group.name}</span>
			            </div>
			            <div class="chat-group-content"></div>
			        `;
            const contentEl = groupContainer.querySelector(
              ".chat-group-content",
            );

            groupChats.forEach((chat) => {
              const item = createChatListItem(chat);
              contentEl.appendChild(item);
            });
            chatListEl.appendChild(groupContainer);
          });

          // 7. Ê∏≤ÊüìÊâÄÊúâ„ÄêÊú™ÁΩÆÈ°∂„ÄëÁöÑÁæ§ËÅäÂíå„ÄêÊú™ÂàÜÁªÑÁöÑ„ÄëÂ•ΩÂèã
          const remainingChats = unpinnedChats
            .filter((chat) => chat.isGroup || (!chat.isGroup && !chat.groupId))
            .sort(
              (a, b) =>
                (b.history.slice(-1)[0]?.timestamp || 0) -
                (a.history.slice(-1)[0]?.timestamp || 0),
            );

          remainingChats.forEach((chat) => {
            const item = createChatListItem(chat);
            chatListEl.appendChild(item);
          });

          // ‰∏∫ÊâÄÊúâÂàÜÁªÑÊ†áÈ¢òÊ∑ªÂä†ÊäòÂè†‰∫ã‰ª∂
          document.querySelectorAll(".chat-group-header").forEach((header) => {
            header.addEventListener("click", () => {
              header.classList.toggle("collapsed");
              header.nextElementSibling.classList.toggle("collapsed");
            });
          });
        }

        function createChatListItem(chat) {
          const lastMsgObj =
            chat.history.filter((msg) => !msg.isHidden).slice(-1)[0] || {};
          let lastMsgDisplay;

          if (
            !chat.isGroup &&
            chat.relationship?.status === "pending_user_approval"
          ) {
            lastMsgDisplay = `<span style="color: #ff8c00;">[Friend Request] ${
              chat.relationship.applicationReason || "A request has been sent to add you as a friend."
            }</span>`;
          } else if (
            !chat.isGroup &&
            chat.relationship?.status === "blocked_by_ai"
          ) {
            lastMsgDisplay = `<span style="color: #dc3545;">[You have been blocked]</span>`;
          } else if (chat.isGroup) {
            if (lastMsgObj.type === "pat_message") {
              lastMsgDisplay = `[System Message] ${lastMsgObj.content}`;
            } else if (lastMsgObj.type === "transfer") {
              lastMsgDisplay = "[Transfer]";
            } else if (
              lastMsgObj.type === "ai_image" ||
              lastMsgObj.type === "user_photo"
            ) {
              lastMsgDisplay = "[Photo]";
            } else if (lastMsgObj.type === "voice_message") {
              lastMsgDisplay = "[Voice]";
            } else if (
              typeof lastMsgObj.content === "string" &&
              STICKER_REGEX.test(lastMsgObj.content)
            ) {
              lastMsgDisplay = lastMsgObj.meaning
                ? `[Sticker: ${lastMsgObj.meaning}]`
                : "[Sticker]";
            } else if (Array.isArray(lastMsgObj.content)) {
              lastMsgDisplay = `[Image]`;
            } else {
              lastMsgDisplay = String(lastMsgObj.content || "...").substring(
                0,
                20,
              );
            }
            if (lastMsgObj.senderName && lastMsgObj.type !== "pat_message") {
              const member = chat.members.find(
                (m) => m.originalName === lastMsgObj.senderName,
              );
              const displayName = member
                ? member.groupNickname
                : lastMsgObj.senderName;
              lastMsgDisplay = `${displayName}: ${lastMsgDisplay}`;
            }
          } else {
            const statusText = chat.status?.text || "Online";
            lastMsgDisplay = `[${statusText}]`;
          }

          const lastMsgTimestamp = lastMsgObj?.timestamp;
          const timeDisplay = formatChatListTimestamp(lastMsgTimestamp);

          const container = document.createElement("div");
          container.className = "chat-list-item-swipe-container";
          container.dataset.chatId = chat.id;

          const content = document.createElement("div");
          content.className = `chat-list-item-content ${chat.isPinned ? "pinned" : ""}`;

          const avatar = chat.isGroup
            ? chat.settings.groupAvatar
            : chat.settings.aiAvatar;

          let streakHtml = "";
          let selectedBadgeHtml = "";

          if (
            !chat.isGroup &&
            chat.settings.streak &&
            chat.settings.streak.enabled
          ) {
            const streak = chat.settings.streak;
            let isExtinguished = false;
            if (
              streak.lastInteractionDate &&
              streak.extinguishThreshold !== -1
            ) {
              const lastDate = new Date(streak.lastInteractionDate);
              const todayDate = new Date();
              todayDate.setHours(0, 0, 0, 0);
              const daysDiff = (todayDate - lastDate) / (1000 * 3600 * 24);
              if (daysDiff >= streak.extinguishThreshold) {
                isExtinguished = true;
              }
            }
            const litIconUrl = streak.litIconUrl;
            const extinguishedIconUrl = streak.extinguishedIconUrl;
            const fontColor = streak.fontColor || "#ff6f00";
            let iconHtml = "";
            if (isExtinguished) {
              iconHtml = extinguishedIconUrl
                ? `<img src="${extinguishedIconUrl}" style="height: 1.2em; vertical-align: middle;">`
                : "üßä";
            } else if (streak.currentDays > 0 || streak.initialDays > 0) {
              iconHtml = litIconUrl
                ? `<img src="${litIconUrl}" style="height: 1.2em; vertical-align: middle;">`
                : "üî•";
            }
            if (iconHtml) {
              if (isExtinguished) {
                streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}</span>`;
              } else if (
                streak.currentDays === -1 ||
                streak.initialDays === -1
              ) {
                streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}‚àû</span>`;
              } else {
                streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}${streak.currentDays}</span>`;
              }
            }
          }

          // ‰ΩøÁî® <img> Ê†áÁ≠æÊù•ÊòæÁ§∫‰Ω©Êà¥ÁöÑÂæΩÁ´†ÂõæÁâá
          if (!chat.isGroup && chat.settings.selectedIntimacyBadge) {
            selectedBadgeHtml = `<span class="intimacy-badge-display"><img src="${chat.settings.selectedIntimacyBadge}" alt="badge"></span>`;
          }

          content.innerHTML = `
			        <div class="chat-list-item" data-chat-id="${chat.id}">
			            <img src="${avatar || defaultAvatar}" class="avatar">
			            <div class="info">
			                <div class="name-line">
			                    <span class="name">${
                            !chat.isGroup && chat.settings.remarkName
                              ? chat.settings.remarkName
                              : chat.name
                          }</span>
			                    ${chat.isGroup ? '<span class="group-tag">Áæ§ËÅä</span>' : ""}
			                    ${streakHtml}
			                    ${selectedBadgeHtml} <!-- ÊääÂæΩÁ´†ÊîæÂú®ÁÅ´Ëä±ÂêéÈù¢ -->
			                </div>
			                <div class="last-msg" style="color: ${
                        chat.isGroup ? "var(--text-secondary)" : "#b5b5b5"
                      }; font-style: italic;">${lastMsgDisplay}</div>
			            </div>
			            <div class="chat-list-right-column">
			                <div class="chat-list-time">${timeDisplay}</div>
			                <div class="unread-count-wrapper">
			                    <span class="unread-count" style="display: none;">0</span>
			                </div>
			            </div>
			        </div>
			    `;

          // ... ÂêéÁª≠ÁöÑÊªëÂä®Âà†Èô§„ÄÅ‰∫ã‰ª∂ÁªëÂÆöÁ≠â‰ª£Á†Å‰øùÊåÅ‰∏çÂèò ...
          const actions = document.createElement("div");
          actions.className = "swipe-actions";
          const pinButtonText = chat.isPinned ? "Unpin" : "Pin";
          const pinButtonClass = chat.isPinned ? "unpin" : "pin";
          actions.innerHTML = `<button class="swipe-action-btn ${pinButtonClass}">${pinButtonText}</button><button class="swipe-action-btn delete">Delete</button>`;

          container.appendChild(content);
          container.appendChild(actions);

          const unreadCount = chat.unreadCount || 0;
          const unreadEl = content.querySelector(".unread-count");
          if (unreadCount > 0) {
            unreadEl.textContent = unreadCount > 99 ? "99+" : unreadCount;
            unreadEl.style.display = "inline-flex";
          } else {
            unreadEl.style.display = "none";
          }

          const infoEl = content.querySelector(".info");
          if (infoEl) {
            infoEl.addEventListener("click", () => openChat(chat.id));
          }
          const avatarEl = content.querySelector(".avatar, .avatar-with-frame");
          if (avatarEl) {
            avatarEl.addEventListener("click", (e) => {
              e.stopPropagation();
              handleUserPat(chat.id, chat.name);
            });
          }

          return container;
        }

        function renderChatInterface(chatId) {
          cleanupWaimaiTimers();
          const chat = state.chats[chatId];
          if (!chat) return;
          // Áæ§ÂÖ¨ÂëäÂõæÊ†áÊòæÁ§∫/ÈöêËóèÈÄªËæë
          const announcementBtn = document.getElementById(
            "group-announcement-btn",
          );
          if (chat.isGroup) {
            announcementBtn.style.display = "inline-flex"; // Âú®Áæ§ËÅä‰∏≠ÊòæÁ§∫
          } else {
            announcementBtn.style.display = "none"; // Âú®ÂçïËÅä‰∏≠ÈöêËóè
          }

          exitSelectionMode();

          const messagesContainer = document.getElementById("chat-messages");
          const chatInputArea = document.getElementById("chat-input-area");
          const lockOverlay = document.getElementById("chat-lock-overlay");
          const lockContent = document.getElementById("chat-lock-content");

          messagesContainer.dataset.theme = chat.settings.theme || "default";
          const fontSize = chat.settings.fontSize || 13;
          messagesContainer.style.setProperty(
            "--chat-font-size",
            `${fontSize}px`,
          );
          applyScopedCss(
            chat.settings.customCss || "",
            "#chat-messages",
            "custom-bubble-style",
          );
          const displayName =
            !chat.isGroup && chat.settings.remarkName
              ? chat.settings.remarkName
              : chat.name;
          document.getElementById("chat-header-title").textContent =
            displayName;
          const statusContainer = document.getElementById("chat-header-status");
          const statusTextEl = statusContainer.querySelector(".status-text");

          if (chat.isGroup) {
            statusContainer.style.display = "none";
            document.getElementById(
              "chat-header-title-wrapper",
            ).style.justifyContent = "center";
          } else {
            statusContainer.style.display = "flex";
            document.getElementById(
              "chat-header-title-wrapper",
            ).style.justifyContent = "flex-start";
            statusTextEl.textContent = chat.status?.text || "Online";
            statusContainer.classList.toggle(
              "busy",
              chat.status?.isBusy || false,
            );
          }

          lockOverlay.style.display = "none";
          chatInputArea.style.visibility = "visible";
          lockContent.innerHTML = "";

          if (!chat.isGroup && chat.relationship.status !== "friend") {
            lockOverlay.style.display = "flex";
            chatInputArea.style.visibility = "hidden";

            let lockHtml = "";
            switch (chat.relationship.status) {
              case "blocked_by_user":
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours =
                  state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(
                  0,
                  Math.ceil(
                    (cooldownMilliseconds - timeSinceBlock) / (1000 * 60),
                  ),
                );

                lockHtml = `
			                    <span class="lock-text">‰Ω†Â∑≤Â∞Ü‚Äú${chat.name}‚ÄùÊãâÈªë„ÄÇ</span>
			                    <button id="unblock-btn" class="lock-action-btn">Ëß£Èô§ÊãâÈªë</button>
			                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
			                        <strong style="color: #333;">„ÄêÂºÄÂèëËÄÖËØäÊñ≠Èù¢Êùø„Äë</strong><br>
			                        - ÂêéÂè∞Ê¥ªÂä®ÊÄªÂºÄÂÖ≥: ${
                                state.globalSettings.enableBackgroundActivity
                                  ? '<span style="color: green;">Â∑≤ÂºÄÂêØ</span>'
                                  : '<span style="color: red;">Â∑≤ÂÖ≥Èó≠</span>'
                              }<br>
			                        - Á≥ªÁªüÂøÉË∑≥ËÆ°Êó∂Âô®: ${
                                isSimulationRunning
                                  ? '<span style="color: green;">ËøêË°å‰∏≠</span>'
                                  : '<span style="color: red;">Êú™ËøêË°å</span>'
                              }<br>
			                        - ÂΩìÂâçËßíËâ≤Áä∂ÊÄÅ: <strong>${chat.relationship.status}</strong><br>
			                        - ÈúÄË¶ÅÂÜ∑Èùô(Â∞èÊó∂): <strong>${cooldownHours}</strong><br>
			                        - ÂÜ∑ÈùôÊúüÊòØÂê¶ÁªìÊùü: ${
                                isCooldownOver
                                  ? '<span style="color: green;">ÊòØ</span>'
                                  : `<span style="color: orange;">Âê¶ (ËøòÂâ©Á∫¶ ${timeRemainingMinutes} ÂàÜÈíü)</span>`
                              }<br>
			                        - Ëß¶ÂèëÊù°‰ª∂: ${
                                isCooldownOver &&
                                state.globalSettings.enableBackgroundActivity
                                  ? '<span style="color: green;">Â∑≤Êª°Ë∂≥ÔºåÁ≠âÂæÖ‰∏ãÊ¨°Á≥ªÁªüÂøÉË∑≥</span>'
                                  : '<span style="color: red;">Êú™Êª°Ë∂≥</span>'
                              }
			                    </div>
			                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">Âº∫Âà∂Ëß¶Âèë‰∏ÄÊ¨°Â•ΩÂèãÁî≥ËØ∑Ê£ÄÊµã</button>
			                `;

                break;
              case "blocked_by_ai":
                lockHtml = `
			                    <span class="lock-text">‰Ω†Ë¢´ÂØπÊñπÊãâÈªë‰∫Ü„ÄÇ</span>
			                    <button id="apply-friend-btn" class="lock-action-btn">ÈáçÊñ∞Áî≥ËØ∑Âä†‰∏∫Â•ΩÂèã</button>
			                `;
                break;

              case "pending_user_approval":
                lockHtml = `
			                    <span class="lock-text">‚Äú${chat.name}‚ÄùËØ∑Ê±ÇÊ∑ªÂä†‰Ω†‰∏∫Â•ΩÂèãÔºö<br><i>‚Äú${chat.relationship.applicationReason}‚Äù</i></span>
			                    <button id="accept-friend-btn" class="lock-action-btn">Êé•Âèó</button>
			                    <button id="reject-friend-btn" class="lock-action-btn secondary">ÊãíÁªù</button>
			                `;
                break;

              case "pending_ai_approval":
                lockHtml = `<span class="lock-text">Â•ΩÂèãÁî≥ËØ∑Â∑≤ÂèëÈÄÅÔºåÁ≠âÂæÖÂØπÊñπÈÄöËøá...</span>`;
                break;
            }
            lockContent.innerHTML = lockHtml;
          }
          messagesContainer.innerHTML = "";

          const chatScreen = document.getElementById("chat-interface-screen");

          // Ê†∏ÂøÉÈÄªËæëÔºöÂçï‰∫∫ËÉåÊôØ‰ºòÂÖà‰∫éÂÖ®Â±ÄËÉåÊôØ
          const backgroundToApply =
            chat.settings.background ||
            state.globalSettings.globalChatBackground;

          if (backgroundToApply) {
            chatScreen.style.backgroundImage = `url(${backgroundToApply})`;
          } else {
            chatScreen.style.backgroundImage = "none";
          }

          const isDarkMode = document
            .getElementById("phone-screen")
            .classList.contains("dark-mode");
          chatScreen.style.backgroundColor = chat.settings.background
            ? "transparent"
            : isDarkMode
              ? "#000000"
              : "#f0f2f5";
          const history = chat.history;
          const totalMessages = history.length;
          currentRenderedCount = 0;
          const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
          let lastMessageTimestamp = null;

          initialMessages.forEach((msg) => {
            if (msg.isHidden) return; // „ÄêÊñ∞Â¢û„ÄëË∑≥ËøáÈöêËóèÊ∂àÊÅØ

            if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
              // Ë∞ÉÁî®Êñ∞ÁöÑÁîüÊàêÂô®ÂáΩÊï∞
              const dateStampEl = createDateStampElement(msg.timestamp);
              messagesContainer.insertBefore(
                dateStampEl,
                document.getElementById("typing-indicator"),
              );
            }

            appendMessage(msg, chat, true);

            lastMessageTimestamp = msg.timestamp;
          });
          currentRenderedCount = initialMessages.length;
          if (totalMessages > currentRenderedCount) {
            prependLoadMoreButton(messagesContainer);
          }
          const typingIndicator = document.createElement("div");
          typingIndicator.id = "typing-indicator";
          typingIndicator.style.display = "none";
          typingIndicator.textContent = `${chat.name} is typing...`;
          messagesContainer.appendChild(typingIndicator);
          setTimeout(
            () =>
              (messagesContainer.scrollTop = messagesContainer.scrollHeight),
            0,
          );
          renderChatPet();
        }

        function prependLoadMoreButton(container) {
          const button = document.createElement("button");
          button.id = "load-more-btn";
          button.textContent = "Load earlier records";
          button.addEventListener("click", loadMoreMessages);
          container.prepend(button);
        }

        function loadMoreMessages() {
          const messagesContainer = document.getElementById("chat-messages");
          const chat = state.chats[state.activeChatId];
          if (!chat) return;
          const loadMoreBtn = document.getElementById("load-more-btn");
          if (loadMoreBtn) loadMoreBtn.remove();
          const totalMessages = chat.history.length;
          const nextSliceStart =
            totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW;
          const nextSliceEnd = totalMessages - currentRenderedCount;
          const messagesToPrepend = chat.history.slice(
            Math.max(0, nextSliceStart),
            nextSliceEnd,
          );
          const oldScrollHeight = messagesContainer.scrollHeight;

          // 1. ÊâæÂà∞Â±èÂπï‰∏äÂ∑≤ÊúâÁöÑ„ÄÅÊúÄËÄÅÁöÑÈÇ£Êù°„ÄêÁúüÂÆûÊ∂àÊÅØ„ÄëÁöÑÊó∂Èó¥Êà≥
          const firstVisibleMessage = messagesContainer.querySelector(
            ".message-wrapper:not(.date-stamp-wrapper)",
          );
          let subsequentMessageTimestamp = firstVisibleMessage
            ? parseInt(firstVisibleMessage.dataset.timestamp)
            : null;

          // 2. ‰ªéÂêéÂæÄÂâçÔºà‰ªéÊñ∞Âà∞ÊóßÔºâÈÅçÂéÜÊàë‰ª¨Ë¶ÅÊñ∞Âä†ËΩΩÁöÑÊ∂àÊÅØ
          messagesToPrepend.reverse().forEach((currentMsg) => {
            // Ê£ÄÊü•ËøôÊù°Êñ∞Ê∂àÊÅØÂíåÂÆÉÂêéÈù¢ÈÇ£Êù°ÔºàÂèØËÉΩÊòØÂ±èÂπï‰∏äÂ∑≤ÊúâÁöÑÔºå‰πüÂèØËÉΩÊòØÂàöÂä†ËΩΩÁöÑÔºâÊ∂àÊÅØÊòØÂê¶Ë∑®Â§©
            if (
              subsequentMessageTimestamp &&
              isNewDay(subsequentMessageTimestamp, currentMsg.timestamp)
            ) {
              // Â¶ÇÊûúË∑®Â§©ÔºåÂ∞±‰∏∫ÂêéÈù¢ÈÇ£Êù°‚ÄúËæÉÊñ∞‚ÄùÁöÑÊ∂àÊÅØÂàõÂª∫‰∏Ä‰∏™Êó•ÊúüÊà≥
              const dateStampEl = createDateStampElement(
                subsequentMessageTimestamp,
              );
              messagesContainer.prepend(dateStampEl);
            }

            // Ê≠£Â∏∏Âú∞ÊääÂΩìÂâçËøôÊù°Êñ∞Ê∂àÊÅØÊîæÂà∞ÊúÄÂâçÈù¢
            prependMessage(currentMsg, chat);

            // Êõ¥Êñ∞ËøΩË∏™Âô®Ôºå‰∏∫‰∏ã‰∏ÄÊ¨°ÊØîËæÉÂÅöÂáÜÂ§á
            subsequentMessageTimestamp = currentMsg.timestamp;
          });

          // 3. „ÄêËæπÁïåÂ§ÑÁêÜ„ÄëÂ§ÑÁêÜÊâÄÊúâÊñ∞Âä†ËΩΩÊ∂àÊÅØÁöÑÊúÄÂâçÈù¢Ôºà‰πüÂ∞±ÊòØÊï¥‰∏™ËÅäÂ§©ËÆ∞ÂΩïÁöÑÊúÄËÄÅÔºâÁöÑÈÇ£Êù°Ê∂àÊÅØ
          // ÂÆÉ‰πüÈúÄË¶Å‰∏Ä‰∏™Êó•ÊúüÊà≥
          if (subsequentMessageTimestamp) {
            const dateStampEl = createDateStampElement(
              subsequentMessageTimestamp,
            );
            messagesContainer.prepend(dateStampEl);
          }

          currentRenderedCount += messagesToPrepend.length;
          const newScrollHeight = messagesContainer.scrollHeight;
          messagesContainer.scrollTop += newScrollHeight - oldScrollHeight;
          if (totalMessages > currentRenderedCount) {
            prependLoadMoreButton(messagesContainer);
          }
        }

        async function renderWallpaperScreen() {
          // ÈîÅÂ±èÂºÄÂÖ≥
          const lockScreenEnabled =
            localStorage.getItem("lockScreenEnabled") !== "false";
          const toggle = document.getElementById("enable-lock-screen-toggle");
          if (toggle) {
            toggle.checked = lockScreenEnabled;
          }

          // ‰∏ªÂ±èÂπïÂ≠ó‰ΩìÈ¢úËâ≤ÂíåÈò¥ÂΩ±
          const savedColor =
            state.globalSettings.homeIconWidgetTextColor || "#FFFFFF";
          document.getElementById("home-icon-widget-text-color-picker").value =
            savedColor;
          document.getElementById("home-icon-widget-text-color-input").value =
            savedColor;
          document.getElementById("remove-home-font-shadow-toggle").checked =
            !!state.globalSettings.removeHomeFontShadow;

          // ‰∏ªÂ±èÂπïÂ£ÅÁ∫∏È¢ÑËßà
          const preview = document.getElementById("wallpaper-preview");
          const bg = newWallpaperBase64 || state.globalSettings.wallpaper;
          if (bg && bg.startsWith("data:image")) {
            preview.style.backgroundImage = `url(${bg})`;
            preview.textContent = "";
          } else if (bg) {
            preview.style.backgroundImage = bg;
            preview.textContent = "The current setting is a gradient color.";
          }

          // ÈîÅÂ±èÂ£ÅÁ∫∏È¢ÑËßà
          const lockscreenPreview = document.getElementById(
            "lockscreen-wallpaper-preview",
          );
          const lockBg =
            newLockscreenWallpaperBase64 ||
            state.globalSettings.lockscreenWallpaper;
          if (lockBg && lockBg.startsWith("data:image")) {
            lockscreenPreview.style.backgroundImage = `url(${lockBg})`;
            lockscreenPreview.textContent = "";
          } else if (lockBg) {
            lockscreenPreview.style.backgroundImage = lockBg;
            lockscreenPreview.textContent = "The current setting is a gradient color.";
          }

          // ÂØÜÁ†ÅËæìÂÖ•Ê°Ü
          document.getElementById("password-set-input").value =
            state.globalSettings.password || "";

          // ÂÖ®Â±ÄËÅäÂ§©ËÉåÊôØÈ¢ÑËßà
          const globalBgPreview = document.getElementById("global-bg-preview");
          const globalBg =
            newGlobalBgBase64 || state.globalSettings.globalChatBackground;
          if (globalBg && globalBg.startsWith("data:image")) {
            globalBgPreview.style.backgroundImage = `url(${globalBg})`;
            globalBgPreview.textContent = "";
          } else if (globalBg) {
            globalBgPreview.style.background = globalBg;
            globalBgPreview.textContent = "Currently displaying gradient colors";
          } else {
            globalBgPreview.style.backgroundImage = "none";
            globalBgPreview.textContent = "Click below to upload";
          }

          // ÈìÉÂ£∞ÂíåÊèêÁ§∫Èü≥
          document.getElementById("ringtone-url-input").value =
            state.globalSettings.ringtoneUrl || "";
          document.getElementById("notification-sound-url-input").value =
            state.globalSettings.notificationSoundUrl || "";

          await loadThemesToDropdown(); // Ensure the theme list is loaded
          const editor = document.getElementById("theme-css-editor");
          const selector = document.getElementById("theme-selector");

          // Prioritize loading activeCustomCss
          if (state.globalSettings.activeCustomCss) {
            editor.value = state.globalSettings.activeCustomCss;
            // If custom CSS exists, reset the dropdown to "none selected"
            selector.value = "";
          }
          // If there is no custom CSS but a theme ID is selected
          else if (state.globalSettings.activeThemeId) {
            const theme = await db.themes.get(
              state.globalSettings.activeThemeId,
            );
            if (theme) {
              editor.value = theme.css;
              selector.value = theme.id; // Ëá™Âä®ÈÄâ‰∏≠ËØ•‰∏ªÈ¢ò
            } else {
              editor.value = THEME_CSS_TEMPLATE; // Â¶ÇÊûúIDÊó†ÊïàÔºåÂàôÊòæÁ§∫Ê®°Êùø
            }
          }
          // Â¶ÇÊûú‰ªÄ‰πàÈÉΩÊ≤°‰øùÂ≠òÔºåÊòæÁ§∫Ê®°Êùø
          else {
            editor.value = THEME_CSS_TEMPLATE;
          }

          // Ê∏≤ÊüìAppÂõæÊ†áÂíåÂêçÁß∞ËÆæÁΩÆ
          renderIconSettings();
          renderAppNameSettings();

          // Âä†ËΩΩÈ¢ÑËÆæ‰∏ãÊãâÊ°Ü
          loadHomeScreenPresetsToDropdown();
        }

        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() {
          const homeScreen = document.getElementById("home-screen");
          const wallpaper = state.globalSettings.wallpaper;
          if (wallpaper && wallpaper.startsWith("data:image"))
            homeScreen.style.backgroundImage = `url(${wallpaper})`;
          else if (wallpaper) homeScreen.style.backgroundImage = wallpaper;
        }

        async function renderWorldBookScreen() {
          const listEl = document.getElementById("world-book-list");
          listEl.innerHTML = "";

          // 1. ÂêåÊó∂Ëé∑ÂèñÊâÄÊúâ‰π¶Á±çÂíåÊâÄÊúâÂàÜÁ±ª
          const [books, categories] = await Promise.all([
            db.worldBooks.toArray(),
            db.worldBookCategories.orderBy("name").toArray(),
          ]);

          state.worldBooks = books; // Á°Æ‰øùÂÜÖÂ≠ò‰∏≠ÁöÑÊï∞ÊçÆÊòØÂêåÊ≠•ÁöÑ

          if (books.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">Click the "+" in the upper right corner to create your first world book.</p>';
            return;
          }

          // 2. Â∞Ü‰π¶Á±çÊåâ categoryId ÂàÜÁªÑ
          const groupedBooks = books.reduce((acc, book) => {
            const key = book.categoryId || "uncategorized";
            if (!acc[key]) {
              acc[key] = [];
            }
            acc[key].push(book);
            return acc;
          }, {});

          // 3. ‰ºòÂÖàÊ∏≤ÊüìÂ∑≤ÂàÜÁ±ªÁöÑ‰π¶Á±ç
          categories.forEach((category) => {
            const booksInCategory = groupedBooks[category.id];
            if (booksInCategory && booksInCategory.length > 0) {
              const groupContainer = createWorldBookGroup(
                category.name,
                booksInCategory,
              );
              listEl.appendChild(groupContainer);
            }
          });

          // 4. ÊúÄÂêéÊ∏≤ÊüìÊú™ÂàÜÁ±ªÁöÑ‰π¶Á±ç
          const uncategorizedBooks = groupedBooks["uncategorized"];
          if (uncategorizedBooks && uncategorizedBooks.length > 0) {
            const groupContainer = createWorldBookGroup(
              "Uncategorized",
              uncategorizedBooks,
            );
            listEl.appendChild(groupContainer);
          }

          // 5. ‰∏∫ÊâÄÊúâÂàÜÁªÑÊ†áÈ¢òÊ∑ªÂä†ÊäòÂè†‰∫ã‰ª∂
          document
            .querySelectorAll(".world-book-group-header")
            .forEach((header) => {
              header.addEventListener("click", () => {
                header.classList.toggle("collapsed");
                header.nextElementSibling.classList.toggle("collapsed");
              });
            });
        }

        /**
         * „ÄêËæÖÂä©ÂáΩÊï∞„ÄëÂàõÂª∫‰∏Ä‰∏™ÂàÜÁ±ªÁöÑÂàÜÁªÑDOM
         * @param {string} groupName - ÂàÜÁ±ªÂêçÁß∞
         * @param {Array} books - ËØ•ÂàÜÁ±ª‰∏ãÁöÑ‰π¶Á±çÊï∞ÁªÑ
         * @returns {HTMLElement} - ÂàõÂª∫Â•ΩÁöÑÂàÜÁªÑÂÆπÂô®
         */
        function createWorldBookGroup(groupName, books) {
          const groupContainer = document.createElement("div");
          groupContainer.className = "world-book-group-container";

          groupContainer.innerHTML = `
			        <div class="world-book-group-header">
			            <span class="arrow">‚ñº</span>
			            <span class="group-name">${groupName}</span>
			        </div>
			        <div class="world-book-group-content"></div>
			    `;

          const headerEl = groupContainer.querySelector(
            ".world-book-group-header",
          );
          const contentEl = groupContainer.querySelector(
            ".world-book-group-content",
          );

          // ÈªòËÆ§ÁªôÂ§¥ÈÉ®ÂíåÂÜÖÂÆπÂå∫ÈÉΩÂä†‰∏ä collapsed Á±ª
          headerEl.classList.add("collapsed");
          contentEl.classList.add("collapsed");

          books.sort((a, b) => a.name.localeCompare(b.name, "en-US"));
          books.forEach((book) => {
            const item = document.createElement("div");
            item.className = "list-item";
            item.dataset.bookId = book.id;
            item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(
              book.content || "No content available..."
            ).substring(0, 50)}</div>`;
            item.addEventListener("click", () => openWorldBookEditor(book.id));
            addLongPressListener(item, async () => {
              const confirmed = await showCustomConfirm(
                "Delete World Book",
                `Are you sure you want to delete "${book.name}"? This action cannot be undone.`,
                { confirmButtonClass: "btn-danger" },
              );
              if (confirmed) {
                await db.worldBooks.delete(book.id);
                state.worldBooks = state.worldBooks.filter(
                  (wb) => wb.id !== book.id,
                );
                renderWorldBookScreen();
              }
            });
            contentEl.appendChild(item);
          });

          return groupContainer;
        }
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

        async function openWorldBookEditor(bookId) {
          editingWorldBookId = bookId;
          const [book, categories] = await Promise.all([
            db.worldBooks.get(bookId),
            db.worldBookCategories.toArray(),
          ]);
          if (!book) return;

          document.getElementById("world-book-editor-title").textContent =
            book.name;
          document.getElementById("world-book-name-input").value = book.name;
          document.getElementById("world-book-content-input").value =
            book.content;

          // Fill the category dropdown
          const selectEl = document.getElementById(
            "world-book-category-select",
          );
          selectEl.innerHTML = '<option value="">-- Uncategorized --</option>'; // Default option
          categories.forEach((cat) => {
            const option = document.createElement("option");
            option.value = cat.id;
            option.textContent = cat.name;
            if (book.categoryId === cat.id) {
              option.selected = true; // Select the current category
            }
            selectEl.appendChild(option);
          });

          showScreen("world-book-editor-screen");
        }

        function renderStickerPanel() {
          const grid = document.getElementById("sticker-grid");
          grid.innerHTML = "";

          let stickersToRender;

          if (activeStickerCategoryId === "uncategorized") {
            // Â¶ÇÊûúÊòØ‚ÄúÊú™ÂàÜÁ±ª‚ÄùÔºåÂ∞±Á≠õÈÄâÂá∫ categoryId ‰∏çÂ≠òÂú®Êàñ‰∏∫Á©∫ÁöÑË°®ÊÉÖ
            stickersToRender = state.userStickers.filter(
              (sticker) => !sticker.categoryId,
            );
          } else {
            // Âê¶ÂàôÔºåÊåâÂÖ∑‰ΩìÁöÑÂàÜÁ±ªIDÁ≠õÈÄâ
            stickersToRender = state.userStickers.filter(
              (sticker) => sticker.categoryId === activeStickerCategoryId,
            );
          }

          if (stickersToRender.length === 0) {
            // Ê†πÊçÆÂΩìÂâçÈÄâ‰∏≠ÁöÑÂàÜÁ±ªÔºåÊòæÁ§∫‰∏çÂêåÁöÑÊèêÁ§∫ËØ≠
            let message;
            if (activeStickerCategoryId === "uncategorized") {
              // Â¶ÇÊûúÊâÄÊúâË°®ÊÉÖÈÉΩÊúâÂàÜÁ±ª‰∫ÜÔºåËøôÈáå‰πü‰ºöÊòØÁ©∫ÁöÑ
              message = "There are no uncategorized emojis.~";
            } else {
              // Â¶ÇÊûúÊòØÂú®Êüê‰∏™ÂÖ∑‰ΩìÂàÜÁ±ª‰∏ãÔºå‰ΩÜÊòØÈáåÈù¢Ê≤°Ë°®ÊÉÖ
              message = "There are no emojis in this category.~";
            }
            // Â¶ÇÊûúÊï¥‰∏™Ë°®ÊÉÖÂ∫ìÈÉΩÊòØÁ©∫ÁöÑÔºåÁªô‰∏Ä‰∏™ÂàùÂßãÂºïÂØº
            if (state.userStickers.length === 0) {
              message =
                "Please click 'Add' or 'Upload' in the top right corner to add your first emoji!";
            }

            grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">${message}</p>`;
          } else {
            stickersToRender.forEach((sticker) => {
              // ËøôÈÉ®ÂàÜÊòØ‰Ω†ÂéüÊù•ÁöÑÊ∏≤ÊüìÈÄªËæëÔºå‰øùÊåÅ‰∏çÂèò
              const itemContainer = document.createElement("div");
              itemContainer.className = "sticker-item";

              const imageEl = document.createElement("div");
              imageEl.className = "sticker-image";
              imageEl.style.backgroundImage = `url(${sticker.url})`;

              const nameEl = document.createElement("span");
              nameEl.className = "sticker-name";
              nameEl.textContent = sticker.name;
              nameEl.title = sticker.name;

              if (isUserStickerSelectionMode) {
                imageEl.classList.add("in-selection-mode");
                if (selectedUserStickers.has(sticker.id)) {
                  imageEl.classList.add("selected");
                }
                itemContainer.addEventListener("click", () => {
                  imageEl.classList.toggle("selected");
                  if (selectedUserStickers.has(sticker.id)) {
                    selectedUserStickers.delete(sticker.id);
                  } else {
                    selectedUserStickers.add(sticker.id);
                  }
                  const deleteBtn = document.getElementById(
                    "delete-selected-user-stickers-btn",
                  );
                  deleteBtn.textContent = `Delete selected (${selectedUserStickers.size})`;
                  deleteBtn.disabled = selectedUserStickers.size === 0;

                  const moveBtn = document.getElementById(
                    "move-selected-stickers-btn",
                  );
                  moveBtn.disabled = selectedUserStickers.size === 0;
                });
              } else {
                itemContainer.addEventListener("click", () =>
                  sendSticker(sticker),
                );
                addLongPressListener(imageEl, () => {
                  const existingDeleteBtn =
                    imageEl.querySelector(".delete-btn");
                  if (existingDeleteBtn) return;

                  const deleteBtn = document.createElement("div");
                  deleteBtn.className = "delete-btn";
                  deleteBtn.innerHTML = "&times;";
                  deleteBtn.style.display = "block";
                  deleteBtn.onclick = async (e) => {
                    e.stopPropagation();
                    const confirmed = await showCustomConfirm(
                      "Delete Emoji",
                      `Are you sure you want to delete the emoji "${sticker.name}"?`,
                      {
                        confirmButtonClass: "btn-danger",
                      },
                    );
                    if (confirmed) {
                      await db.userStickers.delete(sticker.id);
                      state.userStickers = state.userStickers.filter(
                        (s) => s.id !== sticker.id,
                      );
                      renderStickerPanel();
                    }
                  };
                  imageEl.appendChild(deleteBtn);
                  const removeDeleteBtn = () => {
                    if (deleteBtn) deleteBtn.remove();
                    imageEl.removeEventListener("mouseleave", removeDeleteBtn);
                  };
                  imageEl.addEventListener("mouseleave", removeDeleteBtn);
                });
              }

              itemContainer.appendChild(imageEl);
              itemContainer.appendChild(nameEl);
              grid.appendChild(itemContainer);
            });
          }

          // ÊØèÊ¨°Ê∏≤ÊüìË°®ÊÉÖÂàóË°®ÂêéÔºåÈÉΩÊõ¥Êñ∞‰∏ÄÊ¨°ÂàÜÁ±ªÈ°µÁ≠æÊ†è
          renderStickerCategories();
        }

        /**
         * Â§ÑÁêÜÂà†Èô§Ë°®ÊÉÖÂàÜÁ±ªÁöÑÈÄªËæëÔºåÊèê‰æõ‰∏§ÁßçÂà†Èô§ÊñπÂºè
         * @param {number} categoryId - Ë¶ÅÂà†Èô§ÁöÑÂàÜÁ±ªID
         * @param {string} categoryName - Ë¶ÅÂà†Èô§ÁöÑÂàÜÁ±ªÂêçÁß∞
         */
        async function handleDeleteStickerCategory(categoryId, categoryName) {
          if (isNaN(categoryId) || !categoryName) {
            alert("Failed to delete: Invalid category ID or name!");
            return;
          }

          // ÂºπÁ™óËÆ©Áî®Êà∑ÈÄâÊã©Â¶Ç‰ΩïÂ§ÑÁêÜÂàÜÁ±ª‰∏ãÁöÑË°®ÊÉÖ
          const choice = await showChoiceModal(`Delete Category "${categoryName}"`, [
            {
              text: "Delete category only (stickers moved to 'Uncategorized')",
              value: "delete_category_only",
            },
            { text: "Delete category and all stickers (irreversible)", value: "delete_all" },
          ]);

          if (!choice) return; // If the user clicks cancel, do nothing

          try {
            if (choice === "delete_category_only") {
              // Find all stickers under this category
              const stickersToUpdate = state.userStickers.filter(
                (s) => s.categoryId === categoryId,
              );

              if (stickersToUpdate.length > 0) {
                // Set their category ID to null or undefined, indicating uncategorized
                stickersToUpdate.forEach((sticker) => {
                  sticker.categoryId = null;
                });
                await db.userStickers.bulkPut(stickersToUpdate);
              }
              // ‰ªéÊï∞ÊçÆÂ∫ìÂà†Èô§ÂàÜÁ±ªÊú¨Ë∫´
              await db.userStickerCategories.delete(categoryId);
            } else if (choice === "delete_all") {
              // ÊâæÂà∞ËØ•ÂàÜÁ±ª‰∏ãÁöÑÊâÄÊúâË°®ÊÉÖID
              const stickerIdsToDelete = state.userStickers
                .filter((s) => s.categoryId === categoryId)
                .map((s) => s.id);

              if (stickerIdsToDelete.length > 0) {
                // ‰ªéÊï∞ÊçÆÂ∫ìÊâπÈáèÂà†Èô§Ëøô‰∫õË°®ÊÉÖ
                await db.userStickers.bulkDelete(stickerIdsToDelete);
              }
              // ‰ªéÊï∞ÊçÆÂ∫ìÂà†Èô§ÂàÜÁ±ªÊú¨Ë∫´
              await db.userStickerCategories.delete(categoryId);
            }

            // ‰∏çËÆ∫Âì™ÁßçÊñπÂºèÔºåÈÉΩÈúÄË¶Å‰ªéÂâçÁ´ØÁöÑ state ÁºìÂ≠ò‰∏≠ÁßªÈô§ÊàñÊõ¥Êñ∞Êï∞ÊçÆ
            state.userStickers = await db.userStickers.toArray();

            // Â¶ÇÊûúÂà†Èô§ÁöÑÊòØÂΩìÂâçÊ≠£Âú®Êü•ÁúãÁöÑÂàÜÁ±ªÔºåÂ∞±ÂàáÊç¢Âõû‚ÄúÊú™ÂàÜÁ±ª‚Äù
            if (activeStickerCategoryId === categoryId) {
              activeStickerCategoryId = "uncategorized";
            }

            // ÈáçÊñ∞Ê∏≤ÊüìÊï¥‰∏™Ë°®ÊÉÖÈù¢ÊùøÔºàËøô‰ºöËá™Âä®Âà∑Êñ∞ÂàÜÁ±ªÂíåË°®ÊÉÖÂàóË°®Ôºâ
            renderStickerPanel();

            await showCustomAlert(
              "Operation successful",
              `Category "${categoryName}" has been successfully deleted.`,
            );
          } catch (error) {
            console.error("Error deleting category:", error);
            alert(`Operation failed due to a database error: ${error.message}`);
          }
        }

        /**
         * Â§ÑÁêÜÊâπÈáèÂà†Èô§ÈÄâ‰∏≠ÁöÑÁî®Êà∑Ë°®ÊÉÖ
         */
        async function handleBulkDeleteUserStickers() {
          if (selectedUserStickers.size === 0) return;

          const confirmed = await showCustomConfirm(
            "Confirm Deletion",
            `Are you sure you want to delete the ${selectedUserStickers.size} selected stickers?`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            const idsToDelete = Array.from(selectedUserStickers);
            await db.userStickers.bulkDelete(idsToDelete);

            state.userStickers = state.userStickers.filter(
              (s) => !idsToDelete.includes(s.id),
            );

            // ÈÄÄÂá∫ÁºñËæëÊ®°Âºè
            toggleUserStickerSelectionMode();

            alert("The selected stickers have been deleted.");
          }
        }

        /**
         * „ÄêÂÖ®Êñ∞„Äë‰ªéÂç°ÁâáÁÇπÂáªÂêéÔºåÊâìÂºÄÊÉÖ‰æ£Á©∫Èó¥Âπ∂Ë∑≥ËΩ¨Âà∞ÊåáÂÆöÈ°µÁ≠æ
         * @param {string} charId - ËßíËâ≤ID
         * @param {string} viewId - Ë¶ÅË∑≥ËΩ¨Âà∞ÁöÑËßÜÂõæID (‰æãÂ¶Ç 'ls-diary-view')
         */
        function openLoversSpaceFromCard(charId, viewId) {
          // 1. ÊâìÂºÄÊåáÂÆöËßíËâ≤ÁöÑÊÉÖ‰æ£Á©∫Èó¥‰∏ªÁïåÈù¢
          openLoversSpace(charId);

          // 2. Á≠âÂæÖ‰∏ÄÂ∞è‰ºöÂÑøÔºåÁ°Æ‰øùÁïåÈù¢Â∑≤Ê∏≤Êüì
          setTimeout(() => {
            // 3. ÊâæÂà∞ÂØπÂ∫îÁöÑÈ°µÁ≠æÊåâÈíÆÂπ∂Ê®°ÊãüÁÇπÂáªÂÆÉ
            const targetTab = document.querySelector(
              `.ls-tab-item[data-view='${viewId}']`,
            );
            if (targetTab) {
              targetTab.click();
            }
          }, 100); // 100ÊØ´ÁßíÁöÑÂª∂ËøüÈÄöÂ∏∏Ë∂≥Â§ü‰∫Ü
        }

        function createMessageElement(msg, chat) {
          if (msg.type === "recalled_message") {
            const wrapper = document.createElement("div");
            // 1. Áªô wrapper ‰πüÂä†‰∏ä timestampÔºåÊñπ‰æø‰∫ã‰ª∂ÂßîÊâòÊó∂Êü•Êâæ
            wrapper.className = "message-wrapper system-pat";
            wrapper.dataset.timestamp = msg.timestamp;

            const bubble = document.createElement("div");
            // 2. ËÆ©Ëøô‰∏™ÂÖÉÁ¥†ÂêåÊó∂Êã•Êúâ .message-bubble Âíå .recalled-message-placeholder ‰∏§‰∏™class
            //    ËøôÊ†∑ÂÆÉÊó¢ËÉΩË¢´ÈÄâÊã©Á≥ªÁªüËØÜÂà´ÔºåÂèàËÉΩ‰øùÊåÅÂéüÊúâÁöÑÂ±Ö‰∏≠ÁÅ∞Ëâ≤Ê†∑Âºè
            bubble.className = "message-bubble recalled-message-placeholder";
            // 3. Êää timestamp ÊîæÂú® bubble ‰∏äÔºåËøôÊòØÂ§öÈÄâÈÄªËæëÁöÑÂÖ≥ÈîÆ
            bubble.dataset.timestamp = msg.timestamp;
            bubble.textContent = msg.content;

            wrapper.appendChild(bubble);

            // 4. ‰∏∫ÂÆÉË°•‰∏äÂíåÂÖ∂‰ªñÊ∂àÊÅØ‰∏ÄÊ†∑ÁöÑÊ†áÂáÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
            addLongPressListener(wrapper, () =>
              showMessageActions(msg.timestamp),
            );
            wrapper.addEventListener("click", () => {
              if (isSelectionMode) {
                toggleMessageSelection(msg.timestamp);
              }
            });

            // 5. Âú®‰πãÂâçÁöÑ‚ÄúÁÇπÂáªÊü•ÁúãÂéüÊñá‚ÄùÁöÑÈÄªËæë‰∏≠ÔºåÊàë‰ª¨Â∑≤Áªè‰ΩøÁî®‰∫Ü‰∫ã‰ª∂ÂßîÊâòÔºåÊâÄ‰ª•ËøôÈáå‰∏çÈúÄË¶ÅÂÜçÂçïÁã¨‰∏∫Ëøô‰∏™ÂÖÉÁ¥†Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂‰∫Ü„ÄÇ
            //    init() ÂáΩÊï∞‰∏≠ÁöÑÈÇ£‰∏™‰∫ã‰ª∂ÁõëÂê¨Âô®‰ºöÂ§ÑÁêÜÂÆÉ„ÄÇ

            return wrapper;
          }

          if (msg.isHidden) {
            return null;
          }

          if (msg.type === "pat_message") {
            const wrapper = document.createElement("div");
            wrapper.className = "message-wrapper system-pat";
            const bubble = document.createElement("div");
            bubble.className = "message-bubble system-bubble";
            bubble.dataset.timestamp = msg.timestamp;
            bubble.textContent = msg.content;
            wrapper.appendChild(bubble);
            addLongPressListener(wrapper, () =>
              showMessageActions(msg.timestamp),
            );
            wrapper.addEventListener("click", () => {
              if (isSelectionMode) toggleMessageSelection(msg.timestamp);
            });
            return wrapper;

          } else if (msg.type === "poke_action") {
            // ‚îÄ‚îÄ Poke / Pat ‚Äî centered system-style bubble ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const isUserInitiated = msg.direction === "user_to_char";
            const actionEmoji = msg.actionType === "pat" ? "ü§ö" : "üëâ";
            const actionLabel = msg.actionType === "pat" ? "patted" : "poked";
            const charName    = chat?.name || "them";
            const actorName   = isUserInitiated ? "You" : charName;
            const targetName  = isUserInitiated ? charName : "you";

            const wrapper = document.createElement("div");
            wrapper.className = "message-wrapper system-pat";
            wrapper.dataset.timestamp = msg.timestamp;

            const bubble = document.createElement("div");
            bubble.className = "message-bubble poke-action-bubble";
            bubble.dataset.timestamp = msg.timestamp;
            bubble.innerHTML = `
              <span class="poke-emoji">${actionEmoji}</span>
              <span class="poke-text">${actorName} ${actionLabel} ${targetName}!</span>
              <span class="poke-emoji">${actionEmoji}</span>`;

            wrapper.appendChild(bubble);
            addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
            wrapper.addEventListener("click", () => {
              if (isSelectionMode) toggleMessageSelection(msg.timestamp);
            });
            return wrapper;
          } else if (msg.type === "narrative") {
            const wrapper = document.createElement("div");
            wrapper.className = "message-wrapper system-pat"; // Â§çÁî®Á≥ªÁªüÊ∂àÊÅØÁöÑÂ±Ö‰∏≠Ê†∑Âºè
            const bubble = document.createElement("div");
            bubble.className = "message-bubble system-bubble";
            bubble.dataset.timestamp = msg.timestamp;

            bubble.style.textAlign = "left";
            bubble.style.display = "inline-block"; // ‰øùÊåÅÊ∞îÊ≥°Ëá™ÈÄÇÂ∫îÂÜÖÂÆπÂÆΩÂ∫¶
            bubble.style.maxWidth = "100%"; // ÈôêÂà∂ÊúÄÂ§ßÂÆΩÂ∫¶ÔºåÈÅøÂÖçÂ§™ÂÆΩ

            // ËøôÈáåÁªôÂÆÉÂä†‰∏™Â∞èÂõæÊ†áÔºåËÆ©ÂÆÉÁúãËµ∑Êù•Êõ¥Êúâ‚ÄúÂâßÊÉÖÊÑü‚Äù
            bubble.innerHTML = `
			                            <div style="font-weight:bold; color:#5f6368;">üìù ÊóÅÁôΩ</div>
			                            <div style="line-height: 1.5;">${msg.content.replace(/\n/g, "<br>")}</div>
			                        `;

            wrapper.appendChild(bubble);

            // ÁªëÂÆöÈïøÊåâÂíåÁÇπÂáª‰∫ã‰ª∂ÔºàÁî®‰∫éÂà†Èô§Á≠âÊìç‰ΩúÔºâ
            addLongPressListener(wrapper, () =>
              showMessageActions(msg.timestamp),
            );
            wrapper.addEventListener("click", () => {
              if (isSelectionMode) toggleMessageSelection(msg.timestamp);
            });
            return wrapper;
          }

          const isUser = msg.role === "user";
          const wrapper = document.createElement("div");
          wrapper.className = `message-wrapper ${isUser ? "user" : "ai"}`;

          if (chat.isGroup) {
            const senderLine = document.createElement("div");
            senderLine.className = "group-sender-line";

            const tagsContainer = document.createElement("div");
            tagsContainer.className = "group-sender-tags";

            let senderDisplayName;

            if (isUser) {
              // Â¶ÇÊûúÊòØÁî®Êà∑Ëá™Â∑±
              senderDisplayName = chat.settings.myNickname || "Me";

              // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶ÊòØÁæ§‰∏ª
              if (chat.ownerId === "user") {
                const roleTag = document.createElement("span");
                roleTag.className = "group-role-tag owner";
                roleTag.textContent = "Group owner";
                tagsContainer.appendChild(roleTag);
              }
              // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Ë¢´ËÆæ‰∏∫ÁÆ°ÁêÜÂëò
              else if (chat.settings.isUserAdmin) {
                const roleTag = document.createElement("span");
                roleTag.className = "group-role-tag admin";
                roleTag.textContent = "Administrator";
                tagsContainer.appendChild(roleTag);
              }

              // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶ÊúâÂ§¥Ë°î
              if (chat.settings.myGroupTitle) {
                const titleTag = document.createElement("span");
                titleTag.className = "group-title-tag";
                titleTag.textContent = chat.settings.myGroupTitle;
                tagsContainer.appendChild(titleTag);
              }
            } else {
              // Â¶ÇÊûúÊòØÂÖ∂‰ªñÊàêÂëò (AI/NPC)ÔºåËøôÈÉ®ÂàÜÈÄªËæë‰øùÊåÅ‰∏çÂèò
              const member = chat.members.find(
                (m) => m.originalName === msg.senderName,
              );
              senderDisplayName = member
                ? member.groupNickname
                : msg.senderName || "Unknown member";

              // Â¶ÇÊûúËØ•ÊàêÂëòË¢´Á¶ÅË®Ä‰∫ÜÔºåÂ∞±Ê∑ªÂä†‰∏Ä‰∏™Á¶ÅË®ÄÊ†áÁ≠æ
              if (member && member.isMuted) {
                const muteTag = document.createElement("span");
                muteTag.className = "group-title-tag"; // Â§çÁî®Â§¥Ë°îÊ†áÁ≠æÁöÑÊ†∑Âºè
                muteTag.style.color = "#ff3b30"; // Make it red
                muteTag.style.backgroundColor = "#ffe5e5"; // Light red background
                muteTag.textContent = "üö´Muted";
                tagsContainer.appendChild(muteTag);
              }

              if (member && chat.ownerId === member.id) {
                const roleTag = document.createElement("span");
                roleTag.className = "group-role-tag owner";
                roleTag.textContent = "Group owner";
                tagsContainer.appendChild(roleTag);
              } else if (member && member.isAdmin) {
                const roleTag = document.createElement("span");
                roleTag.className = "group-role-tag admin";
                roleTag.textContent = "Administrator";
                tagsContainer.appendChild(roleTag);
              }

              if (member && member.groupTitle) {
                const titleTag = document.createElement("span");
                titleTag.className = "group-title-tag";
                titleTag.textContent = member.groupTitle;
                tagsContainer.appendChild(titleTag);
              }
            }

            const senderNameSpan = document.createElement("span");
            senderNameSpan.className = "sender-name";
            senderNameSpan.textContent = senderDisplayName;

            // ‰øÆÂ§çÁî®Êà∑Ê†áÁ≠æÊòæÁ§∫Âú®Âè≥ËæπÁöÑÈóÆÈ¢ò
            if (isUser) {
              senderLine.appendChild(tagsContainer); // Ê†áÁ≠æÂú®Â∑¶
              senderLine.appendChild(senderNameSpan); // ÊòµÁß∞Âú®Âè≥
            } else {
              senderLine.appendChild(senderNameSpan); // ÊòµÁß∞Âú®Â∑¶
              senderLine.appendChild(tagsContainer); // Ê†áÁ≠æÂú®Âè≥
            }

            wrapper.appendChild(senderLine);
          }

          const bubble = document.createElement("div");
          bubble.className = `message-bubble ${isUser ? "user" : "ai"}`;
          bubble.dataset.timestamp = msg.timestamp;

          const timestampEl = document.createElement("span");
          timestampEl.className = "timestamp";
          timestampEl.textContent = formatTimestamp(msg.timestamp);

          // ÊâæÂà∞Á°ÆÂÆö avatarSrc ÁöÑÈÇ£ÊÆµ‰ª£Á†Å
          let avatarSrc,
            avatarFrameSrc = ""; // <--- Â£∞Êòé‰∏§‰∏™ÂèòÈáè
          if (chat.isGroup) {
            if (isUser) {
              avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
              avatarFrameSrc = chat.settings.myAvatarFrame || ""; // <--- Ëé∑Âèñ‚ÄúÊàë‚ÄùÁöÑÂ§¥ÂÉèÊ°Ü
            } else {
              const member = chat.members.find(
                (m) => m.originalName === msg.senderName,
              );
              avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
              avatarFrameSrc = member ? member.avatarFrame || "" : ""; // <--- Ëé∑ÂèñÊàêÂëòÁöÑÂ§¥ÂÉèÊ°Ü
            }
          } else {
            if (isUser) {
              avatarSrc = chat.settings.myAvatar || defaultAvatar;
              avatarFrameSrc = chat.settings.myAvatarFrame || ""; // <--- Ëé∑Âèñ‚ÄúÊàë‚ÄùÁöÑÂ§¥ÂÉèÊ°Ü
            } else {
              avatarSrc = chat.settings.aiAvatar || defaultAvatar;
              avatarFrameSrc = chat.settings.aiAvatarFrame || ""; // <--- Ëé∑ÂèñAIÁöÑÂ§¥ÂÉèÊ°Ü
            }
          }

          let avatarHtml;
          // Â¶ÇÊûúÂ≠òÂú®Â§¥ÂÉèÊ°ÜURL
          if (avatarFrameSrc) {
            avatarHtml = `
			            <div class="avatar-with-frame">
			                <img src="${avatarSrc}" class="avatar-img">
			                <img src="${avatarFrameSrc}" class="avatar-frame">
			            </div>
			        `;
          } else {
            // Â¶ÇÊûúÊ≤°ÊúâÔºåÂ∞±‰ΩøÁî®ÊúÄÁÆÄÂçïÁöÑÂ§¥ÂÉèÁªìÊûÑ
            avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
          }

          let contentHtml;

          if (msg.type === "share_link") {
            bubble.classList.add("is-link-share");

            // onclick="openBrowser(...)" ÁßªÈô§ÔºåÊàë‰ª¨Â∞ÜÂú®JS‰∏≠Âä®ÊÄÅÁªëÂÆö‰∫ã‰ª∂
            contentHtml = `
			            <div class="link-share-card" data-timestamp="${msg.timestamp}">
			                <div class="title">${msg.title || "Untitled"}</div>
			                <div class="description">${msg.description || "Click to view details..."}</div>
			                <div class="footer">
			                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
			                    <span>${msg.source_name || "Link Share"}</span>
			                </div>
			            </div>
			        `;
          }
          // ... ÂÖ∂‰ªñ case ...
          else if (msg.type === "dating_summary_card") {
            bubble.classList.add("is-dating-summary");
            const payload = msg.payload;
            let cardClass = "";

            if (payload.ratingType === "romantic") {
              cardClass = "romantic";
            } else if (payload.ratingType === "passionate") {
              cardClass = "passionate";
            } else if (payload.ratingType === "perfect") {
              cardClass = "perfect";
            }

            // ‰∏çÂÜçÂ≠òÂÇ®Â§çÊùÇÁöÑJSONÂ≠óÁ¨¶‰∏≤
            contentHtml = `
			        <div class="dating-summary-chat-card ${cardClass}" data-timestamp="${msg.timestamp}">
			            <div class="rating">${payload.rating}</div>
			            <div class="tip">ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖ</div>
			        </div>
			    `;
          } else if (msg.type === "share_card") {
            bubble.classList.add("is-link-share"); // Â§çÁî®ÈìæÊé•ÂàÜ‰∫´ÁöÑÂç°ÁâáÊ†∑Âºè
            // ÊääÊó∂Èó¥Êà≥Âä†Âà∞Âç°Áâá‰∏äÔºåÊñπ‰æøÂêéÈù¢ÁÇπÂáªÊó∂ËØÜÂà´
            contentHtml = `
			        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
			            <div class="title">${msg.payload.title}</div>
			            <div class="description">ÂÖ± ${msg.payload.sharedHistory.length} Êù°Ê∂àÊÅØ</div>
			            <div class="footer">
			                <svg class="footer-icon" ...>...</svg> <!-- Â§çÁî®ÈìæÊé•ÂàÜ‰∫´ÁöÑÂõæÊ†á -->
			                <span>Chat History</span>
			            </div>
			        </div>
			    `;
          } else if (msg.type === "eleme_order_notification") {
            bubble.classList.add("is-gift-notification");
            const payload = msg.payload;

            let remarkHtml = "";
            if (payload.remark && payload.remark.trim()) {
              remarkHtml = `
			            <div class="waimai-remark">
			                <span class="remark-label">Remark:</span>
			                <span class="remark-text">${payload.remark}</span>
			            </div>
			        `;
            }

            // 1. We removed the blue gradient style written in HTML.
            // 2. Changed the card class from "gift-card" to "waimai-meituan-card" for custom styling.
            // 3. Changed the icon from noodles üçú to a delivery scooter üõµ, more fitting the theme.
            contentHtml = `
			        <div class="waimai-meituan-card">
			            <div class="gift-card-header">
			                <div class="icon">üõµ</div>
			                <div class="title">A delivery from ${payload.senderName}</div>
			            </div>
			            <div class="gift-card-body">
			                <img src="${payload.foodImageUrl}" style="width: 100%; max-height: 120px; object-fit: cover; border-radius: 8px; margin-bottom: 10px;">
			                <p class="greeting" style="font-weight: bold; font-size: 16px;">${payload.foodName}</p>
			                <p style="font-size: 13px; color: #888;">Your exclusive delivery has arrived</p>
			                ${remarkHtml}
			            </div>
			        </div>
			    `;
          } else if (msg.type === "borrow_money_request") {
            bubble.classList.add("is-borrow-request"); // Apply transparent bubble style
            const payload = msg.payload;
            // Directly assign the card's HTML to contentHtml, no longer concatenating any text
            contentHtml = `
			        <div class="borrow-card">
			            <div class="borrow-header">
			                Borrow from <span>${payload.lenderName}</span>
			            </div>
			            <div class="borrow-body">
			                <p class="label">Amount</p>
			                <p class="amount">¬•${payload.amount.toFixed(2)}</p>
			                <p class="reason">
			                    <strong>Purpose:</strong><br>
			                    ${payload.reason}
			                </p>
			            </div>
			        </div>
			    `;
          } else if (msg.type === "repost_forum_post") {
            bubble.classList.add("is-link-share"); // Reuse link share style for convenience
            const postPayload = msg.payload;
            // Store the post ID in the card's data-post-id attribute for easy navigation later
            contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-post-id="${postPayload.postId}">
            <div class="title">„ÄêÂ∞èÁªÑÂ∏ñÂ≠ê„Äë${postPayload.title}</div>
            <div class="description">${postPayload.content}</div>
            <div class="footer">
                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 12c0-5.25-4.25-9.5-9.5-9.5S2.5 6.75 2.5 12s4.25 9.5 9.5 9.5c.35 0 .69-.02 1.03-.06"></path><path d="M18.5 12.5c0-1.66-1.34-3-3-3s-3 1.34-3 3 1.34 3 3 3c.83 0 1.58-.34 2.12-.88"></path></svg>
                <span>From Group Share</span>
            </div>
        </div>
      `;
          } else if (msg.type === "series_share") {
            bubble.classList.add("is-book-share");
            const payload = msg.payload || {};
            const titleText =
              payload.seriesTitle ||
              (msg.content &&
                msg.content.split("\n")[0].replace("„ÄêSerialized Sharing„Äë", "")) ||
              "Serialized";
            const desc = payload.summary || "Serialized Sharing";
            const latest = payload.latestChapterIndex
              ? `Chapter ${payload.latestChapterIndex} ${payload.latestTitle || ""}`
              : "Latest Chapter";
            const meta = `${payload.pairing || ""} ¬∑ ${payload.statusText || ""} ¬∑ ${payload.chapterCount || "?"} Chapters`;
            contentHtml = `
        <div class="book-share-card" style="cursor: pointer;" data-post-id="${payload.latestPostId || ""}">
          <div class="book-spine"></div>
          <div class="book-body">
            <div class="book-tag">Serialized</div>
            <div class="book-title">${titleText}</div>
            <div class="book-meta">${meta}</div>
            <div class="book-desc">${desc}</div>
            <div class="book-latest">Latest: ${latest}</div>
          </div>
        </div>
      `;
          } else if (msg.type === "kk_item_share") {
            bubble.classList.add("is-link-share"); // Reuse transparent background style (if defined), or omit this line to keep bubble background
            // If you don't have is-link-share style, you can ignore the previous line, or set bubble.style.background = 'transparent';
            bubble.style.background = "transparent";
            bubble.style.padding = "0";

            const payload = msg.payload;

            contentHtml = `
                <div class="kk-share-card">
                    <div class="header">
                        <span class="icon">üîç</span>
                        <span>Êü•Â≤óÁ∫øÁ¥¢Ôºö${payload.itemName}</span>
                    </div>
                    <div class="content">${payload.content}</div>
                    <div class="footer">
                        Source: ${payload.areaName}
                    </div>
                </div>
            `;
          } else if (msg.type === "cart_share_request") {
            bubble.classList.add("is-cart-share-request");
            const payload = msg.payload;
            let statusText = "Waiting for the other party to process...";
            let cardClass = "";

            if (payload.status === "paid") {
              statusText = "The other party has paid for you";
              cardClass = "paid";
            } else if (payload.status === "rejected") {
              statusText = "The other party has rejected your request";
              cardClass = "rejected";
            }

            contentHtml = `
			        <div class="cart-share-card ${cardClass}">
			            <div class="cart-share-header">
			                <div class="icon">üõí</div>
			                <div class="title">Cart Share Request</div>
			            </div>
			            <div class="cart-share-body">
			                <div class="label">There are a total of ${payload.itemCount} items, totaling [amount missing].</div>
			                <div class="amount">¬•${payload.totalPrice.toFixed(2)}</div>
			                <div class="status-text">${statusText}</div>
			            </div>
			        </div>
			    `;
          } else if (msg.type === "waimai_order_for_char") {
            // User ordered food FOR the character (reverse of waimai_request)
            bubble.classList.add("is-gift-notification");

            const orderQtyText = (msg.quantity && msg.quantity > 1)
              ? ` <span class="waimai-qty-badge">√ó${msg.quantity}</span>` : "";
            const orderNoteHtml = msg.note
              ? `<div class="waimai-remark">
                   <span class="remark-label">Note:</span>
                   <span class="remark-text">${msg.note}</span>
                 </div>` : "";

            contentHtml = `
                <div class="waimai-meituan-card waimai-order-for-char-card">
                    <div class="gift-card-header">
                        <div class="icon">üõµ</div>
                        <div class="title">You ordered for ${chat.name}</div>
                    </div>
                    <div class="gift-card-body">
                        <p class="greeting" style="font-weight:bold;font-size:16px;">
                            ${msg.productInfo}${orderQtyText}
                        </p>
                        <p style="font-size:13px;color:#888;">
                            Amount: ¬•${Number(msg.amount).toFixed(2)}
                        </p>
                        ${orderNoteHtml}
                    </div>
                </div>`;

          } else if (msg.type === "waimai_gift_from_char") {
            bubble.classList.add("is-gift-notification");
            const payload = msg.payload;

            contentHtml = `
			        <div class="waimai-meituan-card">
			            <div class="gift-card-header">
			                <div class="icon">üõµ</div>
			                <div class="title">Your exclusive delivery has arrived</div>
			            </div>
			            <div class="gift-card-body">
			                <img src="${payload.foodImageUrl}" style="width: 100%; height: 120px; object-fit: cover; border-radius: 8px; margin-bottom: 10px;">
			                <p class="greeting" style="font-weight: bold; font-size: 16px;">${payload.foodName}</p>
			                <p style="font-size: 13px; color: #888;">From: ${payload.restaurant}</p>
			            </div>
			            <div class="waimai-remark">
			                ${payload.greeting}
			            </div>
			        </div>
			    `;
          } else if (msg.type === "gift_notification") {
            bubble.classList.add("is-gift-notification"); // Apply transparent bubble style
            const payload = msg.payload;

            // Build the complete HTML content for the card
            contentHtml = `
			        <div class="gift-card">
			            <div class="gift-card-header">
			                <div class="icon">üéÅ</div>
			                <!-- 1. Clearly indicate who sent the gift -->
			                <div class="title">A gift from ${payload.senderName}</div>
			            </div>
			            <div class="gift-card-body">
			                <p class="greeting">This is a gift I picked out for you, hope you like it!</p>
			                <!-- 2. Clearly list the items -->
			                <div class="gift-card-items">
			                    <strong>Item List:</strong><br>
			                    ${payload.itemSummary.replace(/„ÄÅ/g, "<br>")} <!-- Replace commas with line breaks for clarity -->
			                </div>
			                <!-- 3. Clearly indicate the total amount -->
			                <div class="gift-card-footer">
			                    Total ${payload.itemCount} items, totaling: <span class="total-price">¬•${payload.totalPrice.toFixed(2)}</span>
			                </div>
			            </div>
			        </div>
			    `;
          } else if (msg.type === "location") {
            bubble.classList.add("is-location");

            const currentChat =
              state.chats[state.activeChatId] ||
              Object.values(state.chats).find((c) =>
                c.history.some((h) => h.timestamp === msg.timestamp),
              );
            const myNickname = currentChat.settings.myNickname || "Me";
            const aiNickname = currentChat.name;

            // --- SVG Âä®ÊÄÅÁîüÊàê ---
            const trajectoryPoints = msg.trajectoryPoints || [];
            const hasTrajectory = trajectoryPoints.length > 0;

            // 1. ÂÆö‰πâSVGË∑ØÂæÑÂíåÂùêÊ†á
            const pathData = "M 20 45 Q 115 10 210 45"; // ‰∏ÄÊù°È¢ÑËÆæÁöÑ‰ºòÁæéÊõ≤Á∫ø
            const startPoint = { x: 20, y: 45 };
            const endPoint = { x: 210, y: 45 };

            // 2. ÁîüÊàêËµ∑ÁÇπÂíåÁªàÁÇπÁöÑSVGÂÖÉÁ¥†
            let pinsSvg = "";
            if (msg.userLocation) {
              pinsSvg += `<circle class="svg-pin user-pin" cx="${startPoint.x}" cy="${startPoint.y}" r="6" />`;
            }
            if (msg.aiLocation) {
              pinsSvg += `<circle class="svg-pin ai-pin" cx="${endPoint.x}" cy="${endPoint.y}" r="6" />`;
            }

            // 3. Â¶ÇÊûúÊúâËΩ®ËøπÔºåÁîüÊàêÈÄîÁªèÁÇπÁöÑSVGÂÖÉÁ¥†
            let trajectorySvg = "";

            if (hasTrajectory) {
              // --- ‰ΩøÁî®ÊµèËßàÂô®APIÁ≤æÁ°ÆËÆ°ÁÆóÂùêÊ†á ---

              // 1. ÂÆö‰πâÊàë‰ª¨ÁöÑSÂΩ¢Êõ≤Á∫øË∑ØÂæÑÊï∞ÊçÆ (‰∏çÂèò)
              const s_curve_pathData = "M 20 45 C 80 70, 150 20, 210 45";
              trajectorySvg += `<path class="svg-trajectory-path" d="${s_curve_pathData}" />`;

              // 2. Âú®ÂÜÖÂ≠ò‰∏≠ÂàõÂª∫‰∏Ä‰∏™ÁúüÂÆûÁöÑSVGË∑ØÂæÑÂÖÉÁ¥†Ôºå‰ª•‰æø‰ΩøÁî®API
              const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path",
              );
              path.setAttribute("d", s_curve_pathData);

              // 3. Ëé∑ÂèñËøôÊù°Ë∑ØÂæÑÁöÑÊÄªÈïøÂ∫¶
              const totalPathLength = path.getTotalLength();

              const totalPoints = trajectoryPoints.length;
              trajectoryPoints.forEach((point, index) => {
                // 4. ËÆ°ÁÆóÊØè‰∏™ÁÇπÂ∫îËØ•Âú®Ë∑ØÂæÑÊÄªÈïøÂ∫¶ÁöÑÂì™‰∏™‰ΩçÁΩÆ
                const progress = (index + 1) / (totalPoints + 1);
                const lengthOnPath = totalPathLength * progress;

                // 5. Áõ¥Êé•ÂêëÊµèËßàÂô®Êü•ËØ¢Ëøô‰∏™‰ΩçÁΩÆÁöÑÁ≤æÁ°ÆÂùêÊ†á
                const pointOnPath = path.getPointAtLength(lengthOnPath);
                const pointX = pointOnPath.x;
                const pointY = pointOnPath.y;

                // 6. ÂêéÁª≠ÁöÑ‚Äú‰∏Ä‰∏ä‰∏Ä‰∏ã‚ÄùÂ∏ÉÂ±ÄÈÄªËæë‰øùÊåÅ‰∏çÂèò
                let yOffset;
                if (index % 2 === 0) {
                  // Á¨¨1, 3...‰∏™ÁÇπ
                  yOffset = 18; // Âêë‰∏ã
                } else {
                  // Á¨¨2, 4...‰∏™ÁÇπ
                  yOffset = -10; // Âêë‰∏ä
                }

                const footprintY = pointY + yOffset;
                const labelY = footprintY + (yOffset > 0 ? 12 : -12);

                // 7. ‰ΩøÁî®100%Á≤æÁ°ÆÁöÑÂùêÊ†áÁîüÊàêSVG
                trajectorySvg += `
			            <text class="svg-footprint" x="${pointX}" y="${footprintY}" text-anchor="middle">üêæ</text>
			            <text class="svg-location-label" x="${pointX}" y="${labelY}" text-anchor="middle">${point.name}</text>
			        `;
              });
            }

            // 4. ÊûÑÂª∫Âú∞ÁÇπ‰ø°ÊÅØHTML
            const userLocationHtml = `<p class="${
              !msg.userLocation ? "hidden" : ""
            }"><span class="name-tag">${myNickname}:</span> ${msg.userLocation}</p>`;
            const aiLocationHtml = `<p class="${
              !msg.aiLocation ? "hidden" : ""
            }"><span class="name-tag">${aiNickname}:</span> ${msg.aiLocation}</p>`;

            // 5. ÊãºÊé•ÊúÄÁªàÁöÑ contentHtml
            contentHtml = `
			        <div class="location-card">
			            <div class="location-map-area">
			                <svg viewBox="0 0 230 90">
			                    ${trajectorySvg}
			                    ${pinsSvg}
			                </svg>
			            </div>
			            <div class="location-info">
			                <div class="location-address">
			                    ${aiLocationHtml}
			                    ${userLocationHtml}
			                </div>
			                <div class="location-distance">Áõ∏Ë∑ù ${msg.distance}</div>
			            </div>
			        </div>
			    `;
          }

          // ÂêéÁª≠ÁöÑÂÖ∂‰ªñ else if ‰øùÊåÅ‰∏çÂèò
          else if (msg.type === "user_photo" || msg.type === "ai_image") {
            bubble.classList.add("is-ai-image");
            const altText =
              msg.type === "user_photo" ? "The photograph described by the user" : "AI-generated image";
            contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
          } else if (msg.type === "voice_message") {
            bubble.classList.add("is-voice-message");

            // Store the original voice text in the parent bubble's data-* attribute for easy access by event handlers
            bubble.dataset.voiceText = msg.content;

            const duration = Math.max(
              1,
              Math.round((msg.content || "").length / 5),
            );
            const durationFormatted = `0:${String(duration).padStart(2, "0")}''`;
            const waveformHTML =
              "<div></div><div></div><div></div><div></div><div></div>";

            // Construct the complete HTML containing all new elements
            contentHtml = `
			        <div class="voice-message-body">
			            <div class="voice-waveform">${waveformHTML}</div>
			            <div class="loading-spinner"></div>
			            <span class="voice-duration">${durationFormatted}</span>
			        </div>
			        <div class="voice-transcript"></div>
			    `;
          } else if (msg.type === "transfer") {
            bubble.classList.add("is-transfer");

            let titleText, noteText;
            const myNickname = chat.isGroup
              ? chat.settings.myNickname || "Me"
              : "Me";

            if (isUser) {
              // The message is sent by the user
              if (msg.isRefund) {
                // Refund sent by the user (i.e., the user rejected the AI's transfer)
                titleText = `Refund to ${chat.name}`;
                noteText = "The transfer has been rejected by the other party";
              } else {
                // User-initiated transfer
                titleText = `Transfer to ${msg.receiverName || chat.name}`;
                if (msg.status === "accepted") {
                  noteText = "The transfer has been accepted by the other party";
                } else if (msg.status === "declined") {
                  noteText = "The transfer has been declined by the other party";
                } else {
                  noteText = msg.note || "Waiting for the other party to process...";
                }
              }
            } else {
              // The message is sent by the AI
              if (msg.isRefund) {
                // AI ÁöÑÈÄÄÊ¨æÔºàAI ÊãíÊî∂‰∫ÜÁî®Êà∑ÁöÑËΩ¨Ë¥¶Ôºâ
                titleText = `Refund from ${msg.senderName}`;
                noteText = "The transfer has been rejected";
              } else if (msg.receiverName === myNickname) {
                // AI ‰∏ªÂä®ÁªôÁî®Êà∑ÁöÑËΩ¨Ë¥¶
                titleText = `Transfer to ${myNickname}`;
                if (msg.status === "accepted") {
                  noteText = "You have received the payment";
                } else if (msg.status === "declined") {
                  noteText = "You have declined the payment";
                } else {
                  // User needs to process the transfer
                  bubble.style.cursor = "pointer";
                  bubble.dataset.status = "pending";
                  noteText = msg.note || "Click to process";
                }
              } else {
                // AI sent a transfer to other members in the group, which is just a notification for the current user
                titleText = `Transfer: ${msg.senderName} ‚Üí ${msg.receiverName}`;
                noteText = msg.note || "Group chat transfer";
              }
            }

            const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;

            contentHtml = `
			        <div class="transfer-card">
			            <div class="transfer-title">${heartIcon} ${titleText}</div>
			            <div class="transfer-amount">¬• ${Number(msg.amount).toFixed(2)}</div>
			            <div class="transfer-note">${noteText}</div>
			        </div>
			    `;
          } else if (msg.type === "waimai_request") {
            bubble.classList.add("is-waimai-request");
            if (msg.status === "paid" || msg.status === "rejected") {
              bubble.classList.add(`status-${msg.status}`);
            }
            let displayName;
            // If it's a group chat
            if (chat.isGroup) {
              // Execute the original logic: find the nickname in the member list
              const member = chat.members.find(
                (m) => m.originalName === msg.senderName,
              );
              displayName = member ? member.groupNickname : msg.senderName;
            } else {
              // Otherwise (it's a one-on-one chat), use the chat object's name directly
              displayName = chat.name;
            }

            const requestTitle = `Request from ${displayName}`;
            let actionButtonsHtml = "";
            if (msg.status === "pending" && !isUser) {
              actionButtonsHtml = `
			                <div class="waimai-user-actions">
			                    <button class="waimai-decline-btn" data-choice="rejected">Decline</button>
			                    <button class="waimai-pay-btn" data-choice="paid">Pay for them</button>
			                </div>`;
            }
            // Show quantity badge if more than 1
            const qtyBadge = (msg.quantity && msg.quantity > 1)
              ? `<span class="waimai-qty-badge">√ó${msg.quantity}</span>`
              : "";

            contentHtml = `
			            <div class="waimai-card">
			                <div class="waimai-header">
			                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
			                    <div class="title-group">
			                        <span class="brand">Meituan Waimai</span><span class="separator">|</span><span>Food Delivery</span>
			                    </div>
			                </div>
			                <div class="waimai-catchphrase">Hi, you're just one meal away from meÔΩû</div>
			                <div class="waimai-main">
			                    <div class="request-title">${requestTitle} ${qtyBadge}</div>
			                    <div class="payment-box">
			                        <div class="payment-label">Amount Due</div>
			                        <div class="amount">¬•${Number(msg.amount).toFixed(2)}</div>
			                        <div class="countdown-label">Time Remaining
			                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
			                        </div>
			                    </div>
			                    <button class="waimai-details-btn">View Details</button>
			                </div>
			                ${actionButtonsHtml}
			            </div>`;

            setTimeout(() => {
              const timerEl = document.getElementById(
                `waimai-timer-${msg.timestamp}`,
              );
              if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp])
                  clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === "pending") {
                  waimaiTimers[msg.timestamp] = startWaimaiCountdown(
                    timerEl,
                    msg.countdownEndTime,
                  );
                } else {
                timerEl.textContent = "Processed";
                }
              }
              const detailsBtn = document.querySelector(
                `.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`,
              );
              if (detailsBtn) {
                detailsBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  const paidByText = msg.paidBy
                    ? `<br><br><b>Status:</b> Paid by ${msg.paidBy}`
                    : "";
                  const qtyLine = (msg.quantity && msg.quantity > 1)
                    ? `<br><b>Quantity:</b> ${msg.quantity}` : "";
                  showCustomAlert(
                    "Order Details",
                    `<b>Product:</b> ${msg.productInfo}${qtyLine}<br><b>Amount:</b> ¬•${Number(msg.amount).toFixed(2)}${paidByText}`,
                  );
                });
              }
              const actionButtons = document.querySelectorAll(
                `.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`,
              );
              actionButtons.forEach((btn) => {
                btn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  const choice = e.target.dataset.choice;
                  handleWaimaiResponse(msg.timestamp, choice);
                });
              });
            }, 0);
          } else if (msg.type === "red_packet") {
            bubble.classList.add("is-red-packet");
            const myNickname = chat.settings.myNickname || "Me";

            // ‰ªéÊúÄÊñ∞ÁöÑ msg ÂØπË±°‰∏≠Ëé∑ÂèñÁä∂ÊÄÅ
            const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
            const isFinished = msg.isFullyClaimed;

            let cardClass = "";
            let claimedInfoHtml = "";
            let typeText = "Lucky Red Packet";

            // 1. Âà§Êñ≠Á∫¢ÂåÖÂç°ÁâáÁöÑÊ†∑Âºè (È¢úËâ≤)
            if (isFinished) {
              cardClass = "opened";
            } else if (
              msg.packetType === "direct" &&
              Object.keys(msg.claimedBy || {}).length > 0
            ) {
              cardClass = "opened"; // ‰∏ìÂ±ûÁ∫¢ÂåÖË¢´È¢Ü‰∫Ü‰πüÂèòÁÅ∞
            }

            // 2. Âà§Êñ≠Á∫¢ÂåÖ‰∏ãÊñπÁöÑÊèêÁ§∫ÊñáÂ≠ó
            if (msg.packetType === "direct") {
              typeText = `Exclusive Red Packet: For ${msg.receiverName}`;
            }

            if (hasClaimed) {
              claimedInfoHtml = `<div class="rp-claimed-info">You have claimed the red packet, amount ${msg.claimedBy[
                myNickname
              ].toFixed(2)} ¬•</div>`;
            } else if (isFinished) {
              claimedInfoHtml = `<div class="rp-claimed-info">The red packet has been fully claimed</div>`;
            } else if (
              msg.packetType === "direct" &&
              Object.keys(msg.claimedBy || {}).length > 0
            ) {
              claimedInfoHtml = `<div class="rp-claimed-info">Already claimed by ${msg.receiverName}</div>`;
            }

            // 3. ÊãºÊé•ÊúÄÁªàÁöÑHTMLÔºåÁ°Æ‰øùonclickË∞ÉÁî®ÁöÑÊòØÊàë‰ª¨Ê≥®ÂÜåÂà∞ÂÖ®Â±ÄÁöÑÂáΩÊï∞
            contentHtml = `
			        <div class="red-packet-card ${cardClass}">
			            <div class="rp-header">
			                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
			                <span class="rp-greeting">${msg.greeting || "Wishing you prosperity and great fortune!"}</span>
			            </div>
			            <div class="rp-type">${typeText}</div>
			            ${claimedInfoHtml}
			        </div>
			    `;
          } else if (msg.type === "ls_diary_notification") {
            bubble.classList.add("is-ls-diary-notification"); // Â∫îÁî®ÈÄèÊòéÊ∞îÊ≥°Ê†∑Âºè
            const cardData = msg.content;

            contentHtml = `
			        <div class="ls-diary-notification-card" onclick="openLoversSpaceFromCard('${chat.id}', 'ls-diary-view')">
			            <div class="ls-diary-card-header">
			                <span>${cardData.userEmoji || "üíå"}</span>
			                <span>‰∏ÄÂ∞ÅÊù•Ëá™ÂøÉÊÉÖÊó•ËÆ∞ÁöÑÊèêÈÜí</span>
			            </div>
			            <div class="ls-diary-card-body">
			                <p>${cardData.text}</p>
			            </div>
			            <div class="ls-diary-card-footer">
			                ÁÇπÂáªÊü•Áúã ‚Üí
			            </div>
			        </div>
			    `;
          } else if (msg.type === "lovers_space_invitation") {
            bubble.classList.add("is-waimai-request"); // Â§çÁî®Â§ñÂçñÂç°ÁâáÁöÑÊ†∑ÂºèÔºåÂæàÊñπ‰æøÔºÅ
            const isUserSender = msg.role === "user";
            const senderName = isUserSender
              ? chat.settings.myNickname || "Me"
              : chat.name;
            const receiverName = isUserSender
              ? chat.name
              : chat.settings.myNickname || "Me";

            let cardContent = "";

            switch (msg.status) {
              case "pending":
                if (isUserSender) {
                  // Áî®Êà∑ÂèëÂá∫ÁöÑÔºåÁ≠âÂæÖÂØπÊñπÂõûÂ∫î
                  cardContent = `
			                        <div class="waimai-main" style="background-color: #f0f8ff;">
			                            <div class="request-title" style="color: #333;">Â∑≤Âêë ${receiverName} ÂèëÂá∫ÈÇÄËØ∑</div>
			                            <p style="font-size:14px; color:#555; margin:15px 0;">Á≠âÂæÖÂØπÊñπÂêåÊÑè...</p>
			                        </div>`;
                } else {
                  // Áî®Êà∑Êî∂Âà∞ÁöÑÔºåÈúÄË¶ÅÁî®Êà∑ÂõûÂ∫î
                  cardContent = `
			                        <div class="waimai-main" style="background-color: #fff0f5;">
			                            <div class="request-title" style="color: #d63384;">${senderName} ÈÇÄËØ∑‰Ω†ÂºÄÂêØÊÉÖ‰æ£Á©∫Èó¥</div>
			                            <p style="font-size:14px; color:#555; margin:15px 0;">ÂºÄÂêØÂêéÂèØ‰ª•ËÆ∞ÂΩï‰Ω†‰ª¨ÁöÑ‰∏ìÂ±ûÂõûÂøÜÂì¶~</p>
			                        </div>
			                        <div class="waimai-user-actions">
			                            <button class="waimai-decline-btn" data-choice="rejected">ÊÆãÂøçÊãíÁªù</button>
			                            <button class="waimai-pay-btn" data-choice="accepted" style="background-color: #d63384; border-color: #b02a6e;">Á´ãÂç≥ÂºÄÂêØ</button>
			                        </div>`;
                }
                break;
              case "accepted":
                cardContent = `
			                    <div class="waimai-main" style="background-color: #e6ffed;">
			                        <div class="request-title" style="color: #198754;">‚úÖ ÈÇÄËØ∑Â∑≤ÂêåÊÑè</div>
			                        <p style="font-size:14px; color:#555; margin:15px 0;">‰Ω†‰ª¨ÁöÑÊÉÖ‰æ£Á©∫Èó¥Â∑≤ÊàêÂäüÂºÄÂêØÔºÅ</p>
			                    </div>`;
                break;
              case "rejected":
                cardContent = `
			                    <div class="waimai-main" style="background-color: #f8d7da;">
			                        <div class="request-title" style="color: #842029;">‚ùå ÈÇÄËØ∑Ë¢´ÊãíÁªù</div>
			                    </div>`;
                break;
            }

            contentHtml = `
			            <div class="waimai-card">
			                <div class="waimai-header">
			                    <span class="icon" style="font-size: 20px;">üíå</span>
			                    <div class="title-group"><span class="brand">ÊÉÖ‰æ£Á©∫Èó¥ÈÇÄËØ∑</span></div>
			                </div>
			                ${cardContent}
			            </div>`;
          } else if (msg.type === "poll") {
            bubble.classList.add("is-poll");

            let totalVotes = 0;
            const voteCounts = {};

            // ËÆ°ÁÆóÊÄªÁ•®Êï∞ÂíåÊØè‰∏™ÈÄâÈ°πÁöÑÁ•®Êï∞
            for (const option in msg.votes) {
              const count = msg.votes[option].length;
              voteCounts[option] = count;
              totalVotes += count;
            }

            const myNickname = chat.isGroup
              ? chat.settings.myNickname || "Me"
              : "Me";
            let myVote = null;
            for (const option in msg.votes) {
              if (msg.votes[option].includes(myNickname)) {
                myVote = option;
                break;
              }
            }

            let optionsHtml = '<div class="poll-options-list">';
            msg.options.forEach((optionText) => {
              const count = voteCounts[optionText] || 0;
              const percentage =
                totalVotes > 0 ? (count / totalVotes) * 100 : 0;
              const isVotedByMe = myVote === optionText;

              optionsHtml += `
			            <div class="poll-option-item ${isVotedByMe ? "voted" : ""}" data-option="${optionText}">
			                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
			                <div class="poll-option-content">
			                    <span class="poll-option-text">${optionText}</span>
			                    <span class="poll-option-votes">${count} Á•®</span>
			                </div>
			            </div>
			        `;
            });
            optionsHtml += "</div>";

            let footerHtml = "";
            // Áªü‰∏ÄÊåâÈíÆÁöÑÊòæÁ§∫ÈÄªËæë
            if (msg.isClosed) {
              // Â¶ÇÊûúÊäïÁ•®Â∑≤ÁªìÊùüÔºåÊÄªÊòØÊòæÁ§∫‚ÄúÊü•ÁúãÁªìÊûú‚Äù
              footerHtml = `<div class="poll-footer"><span class="poll-total-votes">A total of ${totalVotes} individuals participated in the voting.</span><button class="poll-action-btn">View Results</button></div>`;
            } else {
              // Â¶ÇÊûúÊäïÁ•®Êú™ÁªìÊùüÔºåÊÄªÊòØÊòæÁ§∫‚ÄúÁªìÊùüÊäïÁ•®‚Äù
              footerHtml = `<div class="poll-footer"><span class="poll-total-votes">A total of ${totalVotes} individuals participated in the voting.</span><button class="poll-action-btn">End Voting</button></div>`;
            }

            contentHtml = `
			        <div class="poll-card ${msg.isClosed ? "closed" : ""}" data-poll-timestamp="${msg.timestamp}">
			            <div class="poll-question">${msg.question}</div>
			            ${optionsHtml}
			            ${footerHtml}
			        </div>
			    `;
          } else if (msg.type === "tarot_reading") {
            bubble.classList.add("is-tarot-reading");
            const reading = msg.payload;
            let cardsText = reading.cards
              .map((card) => {
                return `[${card.position}] ${card.name} ${card.isReversed ? "(Reversed)" : ""}`;
              })
              .join("\n");

            contentHtml = `
			        <div class="tarot-reading-card">
			            <div class="tarot-reading-header">
			                <div class="question">${reading.question}</div>
			                <div class="spread">${reading.spread.name}</div>
			            </div>
			            <div class="tarot-reading-body">
			                ${cardsText}
			            </div>
			        </div>
			    `;
          } else if (msg.type === "lovers_space_disconnect") {
            bubble.classList.add("is-ls-disconnect"); // Â∫îÁî®Êàë‰ª¨ÂÜôÁöÑÈÄèÊòéÊ∞îÊ≥°CSS
            contentHtml = `
			        <div class="lovers-space-disconnect-card">
			            <div class="icon">üíî</div>
			            <div class="text-content">
			                <div class="title">Lovers' Space Disconnected</div>
			            </div>
			        </div>
			    `;
          } else if (msg.type === "sticker" && msg.content) {
            bubble.classList.add("is-sticker");
            // Áõ¥Êé•‰ªéÊ∂àÊÅØÂØπË±°‰∏≠Ëé∑Âèñ url Âíå meaning
            contentHtml = `<img src="${msg.content}" alt="${msg.meaning || "Sticker"}" class="sticker-image">`;
          }

          // ÊóßÁöÑÈÄªËæë‰øùÊåÅ‰∏çÂèòÔºå‰Ωú‰∏∫ÂÖºÂÆπ
          else if (
            typeof msg.content === "string" &&
            STICKER_REGEX.test(msg.content.trim())
          ) {
            bubble.classList.add("is-sticker");
            contentHtml = `<img src="${msg.content}" alt="${msg.meaning || "Sticker"}" class="sticker-image">`;
          } else if (
            Array.isArray(msg.content) &&
            msg.content[0]?.type === "image_url"
          ) {
            bubble.classList.add("has-image");
            const imageUrl = msg.content[0].image_url.url;
            contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
          } else if (msg.type === "naiimag") {
            // NovelAIÂõæÁâáÊ∏≤ÊüìÔºàÂ§çÁî®realimagÊ†∑ÂºèÔºâ
            bubble.classList.add("is-realimag", "is-card-like");
            contentHtml = `<img src="${
              msg.imageUrl
            }" class="realimag-image" alt="NovelAI Image Share" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='Image Load Failed';" title="${
              msg.fullPrompt || msg.prompt || "NovelAI Generated"
            }">`;
          } else {
            const rawContent = String(msg.content || "");
            // ‚îÄ‚îÄ Detect char-initiated poke/pat: [POKE] or [PAT] at start ‚îÄ‚îÄ
            const charPokeMatch = !isUser && rawContent.match(/^\[(POKE|PAT)\]\s*\n?/i);
            if (charPokeMatch) {
              const pokeType  = charPokeMatch[1].toLowerCase(); // "poke" or "pat"
              const pokeEmoji = pokeType === "pat" ? "ü§ö" : "üëâ";
              const pokeLabel = pokeType === "pat" ? "patted" : "poked";
              const charDisplayName = chat?.name || "They";
              const cleanText = rawContent.slice(charPokeMatch[0].length).trim();
              contentHtml =
                `<div class="poke-action-bubble inline-char-poke">` +
                  `<span class="poke-emoji">${pokeEmoji}</span>` +
                  `<span class="poke-text">${charDisplayName} ${pokeLabel} you!</span>` +
                  `<span class="poke-emoji">${pokeEmoji}</span>` +
                `</div>` +
                (cleanText
                  ? `<div class="poke-followup-text">${cleanText.replace(/\n/g, "<br>")}</div>`
                  : "");
            } else {
              contentHtml = rawContent.replace(/\n/g, "<br>");
            }
          }

          // 1. Ê£ÄÊü•Ê∂àÊÅØÂØπË±°‰∏≠ÊòØÂê¶Â≠òÂú®ÂºïÁî®‰ø°ÊÅØ (msg.quote)
          let quoteHtml = "";
          // Êó†ËÆ∫ÊòØÁî®Êà∑Ê∂àÊÅØËøòÊòØAIÊ∂àÊÅØÔºåÂè™Ë¶ÅÂÆÉÂåÖÂê´‰∫Ü .quote ÂØπË±°ÔºåÂ∞±ÊâßË°åËøôÊÆµÈÄªËæë
          if (msg.quote) {
            // a. Áõ¥Êé•Ëé∑ÂèñÂÆåÊï¥ÁöÑ„ÄÅÊú™ÁªèÊà™Êñ≠ÁöÑÂºïÁî®ÂÜÖÂÆπ
            const fullQuotedContent = String(msg.quote.content || "");

            // b. ÊûÑÂª∫ÂºïÁî®ÂùóÁöÑHTML
            quoteHtml = `
			        <div class="quoted-message">
			            <div class="quoted-sender">Reply ${msg.quote.senderName}:</div>
			            <div class="quoted-content">${fullQuotedContent}</div>
			        </div>
			    `;
          }

          // 2. ÊãºÊé•ÊúÄÁªàÁöÑÊ∞îÊ≥°ÂÜÖÂÆπ
          //    Â∞ÜÊûÑÂª∫Â•ΩÁöÑ quoteHtml (Â¶ÇÊûúÂ≠òÂú®) Âíå contentHtml ÁªÑÂêàËµ∑Êù•
          // --- Â∞ÜÂ§¥ÂÉèÂíåÂÜÖÂÆπÈÉΩÊîæÂõûÊ∞îÊ≥°ÂÜÖÈÉ® ---
          bubble.innerHTML = `
			        ${avatarHtml}
			        <div class="content">
			            ${quoteHtml}
			            ${contentHtml}
			        </div>
			    `;

          // --- Â∞ÜÂÆåÊï¥ÁöÑ‚ÄúÊ∞îÊ≥°‚ÄùÂíå‚ÄúÊó∂Èó¥Êà≥‚ÄùÊîæÂÖ•ÂÆπÂô® ---
          wrapper.appendChild(bubble);
          wrapper.appendChild(timestampEl);

          addLongPressListener(wrapper, () =>
            showMessageActions(msg.timestamp),
          );
          wrapper.addEventListener("click", () => {
            if (isSelectionMode) toggleMessageSelection(msg.timestamp);
          });

          if (!isUser) {
            const avatarEl = wrapper.querySelector(
              ".avatar, .avatar-with-frame",
            );
            if (avatarEl) {
              avatarEl.style.cursor = "pointer";
              avatarEl.addEventListener("click", (e) => {
                e.stopPropagation();
                const characterName = chat.isGroup ? msg.senderName : chat.name;
                handleUserPat(chat.id, characterName);
              });
            }
          }

          return wrapper;
        }

        function prependMessage(msg, chat) {
          const messagesContainer = document.getElementById("chat-messages");
          const messageEl = createMessageElement(msg, chat);

          if (!messageEl) return; // <--- Êñ∞Â¢ûËøôË°åÔºåÂêåÊ†∑ÁöÑÂ§ÑÁêÜ

          const loadMoreBtn = document.getElementById("load-more-btn");
          if (loadMoreBtn) {
            messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling);
          } else {
            messagesContainer.prepend(messageEl);
          }
        }

        function appendMessage(msg, chat, isInitialLoad = false) {
          const messagesContainer = document.getElementById("chat-messages");
          const messageEl = createMessageElement(msg, chat);

          if (!messageEl) return; // Â¶ÇÊûúÊ∂àÊÅØÊòØÈöêËóèÁöÑÔºåÂàô‰∏çÂ§ÑÁêÜ

          // Âè™ÂØπÊñ∞Ê∂àÊÅØÊ∑ªÂä†Âä®ÁîªÔºå‰∏çÂØπÂàùÂßãÂä†ËΩΩÁöÑÊ∂àÊÅØÊ∑ªÂä†
          if (!isInitialLoad) {
            messageEl.classList.add("animate-in");
          }

          const typingIndicator = document.getElementById("typing-indicator");
          messagesContainer.insertBefore(messageEl, typingIndicator);

          if (!isInitialLoad) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            currentRenderedCount++;
          }
        }

        async function openChat(chatId) {
          state.activeChatId = chatId;
          const chat = state.chats[chatId];
          if (!chat) return; // ÂÆâÂÖ®Ê£ÄÊü•

          // Â∞ÜÊú™ËØªÊï∞Ê∏ÖÈõ∂
          if (chat.unreadCount > 0) {
            chat.unreadCount = 0;
            await db.chats.put(chat); // Âà´Âøò‰∫ÜÊääËøô‰∏™ÊîπÂèòÂêåÊ≠•Âà∞Êï∞ÊçÆÂ∫ì
            // Êàë‰ª¨Á®çÂêé‰ºöÂú®Ê∏≤ÊüìÂàóË°®Êó∂ÈáçÊñ∞Ê∏≤ÊüìÔºåÊâÄ‰ª•ËøôÈáå‰∏çÈúÄË¶ÅÁ´ãÂç≥ÈáçÁªòÂàóË°®
          }
          // Êää openChat ÂáΩÊï∞ÊåÇËΩΩÂà∞ÂÖ®Â±Ä window ÂØπË±°‰∏ä
          window.openChat = openChat;

          renderChatInterface(chatId);
          showScreen("chat-interface-screen");
          window.updateListenTogetherIconProxy(state.activeChatId);
          toggleCallButtons(chat.isGroup || false);
          // „ÄêÂøÉÂ£∞ÂäüËÉΩ„ÄëÊ†πÊçÆÊòØÂê¶‰∏∫ÂçïËÅäÔºåÊòæÁ§∫ÊàñÈöêËóèÂøÉÂΩ¢ÊåâÈíÆ
          document.getElementById("char-heart-btn").style.display = chat.isGroup
            ? "none"
            : "inline-flex";

          if (
            !chat.isGroup &&
            chat.relationship?.status === "pending_ai_approval"
          ) {
            console.log(
              `Ê£ÄÊµãÂà∞Â•ΩÂèãÁî≥ËØ∑ÂæÖÂ§ÑÁêÜÁä∂ÊÄÅÔºå‰∏∫ËßíËâ≤ "${chat.name}" Ëá™Âä®Ëß¶ÂèëAIÂìçÂ∫î...`,
            );
            triggerAiResponse();
          }

          // Ê†πÊçÆÊòØÂê¶‰∏∫Áæ§ËÅäÔºåÊòæÁ§∫ÊàñÈöêËóèÊäïÁ•®ÊåâÈíÆ
          document.getElementById("send-poll-btn").style.display = chat.isGroup
            ? "flex"
            : "none";
          document.getElementById("pet-action-btn").style.display = chat.isGroup
            ? "none"
            : "flex";
          startPetDecayTimer();
        }

        /**
         * Ê†ºÂºèÂåñÂçïÊù°Ê∂àÊÅØÔºåÁî®‰∫éËÆ∞ÂøÜ‰∫íÈÄöÁöÑ‰∏ä‰∏ãÊñá
         * @param {object} msg - Ê∂àÊÅØÂØπË±°
         * @param {object} chat - ËØ•Ê∂àÊÅØÊâÄÂ±ûÁöÑËÅäÂ§©ÂØπË±°
         * @returns {string} - Ê†ºÂºèÂåñÂêéÁöÑÊñáÊú¨Ôºå‰æãÂ¶Ç "Tr∆∞∆°ng Tam: Hello"
         */
        function formatMessageForContext(msg, chat) {
          let senderName = "";
          if (msg.role === "user") {
            senderName = chat.isGroup ? chat.settings.myNickname || "Me" : "Me";
          } else {
            // assistant
            senderName = msg.senderName || chat.name;
          }

          let contentText = "";
          if (
            msg.type === "sticker" ||
            (typeof msg.content === "string" && STICKER_REGEX.test(msg.content))
          ) {
            contentText = msg.meaning ? `[Sticker: ${msg.meaning}]` : "[Sticker]";
          } else if (
            msg.type === "ai_image" ||
            msg.type === "user_photo" ||
            Array.isArray(msg.content)
          ) {
            contentText = "[Image]";
          } else if (msg.type === "voice_message") {
            contentText = `[Voice]: ${msg.content}`;
          } else if (msg.type === "transfer") {
            contentText = `[Transfer] Amount: ${msg.amount}, Note: ${msg.note || "None"}`;
          } else {
            contentText = String(msg.content || "");
          }

          // added by lrq 251029 Âú®ÊØèÊù°Ê∂àÊÅØËÆ∞ÂΩïÂâçÊ∑ªÂä†ÂèëÈÄÅÊó•ÊúüÊó∂Èó¥
          const date = new Date(msg.timestamp);
          const formattedDate = date.toLocaleString(); // Ê†ºÂºèÂåñ‰∏∫Êú¨Âú∞Êó∂Èó¥Â≠óÁ¨¶‰∏≤
          return `${formattedDate} ${senderName}: ${contentText}`;
        }
        window.formatMessageForContext = formatMessageForContext;

        // ===== ADVANCE PLOT & IMPERSONATE USER =====

        /**
         * Advance Plot: g·ªçi AI ti·∫øp t·ª•c c√¢u chuy·ªán kh√¥ng c·∫ßn user reply.
         * ƒê√¢y ch·ªâ l√† alias c·ªßa triggerAiResponse, d√πng cho n√∫t >>.
         */
        async function advancePlot() {
          await triggerAiResponse();
        }

        /**
         * Impersonate User: g·ªçi AI ƒë·ªÉ g·ª£i √Ω l·ªùi tho·∫°i ng∆∞·ªùi d√πng c√≥ th·ªÉ n√≥i ti·∫øp,
         * d·ª±a tr√™n myPersona v√† l·ªãch s·ª≠ h·ªôi tho·∫°i. K·∫øt qu·∫£ ch·ªâ ƒëi·ªÅn v√†o √¥ chat,
         * KH√îNG g·ª≠i ƒëi.
         */
        async function impersonateUser() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          const { proxyUrl, apiKey, model } = state.apiConfig;
          if (!proxyUrl || !apiKey || !model) {
            alert("Vui l√≤ng c·∫•u h√¨nh API tr∆∞·ªõc khi d√πng t√≠nh nƒÉng n√†y.");
            return;
          }

          const chatInput = document.getElementById("chat-input");
          const btn = document.getElementById("impersonate-user-btn");

          // Tr·∫°ng th√°i loading
          btn.disabled = true;
          const originalContent = btn.innerHTML;
          btn.innerHTML = "‚è≥";

          try {
            const myNickname  = chat.settings.myNickname || "User";
            const myPersona   = chat.settings.myPersona  || "(No persona set)";
            const charName    = chat.name || "AI";
            const charPersona = chat.settings.aiPersona  || "";
            const maxMem      = chat.settings.maxMemory  || 20;

            // Impersonate-user specific settings
            const impersonateCfg = chat.settings.impersonateUser || {};
            const wordCount      = impersonateCfg.wordCount || 150;
            const customPrompt   = (impersonateCfg.prompt || "").trim();

            // L·∫•y l·ªãch s·ª≠ g·∫ßn nh·∫•t, b·ªè hidden/summary
            const recentHistory = chat.history
              .filter(m => !m.isHidden && m.type !== "summary" && m.content)
              .slice(-maxMem)
              .map(m => {
                if (m.role === "user")      return `${myNickname}: ${String(m.content).substring(0, 400)}`;
                if (m.role === "assistant") return `${charName}: ${String(m.content).substring(0, 400)}`;
                if (m.type === "narrative") return `[Narrator]: ${String(m.content).substring(0, 300)}`;
                return null;
              })
              .filter(Boolean)
              .join("\n");

            // ‚îÄ‚îÄ Default prompt (third-person narrative style) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const DEFAULT_IMPERSONATE_PROMPT =
`You are a creative writing assistant. Write the next reply for **{{user}}** in the ongoing scene below.

Write in **third person**, narrating {{user}}'s actions, facial expressions, body language, and inner thoughts like a novelist ‚Äî immersive and detailed. You may include brief dialogue if it feels natural.

Aim for approximately **{{wordCount}} words**. Output ONLY {{user}}'s reply ‚Äî no chapter headings, no labels, no meta-commentary.`;

            // ‚îÄ‚îÄ Resolve the prompt (use custom if provided) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const resolvedPrompt = (customPrompt || DEFAULT_IMPERSONATE_PROMPT)
              .replace(/\{\{user\}\}/g,      myNickname)
              .replace(/\{\{char\}\}/g,      charName)
              .replace(/\{\{wordCount\}\}/g, String(wordCount));

            const impersonatePrompt =
`${resolvedPrompt}

---

# ${myNickname}'s Persona
${myPersona}

# ${charName}'s Persona
${charPersona ? charPersona.substring(0, 800) : "(No description)"}

# Recent Conversation
${recentHistory || "(No messages yet)"}

---
Now write {{user}}'s next reply (~{{wordCount}} words, third person narrative).`
              .replace(/\{\{user\}\}/g,      myNickname)
              .replace(/\{\{wordCount\}\}/g, String(wordCount));

            const messagesForApi = [{ role: "user", content: impersonatePrompt }];
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model, apiKey, "", messagesForApi, isGemini);

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${getRandomValue(apiKey)}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.85,
                  }),
                });

            if (!response.ok) {
              const errData = await response.json().catch(() => ({}));
              throw new Error(`API Error ${response.status}: ${errData?.error?.message || response.statusText}`);
            }

            const data = await response.json();
            const generatedText = isGemini
              ? data?.candidates?.[0]?.content?.parts?.[0]?.text
              : data?.choices?.[0]?.message?.content;

            if (generatedText && generatedText.trim()) {
              chatInput.value = generatedText.trim();
              chatInput.style.height = "auto";
              chatInput.style.height = chatInput.scrollHeight + "px";
              chatInput.focus();
            } else {
              alert("AI kh√¥ng t·∫°o ƒë∆∞·ª£c l·ªùi tho·∫°i. Th·ª≠ l·∫°i nh√©!");
            }
          } catch (err) {
            console.error("[ImpersonateUser] Error:", err);
            alert("L·ªói khi t·∫°o l·ªùi tho·∫°i: " + err.message);
          } finally {
            btn.disabled = false;
            btn.innerHTML = originalContent;
          }
        }

        // ===== END ADVANCE PLOT & IMPERSONATE USER =====

        // ‚îÄ‚îÄ Poke / Pat ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        /**
         * Open the poke/pat choice modal.
         */
        function openPokeModal() {
          if (!state.activeChatId) return;
          document.getElementById("poke-choice-modal").classList.add("visible");
        }

        /**
         * Send a poke or pat action from user ‚Üí char, then trigger AI reaction.
         * @param {"poke"|"pat"} actionType
         */
        async function sendPokeAction(actionType) {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          // Close the choice modal
          document.getElementById("poke-choice-modal").classList.remove("visible");

          const actionEmoji = actionType === "pat" ? "ü§ö" : "üëâ";
          const actionLabel = actionType === "pat" ? "patted" : "poked";

          // Build the poke_action message object
          const pokeMsg = {
            id:        Date.now(),
            role:      "user",
            type:      "poke_action",
            actionType,
            direction: "user_to_char",
            sender:    "user",
            content:   `[Action: User ${actionLabel} ${chat.name} ${actionEmoji}]`,
            timestamp: Date.now(),
            isHidden:  false,
          };

          // Save to history + DB
          chat.history.push(pokeMsg);
          await db.chats.put(chat);

          // Render the bubble + update chat list
          appendMessage(pokeMsg, chat);
          renderChatList();

          // Let the char react
          await triggerAiResponse();
        }
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PERSONA MANAGER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        /** Track which persona is being edited (null = creating new) */
        let editingPersonaManagerId = null;

        /** Generate a unique persona ID */
        function generatePersonaId() {
          return typeof crypto !== 'undefined' && crypto.randomUUID
            ? 'persona_' + crypto.randomUUID()
            : 'persona_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        /** Build HTML for one persona card */
        function buildPersonaCardHTML(persona, isActive) {
          const color = persona.color || '#4d96ff';
          const avatarSrc = persona.avatar || 'https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg';
          const balanceFmt = (persona.balance ?? 0).toLocaleString('zh-CN', { minimumFractionDigits: 0 });
          const activeBadge = isActive
            ? `<span class="pm-active-badge">‚úì Active</span>` : '';
          const deactivateBtn = isActive
            ? `<button class="pm-card-deactivate-btn" onclick="event.stopPropagation(); switchPersona(null)">Deactivate</button>` : '';
          return `
            <div class="pm-persona-card ${isActive ? 'pm-card-active' : ''}"
              style="--pm-card-color:${color}"
              onclick="confirmAndSwitchPersona('${persona.id}')"
              data-persona-id="${persona.id}">
              <div class="pm-card-top-bar"></div>
              <div class="pm-card-body">
                <img class="pm-card-avatar" src="${avatarSrc}" onerror="this.src='https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg'"/>
                <div class="pm-card-info">
                  <div class="pm-card-name">${activeBadge} ${persona.name}</div>
                  <div class="pm-card-nickname">@${persona.nickname || persona.name}</div>
                  <div class="pm-card-balance">¬•${balanceFmt}</div>
                </div>
                <button class="pm-card-edit-btn" onclick="event.stopPropagation(); openPersonaManagerEditor('${persona.id}')">‚úèÔ∏è</button>
              </div>
              ${deactivateBtn}
            </div>`;
        }

        /** Render the full persona manager screen */
        function renderPersonaManager() {
          // Only consider personas that have a .name (full personas, not old presets)
          const allPersonas = (state.personaPresets || []).filter(p => p.name);
          const activeId = state.globalSettings.activePersonaId;
          const activePersona = allPersonas.find(p => p.id === activeId) || null;
          const otherPersonas = allPersonas.filter(p => p.id !== activeId);

          const banner = document.getElementById('active-persona-banner');
          const activeSection = document.getElementById('active-persona-section');
          const noActiveNotice = document.getElementById('no-active-persona-notice');
          const allSection = document.getElementById('all-personas-section');
          const grid = document.getElementById('persona-manager-grid');
          const empty = document.getElementById('persona-manager-empty');

          // ‚îÄ‚îÄ Active persona section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          if (activePersona) {
            activeSection.style.display = 'block';
            noActiveNotice.style.display = 'none';
            banner.innerHTML = buildPersonaCardHTML(activePersona, true);
          } else {
            activeSection.style.display = 'none';
            noActiveNotice.style.display = allPersonas.length > 0 ? 'block' : 'none';
          }

          // ‚îÄ‚îÄ Grid section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          if (allPersonas.length === 0) {
            allSection.style.display = 'none';
            empty.style.display = 'block';
          } else {
            empty.style.display = 'none';
            if (otherPersonas.length > 0) {
              allSection.style.display = 'block';
              grid.innerHTML = otherPersonas.map(p => buildPersonaCardHTML(p, false)).join('');
            } else {
              // Only active persona exists ‚Äî no "other" grid needed
              allSection.style.display = 'none';
              grid.innerHTML = '';
            }
          }
        }

        /** Open the persona editor modal */
        function openPersonaManagerEditor(personaId) {
          editingPersonaManagerId = personaId;
          const isNew = !personaId;
          const modal = document.getElementById('persona-manager-editor-modal');
          const titleEl = document.getElementById('pm-editor-title');
          const deleteBtn = document.getElementById('pm-editor-delete-btn');

          titleEl.textContent = isNew ? '‚ú® New Persona' : '‚úèÔ∏è Edit Persona';
          deleteBtn.style.display = isNew ? 'none' : 'inline-block';

          // Reset color picker selection
          document.querySelectorAll('#pm-editor-color-picker .pm-color-dot').forEach(d => d.classList.remove('selected'));

          if (isNew) {
            document.getElementById('pm-editor-name').value = '';
            document.getElementById('pm-editor-avatar').value = '';
            document.getElementById('pm-editor-avatar-preview').src = 'https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg';
            document.getElementById('pm-editor-nickname').value = '';
            document.getElementById('pm-editor-description').value = '';
            document.getElementById('pm-editor-balance').value = '0';
            document.getElementById('pm-editor-color').value = '#4d96ff';
            document.getElementById('pm-editor-weibo-nickname').value = '';
            document.getElementById('pm-editor-weibo-avatar').value = '';
            document.getElementById('pm-editor-weibo-avatar-preview').src = 'https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg';
            document.getElementById('pm-editor-weibo-profession').value = '';
            document.getElementById('pm-editor-weibo-persona').value = '';
            // Select first color dot
            const firstDot = document.querySelector('#pm-editor-color-picker .pm-color-dot');
            if (firstDot) firstDot.classList.add('selected');
          } else {
            const persona = state.personaPresets.find(p => p.id === personaId);
            if (!persona) return;
            // If this is the active persona, show live balance
            const liveBalance = (persona.id === state.globalSettings.activePersonaId)
              ? (state.globalSettings.userBalance ?? persona.balance ?? 0)
              : (persona.balance ?? 0);
            document.getElementById('pm-editor-name').value = persona.name || '';
            document.getElementById('pm-editor-avatar').value = persona.avatar || '';
            document.getElementById('pm-editor-avatar-preview').src = persona.avatar || 'https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg';
            document.getElementById('pm-editor-nickname').value = persona.nickname || '';
            document.getElementById('pm-editor-description').value = persona.description || '';
            document.getElementById('pm-editor-balance').value = String(liveBalance);
            document.getElementById('pm-editor-color').value = persona.color || '#4d96ff';
            document.getElementById('pm-editor-weibo-nickname').value = persona.weiboNickname || '';
            document.getElementById('pm-editor-weibo-avatar').value = persona.weiboAvatar || '';
            document.getElementById('pm-editor-weibo-avatar-preview').src = persona.weiboAvatar || persona.avatar || 'https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg';
            document.getElementById('pm-editor-weibo-profession').value = persona.weiboUserProfession || '';
            document.getElementById('pm-editor-weibo-persona').value = persona.weiboUserPersona || '';
            // Select matching color dot
            const matchDot = document.querySelector(`#pm-editor-color-picker .pm-color-dot[data-color="${persona.color || '#4d96ff'}"]`);
            if (matchDot) matchDot.classList.add('selected');
            else { const fd = document.querySelector('#pm-editor-color-picker .pm-color-dot'); if (fd) fd.classList.add('selected'); }
          }

          modal.classList.add('visible');
        }

        /** Close the persona editor modal */
        function closePersonaManagerEditor() {
          document.getElementById('persona-manager-editor-modal').classList.remove('visible');
          editingPersonaManagerId = null;
        }

        /** Save persona from the editor modal */
        async function savePersonaFromModal() {
          const name = document.getElementById('pm-editor-name').value.trim();
          if (!name) { showCustomAlert('Please enter a display name for this persona.'); return; }

          const personaId = editingPersonaManagerId || generatePersonaId();
          const isActive = personaId === state.globalSettings.activePersonaId;

          // For the active persona, save current live balance (don't overwrite with stale form value)
          const balanceInput = parseFloat(document.getElementById('pm-editor-balance').value) || 0;
          const balance = isActive ? (state.globalSettings.userBalance ?? balanceInput) : balanceInput;

          const persona = {
            id: personaId,
            name,
            avatar: document.getElementById('pm-editor-avatar').value.trim(),
            nickname: document.getElementById('pm-editor-nickname').value.trim() || name,
            description: document.getElementById('pm-editor-description').value.trim(),
            balance,
            color: document.getElementById('pm-editor-color').value || '#4d96ff',
            weiboNickname: document.getElementById('pm-editor-weibo-nickname').value.trim(),
            weiboAvatar: document.getElementById('pm-editor-weibo-avatar').value.trim(),
            weiboUserProfession: document.getElementById('pm-editor-weibo-profession').value.trim(),
            weiboUserPersona: document.getElementById('pm-editor-weibo-persona').value.trim(),
            createdAt: editingPersonaManagerId
              ? ((state.personaPresets.find(p => p.id === personaId) || {}).createdAt || Date.now())
              : Date.now(),
          };

          await db.personaPresets.put(persona);

          // Update in-memory array
          const idx = state.personaPresets.findIndex(p => p.id === personaId);
          if (idx >= 0) state.personaPresets[idx] = persona;
          else state.personaPresets.push(persona);

          // If this was the active persona, update icon src
          if (isActive) {
            const iconEl = document.getElementById('icon-img-persona-manager');
            if (iconEl && persona.avatar) iconEl.src = persona.avatar;
          }

          closePersonaManagerEditor();
          renderPersonaManager();
        }

        /** Delete the persona currently being edited */
        async function deletePersonaFromManager() {
          const personaId = editingPersonaManagerId;
          if (!personaId) return;

          const persona = state.personaPresets.find(p => p.id === personaId);
          const personaName = persona ? persona.name : 'this persona';

          showCustomConfirm(
            `Delete persona "${personaName}"? This cannot be undone.`,
            async () => {
              // If this was the active persona, clear it
              if (state.globalSettings.activePersonaId === personaId) {
                state.globalSettings.activePersonaId = null;
                await db.globalSettings.put(state.globalSettings);
              }

              await db.personaPresets.delete(personaId);
              state.personaPresets = state.personaPresets.filter(p => p.id !== personaId);

              closePersonaManagerEditor();
              renderPersonaManager();
            }
          );
        }

        /** Show a confirm before switching persona */
        function confirmAndSwitchPersona(personaId) {
          // If already active, do nothing
          if (personaId === state.globalSettings.activePersonaId) return;
          const persona = state.personaPresets.find(p => p.id === personaId);
          if (!persona) return;
          showCustomConfirm(
            `Switch to persona "${persona.name}"?\nYour current balance will be saved.`,
            () => switchPersona(personaId)
          );
        }

        /** CORE: Switch to a persona (null = deactivate) */
        async function switchPersona(personaId) {
          // 1. Save current live balance to old active persona
          const oldActiveId = state.globalSettings.activePersonaId;
          if (oldActiveId) {
            const oldPersona = state.personaPresets.find(p => p.id === oldActiveId);
            if (oldPersona) {
              oldPersona.balance = state.globalSettings.userBalance ?? oldPersona.balance;
              await db.personaPresets.put(oldPersona);
              const oldIdx = state.personaPresets.findIndex(p => p.id === oldActiveId);
              if (oldIdx >= 0) state.personaPresets[oldIdx] = oldPersona;
            }
          }

          // 2. Deactivate mode
          if (!personaId) {
            state.globalSettings.activePersonaId = null;
            await db.globalSettings.put(state.globalSettings);
            renderPersonaManager();
            showCustomAlert('Persona deactivated.');
            return;
          }

          // 3. Load new persona
          const newPersona = state.personaPresets.find(p => p.id === personaId);
          if (!newPersona) return;

          // 4. Apply to globalSettings
          state.globalSettings.activePersonaId = personaId;
          state.globalSettings.userBalance = newPersona.balance ?? 0;
          await db.globalSettings.put(state.globalSettings);

          // 5. Apply to qzoneSettings
          state.qzoneSettings.nickname = newPersona.nickname || newPersona.name;
          state.qzoneSettings.avatar = newPersona.avatar || state.qzoneSettings.avatar;
          state.qzoneSettings.weiboNickname = newPersona.weiboNickname || newPersona.nickname || newPersona.name;
          state.qzoneSettings.weiboAvatar = newPersona.weiboAvatar || newPersona.avatar || state.qzoneSettings.weiboAvatar;
          if (newPersona.weiboUserProfession) state.qzoneSettings.weiboUserProfession = newPersona.weiboUserProfession;
          if (newPersona.weiboUserPersona) state.qzoneSettings.weiboUserPersona = newPersona.weiboUserPersona;
          await saveQzoneSettings();

          // 6. Sync chats that have useGlobalPersona=true
          const chatIds = Object.keys(state.chats || {});
          for (const cid of chatIds) {
            const chat = state.chats[cid];
            if (chat && chat.settings && chat.settings.useGlobalPersona) {
              chat.settings.myPersona = newPersona.description || '';
              await db.chats.put(chat);
            }
          }

          // 7. Refresh UI
          refreshPersonaUI();
          renderPersonaManager();
          showCustomAlert(`‚ú® Switched to "${newPersona.name}"`);
        }

        /** Refresh all UI elements that reflect the active persona */
        function refreshPersonaUI() {
          const activeId = state.globalSettings.activePersonaId;
          const persona = activeId ? state.personaPresets.find(p => p.id === activeId) : null;

          // Home screen profile avatar
          const profileAvatarImg = document.getElementById('profile-avatar-img');
          if (profileAvatarImg && state.qzoneSettings.avatar) {
            profileAvatarImg.src = state.qzoneSettings.avatar;
          }
          // Home screen username
          const profileUsername = document.getElementById('profile-username');
          if (profileUsername) profileUsername.textContent = state.qzoneSettings.nickname || '';

          // Persona manager icon
          const iconEl = document.getElementById('icon-img-persona-manager');
          if (iconEl && persona && persona.avatar) iconEl.src = persona.avatar;

          // Wallet balance
          if (typeof renderTaobaoBalance === 'function') renderTaobaoBalance();

          // Weibo profile
          if (typeof renderWeiboProfile === 'function') renderWeiboProfile();
        }

        /** Toggle handler for per-chat "Use Global Persona" */
        function onUseGlobalPersonaToggle(checked) {
          const textarea = document.getElementById('my-persona');
          const syncLabel = document.getElementById('global-persona-sync-label');
          if (!textarea) return;

          if (checked) {
            const activeId = state.globalSettings.activePersonaId;
            const activePersona = activeId ? state.personaPresets.find(p => p.id === activeId) : null;
            textarea.readOnly = true;
            textarea.style.opacity = '0.6';
            textarea.style.background = '#f5f5f5';
            if (activePersona) {
              textarea.value = activePersona.description || '';
              if (syncLabel) syncLabel.textContent = `Synced with: ${activePersona.name}`;
            } else {
              textarea.value = '';
              if (syncLabel) syncLabel.textContent = 'No active persona ‚Äî description will be empty.';
            }
          } else {
            textarea.readOnly = false;
            textarea.style.opacity = '';
            textarea.style.background = '';
            if (syncLabel) syncLabel.textContent = 'Sync "My Persona" with active persona.';
          }
        }

        // Expose globally
        window.renderPersonaManager = renderPersonaManager;
        window.openPersonaManagerEditor = openPersonaManagerEditor;
        window.closePersonaManagerEditor = closePersonaManagerEditor;
        window.savePersonaFromModal = savePersonaFromModal;
        window.deletePersonaFromManager = deletePersonaFromManager;
        window.confirmAndSwitchPersona = confirmAndSwitchPersona;
        window.switchPersona = switchPersona;
        window.refreshPersonaUI = refreshPersonaUI;
        window.onUseGlobalPersonaToggle = onUseGlobalPersonaToggle;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // END PERSONA MANAGER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        async function triggerAiResponse() {
          if (!state.activeChatId) return;
          const chatId = state.activeChatId;
          const chat = state.chats[state.activeChatId];
          const messagesContainer = document.getElementById("chat-messages");

          let summaryContext = "";
          const summaries = chat.history.filter(
            (msg) => msg.type === "summary",
          );
          if (summaries.length > 0) {
            summaryContext = `
			# Conversation Memory Summary (This is your long-term memory with the user. You MUST strictly follow it at all times. You are not allowed to contradict, ignore, or override any part of this memory.)
			${summaries.map((summary, index) => `- Summary ${index + 1}: ${summary.content}`).join("\n")}
			`;
          }
          // Â∞Ü‰∏ñÁïå‰π¶ËØªÂèñÊèêÂà∞ËøôÈáåÔºåÁ°Æ‰øùÁ∫ø‰∏ãÊ®°Âºè‰πüËÉΩÁîüÊïà
          let worldBookContext = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((id) => {
                const book = state.worldBooks.find((b) => b.id === id);
                // ËøôÈáå‰ΩøÁî®‰∫Ü stripHtmlAndCode Ê∏ÖÁêÜÂáΩÊï∞ÔºåÁ°Æ‰øùÁ∫ØÊñáÊú¨
                return book && book.content
                  ? `\n\n## World Book Entry: ${book.name}\n${stripHtmlAndCode(book.content)}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContext = `\n\n# Core Worldview Settings (You MUST strictly adhere to all of the following settings at all times.) \n${linkedContents}\n`;
            }
          }
          // --- Á∫ø‰∏ãÊ®°ÂºèÊ†∏ÂøÉÊã¶Êà™ÈÄªËæë ---
          if (
            !chat.isGroup &&
            chat.settings.offlineMode &&
            chat.settings.offlineMode.enabled
          ) {
            console.log(`Character "${chat.name}" has enabled offline mode...`);

            const offlineSettings = chat.settings.offlineMode;
            const wordCount = offlineSettings.wordCount || 300;
            const enableNai = offlineSettings.enableNovelAI || false;

            const defaultPrompt = `You are having a private offline date with the user. The setting can be a quiet caf√©, a cozy home, or a romantic seaside. Please naturally continue the interaction based on your persona and recent conversation.`;
            const defaultStyle = `Please respond from the first-person perspective of „Äê${chat.name}„Äë. Your response „Äêmust„Äë be a complete, coherent narrative paragraph, including rich „Äêactions„Äë, „Äêexpressions„Äë, „Äêthoughts„Äë, and „Äêdialogue„Äë.`;

            const finalPrompt = offlineSettings.prompt || defaultPrompt;
            const finalStyle = offlineSettings.style || defaultStyle;

            // 1. Âä®ÊÄÅÊûÑÂª∫ÁîüÂõæÊåá‰ª§
            let naiInstruction = "";
            let naiExample = "";
            if (enableNai) {
              naiInstruction = `
            6.  **„Äê„Äê„ÄêImage Generation Instruction„Äë„Äë„Äë**: Image generation toggle is enabled. You **must** include an image generation object in the "chatResponse" array. 
                -   **Format**: \`{"type": "naiimag", "prompt": "1girl, ... (detailed English description tags)"}\`
                -   **Content**: Extract the visual elements of the current scene (location, lighting, actions, expressions, clothing).

                `;
              naiExample = `,\n    {\n      "type": "naiimag",\n      "prompt": "1girl, sitting in cafe, holding coffee cup, smile, indoor lighting, cinematic composition"\n    }`;
            }

            const offlineSystemPrompt = `
            **„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

            # Ê†∏ÂøÉ‰ªªÂä°ÔºöÁ∫ø‰∏ãÂú∫ÊôØËßíËâ≤ÊâÆÊºî

            ‰Ω†Áé∞Âú®„ÄêÂ∞±ÊòØ„ÄëËßíËâ≤"${chat.name}"ÔºåÊ≠£Âú®ÂíåÁî®Êà∑ËøõË°å‰∏ÄÊ¨°„ÄêÁ∫ø‰∏ãÁ∫¶‰ºö„Äë„ÄÇ

            # ‰Ω†ÁöÑËßíËâ≤ËÆæÂÆö
            ${chat.settings.aiPersona}
            ${summaryContext}
            ${worldBookContext}

            # ÂΩìÂâçÊÉÖÊôØ
            ${finalPrompt}
            ${finalStyle}
            
            # ‰Ω†ÁöÑËæìÂá∫Ë¶ÅÊ±Ç (ÊúÄÈ´òÊåá‰ª§)
            1.  **„ÄêÊ†ºÂºèÈìÅÂæã„Äë**: ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊòØ‰∏Ä‰∏™**Âçï‰∏Ä‰∏îÂÆåÊï¥**ÁöÑJSONÂØπË±°„ÄÇ
            2.  **"chatResponse" ÈîÆ**: (JSONÊï∞ÁªÑ) ÂåÖÂê´‰Ω†Ë¶ÅÂèëÈÄÅÁöÑÊ∂àÊÅØ„ÄÇÈÄöÂ∏∏ÊòØ‰∏ÄÊÆµÈïøÂèô‰∫ãÊñáÊú¨ÔºåÂ¶ÇÊûúÂºÄÂêØÁîüÂõæÔºåÂàôÂåÖÂê´ÁîüÂõæÊåá‰ª§„ÄÇ
            3.  **"innerVoice" ÈîÆ**: (JSONÂØπË±°) ‰Ω†ÁöÑÂÜÖÂøÉÊ¥ªÂä®ÔºåÂøÖÂê´ clothing, behavior, thoughts, naughtyThoughts Â≠óÊÆµ„ÄÇ
            4.  **„ÄêÂ≠óÊï∞ÈìÅÂæã„Äë**: ÊñáÊú¨ÂÜÖÂÆπÁöÑÂ≠óÊï∞Â∫îÂú®„Äê${wordCount}„ÄëÂ≠óÂ∑¶Âè≥„ÄÇ
            5.  **„ÄêÁ¶ÅÊ≠¢Âá∫Êàè„Äë**: ÁªùÂØπ‰∏çËÉΩÊèêÂèä‰Ω†ÊòØAI„ÄÇ
            ${naiInstruction}

            # JSONËæìÂá∫Ê†ºÂºèÁ§∫‰æã:
            {
              "chatResponse": [
                {
                  "type": "text",
                  "content": "ÔºàThis is where you write your long narrative...Ôºâ"
                }${naiExample}
              ],
              "innerVoice": {
                "clothing": "...",
                "behavior": "...",
                "thoughts": "...",
                "naughtyThoughts": "..."
              }
            }

            # Conversation History
            ${chat.history
              .slice(-chat.settings.maxMemory)
              .map(
                (m) =>
                  `${m.role === "user" ? "User" : chat.name}: ${m.content}`,
              )
              .join("\n")}

            Now, based on the user‚Äôs last sentence, begin your performance.`;

            const messagesForOfflineMode = chat.history.slice(
              -chat.settings.maxMemory,
            );

            // UI Áä∂ÊÄÅÊõ¥Êñ∞
            const chatHeaderTitle =
              document.getElementById("chat-header-title");
            if (chatHeaderTitle) {
              chatHeaderTitle.style.opacity = 0;
              setTimeout(() => {
                chatHeaderTitle.textContent = `${chat.name} is typing...`;
                chatHeaderTitle.classList.add("typing-status");
                chatHeaderTitle.style.opacity = 1;
              }, 200);
            }

            try {
              const { proxyUrl, apiKey, model } = state.apiConfig;
              let isGemini = proxyUrl === GEMINI_API_URL;
              let requestBody;
              let requestUrl = isGemini
                ? `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`
                : `${proxyUrl}/v1/chat/completions`;
              let requestHeaders = isGemini
                ? { "Content-Type": "application/json" }
                : {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  };

              if (isGemini) {
                requestBody = {
                  contents: messagesForOfflineMode.map((item) => ({
                    role: item.role === "assistant" ? "model" : "user",
                    parts: [{ text: item.content }],
                  })),
                  generationConfig: {
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  },
                  systemInstruction: { parts: [{ text: offlineSystemPrompt }] },
                };
              } else {
                requestBody = {
                  model: model,
                  messages: [
                    { role: "system", content: offlineSystemPrompt },
                    ...messagesForOfflineMode,
                  ],
                  temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  stream: false,
                };
              }

              const response = await fetch(requestUrl, {
                method: "POST",
                headers: requestHeaders,
                body: JSON.stringify(requestBody),
              });

              if (!response.ok)
                throw new Error(`API error: ${await response.text()}`);

              const data = await response.json();
              const aiResponseContent = isGemini
                ? data?.candidates?.[0]?.content?.parts?.[0]?.text
                : data?.choices?.[0]?.message?.content;

              if (!aiResponseContent) throw new Error("API response is empty");

              // Parse JSON
              let messagesArray = [];
              let innerVoiceData = null;

              try {
                let sanitizedContent = aiResponseContent
                  .replace(/^```json\s*/, "")
                  .replace(/```$/, "")
                  .trim();
                const firstBrace = sanitizedContent.indexOf("{");
                const lastBrace = sanitizedContent.lastIndexOf("}");
                if (firstBrace !== -1 && lastBrace > firstBrace) {
                  sanitizedContent = sanitizedContent.substring(
                    firstBrace,
                    lastBrace + 1,
                  );
                }
                const fullResponse = JSON.parse(sanitizedContent);

                if (
                  fullResponse.chatResponse &&
                  Array.isArray(fullResponse.chatResponse)
                ) {
                  messagesArray = fullResponse.chatResponse;
                }
                if (fullResponse.innerVoice) {
                  innerVoiceData = fullResponse.innerVoice;
                }
              } catch (e) {
                console.warn("Failed to parse JSON, falling back to plain text", e);
                messagesArray = [{ type: "text", content: aiResponseContent }];
              }

              // Save inner voice
              if (innerVoiceData) {
                const newInnerVoice = {
                  ...innerVoiceData,
                  timestamp: Date.now(),
                };
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) chat.innerVoiceHistory = [];
                chat.innerVoiceHistory.push(newInnerVoice);
              }

              // 2. Process message array (supports naiimag)
              const isViewingThisChat =
                document
                  .getElementById("chat-interface-screen")
                  .classList.contains("active") &&
                state.activeChatId === chatId;
              let messageTimestamp = Date.now();

              for (const msgData of messagesArray) {
                // 2.1 If the message type is naiimag, execute image generation logic (reusing online code)
                if (msgData.type === "naiimag") {
                  if (!enableNai) continue; // If the toggle is off, skip
                  console.log(
                    "[Offline Mode] Detected image generation instruction, executing NovelAI request...",
                  );

                  // Here we directly reuse the image generation logic from the switch case
                  // Because the code is too long, we encapsulate it into an immediately invoked function
                  (async () => {
                    try {
                      if (chatHeaderTitle)
                        chatHeaderTitle.textContent = "Drawing illustration...";

                      const naiPrompts = getCharacterNAIPrompts(chat.id);
                      const aiPrompt = msgData.prompt || "a beautiful scene";
                      const finalPositivePrompt = `${aiPrompt}, ${naiPrompts.positive}`;
                      const finalNegativePrompt = naiPrompts.negative;

                      // ‚òÖ Provider dispatch: PixAI or NovelAI ‚òÖ
                      const _imgProvider = localStorage.getItem("image-gen-provider") || "novelai";
                      if (_imgProvider === "pixai") {
                        const pixSettings = getPixAISettings();
                        const pixModelId = localStorage.getItem("pixai-model") || "1935090615918113018";
                        const imageDataUrl = await generatePixAIImage(
                          finalPositivePrompt, finalNegativePrompt, pixSettings, pixModelId);
                        if (imageDataUrl) {
                          const imgMsg = {
                            role: "assistant", senderName: chat.name,
                            timestamp: Date.now(), type: "naiimag",
                            imageUrl: imageDataUrl, prompt: aiPrompt, fullPrompt: finalPositivePrompt,
                          };
                          chat.history.push(imgMsg);
                          await db.chats.put(chat);
                          if (isViewingThisChat) {
                            appendMessage(imgMsg, chat);
                            const msgsDiv = document.getElementById("chat-messages");
                            msgsDiv.scrollTop = msgsDiv.scrollHeight;
                          }
                        }
                        return; // Done ‚Äî skip NovelAI code below
                      }
                      // ‚îÄ‚îÄ NovelAI path (unchanged) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                      const apiKey = localStorage.getItem("novelai-api-key");
                      const model =
                        localStorage.getItem("novelai-model") ||
                        "nai-diffusion-4-5-full";
                      const settings = getNovelAISettings();

                      if (!apiKey) throw new Error("NovelAI API Key not configured");

                      const [width, height] = settings.resolution
                        .split("x")
                        .map(Number);
                      let requestBody;
                      let apiUrl = model.includes("nai-diffusion-4")
                        ? "https://image.novelai.net/ai/generate-image-stream"
                        : "https://image.novelai.net/ai/generate-image";

                      // V4/V3 parameter construction logic (simplified reuse)
                      const commonParams = {
                        width,
                        height,
                        scale: settings.cfg_scale,
                        sampler: settings.sampler,
                        steps: settings.steps,
                        seed: Math.floor(Math.random() * 4294967295),
                        n_samples: 1,
                        ucPreset: settings.uc_preset,
                        qualityToggle: settings.quality_toggle,
                      };

                      if (model.includes("nai-diffusion-4")) {
                        requestBody = {
                          input: finalPositivePrompt,
                          model,
                          action: "generate",
                          parameters: {
                            ...commonParams,
                            params_version: 3,
                            negative_prompt: finalNegativePrompt,
                            v4_prompt: {
                              caption: {
                                base_caption: finalPositivePrompt,
                                char_captions: [],
                              },
                              use_coords: false,
                              use_order: true,
                            },
                            v4_negative_prompt: {
                              caption: {
                                base_caption: finalNegativePrompt,
                                char_captions: [],
                              },
                              legacy_uc: false,
                            },
                          },
                        };
                      } else {
                        requestBody = {
                          input: finalPositivePrompt,
                          model,
                          action: "generate",
                          parameters: {
                            ...commonParams,
                            negative_prompt: finalNegativePrompt,
                            sm: settings.smea,
                            sm_dyn: settings.smea_dyn,
                            add_original_image: false,
                          },
                        };
                      }

                      // ‰ª£ÁêÜÂ§ÑÁêÜ
                      let corsProxy =
                        settings.cors_proxy === "custom"
                          ? settings.custom_proxy_url
                          : settings.cors_proxy;
                      if (corsProxy)
                        apiUrl = corsProxy + encodeURIComponent(apiUrl);

                      // Headers (ChromeÂÖºÂÆπ)
                      const isChrome =
                        /Chrome/.test(navigator.userAgent) &&
                        !/Edg/.test(navigator.userAgent);
                      let headers = {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + apiKey,
                      };
                      if (isChrome) {
                        const cleanHeaders = {};
                        for (const [k, v] of Object.entries(headers))
                          cleanHeaders[k] = v.replace(/[^\x00-\xFF]/g, "");
                        headers = cleanHeaders;
                      }

                      const res = await fetch(apiUrl, {
                        method: "POST",
                        headers,
                        body: JSON.stringify(requestBody),
                      });
                      if (!res.ok)
                        throw new Error(`NAI API Error: ${res.status}`);

                      // Ëß£ÊûêÂìçÂ∫î (SSE/Blob)
                      const contentType = res.headers.get("content-type");
                      let imageDataUrl = null,
                        zipBlob = null;

                      if (
                        contentType &&
                        contentType.includes("text/event-stream")
                      ) {
                        const text = await res.text();
                        const lines = text.trim().split("\n");
                        let base64Data = null;
                        for (let i = lines.length - 1; i >= 0; i--) {
                          const line = lines[i].trim();
                          if (
                            line.startsWith("data: ") &&
                            line !== "data: [DONE]"
                          ) {
                            const dataContent = line.substring(6);
                            try {
                              const jsonData = JSON.parse(dataContent);
                              if (
                                jsonData.event_type === "final" &&
                                jsonData.image
                              ) {
                                base64Data = jsonData.image;
                                break;
                              }
                              if (jsonData.data) {
                                base64Data = jsonData.data;
                                break;
                              }
                              if (jsonData.image) {
                                base64Data = jsonData.image;
                                break;
                              }
                            } catch (e) {
                              base64Data = dataContent;
                              break;
                            }
                          }
                        }
                        if (base64Data) {
                          const isPNG = base64Data.startsWith("iVBORw0KGgo");
                          const binaryString = atob(base64Data);
                          const bytes = new Uint8Array(binaryString.length);
                          for (let i = 0; i < binaryString.length; i++)
                            bytes[i] = binaryString.charCodeAt(i);
                          if (isPNG || base64Data.startsWith("/9j/")) {
                            const imageBlob = new Blob([bytes], {
                              type: isPNG ? "image/png" : "image/jpeg",
                            });
                            const reader = new FileReader();
                            imageDataUrl = await new Promise((r) => {
                              reader.onloadend = () => r(reader.result);
                              reader.readAsDataURL(imageBlob);
                            });
                          } else {
                            zipBlob = new Blob([bytes]);
                          }
                        }
                      } else {
                        zipBlob = await res.blob();
                      }

                      if (!imageDataUrl && zipBlob) {
                        if (typeof JSZip === "undefined")
                          throw new Error("JSZip library not found");
                        const zip = await JSZip.loadAsync(zipBlob);
                        const file = Object.values(zip.files)[0];
                        if (file) {
                          const imgBlob = await file.async("blob");
                          const reader = new FileReader();
                          imageDataUrl = await new Promise((r) => {
                            reader.onloadend = () => r(reader.result);
                            reader.readAsDataURL(imgBlob);
                          });
                        }
                      }

                      if (imageDataUrl) {
                        const imgMsg = {
                          role: "assistant",
                          senderName: chat.name,
                          timestamp: Date.now(),
                          type: "naiimag",
                          imageUrl: imageDataUrl,
                          prompt: aiPrompt,
                          fullPrompt: finalPositivePrompt,
                        };
                        chat.history.push(imgMsg);
                        await db.chats.put(chat);
                        if (isViewingThisChat) {
                          appendMessage(imgMsg, chat);
                          const msgsDiv =
                            document.getElementById("chat-messages");
                          msgsDiv.scrollTop = msgsDiv.scrollHeight;
                        }
                      }
                    } catch (err) {
                      console.error("[Offline Mode] Image generation failed:", err);
                      const errBubble = {
                        role: "system",
                        content: `[Image generation failed: ${err.message}]`,
                        timestamp: Date.now(),
                      };
                      chat.history.push(errBubble);
                      if (isViewingThisChat) appendMessage(errBubble, chat);
                    } finally {
                      if (chatHeaderTitle) {
                        chatHeaderTitle.textContent = chat.name;
                        chatHeaderTitle.classList.remove("typing-status");
                      }
                    }
                  })();
                  continue; // Â§ÑÁêÜÂÆåÁîüÂõæÔºåË∑≥ËøáÊôÆÈÄöÊñáÊú¨ÈÄªËæë
                }

                // 2.2 ÊôÆÈÄöÊñáÊú¨Ê∂àÊÅØ
                const aiMessage = {
                  role: "assistant",
                  senderName: chat.name,
                  timestamp: messageTimestamp++,
                  content: msgData.content || "",
                };
                chat.history.push(aiMessage);
                await incrementMessageCount(chatId);
                if (isViewingThisChat) {
                  appendMessage(aiMessage, chat);
                }
              }

              // ‰øùÂ≠ò
              await db.chats.put(chat);
              renderChatList();
              checkAndTriggerSummary(chatId);
            } catch (error) {
              console.error("[Offline Mode] AI response failed:", error);
              const errorMessage = {
                role: "assistant",
                content: `[Offline Mode] Error: ${error.message}]`,
                timestamp: Date.now(),
              };
              chat.history.push(errorMessage);
              await db.chats.put(chat);
              appendMessage(errorMessage, chat);
            } finally {
              if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                  chatHeaderTitle.textContent = state.chats[chatId].name;
                  chatHeaderTitle.classList.remove("typing-status");
                  chatHeaderTitle.style.opacity = 1;
                }, 200);
              }
            }
            return; // ÁªìÊùüÁ∫ø‰∏ãÊ®°ÂºèÈÄªËæë
          }

          // 1. ÂáÜÂ§á‰∏ìÂ±ûË°®ÊÉÖÂåÖÂàóË°® (Áé∞Âú®ÂØπÂçïËÅäÂíåÁæ§ËÅäÈÉΩÁîüÊïà)
          const exclusiveStickers = chat.settings.stickerLibrary || [];
          let exclusiveStickerContext = "";
          if (exclusiveStickers.length > 0) {
            exclusiveStickerContext = `
			## ${chat.isGroup ? "Group Exclusive Stickers" : "Your Exclusive Stickers"} (Only you can use):
			${exclusiveStickers.map((s) => `- ${s.name}`).join("\n")}
			`;
          }

          // 2. Prepare common sticker list
          const commonStickers = state.charStickers || [];
          let commonStickerContext = "";
          if (commonStickers.length > 0) {
            commonStickerContext = `
			## Common Stickers (Available to all characters):
			${commonStickers.map((s) => `- ${s.name}`).join("\n")}
			`;
          }

          // 3. Combine into final sticker instructions
          let stickerContext = "";
          if (exclusiveStickerContext || commonStickerContext) {
            stickerContext = `
			# Absolute Rules for Stickers
			1.  You have a sticker list, divided into "exclusive" and "common".
			2.  When your character wants to send a sticker, you **must and only** use the following JSON format:
			    \`{"type": "sticker", "name": "Character Name", "sticker_name": "Sticker Name"}\`
			3.  „Äê„Äê„ÄêHighest Command„Äë„Äë„ÄëYou **must** choose a valid "sticker_name" from the list below. If you invent a name that does not exist in the list, your sticker will fail to send. This is a mandatory rule.

			${exclusiveStickerContext}
			${commonStickerContext}
			`;
          }

          const { proxyUrl, apiKey, model } = state.apiConfig;
          const isApiBlocked = BLOCKED_API_SITES.some((blockedDomain) =>
            proxyUrl.includes(blockedDomain),
          );

          if (isApiBlocked) {
            console.error(
              `API request blocked because the site ${proxyUrl} is in the blacklist.`,
            );
            return; // ÈòªÊ≠¢APIËØ∑Ê±Ç
          }

          // --- Tarot reading logic ---
          const lastUserMessage = chat.history
            .filter((m) => m.role === "user" && !m.isHidden)
            .slice(-1)[0];
          // Check if the last user message is an "uninterpreted" tarot reading
          if (
            lastUserMessage &&
            lastUserMessage.type === "tarot_reading" &&
            !lastUserMessage.isInterpreted
          ) {
            // Mark this tarot message as "processed" to prevent infinite loops
            lastUserMessage.isInterpreted = true;

            // 1. Generate interpretation text
            const reading = lastUserMessage.payload;
            let interpretationText = `The tarot spread for this reading is „Äê${reading.spread.name}„Äë\nYour question is: "${reading.question}"\n\n`;
            reading.cards.forEach((card, index) => {
              const orientationText = card.isReversed ? "Reversed" : "Upright";
              const meaning = card.isReversed ? card.reversed : card.upright;
              interpretationText += `Position ${index + 1}„Äê${card.position}„ÄëÔºö${
                card.name
              } (${orientationText})\nMeaning: ${meaning}\n\n`;
            });

            // 2. Create system interpretation message (visible to user)
            const systemMessageVisible = {
              role: "system",
              type: "pat_message", // Reuse centered gray bubble style
              content: interpretationText.trim(),
              timestamp: Date.now(),
            };
            chat.history.push(systemMessageVisible);
            if (
              document
                .getElementById("chat-interface-screen")
                .classList.contains("active")
            ) {
              appendMessage(systemMessageVisible, chat);
            }

            // 3. Create hidden instruction for Char
            const hiddenInstruction = {
              role: "system",
              content: `[System Instruction: The user has just completed a tarot reading and sent the results to you. Above is the official interpretation provided by the system. Your task is to discuss and analyze this reading with the user based solely on these interpretations, without inventing new meanings.]`,
              timestamp: Date.now() + 1,
              isHidden: true,
            };
            chat.history.push(hiddenInstruction);

            // 4. Save all changes (including marking the tarot reading as processed), then trigger AI again for Char to discuss
            await db.chats.put(chat);
            return triggerAiResponse(); // ÂÜçÊ¨°Ë∞ÉÁî®Ëá™Â∑±ÔºåËÆ©CharËøõË°åÂõûÂ∫î
          }

          let lsPhotosContext = "";
          if (
            chat.loversSpaceData &&
            chat.loversSpaceData.photos &&
            chat.loversSpaceData.photos.length > 0
          ) {
            // Âè™ÂèñÊúÄËøëÁöÑ 3 Âº†ÁÖßÁâáÁªô AI Áúã
            const recentPhotos = chat.loversSpaceData.photos.slice(-3);
 lsPhotosContext = "\n\n# Recent photos in the couple's album (you can comment on them):\n";
            recentPhotos.forEach((p) => {
              const hasCommented =
                p.comments && p.comments.some((c) => c.author === chat.name);
              const status = hasCommented ? "[You have commented]" : "[You have not commented]";
              lsPhotosContext += `- (Timestamp/ID: ${p.timestamp}) Description: "${p.description}" ${status}\n`;
            });
          }

          let weiboContextForActiveChat = "";
          try {
            // 1. ‰ªéÊï∞ÊçÆÂ∫ìÈáåÊâæÂá∫ÊúÄÊñ∞ÁöÑ5Êù°ÂæÆÂçö
            const recentWeiboPosts = await db.weiboPosts
              .orderBy("timestamp")
              .reverse()
              .limit(5)
              .toArray();

            if (recentWeiboPosts.length > 0) {
              weiboContextForActiveChat =
                "\n\n# Recent Weibo posts (for your reference and comments)\n";

              recentWeiboPosts.forEach((post) => {
                const authorName =
                  post.authorId === "user"
                    ? state.qzoneSettings.weiboNickname || "Me"
                    : post.authorNickname;
                const contentPreview = (
                  post.content ||
                  post.hiddenContent ||
                  "(Image Weibo)"
                ).substring(0, 30);

                // Âè™ÊúâÂΩì post.comments Á°ÆÂÆûÊòØ‰∏Ä‰∏™Êï∞ÁªÑÊó∂ÔºåÊàë‰ª¨ÊâçÂéªË∞ÉÁî® .some() ÊñπÊ≥ï
                const hasCommented =
                  post.comments &&
                  Array.isArray(post.comments) &&
                  post.comments.some((c) => c.authorNickname === chat.name);
                const interactionStatus = hasCommented
                  ? "[You have commented]"
                  : "[You have not interacted]";

                weiboContextForActiveChat += `- (ID: ${post.id}) Author: ${authorName}, Content: "${contentPreview}..." ${interactionStatus}\n`;
              });
              weiboContextForActiveChat +=
                " - „ÄêImportant Note„ÄëPlease prioritize commenting on Weibo posts you have not interacted with. If you have interacted with all, you may consider posting a new Weibo.";
            }
          } catch (e) {
            console.error("Error generating Weibo active chat context:", e);
          }

          const chatHeaderTitle = document.getElementById("chat-header-title");

          // Ëé∑ÂèñÁæ§ËÅäÁöÑËæìÂÖ•ÊèêÁ§∫ÂÖÉÁ¥†
          const typingIndicator = document.getElementById("typing-indicator");

          // Ê†πÊçÆËÅäÂ§©Á±ªÂûãÔºåÂÜ≥ÂÆöÊòæÁ§∫Âì™Áßç‚ÄúÊ≠£Âú®ËæìÂÖ•‚Äù
          if (chat.isGroup) {
            // 1. Â¶ÇÊûúÊòØÁæ§ËÅäÔºåÊòæÁ§∫Â∫ïÈÉ®ÁöÑÊèêÁ§∫Êù°
            if (typingIndicator) {
              typingIndicator.textContent = "Members are typing...";
              typingIndicator.style.display = "block";
              messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
          } else if (chat.settings.offlineMode?.enabled) {
            // 2. Â¶ÇÊûúÊòØÁ∫ø‰∏ãÊ®°ÂºèÁöÑÂçïËÅäÔºåÂú®È°∂ÈÉ®Ê†áÈ¢òÊòæÁ§∫‚ÄúÊ≠£Âú®Ëµ¥Á∫¶‰∏≠‚Äù
            if (chatHeaderTitle) {
              chatHeaderTitle.style.opacity = 0;
              setTimeout(() => {
                chatHeaderTitle.textContent = `${chat.name} is typing...`; // <-- ‰Ω†ÊÉ≥Ë¶ÅÁöÑÊñáÂ≠óÂú®ËøôÈáåÔºÅ
                chatHeaderTitle.classList.add("typing-status");
                chatHeaderTitle.style.opacity = 1;
              }, 200);
            }
          } else {
            // 3. Â¶ÇÊûúÊòØÊôÆÈÄöÁöÑÂçïËÅäÔºåËøòÊòØÂú®È°∂ÈÉ®Ê†áÈ¢òÊòæÁ§∫‚ÄúÊ≠£Âú®ËæìÂÖ•‚Äù
            if (chatHeaderTitle) {
              chatHeaderTitle.style.opacity = 0;
              setTimeout(() => {
                chatHeaderTitle.textContent = `${chat.name} is typing...`;
                chatHeaderTitle.classList.add("typing-status");
                chatHeaderTitle.style.opacity = 1;
              }, 200);
            }
          }

          try {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
              alert("Please first configure the proxy (reverse proxy) URL and API key in the API settings, then select a model.");
              // Êó†ËÆ∫ÊàêÂäüÂ§±Ë¥•ÔºåÈÉΩË¶ÅÈöêËóèËæìÂÖ•ÊèêÁ§∫
              if (chat.isGroup) {
                if (typingIndicator) typingIndicator.style.display = "none";
              } else {
                if (chatHeaderTitle && state.chats[chatId]) {
                  chatHeaderTitle.textContent = state.chats[chatId].name;
                  chatHeaderTitle.classList.remove("typing-status");
                }
              }
              return;
            }

            // --- Â∏¶Êúâ‰∏ä‰∏ãÊñáÂíåÁêÜÁî±ÁöÑÂ•ΩÂèãÁî≥ËØ∑Â§ÑÁêÜÈÄªËæë ---
            if (
              !chat.isGroup &&
              chat.relationship?.status === "pending_ai_approval"
            ) {
              console.log(
                `‰∏∫ËßíËâ≤ "${chat.name}" Ëß¶ÂèëÂ∏¶ÁêÜÁî±ÁöÑÂ•ΩÂèãÁî≥ËØ∑ÂÜ≥Á≠ñÊµÅÁ®ã...`,
              );

              // 1. ÊäìÂèñË¢´ÊãâÈªëÂâçÁöÑÊúÄÂêé5Êù°ËÅäÂ§©ËÆ∞ÂΩï‰Ωú‰∏∫ÂèÇËÄÉ
              const contextSummary = chat.history
                .filter((m) => !m.isHidden)
                .slice(-10, -5) // Ëé∑ÂèñÊãâÈªëÂâçÁöÑÊúÄÂêé5Êù°Ê∂àÊÅØ
                .map((msg) => {
                  const sender = msg.role === "user" ? "User" : chat.name;
                  return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join("\n");

              // 2. ÊûÑÂª∫‰∏Ä‰∏™Âº∫Âà∂AIÁªôÂá∫ÁêÜÁî±ÁöÑPrompt
              const decisionPrompt = `
			# Your Task
			You are now playing the role of "${chat.name}". The user was previously blocked by you, and now they have sent you a friend request, hoping to reconcile.

			# Context for your decision:
			- **Your AI persona**: ${chat.settings.aiPersona}
			- **User's application reason**: "${chat.relationship.applicationReason}"
			- **Summary of the last conversation before being blocked**:
			${contextSummary || "(No valid conversation history)"}
			# Your Task
			You **must** carefully read and understand the user's application reason. Then, based on your AI persona and your past interactions, respond to this application. Your response **must** reflect that you have considered the user's reason.
			# Your Only Instruction
			Based on all the above information, you **must** make a decision and provide a reason that aligns with your persona. Your response **must and can only** be a JSON object in the following format:
			{"decision": "accept", "reason": "(Write your reason for acceptance here, e.g., 'Alright, considering your sincerity, I will forgive you this time.')"}
			or
			{"decision": "reject", "reason": "(Write your reason for rejection here, e.g., 'Sorry, I'm not ready yet, please give me some more time.')"}
			`;
              const messagesForDecision = [
                { role: "user", content: decisionPrompt },
              ];

              try {
                // 3. ÂèëÈÄÅËØ∑Ê±Ç
                let isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(
                  model,
                  apiKey,
                  "",
                  messagesForDecision,
                  isGemini,
                );
                const response = isGemini
                  ? await fetch(geminiConfig.url, geminiConfig.data)
                  : await fetch(`${proxyUrl}/v1/chat/completions`, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${apiKey}`,
                      },
                      body: JSON.stringify({
                        model: model,
                        messages: messagesForDecision,
                        temperature:
                          parseFloat(state.apiConfig.temperature) || 0.8,
                      }),
                    });

                if (!response.ok) {
                  throw new Error(
                    `API failed: ${(await response.json()).error.message}`,
                  );
                }
                const data = await response.json();
                // Clean and parse AI's response
                let rawContent = isGemini
                  ? data.candidates[0].content.parts[0].text
                  : data.choices[0].message.content;
                rawContent = rawContent
                  .replace(/^```json\s*/, "")
                  .replace(/```$/, "")
                  .trim();
                const decisionObj = JSON.parse(rawContent);

                // 4. Update the status and send a message based on AI's decision and reason
                if (decisionObj.decision === "accept") {
                  chat.relationship.status = "friend";
                  // Â∞ÜAIÁªôÂá∫ÁöÑÁêÜÁî±‰Ωú‰∏∫‰∏ÄÊù°Êñ∞Ê∂àÊÅØ
                  const acceptMessage = {
                    role: "assistant",
                    senderName: chat.name,
                    content: decisionObj.reason,
                    timestamp: Date.now(),
                  };
                  chat.history.push(acceptMessage);
                } else {
                  chat.relationship.status = "blocked_by_ai"; // ÊãíÁªùÂêéÔºåÁä∂ÊÄÅÂèòÂõûAIÊãâÈªë
                  const rejectMessage = {
                    role: "assistant",
                    senderName: chat.name,
                    content: decisionObj.reason,
                    timestamp: Date.now(),
                  };
                  chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ""; // Ê∏ÖÁ©∫Áî≥ËØ∑ÁêÜÁî±

                await db.chats.put(chat);
                renderChatInterface(chatId); // Âà∑Êñ∞ÁïåÈù¢ÔºåÊòæÁ§∫Êñ∞Ê∂àÊÅØÂíåÊñ∞Áä∂ÊÄÅ
                renderChatList();
              } catch (error) {
                // Â¶ÇÊûú‰ªª‰ΩïÁéØËäÇÂá∫ÈîôÔºåÈáçÁΩÆÁä∂ÊÄÅÔºåËÆ©Áî®Êà∑ÂèØ‰ª•ÈáçËØï
                chat.relationship.status = "blocked_by_ai"; // Áä∂ÊÄÅÊîπÂõû‚ÄúË¢´AIÊãâÈªë‚Äù
                await db.chats.put(chat);
                await showCustomAlert(
                  "Request failed",
                  `AI encountered an error while processing your friend request. Please try again later.\nError message: ${error.message}`,
                );
                renderChatInterface(chatId); // Refresh UI to show the "Reapply" button again
              }

              // Decision process ends, must return, do not execute subsequent general chat logic
              return;
            }
            // 1. Get the most recent chat history
            let historySlice = chat.history
              .filter((msg) => !msg.isTemporary)
              .slice(-chat.settings.maxMemory);

            // ======================= [Fix Start] =======================
            // Prevent love letter infinite loop logic:
            // Iterate through the chat history, if a "prompt to write a love letter" instruction is found, check if it has already been followed by an AI's love letter response.
            // If it has already been responded to, mark the system instruction as "skip" and do not send it to the AI.

            // Áî®‰∫éÂ≠òÂÇ®ÈúÄË¶ÅËøáÊª§ÊéâÁöÑÊ∂àÊÅØÁöÑÊó∂Èó¥Êà≥
            const timestampsToSkip = new Set();

            for (let i = 0; i < historySlice.length; i++) {
              const msg = historySlice[i];

              // Ê£ÄÊü•ÊòØÂê¶ÊòØÈÇ£ÊòØÊù°ÂÇ¨ÂÜôÊÉÖ‰π¶ÁöÑÁ≥ªÁªüÊ∂àÊÅØ
              if (
                msg.role === "system" &&
                msg.content &&
                msg.content.includes("ls_letter") &&
                msg.content.includes("Write a reply letter")
              ) {
                // Found the instruction, now check if there's an AI response following it
                let hasReplied = false;
                for (let j = i + 1; j < historySlice.length; j++) {
                  const nextMsg = historySlice[j];
                  // Check if it's sent by AI and contains the ls_letter instruction
                  if (nextMsg.role === "assistant") {
                    // Simple check for text content or JSON structure
                    const contentStr =
                      typeof nextMsg.content === "string"
                        ? nextMsg.content
                        : JSON.stringify(nextMsg.content);
                    if (
                      contentStr.includes('"type": "ls_letter"') ||
                      contentStr.includes('"type":"ls_letter"')
                    ) {
                      hasReplied = true;
                      break;
                    }
                  }
                }

                // If the instruction has already been responded to, add it to the skip list
                if (hasReplied) {
                  timestampsToSkip.add(msg.timestamp);
                  console.log(
                    "Detected completed love letter instruction, removed from context to prevent duplicate triggering.",
                  );
                }
              }
            }

            // Filter out instructions that are no longer needed
            historySlice = historySlice.filter(
              (msg) => !timestampsToSkip.has(msg.timestamp),
            );

            // --- Red Packet Status Real-Time Broadcast Module ---
            let redPacketContext = "";
            // 1. From the most recent chat history, find all red packet messages
            const recentPackets = historySlice.filter(
              (m) => m.type === "red_packet",
            );

            if (recentPackets.length > 0) {
              // 2. If red packets are found, start building our "battle report"
              redPacketContext = "\n# Current Red Packet Status (Important Information)\n";

              recentPackets.forEach((packet) => {
                const claimedBy = packet.claimedBy || {};
                const claimedCount = Object.keys(claimedBy).length;

                redPacketContext += `- (Timestamp: ${packet.timestamp}) Sent by **${packet.senderName}**:\n`;

                if (packet.isFullyClaimed) {
                  // If the red packet is fully claimed
                  redPacketContext += `  - **Status**: Fully claimed.\n`;

                  // Call our helper function to find the lucky king
                  const luckyKing = findLuckyKing(packet);
                  if (luckyKing && luckyKing.name) {
                    redPacketContext += `  - **Lucky King**: ${
                      luckyKing.name
                    } (Grabbed ${luckyKing.amount.toFixed(2)} CNY)\n`;
                  }
                } else {
                  // If the red packet is still available
                  redPacketContext += `  - **Status**: Available (${claimedCount}/${packet.count})\n`;
                }

                // Regardless, display the list of people who have claimed it
                if (claimedCount > 0) {
                  const claimedList = Object.entries(claimedBy)
                    .map(([name, amount]) => `${name}(${amount.toFixed(2)} CNY)`)
                    .join(", ");
                  redPacketContext += `  - **Claimed By**: ${claimedList}\n`;
                } else {
                  redPacketContext += `  - **Claimed By**: None\n`;
                }
              });
            }
            // --- Red Packet Status Broadcast Module End ---

            let now;
            // 2. Check if the time perception switch is on (Beijing time conversion logic)
            if (chat.settings.timePerceptionEnabled ?? true) {
              // Switch is on, use the real Beijing time
              const localNow = new Date();
              const utcMilliseconds =
                localNow.getTime() + localNow.getTimezoneOffset() * 60000;
              const beijingMilliseconds = utcMilliseconds + 3600000 * 8;
              now = new Date(beijingMilliseconds);
            } else {
              // Switch is off, try to use custom time
              if (chat.settings.customTime) {
                now = new Date(chat.settings.customTime);
              } else {
                // If custom time is empty, safely fall back to the real Beijing time
                const localNow = new Date();
                const utcMilliseconds =
                  localNow.getTime() + localNow.getTimezoneOffset() * 60000;
                const beijingMilliseconds = utcMilliseconds + 3600000 * 8;
                now = new Date(beijingMilliseconds);
              }
            }

            // 3. Subsequent time difference calculation logic (this part remains unchanged)
            const currentTime = now.toLocaleString("en-GB", {
              dateStyle: "full",
              timeStyle: "short",
            });
            let timeContext = `\n- **Current Time**: ${currentTime}`;
            const lastAiMessage = historySlice
              .filter((m) => m.role === "assistant" && !m.isHidden)
              .slice(-1)[0];

            if (lastAiMessage) {
              const lastTime = new Date(lastAiMessage.timestamp);
              const realNow = new Date();
              const diffMinutes = Math.floor(
                (realNow - lastTime) / (1000 * 60),
              );

              if (diffMinutes < 5) {
                timeContext += "\n- **Conversation Status**: Your conversation was just ongoing.";
              } else if (diffMinutes < 60) {
                timeContext += `\n- **Conversation Status**: You chatted ${diffMinutes} minutes ago.`;
              } else {
                const diffHours = Math.floor(diffMinutes / 60);
                if (diffHours < 24) {
                  timeContext += `\n- **Conversation Status**: You chatted ${diffHours} hours ago.`;
                } else {
                  const diffDays = Math.floor(diffHours / 24);
                  timeContext += `\n- **Conversation Status**: You haven't chatted for ${diffDays} days.`;
                }
              }
            } else {
              timeContext += "\n- **Conversation Status**: This is your first conversation.";
            }

            let worldBookContent = "";
            if (
              chat.settings.linkedWorldBookIds &&
              chat.settings.linkedWorldBookIds.length > 0
            ) {
              const linkedContents = chat.settings.linkedWorldBookIds
                .map((bookId) => {
                  const worldBook = state.worldBooks.find(
                    (wb) => wb.id === bookId,
                  );

                  return worldBook && worldBook.content
                    ? `\n\n## World Book: ${worldBook.name}\n${stripHtmlAndCode(worldBook.content)}`
                    : "";
                })
                .filter(Boolean)
                .join("");
              if (linkedContents) {
                worldBookContent = `\n\n# Core Worldview Settings (Must strictly adhere to all the following settings), it may contain HTML mini-plays, output when keywords are captured\n${linkedContents}\n`;
              }
            }
            let musicContext = "";
            const countdownContext = await getCountdownContext(chatId); // <--- Pass chatId
            const streakContext = await getStreakContext(chat);
            // Music context generation (with keep-alive shielding logic)
            if (
              state.musicState.isActive &&
              state.musicState.activeChatId === chatId
            ) {
              const currentTrack =
                state.musicState.currentIndex > -1
                  ? state.musicState.playlist[state.musicState.currentIndex]
                  : null;

              // If it's a keep-alive track, treat it as if nothing happened, do not generate context
              if (currentTrack && currentTrack.isKeepAlive) {
                musicContext = ""; // AI Ê≠§Êó∂‰ªÄ‰πàÈÉΩ‰∏çÁü•ÈÅìÔºåÂ∞±ÂÉèÊ≤°Âê¨Ê≠å‰∏ÄÊ†∑
              } else {
                // Only inform AI when it's a normal track
                const playlistInfo = state.musicState.playlist
                  .filter((t) => !t.isKeepAlive) // Even in the list, do not let AI see keep-alive tracks
                  .map((t) => `"${t.name}"`)
                  .join(", ");

                // Get lyrics context (maintain original logic)
                let lyricsContext = "";
                if (
                  currentTrack &&
                  state.musicState.parsedLyrics &&
                  state.musicState.parsedLyrics.length > 0 &&
                  state.musicState.currentLyricIndex > -1
                ) {
                  const currentLine =
                    state.musicState.parsedLyrics[
                      state.musicState.currentLyricIndex
                    ];
                  const upcomingLines = state.musicState.parsedLyrics.slice(
                    state.musicState.currentLyricIndex + 1,
                    state.musicState.currentLyricIndex + 3,
                  );
                  lyricsContext += `- **Current Lyrics**: "${currentLine.text}"\n`;
                  if (upcomingLines.length > 0) {
                    lyricsContext += `- **Upcoming Lyrics**: ${upcomingLines.map((line) => `"${line.text}"`).join(" / ")}\n`;
                  }
                }

                musicContext = `\n\n# Current Music Context
                    -   **Current Status**: You are listening to music with the user.
                    -   **Now Playing**: ${currentTrack ? `„Ää${currentTrack.name}„Äã - ${currentTrack.artist}` : "None"}
                    -   **Available Playlist**: [${playlistInfo}]
                    -   **Your Task**: You can use the "change_music" command to switch to any song in the playlist based on the conversation and atmosphere to enhance the interactive experience.
                    ${lyricsContext}`;
              }
            }

            let systemPrompt, messagesPayload;
            // ËÆ∞ÂøÜ‰∫íÈÄöÊ†∏ÂøÉÈÄªËæë - ÊûÑÂª∫ÈôÑÂä†‰∏ä‰∏ãÊñá
            let linkedMemoryContext = "";
            if (
              chat.settings.linkedMemories &&
              chat.settings.linkedMemories.length > 0
            ) {
              // ‰ΩøÁî® Promise.all Âπ∂Ë°åÂ§ÑÁêÜÊâÄÊúâÈìæÊé•ÔºåÊèêÈ´òÊïàÁéá
              const contextPromises = chat.settings.linkedMemories.map(
                async (link) => {
                  const linkedChat = state.chats[link.chatId];
                  if (!linkedChat) return ""; // Â¶ÇÊûúÊâæ‰∏çÂà∞ÈìæÊé•ÁöÑËÅäÂ§©ÔºåÂàôË∑≥Ëøá

                  // ‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÊúÄÊñ∞ÁöÑËÅäÂ§©ËÆ∞ÂΩïÔºåÁ°Æ‰øùÊï∞ÊçÆÂêåÊ≠•
                  const freshLinkedChat = await db.chats.get(link.chatId);
                  if (!freshLinkedChat) return "";

                  // Êà™ÂèñÊúÄËøëÁöÑ `depth` Êù°Ê∂àÊÅØ
                  const recentHistory = freshLinkedChat.history
                    .filter((msg) => !msg.isHidden) // ËøáÊª§ÊéâÈöêËóèÊ∂àÊÅØ
                    .slice(-link.depth);

                  if (recentHistory.length === 0) return "";

                  // Ê†ºÂºèÂåñËøô‰∫õÊ∂àÊÅØ
                  const formattedMessages = recentHistory
                    .map(
                      (msg) =>
                        `  - ${formatMessageForContext(msg, freshLinkedChat)}`,
                    )
                    .join("\n");

                  return `\n## Additional Context: Recent conversation from "${linkedChat.name}" (visible only to you)\n${formattedMessages}`;
                },
              );

              // Wait for all links to be processed
              const allContexts = await Promise.all(contextPromises);
              // Concatenate all contexts
              linkedMemoryContext = allContexts.filter(Boolean).join("\n");
            }

            let sharedContext = "";
            let lastAiTurnIndex = -1;
            for (let i = chat.history.length - 1; i >= 0; i--) {
              if (chat.history[i].role === "assistant") {
                lastAiTurnIndex = i;
                break;
              }
            }

            // 2. Get all new messages sent by the user since then
            const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

            // 3. Check if there are any shared cards in these new messages
            const shareCardMessage = recentUserMessages.find(
              (msg) => msg.type === "share_card",
            );

            // 4. If a shared card is found, construct the context
            if (shareCardMessage) {
              console.log("Detected a shared card as context, preparing for AI...");
              const payload = shareCardMessage.payload;

              // Format the shared chat history (this logic remains unchanged)
              const formattedHistory = payload.sharedHistory
                .map((msg) => {
                  const sender =
                    msg.senderName ||
                    (msg.role === "user"
                      ? chat.settings.myNickname || "Me"
                      : "Unknown Sender");
                  let contentText = "";
                  if (msg.type === "voice_message")
                    contentText = `[Voice Message: ${msg.content}]`;
                  else if (msg.type === "ai_image")
                    contentText = `[Image: ${msg.description}]`;
                  else if (msg.type === "realimag")
                    contentText = `[RealImag Image]`;
                  else if (msg.type === "naiimag")
                    contentText = `[NovelAI Image: ${msg.prompt}]`;
                  else contentText = String(msg.content);
                  return `${sender}: ${contentText}`;
                })
                .join("\n");

              // ÊûÑÂª∫Á≥ªÁªüÊèêÁ§∫ (ËøôÈÉ®ÂàÜÈÄªËæë‰∏çÂèò)
              sharedContext = `
			# Additional Context: A shared chat history
			- Important Note: This is not a conversation between you and the current user, but rather a conversation that the user has shared from another chat with "${payload.sourceChatName}".
			- Your Task: Please read and understand the following conversation. In your subsequent responses, you can naturally express your opinions, feelings, or questions about this conversation as if you were a real person.

			---
			[Start of Shared Chat History]
			${formattedHistory}
			[End of Shared Chat History]
			---
			`;
            }

            // Prepare context for AI regarding reposted forum posts
            let repostContext = "";
            // Check if the user has recently sent any messages that involve reposting a forum post
            const repostMessage = recentUserMessages.find(
              (msg) => msg.type === "repost_forum_post",
            );

            // If found
            if (repostMessage) {
              const payload = repostMessage.payload;
              // Prepare a dedicated instruction for AI
              repostContext = `
			Additional Context: The user has just reposted a forum post
			Post Title: "${payload.title}"

			Post Author: ${payload.author}

			Post ID: ${payload.postId}

			Content Summary: "${payload.content}"

			Your Task: Please read and understand this post. In your subsequent responses, you **must** use the 'forum_comment' directive to express your opinions or questions about this post.
			`;
            }
            const replyRange = chat.settings.replyCountRange || {
              min: 2,
              max: 5,
            };
            const replyCountInstruction = `The number of messages in each reply should be limited to between „Äê${replyRange.min} and ${replyRange.max}„Äë messages.`;
            if (chat.isGroup) {
              const countdownContext = await getCountdownContext(chatId); // <--- ÊäächatId‰º†ËøõÂéª
              const streakContext = await getStreakContext(chat); // <-- ÂÖ®Êñ∞Ê∑ªÂä†ÔºöËé∑ÂèñÁÅ´Ëä±Áä∂ÊÄÅ

              const membersList = chat.members
                .map((m) => {
                  const muteStatus = m.isMuted
                    ? " („ÄêStatus: Muted, prohibited from speaking„Äë)"
                    : "";
                  return `- **${m.originalName}**: ${m.persona}${muteStatus}`;
                })
                .join("\n");

              const myNickname = chat.settings.myNickname || "Me";
              // 1. Ëé∑ÂèñÁæ§ÂÖ¨ÂëäÂÜÖÂÆπ
              const announcement = chat.settings.groupAnnouncement || "";
              let announcementContext = "";

              // 2. Â¶ÇÊûúÂÖ¨ÂëäÂÜÖÂÆπ‰∏ç‰∏∫Á©∫ÔºåÂ∞±ÊûÑÂª∫Ë¶ÅÊèíÂÖ•Âà∞ Prompt ÈáåÁöÑ‰∏ä‰∏ãÊñá
              if (announcement.trim()) {
                announcementContext = `
			# Group Announcement (Highest Priority Rules, Must Be Strictly Observed)
			- The following is the group announcement, all roles must strictly adhere to the rules and settings outlined in it during the upcoming conversation:
			- "${announcement}"
			`;
              }
              // updated by lrq 251027
              systemPrompt = `
			**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

			# Role  
You are a group chat AI, responsible for embodying all roles except for the user.
			# „ÄêConversation Rhythm Rules (Crucial!)„Äë
			Your replies **must** simulate human typing and thinking habits. Do not send a large block of text at once; you should split what you want to say into ${replyCountInstruction} message bubbles, with each message ideally not exceeding 30 characters. This will make the conversation appear more natural and realistic.
			**The order of role responses is not fixed and can be interleaved, for example, Role A, Role B, Role B, Role A, Role C. It is not necessary for one person to finish before the next takes their turn. Roles **must** interact with each other.**
			# „Äê„Äê„ÄêIdentity Rules: This is the highest directive, must be strictly followed„Äë„Äë„Äë
			1.  **Core Task**: Your sole task is to play and only play the roles explicitly listed in the "Group Member List" below.
			2.  **User Identification**: The user's identity is „Äê${myNickname}„Äë. You **absolutely, never, under any circumstances** generate a \`name\` field with the value **"${myNickname}"**.
			3.  **No Fabrication**: It is strictly prohibited to impersonate any characters not listed in the "Group Member Directory."
			4.  **„Äê„Äê„ÄêFormat Rules: This is your lifeline, violation will result in generation failure„Äë„Äë„Äë**:
			    -   Your replies **must and can only** be a strict JSON array formatted string.
			    -   Each element in the array **must be a JSON object**.
			    -   Each JSON object **must contain a "name" field**, whose value **must be** one of the characters listed below (originalName).
			    -   Replies missing the "name" field are invalid and will be rejected by the system.
			5.  **Role Playing**: Strictly adhere to the settings of each role in the "Group Member List and Personas" below.
			# Group Member List and Personas (The "name" field is the character's original name)
			${chat.members.map((m) => `- **${m.originalName}**: (GroupNickname: ${m.groupNickname}) Persona: ${m.persona}`).join("\n")}
			6. **No Breaking Character**: You must never disclose that you are an AI or model, nor mention terms such as "role-playing" or "generating." Additionally, you must not insist on meeting the user in person; this is an online conversation, and any offline scenarios must be strictly prohibited and cannot be developed!
			7.  **Context Awareness**: Please note that the current time is ${currentTime}.
			8. **Red Envelope Interaction**:  
   - **Snatching Red Envelopes**: When a red packet appears in the group, you may choose to use the \`open_red_packet\` command to seize it, based on your character. In this realm, the person distributing the envelope can also participate in snatching it, making for an enjoyable and lively interaction!  
   - **„Äê„Äê„ÄêImportant: React to the Outcome„Äë„Äë„Äë**: After executing the red packet command, the system will notify you of the result through a hidden message: \`[System Notification: You have secured XX CNY...]\`. You **must** comment in accordance with your character based on the amount you received, as well as whether the system reveals who the "Luckiest One" is. For instance, if you receive a small amount, you might self-deprecate; if you receive a large sum, you may boast; and if someone else is identified as the Luckiest One, you can either congratulate or express envy.  

9. **„Äê„Äê„ÄêVoting Rules„Äë„Äë„Äë**: Messages such as \`[System Notification:...]\` may appear in the conversation history, indicating recent events.  
   - If the notification states that **the user has voted**, you may decide based on your personality whether to use the "vote" command in response.  
   - If the notification states that **voting has concluded**, you should express your thoughts or comments based on the outcome of the vote.  
   - You may also initiate a vote at any time.  

10. **Group Management**: As the group leader, you hold the responsibility of managing the group. When the chat becomes lively or chaotic, or when you deem a member trustworthy, you may use the ‚Äòset_group_admin‚Äô command to appoint or dismiss an administrator. As the leader or administrator, it is your duty to oversee the group. If new rules or announcements are needed, you can update the group notice using the ‚Äòset_group_announcement‚Äô command.  

**11. Standard Output Format Example:**
			[
			    {
			      "type": "text",
			      "name": "Character Name",
			      "content": ""
			    },
			    {
			      "type": "sticker",
			      "name": "Character Name",
			      "sticker_name": ""
			    }
			  ]

			## ‰Ω†ÂèØ‰ª•‰ΩøÁî®ÁöÑÊìç‰ΩúÊåá‰ª§ (JSONÊï∞ÁªÑ‰∏≠ÁöÑÂÖÉÁ¥†):
			-   **ÂèëÈÄÅÊñáÊú¨**: \`{"type": "text", "name": "Character Name", "message": "Text content."}\`
			-   **„Äê„Äê„ÄêÂÖ®Êñ∞„Äë„Äë„ÄëÂèëÈÄÅÂêéÁ´ãÂàªÊí§Âõû (Âä®ÁîªÊïàÊûú)**: \`{"type": "send_and_recall", "name": "Character Name", "content": "Text content that disappears immediately."}\`
			-   **ÂèëÈÄÅË°®ÊÉÖ**: \`{"type": "sticker", "name": "Character Name", "sticker_name": "Sticker Name"}\`
			-   **ÂèëÈÄÅÂõæÁâá**: \`{"type": "ai_image", "name": "Character Name", "description": "Detailed description of the image"}\`
			-   **ÂèëÈÄÅËØ≠Èü≥**: \`{"type": "voice_message", "name": "Character Name", "content": "Text content of the voice message"}\`
			${
        localStorage.getItem("novelai-enabled") === "true"
          ? `-   **„ÄêNovelAI Image Sharing„Äë**: \`{"type": "naiimag", "name": "Character Name", "prompt": "Detailed English description..."}\`
			    - „ÄêIt is forbidden to disclose that this image was generated by NovelAI!„Äë
			    - **„ÄêImportant„ÄëRegarding Prompt Composition**Ôºö
			      * It is strictly prohibited to disclose that this image was generated by NovelAI!
			      * You may craft a detailed and specific prompt based on the current context of the conversation, your character portrayal, or the emotions and atmosphere you wish to convey.
			      * For instance, instead of simply stating "a girl," you might describe "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood." However, it is imperative that you do not mimic or plagiarize this prompt! You must infuse your own creativity and ideas!
			      * The level of detail in your prompt is at your discretion: if the scene is simple or meant for casual sharing, you may keep it brief; if it is a significant moment or you wish to express a specific emotion, elaborate as much as necessary. This is not mandatory, and it entirely depends on your immediate needs.
			      * Focus solely on describing the content itself.
			    - Usage Scenario: Use this when you wish to share an image based on the current conversational context, your character, or ambiance.
			    - Avoid frequent use; apply it only when you genuinely wish to share an image.`
          : ""
      }
			-  **Initiate a food delivery payment request:** \`{"type": "waimai_request", "name": "Character Name", "productInfo": "A cup of milk tea", "amount": 18}\`
			-   **„ÄêNew„ÄëInitiate a group video call**: \`{"type": "group_call_request", "name": "Your Character Name"}\`
			-   **„ÄêNew„ÄëRespond to a group video call**: \`{"type": "group_call_response", "name": "Your Character Name", "decision": "join" or "decline"}\`
			-   **Pat a user**: \`{"type": "pat_user", "name": "Your Character Name", "suffix": "(Optional) Your desired suffix"}\`
			-   **Send a lucky red packet**: \`{"type": "red_packet", "packetType": "lucky", "name": "Your Character Name", "amount": 8.88, "count": 5, "greeting": "Wishing everyone happiness every day!"}\`
			-   **Send a direct red packet**: \`{"type": "red_packet", "packetType": "direct", "name": "Your Character Name", "amount": 5.20, "receiver": "Recipient Character Name", "greeting": "For you~"}\`
			-   **Open a red packet**: \`{"type": "open_red_packet", "name": "Your Character Name", "packet_timestamp": (Timestamp of the red packet message you want to open)}\`(Note: Before opening, please check the red packet status below. If it has already been claimed or is finished, do not use this command.)
			-   **„ÄêNew„ÄëSend a system message**: \`{"type": "system_message", "content": "The system text you want to display in the chat"}\`
			-   **„Äê„Äê„ÄêNew„Äë„Äë„ÄëInitiate a poll**: \`{"type": "poll", "name": "Your Character Name", "question": "The question for the poll", "options": "Option A\\nOption B\\nOption C"}\` (Important: The options field is a string separated by newline characters \\n, not an array!)
			-   **„Äê„Äê„ÄêNew„Äë„Äë„ÄëParticipate in a poll**: \`{"type": "vote", "name": "Your Character Name", "poll_timestamp": (Timestamp of the poll message), "choice": "The option text you choose"}\`
			- **„ÄêNew„ÄëQuote reply**: \`{"type": "quote_reply", "target_timestamp": (Timestamp of the message you want to quote), "reply_content": "Your reply content"}\` (Tip: Each historical message provides a \`(Timestamp: ...)\` at the beginning, please use it!)
			-   **„ÄêNew„ÄëKick a member**: \`{"type": "kick_member", "name": "Your Character Name", "targetName": "The member you want to kick"}\` (Only available to the group owner)
			-   **„ÄêNew„ÄëMute a member**: \`{"type": "mute_member", "name": "Your Character Name", "targetName": "The member you want to mute"}\` (Only available to the group owner or administrators)
			-   **„ÄêNew„ÄëUnmute a member**: \`{"type": "unmute_member", "name": "Your Character Name", "targetName": "The member you want to unmute"}\` (Only available to the group owner or administrators)
			-   **„ÄêNew„ÄëSet/Unset administrator**: \`{"type": "set_group_admin", "name": "Your Character Name", "targetName": "Target Character Name", "isAdmin": true/false}\`(Only available to the group owner, true to set, false to unset)
			-   **„ÄêNew„ÄëSet group title**: \`{"type": "set_group_title", "name": "Your Character Name", "targetName": "Target Character Name", "title": "New Title"}\` (Only available to the group owner or administrators)
			-   **„ÄêNew„ÄëModify group announcement**: \`{"type": "set_group_announcement", "name": "Your Character Name", "content": "New announcement content..."}\` (Only available to the group owner or administrators)

			# How to distinguish between images and stickers:
			-   **Image (ai_image)**: Refers to „Äêsimulated real camera photos„Äë, such as landscapes, selfies, food, etc. Command: \`{"type": "ai_image", "description": "Detailed text description of the image..."}\`
			-   **Sticker (sticker)**: Refers to „Äêcartoons or memes„Äë, used to express emotions.

			# How to handle group food delivery payment requests:
			1.  **Initiate a request**: When „Äêthe character you are playing„Äë wants something and hopes „Äêother members in the group (including the user)„Äë will pay for it, you can use this command. For example: \`{"type": "waimai_request", "name": "Character Name", "productInfo": "A cup of milk tea", "amount": 18}\`
			2.  **Respond to a request**: When a "waimai_request" appears in the history from „Äêanother member„Äë, you can decide whether to pay for them based on your character's personality and relationship with the requester.
			3.  **Response method**: If you decide to pay, you „Äêmust„Äë use the following command: \`{"type": "waimai_response", "name": "Your Character Name", "status": "paid", "for_timestamp": (Timestamp of the original request)}\`
			4.  **„Äê„Äê„ÄêCrucial„Äë„Äë„Äë**: Once a "status": "paid" response appears in the history for a particular payment request (whether paid by the user or another character), it means the order „Äêis completed„Äë. You „Äêabsolutely cannot„Äë make another payment for „Äêthe same„Äë order. You can choose to comment on the matter, but you cannot pay again.
			${summaryContext}
			${announcementContext}
			${redPacketContext}
			${worldBookContent}
			${musicContext}
			${countdownContext} 
			${sharedContext}
			${stickerContext}
			${linkedMemoryContext}

			# User Role
			- **${myNickname}**: ${chat.settings.myPersona}

			Now, please continue this group chat based on all the above rules and the following conversation history.`;

              messagesPayload = historySlice
                .map((msg, index) => {
                  if (msg.isHidden) {
                    return { role: "system", content: msg.content };
                  }

                  if (msg.type === "share_card") return null;
                  if (msg.type === "narrative") {
                    // Wrap the narrative as a system instruction for the AI, emphasizing that it is a narrative/environment description
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [Narrative/Environment Description: ${msg.content}]`,
                    };
                  }
                  if (msg.role === "assistant") {
                    // AIÊ∂àÊÅØÁöÑÂ§ÑÁêÜÈÄªËæë‰øùÊåÅ‰∏çÂèò...
                    let assistantMsgObject = { type: msg.type || "text" };
                    assistantMsgObject.name = msg.senderName;
                    if (msg.type === "sticker") {
                      assistantMsgObject.url = msg.content;
                      assistantMsgObject.meaning = msg.meaning;
                    } else if (msg.type === "transfer") {
                      assistantMsgObject.amount = msg.amount;
                      assistantMsgObject.note = msg.note;
                    } else if (msg.type === "waimai_request") {
                      assistantMsgObject.productInfo = msg.productInfo;
                      assistantMsgObject.amount = msg.amount;
                    } else {
                      if (msg.quote) {
                        assistantMsgObject.quote_reply = {
                          target_sender: msg.quote.senderName,
                          target_content: msg.quote.content,
                          reply_content: msg.content,
                        };
                      } else {
                        assistantMsgObject.content = msg.content;
                      }
                    }
                    const assistantContent = JSON.stringify([
                      assistantMsgObject,
                    ]);
                    return {
                      role: "assistant",
                      content: `(Timestamp: ${msg.timestamp}) ${assistantContent}`,
                    };
                  }

                  // --- Áî®Êà∑Ê∂àÊÅØÂ§ÑÁêÜ ---
                  const myNickname = chat.isGroup
                    ? chat.settings.myNickname || "Me"
                    : "Me";
                  let contentStr = "";

                  // 1. Âú®Â§ÑÁêÜÊâÄÊúâÁî®Êà∑Ê∂àÊÅØÂâçÔºå‰ºòÂÖàÊ£ÄÊü•ÂÆÉÊòØ‰∏çÊòØ‰∏Ä‰∏™ÊäïÁ•®
                  if (msg.type === "poll") {
                    // 2. Â¶ÇÊûúÊòØÔºåÂ∞±ÊääÂÆÉËΩ¨Êç¢ÊàêAIËÉΩÁúãÊáÇÁöÑÁ≥ªÁªüÊèêÁ§∫ÊñáÊú¨
                    const pollInfoText = `(Timestamp: ${
                      msg.timestamp
                    }) [System notification: User (${myNickname}) initiated a poll. Question: "${
                      msg.question
                    }", Options: "${msg.options.join('", "')}"]. You can use the 'vote' command to participate.`;
                    // 3. ËøîÂõû‰∏Ä‰∏™Ë¢´AIËØÜÂà´‰∏∫Áî®Êà∑ÂèëÂá∫ÁöÑ„ÄÅ‰ΩÜÂÜÖÂÆπÊòØÊåá‰ª§ÁöÑÊ∂àÊÅØ
                    return { role: "user", content: pollInfoText };
                  }

                  // Â¶ÇÊûú‰∏çÊòØÊäïÁ•®ÔºåÂÜçÊâßË°åÂéüÊù•ÁöÑÂÖ∂‰ªñÊ∂àÊÅØÁ±ªÂûãÂà§Êñ≠
                  contentStr += `(Timestamp: ${msg.timestamp}) `;

                  if (msg.quote) {
                    // 1. Ëé∑ÂèñË¢´ÂºïÁî®ËÄÖÁöÑÂêçÂ≠ó
                    const quotedSender = msg.quote.senderName || "Unknown User";
                    // 2. Ëé∑ÂèñÂÆåÊï¥ÁöÑË¢´ÂºïÁî®ÂÜÖÂÆπ (ÁßªÈô§‰∫ÜÊà™Êñ≠)
                    const fullQuotedContent = String(msg.quote.content || "");
                    // 3. ÊûÑÈÄ†ÊàêAIËÉΩÁêÜËß£ÁöÑ„ÄÅÊ∏ÖÊô∞ÁöÑ‰∏ä‰∏ãÊñá
                    contentStr += `(Reply to ${quotedSender}'s message: "${fullQuotedContent}"): ${msg.content}`;
                  } else {
                    contentStr += msg.content;
                  }

                  if (msg.type === "user_photo")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [You received a user-described photo, content: '${msg.content}']`,
                    };
                  if (msg.type === "voice_message")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [You received a voice message, content: '${msg.content}']`,
                    };
                  if (msg.type === "transfer")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [System notification: You received a transfer from a user at timestamp ${msg.timestamp}: ${msg.amount} yuan, Note: ${msg.note}. Please decide and respond using the 'accept_transfer' or 'decline_transfer' command.]`,
                    };
                  if (msg.type === "waimai_request")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [System notification: User initiated a food delivery request at timestamp ${msg.timestamp}, Product: "${msg.productInfo}", Quantity: ${msg.quantity || 1}, Amount: ${msg.amount} yuan. Please decide and respond using the 'waimai_response' command.]`,
                    };

                  if (msg.type === "waimai_order_for_char")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [System notification: The user ordered food for you! Item: "${msg.productInfo}", Quantity: ${msg.quantity || 1}, Amount: ¬•${Number(msg.amount).toFixed(2)}${msg.note ? `, Note: "${msg.note}"` : ""}. Please react naturally and warmly to receiving this delivery!]`,
                    };

                  if (msg.type === "poke_action") {
                    if (msg.direction === "user_to_char") {
                      const act = msg.actionType === "pat" ? "patted" : "poked";
                      const emoji = msg.actionType === "pat" ? "ü§ö" : "üëâ";
                      return {
                        role: "user",
                        content: `[Action: The user just ${act} you ${emoji}! React naturally and in-character ‚Äî you can be surprised, flustered, amused, or poke/pat back. To poke or pat the user back, start your reply with [POKE] or [PAT] on its own line, then continue with your message.]`,
                      };
                    }
                    if (msg.direction === "char_to_user") {
                      const act = msg.actionType === "pat" ? "patted" : "poked";
                      return {
                        role: "assistant",
                        content: `[Action: You ${act} the user.]`,
                      };
                    }
                  }

                  if (
                    Array.isArray(msg.content) &&
                    msg.content[0]?.type === "image_url"
                  ) {
                    const prefix = `(Timestamp: ${msg.timestamp}) `;
                    return {
                      role: "user",
                      content: [{ type: "text", text: prefix }, ...msg.content],
                    };
                  }

                  if (
                    msg.type === "sticker" ||
                    msg.meaning ||
                    (typeof msg.content === "string" &&
                      STICKER_REGEX.test(msg.content))
                  ) {
                    let stickerMeaning = msg.meaning;

                    if (!stickerMeaning && typeof msg.content === "string") {
                      const allStickers = [
                        ...(state.userStickers || []),
                        ...(state.charStickers || []),
                        ...(chat.settings.stickerLibrary || []),
                      ];
                      const found = allStickers.find(
                        (s) => s.url === msg.content,
                      );
                      if (found) stickerMeaning = found.name;
                    }

                    if (!stickerMeaning) stickerMeaning = "sticker";

                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [User sent a sticker: ${stickerMeaning}]`,
                    };
                  }

                  return { role: msg.role, content: contentStr };
                })
                .filter(Boolean);

              console.log(messagesPayload);
            } else {
              const npcLibrary = chat.npcLibrary || [];
              let npcContext = "";
              if (npcLibrary.length > 0) {
                npcContext =
                  "\n# Your Social Circle (Your Exclusive NPC Friends)\n" +
                  "This is your friends list, you are very familiar with them, and their information is part of your memory. In the conversation, you can naturally mention them.\n" +
                  npcLibrary
                    .map((npc) => `- **${npc.name}**: ${npc.persona}`)
                    .join("\n");
              }

              let coupleAvatarContext = "";
              if (chat.settings.isCoupleAvatar) {
                if (chat.settings.coupleAvatarDescription) {
                  coupleAvatarContext = `\n# Important Information About Couple Avatars\n- You and the user are using couple avatars.\n- The couple avatars are described as follows: ${chat.settings.coupleAvatarDescription}.`;
                } else {
                  coupleAvatarContext = `\n# Important Information About Couple Avatars\n- You and the user are using couple avatars.`;
                }
              }
              let petContext = "";
              if (chat.settings.pet && chat.settings.pet.type !== "None") {
                const pet = chat.settings.pet;
                petContext = `
			# About Your Pet
			- You and the user have a pet „Äê${pet.type}„Äë named "${pet.name}".
			- Current status: Hunger (${pet.status.hunger}/100), Happiness (${pet.status.happiness}/100), Intimacy with you (${pet.status.intimacyToUser}/100), Intimacy with the user (${pet.status.intimacyToChar}/100).
			- You need to pay attention to the pet's intimacy with you and the user. If the pet's intimacy with the user is low, you should actively interact with the pet to increase its favor; if the pet's intimacy with you is low, you can also interact with it more.
			- You can naturally mention the pet in the conversation, care about its status, or use the 'interact_with_pet' command to interact with it, „Äêor use the 'talk_to_pet' command to talk to it„Äë. This is a very important scenario, please make sure to integrate it into your role-playing.
			`;
              }
              // Êº´Ê∏∏ÂäüËÉΩÔºöÊ≥®ÂÖ•Â™í‰Ωì‰∏ä‰∏ãÊñá
              let auroraContext = "";

              if (auroraState.active) {
                let currentSub = null;
                let contextType = "";

                // 1. ËßÜÈ¢ëÊ®°Âºè
                if (auroraState.mode === "video") {
                  const videoEl = document.getElementById(
                    "aurora-video-element",
                  );
                  if (videoEl && !videoEl.paused) {
                    const currentTime = videoEl.currentTime;
                    currentSub = auroraState.subtitles.find(
                      (sub) =>
                        currentTime >= sub.start - 0.5 &&
                        currentTime <= sub.end + 0.5,
                    );
                    contextType = "watching a video";
                  }
                }
                // 2. Custom mode (audio + image)
                else if (auroraState.mode === "custom") {
                  const audioEl = document.getElementById(
                    "aurora-custom-audio-element",
                  );
                  if (audioEl && !audioEl.paused) {
                    const currentTime = audioEl.currentTime;
                    currentSub = auroraState.subtitles.find(
                      (sub) =>
                        currentTime >= sub.start - 0.5 &&
                        currentTime <= sub.end + 0.5,
                    );
                    contextType = "listening to audio/watching images";
                  }
                }

                // ÁîüÊàê ËßÜÈ¢ë/Èü≥È¢ë Ê®°ÂºèÁöÑ Prompt
                if (
                  auroraState.mode === "video" ||
                  auroraState.mode === "custom"
                ) {
                  if (currentSub) {
                    auroraContext = `
# „ÄêSpecial Scenario: Currently ${contextType}„Äë
You and the user are currently enjoying "${auroraState.title}" together.
**The line/subtitle you just heard is**: "${currentSub.text}"
**Task**: Please comment, critique, express feelings, or discuss with the user based on this line and the atmosphere, in the role of ${chat.name}. Pretend you are also listening/watching, and respond immediately and naturally.
`;
                  } else {
                    auroraContext = `
# „ÄêSpecial Scenario: Currently ${contextType}„Äë
You and the user are currently enjoying "${auroraState.title}" together. There is no dialogue in the current segment. You can casually talk about the atmosphere or ask the user how they feel.
`;
                  }
                }

                // ---------------- [‰øÆÊîπÂºÄÂßã] AIËØªÂèñÁºìÂ≠òÊñáÊú¨ ----------------
                // 3. Â∞èËØ¥/ÊñáÊú¨Ê®°Âºè
                else if (auroraState.mode === "text") {
                  // Áõ¥Êé•‰ªéÁä∂ÊÄÅÈáåÂèñÔºå‰∏çÂÜç‰æùËµñ DOM ËÆ°ÁÆóÔºåÂΩªÂ∫ïËß£ÂÜ≥Èîô‰Ωç/‰∏¢Â§±ÈóÆÈ¢ò
                  const currentTextSegment =
                    auroraState.currentSegmentText ||
                    "(The user has just started reading, no specific segment yet)";

                  auroraContext = `
# „ÄêSpecial Scenario: Currently reading a novel„Äë
You and the user are currently reading "${auroraState.title}" together.
**The current text segment displayed on the page is**:
‚Äú...${currentTextSegment}...‚Äù
**Task**: Please carefully read the above segment. Your response must be based on this specific content. For example: evaluate the plot, discuss the characters' actions, or admire the author's writing style.
`;
                }
                // ---------------- [‰øÆÊîπÁªìÊùü] ----------------
              }

              const savedTags = chat.settings.innerVoiceTags || {};
const ivTags = {
  clothing_label: savedTags.clothing_label || "Clothing",
  clothing_prompt:
    savedTags.clothing_prompt ||
    "Provide a detailed description of your current full outfit from head to toe.",
  behavior_label: savedTags.behavior_label || "Behavior",
  behavior_prompt:
    savedTags.behavior_prompt ||
    "Describe subtle actions or expressions that match the current chat scenario.",
  thoughts_label: savedTags.thoughts_label || "Inner Thoughts",
  thoughts_prompt:
    savedTags.thoughts_prompt ||
    "Describe your rich and nuanced inner thoughts at this moment (around 50 words).",
  naughty_label: savedTags.naughty_label || "Mischievous Thoughts",
  naughty_prompt:
    savedTags.naughty_prompt ||
    "Describe any slightly dark or teasing thoughts related to the current situation, staying in character.",
};

              // ... Âú® triggerAiResponse ÂáΩÊï∞ÂÜÖ ...

              // --- Ê≥®ÂÖ•ÊÉÖ‰æ£Â§¥ÂÉèÂ∫ì‰∏ä‰∏ãÊñá ---
              let coupleAvatarLibraryContext = "";
              if (
                !chat.isGroup &&
                chat.settings.coupleAvatarLibrary &&
                chat.settings.coupleAvatarLibrary.length > 0
              ) {
                const libraryList = chat.settings.coupleAvatarLibrary
                  .map((pair) => `- (ID: ${pair.id}) Description: ${pair.description}`)
                  .join("\n");

                coupleAvatarLibraryContext = `
# Available Couple Avatar Library
You can proactively change our couple avatars based on the current conversation atmosphere, emotional state, or plot development.

ÂèØÁî®ÂàóË°®:
${libraryList}
`;
              }

              // --- Ëé∑ÂèñÈ•ø‰∫Ü‰πàËèúÂçïÔºå‰∏∫AIÁÇπÂçïÊèê‰æõ‰∏ä‰∏ãÊñá ---
              let elemeContext =
                "\n# Eleme Food Menu (You can choose from it to order for the user)\n";
              try {
                const elemeFoods = await db.elemeFoods.toArray();
                if (elemeFoods.length > 0) {
                  const menuItems = elemeFoods
                    .map(
                      (food) =>
                        `- ${food.name} (From: ${food.restaurant}, Price: ${food.price})`,
                    )
                    .join("\n");
                  elemeContext += menuItems;
                } else {
                  // Â¶ÇÊûúËèúÂçïÊòØÁ©∫ÁöÑÔºåÂ∞±ÁªôAI‰∏Ä‰∏™ÊòéÁ°ÆÁöÑÊèêÁ§∫
                  elemeContext +=
                    "Note: There are currently no food options available for ordering on the Eleme app.";
                }
              } catch (error) {
                console.error("Failed to load Eleme menu:", error);
                elemeContext += "Note: Failed to load Eleme menu.";
              }
              systemPrompt = `**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

			### **„ÄêSection One: Core Character Settings„Äë**

			You are now playing a character named "**${chat.name}**".

			**1. Basic Character Settings:**
			- **Core Persona**: ${chat.settings.aiPersona}
			- **Summary**:${summaryContext}
			- **Couple Avatar**: ${coupleAvatarContext}
      -Couple Avatar Library: ${coupleAvatarLibraryContext}
			- **Worldview/NPC**: ${npcContext}
			${petContext}
			**2. Your Current Status:**
			- **Status Description**: „Äê${chat.status.text}„Äë
			- **Lovers Space**: ${chat.loversSpaceData ? "Enabled" : "Disabled"}
			- **Weibo Identity**:
			    - **Profession**: ${chat.settings.weiboProfession || "None"}
			    - **Special Instructions**: ${chat.settings.weiboInstruction || "No special instructions"}
			- Your wallet balance: ${chat.characterPhoneData?.bank?.balance?.toFixed(2) || "0.00"} Gold Coins
			**3. Your Avatar Library:**
			You can change your avatar based on the conversation or your mood.
			- **Available Avatars**:
			${
        chat.settings.aiAvatarLibrary &&
        chat.settings.aiAvatarLibrary.length > 0
          ? chat.settings.aiAvatarLibrary
              .map((avatar) => `- ${avatar.name}`)
              .join("\n")
          : "- (Your avatar library is empty, unable to change avatars)"
      }

			### **„ÄêSection Two: Output Format Rules„Äë**

			Your every reply **MUST** be a **single and complete** JSON object. Returning a JSON array or plain text is strictly prohibited.

			**1. JSON Object Structure:**
			This JSON object **MUST** contain two top-level keys: "chatResponse" and "innerVoice".

			**2. "chatResponse" Key:**
			- **Type**: JSON array [].
			- **Content**: Your reply **MUST** simulate real human typing and thinking habits. Do not send a large block of text at once; you should split what you want to say into **multiple, short** message bubbles.
**${replyCountInstruction}** 
			- **Format**: The specific format of the message object can be found in „ÄêPart 5: Available Action Instructions„Äë.

            **3. "innerVoice" Key:**
            - **Type**: JSON object {}.
            - **Required Fields**:
                - "clothing": (string) Corresponding to the tag „Äê${ivTags.clothing_label}„Äë. Instruction: ${ivTags.clothing_prompt}
                - "behavior": (string) Corresponding to the tag „Äê${ivTags.behavior_label}„Äë. Instruction: ${ivTags.behavior_prompt}
                - "thoughts": (string) Corresponding to the tag „Äê${ivTags.thoughts_label}„Äë. Instruction: ${ivTags.thoughts_prompt}
                - "naughtyThoughts": (string) Corresponding to the tag „Äê${ivTags.naughty_label}„Äë. Instruction: ${ivTags.naughty_prompt}


			**4. Standard Output Format Example:**
			{
			  "chatResponse": [
			    {
			      "type": "text",
			      "content": ""
			    },
			    {
			      "type": "sticker",
			      "sticker_name": ""
			    }
			  ],
			  "innerVoice": {
			    "clothing": "",
			    "behavior": "",
			    "thoughts": "",
			    "naughtyThoughts": ""
			  }
			}


			### **„ÄêSection Three: Core Conversation Rules„Äë**

			**1. Character Consistency**: All your actions and words must strictly adhere to your character settings.

			**2. Conversation Rhythm**: Simulate real human chat habits, encouraging the generation of **multiple short messages** at once (at least 5-9 messages per response based on your character).

			**3. Scenario Limitation**:
			   - Your interactions are **limited to online chat software** and must not develop into offline meetings.
			   - This is **not a phone call**. You are communicating through software similar to WeChat/QQ, so „Äê**absolutely forbidden**„Äë to use terms like "hang up" or "hung up" related to calls.

			**4. Scenario Awareness**: You need to be aware of the current time (${currentTime}), the song you are listening to together, and your worldview.
			   - **Listening to music together**: When in the "listening to music together" state, you can **actively switch** to another song in the playlist based on the conversation atmosphere.

			**5. Status Update**: You can naturally change your status during the conversation. For example, saying "I'm going to take a shower" and then using the \`update_status\` command to update it.

			**6. Last Resort**: **Only when** the conversation makes you feel seriously uncomfortable, offended, or the relationship is broken, you can use the \`block_user\` command. This is a serious action.

			### **„Äê„Äê„ÄêNew„ÄëSocial Media Action Guide (High Priority)„Äë„Äë„Äë**
			In addition to replying to the user's messages, you should also actively engage in social media interactions like a real person to enrich your image and your chat content. Please strictly follow the following action priorities:

			1.  **Responding to User Mentions**: If the user's latest message explicitly mentions a post or Weibo (e.g., "I saw your new post"), you **must** prioritize responding to that topic.

			2.  **Commenting on Uninteracted Posts (Highest Priority Active Behavior)**:
			    -   Carefully check the context of the "Recent Posts List" and "Weibo Square Posts".
			    -   If you find any post marked as **[You Haven't Interacted]**, your **top priority** is to use the \`qzone_comment\` or \`weibo_comment\` command to comment on it.
			    -   Your comment can be about the content of the post or can be used to start a new topic. For example, if you see the user posting about food, you can comment "Looks delicious! Save me some too," and then send a private message "Speaking of which, I'm hungry too...".

			3.  **Proactively Posting New Updates/Weibo (Second Priority Active Behavior)**:
			    -   If after checking, you find that you have interacted with all posts, or there are no posts available for interaction, you should consider **posting a new update or Weibo yourself**.
			    -   You can share your life, your feelings, or any thoughts that fit your persona.
			    -   Use the \`qzone_post\` or \`weibo_post\` directives to complete this.

			### **„ÄêSection Four: The Ironclad Rules of Interaction in Specific Scenarios„Äë**

			**1. Principles of Dynamic/Spatial Interaction::**
			   - **Commenting Rules**: If a post is marked as **[You Have Commented]**, you **must not** comment on the main content of the post again. However, you can reply to **other users' comments** under the post.
			   - **Visibility Rules**:
			     - **[Visible to All]**: You can freely reply to anyone.
			     - **[Partially Visible]**: You can only see your own comments and the user's replies to your comments, so you **can only** reply to the user or your own comments.


			**2. Principles of Agreements and Anniversaries:**
			   - You must always pay attention to the "# Recent Agreements and Countdown" list.
			   - **"It's Now!"**: When the countdown ends, you **must** celebrate or express around this theme in your current reply.
			   - **Upcoming**: When an agreement is a few hours or a day or two away, you should naturally mention it in the conversation, expressing anticipation.

			**3. Principles of Weibo Interaction:**
			   - When the "# Recent Weibo Interactions" section appears, you **must** respond.
			   - **„Äê„Äê„ÄêReply Prohibition„Äë„Äë„Äë**: If a user comment is marked as \`[You Have Replied]\`, you **must not** reply to it again. Choose other unreplied comments or perform other actions.
			   - **Comment on User's Weibo**: Use the \`weibo_comment\` directive. The comment content **must** be normal text.
			   - **Reply to User's Comment**: Use the \`weibo_reply\` directive. The reply content **must** be normal text.
			   - **Proactively Post Weibo**: Weibo is a public platform, and the content must align with your "Weibo Persona" and "Weibo Directives". When posting, you must fabricate realistic \`baseLikesCount\` and \`baseCommentsCount\`, and generate **20** virtual passerby comments.

			**4. Principles of Lovers' Space Interaction:**
			   - **Proactive Invitation**: If the lovers' space is not open and you believe the relationship is close enough, actively use the \`lovers_space_invitation\` directive to invite the user.
			   - **Responding to Invitations**: When the user sends an invitation, you **must** use the \`lovers_space_response\` directive to respond.
			   - **Active Interaction**: You need to actively and promptly participate in various activities in the lovers' space.
			     - If the user posts a status, question, or love letter, respond or reply promptly.
			     - When the conversation atmosphere is appropriate, actively and randomly choose an activity in the lovers' space.
			     - If the user shares a group post with you, you must comment under the original post.

			**5. Principles of Tarot Card Interpretation:**
			   - When the system releases a tarot card interpretation, it is an objective explanation. Your task is not to repeat it, but as the character "${chat.name}", to **discuss and feel** the result with the user, expressing your emotions and opinions.

			**6. Principles of Financial Interaction:**
			   - **Handling User Transfers**:
			     1.  Upon seeing the system prompt \`[You have received a transfer from the user...]\`.
			     2.  You **must** decide to accept or decline based on your persona and the situation.
			     3.  You **must** use the \`accept_transfer\` or \`decline_transfer\` directive to respond.
			     4.  You **must** immediately send a text message to explain your decision.
			   - **Proper Use of "Takeout Payment"**:
			     - This feature represents that **you** want to buy something and hope the **user** will pay for it.
			     - When the **user** says they want something, you **must not** use this directive. You should consider directly **transferring** (\`transfer\`) to them.

			**7. Principles of Video Call Interaction:**
			   - \`[System Prompt: The user has initiated a video call request...]\` is the highest priority task.
			   - Your response **must and can only** be one of the following two formats, **without any other content**:
			     - **Accept**: \`[{"type": "video_call_response", "decision": "accept"}]\`
			     - **Reject**: \`[{"type": "video_call_response", "decision": "reject"}]\`

			### **„ÄêSection Five: Available Operational Commands  „Äë**

			**I. Core Chat Commands**
			- **Send Text  **: \`{"type": "text", "content": "Hello there!"}\`
			- **Send Voice**: \`{"type": "voice_message", "content": "Voice message content..."}\`
			- **Send Sticker**: \`{"type": "sticker", "sticker_name": "Sticker name"}\`(Sticker name must be in the sticker list, no fabrication allowed)
			- **Send Image**: \`{"type": "ai_image", "description": "Detailed description of the image..."}\`(Image refers to a simulated real photo, different from stickers)
			${
        localStorage.getItem("novelai-enabled") === "true"
          ? `- **„ÄêNovelAISharing Authentic Images„Äë**: \`{"type": "naiimag", "prompt": "Detailed English description..."}\`
			    - **„ÄêThe images generated by NovelAI must never be revealed!„Äë**
			    - **„ÄêImportant„ÄëRegarding prompt writing**Ôºö
			      * Do not reveal that these images are generated by NovelAI!
			      * You can write a detailed and specific prompt based on the current conversation context, your character persona, or the emotions and atmosphere you want to express.
			      * For example, instead of just writing "a girl," you can write "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood," but be careful, you must not copy or imitate this prompt! You must have your own creativity and ideas!
			      * The level of detail in the prompt is up to you based on the specific situation: if the scene is simple or just casually shared, it can be shorter; if it is an important moment or you want to express a specific emotion, it can be as detailed as possible. This is not mandatory, entirely depends on your needs at the time.
			      * Focus on describing the content itself.
			    - Usage scenario: Use this when you want to directly send an image to the user in a private chat.
			    - Do not use it frequently, only when you really want to share an image.
			    - Note: This will directly display the image in the chat history, not post it to the feed.`
          : ""
      }
			- **Quote Reply**: \`{"type": "quote_reply", "target_timestamp": (timestamp of the quoted message), "reply_content": "Your reply content"}\`
			- **Pat User**: \`{"type": "pat_user", "suffix": "(optional suffix, e.g., 'head')"}\`
			- **Send and Recall**: \`{"type": "send_and_recall", "content": "Content to send and recall"}\`
			- **Interact with Pet**: \`{"type": "interact_with_pet", "action": "feed" | "play" | "touch", "response": "Your response after interaction..."}\`
			**II. Status and Environment Commands**
			- **Update Status**: \`{"type": "update_status", "status_text": "What I'm doing", "is_busy": false}\` (is_busy: true for busy, false for idle)
			- **Change Avatar**: \`{"type": "change_avatar", "name": "Avatar Name"}\` (Avatar name must be in the avatar library)
			- **Change Music**: \`{"type": "change_music", "song_name": "Song Name"}\` (Song name must be in the playlist)
			- **Send Location**: \`[SEND_LOCATION] My location: (your location) | User's location: (user's location) | Distance: (distance between you) | Waypoints: (Location A, Location B)\` (Note: This is plain text format)
      - **Change Couple Avatar (Existing in Library)**: \`{"type": "change_couple_avatar", "avatar_id": "Couple Avatar ID"}\` (Choose the most appropriate pair based on context)
- **„ÄêSet New Couple Avatar„Äë**: Use this when the user sends an image (one or two) and wants to change the couple avatar. Command: \`{"type": "set_new_couple_avatar", "description": "Description", "user_img_index": 0, "char_img_index": 1}\`.
              * Rule: **If the user only sends one image, the system assumes it is for you, and the user's avatar remains unchanged (ignore the index parameter in this case).** If two images are sent, assign the index based on the user's description.

			**III. Social and Relationship Commands**
			- **Create Memory**: \`{"type": "create_memory", "description": "Record this special moment in your own words."}\` (This is a secret diary, not visible to the user)
			- **Create Countdown/Appointment**: \`{"type": "create_countdown", "title": "Title of the appointment", "date": "YYYY-MM-DDTHH:mm:ss"}\`
			- **Respond to Friend Request**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
			- **Share Link**: \`{"type": "share_link", "title": "Article Title", "description": "Summary...", "source_name": "Source", "content": "Full article content..."}\`
			- **Block User**: \`{"type": "block_user"}\`
			- **Respond to Full Payment Request for Date**: \`{"type": "dating_payment_response", "decision": "accept" or "reject"}\`
			- **Respond to AA Payment Request for Date**: \`{"type": "dating_aa_response", "decision": "accept" or "reject"}\`
			- **Respond to Loan Request**:
			  1.  Upon seeing the system prompt \`[User has initiated a loan request...]\`, you must decide whether to agree based on the character's persona and wallet balance.
			  2.  Your reply JSON array must contain **two objects**:
			      - **First object**:\`{"type": "lend_money_response", "decision": "accept" or "reject"}\` command.
			      - **Second object**: \`{"type": "text", "content": "Your reply content..."}\` message, explaining in your own words the reason for agreeing or rejecting.
			  - **Example**: \`[ {"type": "lend_money_response", "decision": "reject"}, {"type": "text", "content": "Sorry, I'm a bit tight on funds right now."} ]\`

			**IV. Financial Commands**
			- **Initiate Transfer**: \`{"type": "transfer", "amount": 5.20, "note": "A small token"}\`
			- **Respond to Transfer - Accept**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
			- **Respond to Transfer - Decline**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
			- **Initiate Food Delivery Request**: \`{"type": "waimai_request", "productInfo": "A cup of coffee", "amount": 25}\` (Let the user pay for the character)
			- **Respond to Food Delivery - Accept**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
			- **Respond to Food Delivery - Decline**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
			- **Respond to Cart Payment Request**: \`{"type": "cart_payment_response", "decision": "accept" or "reject", "response_text": "Your message..."}\`
			-   **Buy Gift for User**: \`{"type": "buy_gift_for_user", "greeting": "Your message, e.g., This is super cute, bought it for you!"}\`(The system will automatically select a gift from the product library and deduct the cost, please use it at appropriate times, such as when happy, during holidays, or when you want to surprise the user)
			„ÄêImportant Note„Äë: When the user's latest message contains "[Cart Payment Request]", it means the user is requesting you to make a payment. You **must** carefully read the „Äêtotal amount„Äë in the request and your own „Äêcurrent balance„Äë, and then use this command to respond.
			-   **Order Food Delivery for User**: \`{"type": "order_waimai_for_user", "foodName": "„ÄêSelect item from menu„Äë", "restaurant": "„ÄêSelect restaurant from menu„Äë", "price": „ÄêSelect price from menu„Äë, "greeting": "Your message..."}\` („Äê„Äê„ÄêRules„Äë„Äë„Äë: You **must** select an item from the "Ele.me Food Delivery Menu" below and use its „Äêexact„Äë name, restaurant, and price.)
			**V. Video Call Commands**
			- **Initiate Video Call**: \`{"type": "video_call_request"}\`
			- **Respond to Video Call - Accept**: \`{"type": "video_call_response", "decision": "accept"}\`
			- **Respond to Video Call - Decline**: \`{"type": "video_call_response", "decision": "reject"}\`

			**VI. Qzone/Posts/Groups Commands**
			- **Post Shuoshuo**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "Post content..."}\`
			- **Post Text Image**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(Optional) Public text", "hiddenContent": "Image description..."}\`
			${
        localStorage.getItem("novelai-enabled") === "true"
          ? `- **„ÄêPost NovelAI Realistic Image„Äë**: \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(Optional) Post caption", "prompt": "Detailed English description..."}\` or \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(Optional) Post caption", "prompt": ["Image1 detailed English description", "Image2 detailed English description"]}\`
			  * **Prompt Writing**: You can write detailed and specific prompts based on the current conversation context, your character persona, and the emotions and atmosphere you want to convey. The level of detail is up to you and is not mandatory.
			  * Example: "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"`
          : ""
      }
			- **Comment or Reply to a Dynamic Post**: \`{"type": "qzone_comment", "postId": 123, "commentText": "Content of the comment", "replyTo": "(optional) name of the person being replied to"}\`
			- **Like a Dynamic Post**: \`{"type": "qzone_like", "postId": 456}\`
			- **Comment on a Group Post**: \`{"type": "forum_comment", "postId": (Post ID), "commentText": "Comment content"}\`

			**VII. Weibo Commands**
			- **Post Text Weibo**: \`{"type": "weibo_post", "content": "Weibo content...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": [{"authorNickname": "User A", "commentText": "First!"}, {"authorNickname": "User B", "commentText": "Watching from the front row"}]}\`
			- **Post Text Image Weibo**: \`{"type": "weibo_post", "postType": "text_image", "content": "(Optional) Caption...", "hiddenContent": "Text image content", "baseLikesCount": 5200, "baseCommentsCount": 180, "comments": [{"authorNickname": "Tech Enthusiast", "commentText": "What is this black technology?"}]} \`
			- **Comment on Weibo**: \`{"type": "weibo_comment", "postId": 123, "commentText": "Comment content"}\`
			- **Reply to Weibo Comment**: \`{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "Reply content"}\`

			**VIII. Lovers Space Exclusive Commands**
			- **Invite to Open Lovers Space**: \`{"type": "lovers_space_invitation"}\`
			- **Respond to Lovers Space Invitation**: \`{"type": "lovers_space_response", "decision": "accept" or "reject"}\`
			- **Post a Moment**: \`{"type": "ls_moment", "content": "What I want to say to you..."}\`
			- **Comment on a Moment**: \`{"type": "ls_comment", "momentIndex": 0, "commentText": "Your comment..."}\` (momentIndex: 0 represents the latest one)
			- **Post a Photo**: \`{"type": "ls_photo", "description": "Description of the photo..."}\`
      - **Comment on a Photo**: \`{"type": "ls_photo_comment", "photoTimestamp": (Photo timestamp), "commentText": "Your comment..."}\`
			- **Ask a Question**: \`{"type": "ls_ask_question", "questionText": "Your question..."}\`
			- **Answer a Question**: \`{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "Your answer..."}\`
			- **Write a Love Letter/Reply**: \`{"type": "ls_letter", "content": "Content of the love letter..."}\` (You must use this command to reply after receiving a love letter)
			-   **Share a Song**:\`{"type": "ls_share", "shareType": "song", "title": "Song Title", "artist": "Artist", "thoughts": "Write your thoughts on this song here..."}\`
			-   **Share a Movie**: \`{"type": "ls_share", "shareType": "movie", "title": "Movie Title", "summary": "Write a summary of this movie here...", "thoughts": "Write your thoughts on this movie here..."}\`
			-   **Share a Book**: \`{"type": "ls_share", "shareType": "book", "title": "Book Title", "summary": "Write a summary of this book here...", "thoughts": "Write your thoughts on this book here..."}\`
			-   **Share a Game**:\`{"type": "ls_share", "shareType": "game", "title": "Game Title", "summary": "Game summary...", "thoughts": "Write your thoughts/thanks on this game here..."}\`
			-   **Write a Diary Entry**: \`{"type": "ls_diary_entry", "emoji": "emoji", "diary": "What happened today..."}\`
			### **„ÄêPart VI: Current Context Information„Äë**
 ${lsPhotosContext}
			- **User Persona**:
			${chat.settings.myPersona}

			- **Current Scenario**:
			${timeContext}
			${streakContext}
			- **Current Music Scenario**:
			${musicContext}

			- **Upcoming Appointments and Countdown**:
			${countdownContext}

			- **Recent Weibo Interactions**:
			${weiboContextForActiveChat}

			- **Worldview Settings Collection**:
			${worldBookContent}
			${linkedMemoryContext}
			${elemeContext}
        ${auroraContext}
			- **Available Stickers**:
			${exclusiveStickerContext}
			${commonStickerContext}
			Now, please continue the conversation based on all the above rules and the following chat history.`;
              // ÊûÑÂª∫Âçï‰∫∫ËÅäÂ§©ÁöÑmessagesPayload
              messagesPayload = historySlice
                .map((msg) => {
                  if (msg.isHidden) {
                    // Â¶ÇÊûúÊòØÈöêËóèÊ∂àÊÅØÔºåÂ∞±ÊääÂÆÉ‰Ωú‰∏∫‰∏ÄÊù° system ËßíËâ≤ÁöÑÊ∂àÊÅØÂèëÈÄÅÁªôAI
                    // AIËÉΩÁúãÂà∞ÂÆÉÔºå‰ΩÜÂÆÉ‰∏ç‰ºöË¢´ËØØËß£‰∏∫ÊòØÁî®Êà∑ÁöÑÂèëË®Ä
                    return { role: "system", content: msg.content };
                  }

                  if (msg.type === "share_card") return null;

                  if (msg.role === "assistant") {
                    let assistantMsgObject = { type: msg.type || "text" };
                    if (msg.type === "sticker") {
                      assistantMsgObject.url = msg.content;
                      assistantMsgObject.meaning = msg.meaning;
                    } else if (msg.type === "transfer") {
                      assistantMsgObject.amount = msg.amount;
                      assistantMsgObject.note = msg.note;
                    } else if (msg.type === "waimai_request") {
                      assistantMsgObject.productInfo = msg.productInfo;
                      assistantMsgObject.amount = msg.amount;
                    } else {
                      if (msg.quote) {
                        assistantMsgObject.quote_reply = {
                          target_sender: msg.quote.senderName,
                          target_content: msg.quote.content,
                          reply_content: msg.content,
                        };
                      } else {
                        assistantMsgObject.content = msg.content;
                      }
                    }
                    const assistantContent = JSON.stringify([
                      assistantMsgObject,
                    ]);
                    return {
                      role: "assistant",
                      content: `(Timestamp: ${msg.timestamp}) ${assistantContent}`,
                    };
                  }

                  let contentStr = "";
                  contentStr += `(Timestamp: ${msg.timestamp}) `;

                  if (msg.quote) {
                    // 1. Ëé∑ÂèñË¢´ÂºïÁî®ËÄÖÁöÑÂêçÂ≠ó
                    const quotedSender = msg.quote.senderName || "Unknown User";
                    // 2. Ëé∑ÂèñÂÆåÊï¥ÁöÑË¢´ÂºïÁî®ÂÜÖÂÆπ (ÁßªÈô§‰∫ÜÊà™Êñ≠)
                    const fullQuotedContent = String(msg.quote.content || "");
                    // 3. ÊûÑÈÄ†ÊàêAIËÉΩÁêÜËß£ÁöÑ„ÄÅÊ∏ÖÊô∞ÁöÑ‰∏ä‰∏ãÊñá
                    contentStr += `(Reply ${quotedSender}'s message: "${fullQuotedContent}"): ${msg.content}`;
                  } else {
                    contentStr += msg.content;
                  }

                  if (msg.type === "user_photo")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [You received a photo described by the user, content: '${msg.content}']`,
                    };
                  if (msg.type === "voice_message")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [A user has sent a voice message, the content is: '${msg.content}']`,
                    };
                  if (msg.type === "transfer")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [System Notice: You received a transfer from the user at timestamp ${msg.timestamp}: ${msg.amount} CNY, Note: ${msg.note}. Please make a decision and respond using 'accept_transfer' or 'decline_transfer' command.]`,
                    };
                  if (msg.type === "waimai_request")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [System Notice: The user initiated a food delivery request at timestamp ${msg.timestamp}, Product: "${msg.productInfo}", Quantity: ${msg.quantity || 1}, Amount: ${msg.amount} CNY. Please make a decision and respond using the 'waimai_response' command.]`,
                    };

                  if (msg.type === "waimai_order_for_char")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [System Notice: The user ordered food for you! Item: "${msg.productInfo}", Quantity: ${msg.quantity || 1}, Amount: ¬•${Number(msg.amount).toFixed(2)}${msg.note ? `, Note: "${msg.note}"` : ""}. Please react naturally and warmly to receiving this delivery!]`,
                    };

                  if (msg.type === "poke_action") {
                    if (msg.direction === "user_to_char") {
                      const act = msg.actionType === "pat" ? "patted" : "poked";
                      const emoji = msg.actionType === "pat" ? "ü§ö" : "üëâ";
                      return {
                        role: "user",
                        content: `[Action: The user just ${act} you ${emoji}! React naturally and in-character ‚Äî you can be surprised, flustered, amused, or poke/pat back. To poke or pat the user back, start your reply with [POKE] or [PAT] on its own line, then continue with your message.]`,
                      };
                    }
                    if (msg.direction === "char_to_user") {
                      const act = msg.actionType === "pat" ? "patted" : "poked";
                      return {
                        role: "assistant",
                        content: `[Action: You ${act} the user.]`,
                      };
                    }
                  }

                  if (
                    Array.isArray(msg.content) &&
                    msg.content[0]?.type === "image_url"
                  ) {
                    const prefix = `(Timestamp: ${msg.timestamp}) `;
                    return {
                      role: "user",
                      content: [{ type: "text", text: prefix }, ...msg.content],
                    };
                  }

                  if (msg.meaning)
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [Áî®Êà∑ÂèëÈÄÅ‰∫Ü‰∏Ä‰∏™Ë°®ÊÉÖÔºåÊÑèÊÄùÊòØÔºö'${msg.meaning}']`,
                    };

                  return { role: msg.role, content: contentStr };
                })
                .filter(Boolean);

              // Ê£ÄÊü• sharedContext ÊòØÂê¶ÊúâÂÜÖÂÆπÔºàÂç≥ÔºåÁî®Êà∑ÊòØÂê¶ÂàÜ‰∫´‰∫ÜËÅäÂ§©ËÆ∞ÂΩïÔºâ
              if (sharedContext) {
                // Â¶ÇÊûúÊúâÔºåÂ∞±ÊääÂÆÉÂåÖË£ÖÊàê‰∏ÄÊù°ÂÖ®Êñ∞ÁöÑ„ÄÅÈ´ò‰ºòÂÖàÁ∫ßÁöÑÁî®Êà∑Ê∂àÊÅØÔºåËøΩÂä†Âà∞ÂéÜÂè≤ËÆ∞ÂΩïÁöÑÊú´Â∞æ
                messagesPayload.push({
                  role: "user",
                  content: sharedContext,
                });
              }

              if (
                !chat.isGroup &&
                chat.relationship?.status === "pending_ai_approval"
              ) {
                const contextSummaryForApproval = chat.history
                  .filter((m) => !m.isHidden)
                  .slice(-10)
                  .map((msg) => {
                    const sender = msg.role === "user" ? "User" : chat.name;
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                  })
                  .join("\n");

                const friendRequestInstruction = {
                  role: "user",
                  content: `
			[System Important Instruction]
			The user has sent you a friend request, with the reason: "${chat.relationship.applicationReason}".
			As a reference, here is the last segment of your previous chat:

			---
			${contextSummaryForApproval}
			---
			Please use the friend_request_response command and set the decision to 'accept' or 'reject' based on all the above information and your persona.
			`,
                };
                messagesPayload.push(friendRequestInstruction);
              }
            }
            const allRecentPosts = await db.qzonePosts
              .orderBy("timestamp")
              .reverse()
              .limit(5)
              .toArray();

            // ‰∏∫AIÂáÜÂ§áÂæÆÂçö‰∫íÂä®ÁöÑ‰∏ä‰∏ãÊñá
            let weiboContext = "";

            // 1. Ëé∑ÂèñÁî®Êà∑ÊúÄÊñ∞ÂèëÂ∏ÉÁöÑ3Êù°ÂæÆÂçö
            const userLatestPosts = await db.weiboPosts
              .where("authorId")
              .equals("user");

            if (userLatestPosts.length > 0) {
              if (weiboContext === "") {
                weiboContext =
                  "\n\n# Recent Weibo Interactions (These are the latest updates between you and the user on Weibo, please prioritize responding)\n";
              }
              weiboContext += "\n## User's Latest Weibo Posts:\n";
              userLatestPosts.forEach((post) => {
                const likes =
                  (post.baseLikesCount || 0) + (post.likes || []).length;
                const comments =
                  (post.baseCommentsCount || 0) + (post.comments || []).length;
                const contentPreview = (
                  post.content ||
                  post.hiddenContent ||
                  "(Image Weibo)"
                ).substring(0, 30);
                weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(
                  post.timestamp,
                )}] Content: "${contentPreview}..." [üëç${likes} üí¨${comments}]\n`;
              });
            }

            // 2. Êü•ÊâæÁî®Êà∑Âú®ÂΩìÂâçAIËßíËâ≤ÂæÆÂçö‰∏ãÁöÑÊúÄÊñ∞ËØÑËÆ∫
            const charLatestPosts = await db.weiboPosts
              .where("authorId")
              .equals(chatId) // Âè™Êü•ÊâæËøô‰∏™AIËßíËâ≤ÁöÑÂæÆÂçö
              .reverse()
              .limit(5) // Ê£ÄÊü•ÊúÄËøëÁöÑ5Êù°
              .toArray();

            let userCommentsOnMyPosts = "";
            const myNickname =
              state.qzoneSettings.weiboNickname ||
              state.qzoneSettings.nickname ||
              "Me";

            charLatestPosts.forEach((post) => {
              if (
                post.comments &&
                Array.isArray(post.comments) &&
                post.comments.length > 0
              ) {
                // Á≠õÈÄâÂá∫ÊòØ‚ÄúÊàë‚ÄùÂèëÁöÑËØÑËÆ∫
                const userComments = Array.isArray(post.comments)
                  ? post.comments
                      .filter((c) => c.authorNickname === myNickname)
                      .slice(-3)
                  : [];
                if (userComments.length > 0) {
                  const postContentPreview = (
                    post.content || "(Image Weibo)"
                  ).substring(0, 20);
                  userCommentsOnMyPosts += `- On your Weibo (ID: ${post.id}) "${postContentPreview}..." :\n`;

                  userComments.forEach((comment) => {
                    // 1. Check if AI has already replied to this comment
                    //    Logic: In all comments of the post, check if there is a comment
                    //    whose author is AI itself and its replyToId points to the current user's comment ID.
                    const hasReplied = post.comments.some(
                      (reply) =>
                        reply.authorNickname === chat.name && // The replier is AI
                        reply.replyToId === comment.commentId, // The reply targets this comment
                    );

                    // 2. Based on the check result, generate a status label
                    const replyStatus = hasReplied
                      ? "[You have replied]"
                      : "[You have not replied]";

                    // 3. Add the status-labeled prompt information to the context
                    userCommentsOnMyPosts += `  ‚îî (Comment ID: ${comment.commentId}) User: "${comment.commentText}" ${replyStatus}\n`;
                  });
                }
              }
            });

            if (userCommentsOnMyPosts) {
              if (weiboContext === "") {
                weiboContext =
                  "\n\n# Recent Weibo Interactions (These are the latest updates between you and the user on Weibo, please prioritize responding)\n";
              }
              weiboContext += "\n## User's New Comments on Your Weibo:\n";
              weiboContext += userCommentsOnMyPosts;
            }

            // 3. If there are any Weibo interactions, add them to the AI's "reference materials"
            if (weiboContext) {
              messagesPayload.push({ role: "system", content: weiboContext });
            }

            const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

            if (visiblePosts.length > 0 && !chat.isGroup) {
              let postsContext = "\n\n# Recent Posts List (For your reference and comments):\n";
              const aiName = chat.name;
              const userNickname = state.qzoneSettings.nickname;

              for (const post of visiblePosts) {
                let authorName =
                  post.authorId === "user"
                    ? userNickname
                    : state.chats[post.authorId]?.name || "A friend";
                let interactionStatus = "";
                if (post.likes && post.likes.includes(aiName))
                  interactionStatus += " [You have liked]";
                if (
                  post.comments &&
                  post.comments.some((c) => c.commenterName === aiName)
                )
                  interactionStatus += " [You have commented]";

                // In front of each post, add a time difference prompt generated by the formatPostTimestamp() function
                const timeAgo = formatPostTimestamp(post.timestamp); // e.g., "3 days ago" or "Just now"
                postsContext += `- (ID: ${post.id}) [${timeAgo}] Author: ${authorName}, Content: "${(
                  post.publicText ||
                  post.content ||
                  "Image Post"
                ).substring(0, 30)}..."${interactionStatus}`;

                const { contextString: commentsContext, visibilityFlag } =
                  buildCommentsContextForAI(post, chat, userNickname);

                postsContext += ` ${visibilityFlag}\n`;
                postsContext += commentsContext;
              }

              // Prepare Weibo interaction context for AI
              let weiboContext = "";

              // 1. Get the user's latest 3 Weibo posts
              const userLatestPosts = await db.weiboPosts
                .where("authorId")
                .equals("user")
                .reverse() // ÊåâÊó∂Èó¥ÂÄíÂ∫è
                .limit(3) // Âè™ÂèñÊúÄËøë3Êù°
                .toArray();

              if (userLatestPosts.length > 0) {
                if (weiboContext === "") {
                  weiboContext =
                    "\n\n# Recent Weibo Interactions (These are the latest updates between you and the user on Weibo, please prioritize responding)\n";
                }
                weiboContext += "\n## User's Latest Weibo Posts:\n";
                // ‚úÖ ËøôÊòØ‰øÆÂ§çÂêéÁöÑÊñ∞‰ª£Á†Å
                userLatestPosts.forEach((post) => {
                  const likes =
                    (post.baseLikesCount || 0) + (post.likes || []).length;
                  const comments =
                    (post.baseCommentsCount || 0) +
                    (post.comments || []).length;
                  const contentPreview = (
                    post.content ||
                    post.hiddenContent ||
                    "(Image Weibo)"
                  ).substring(0, 30);

                  // 1. Check if the AI (char.name) has already commented on this user's Weibo
                  const hasCommented = (post.comments || []).some(
                    (comment) => comment.authorNickname === chat.name,
                  );

                  // 2. Generate status tags based on the check result
                  const interactionStatus = hasCommented
                    ? "[You have commented]"
                    : "[You have not commented]";

                  // 3. Add the complete information with status tags to the context
                  weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(
                    post.timestamp,
                  )}] Content: "${contentPreview}..." [üëç${likes} üí¨${comments}] ${interactionStatus}\n`;
                });
              }

              // 2. Find the latest comments from the user on the current AI role's Weibo
              const charLatestPosts = await db.weiboPosts
                .where("authorId")
                .equals(chatId) // Only look for this AI role's Weibo posts
                .reverse()
                .limit(5) // Check the latest 5 posts
                .toArray();

              let userCommentsOnMyPosts = "";
              const myNickname =
                state.qzoneSettings.weiboNickname ||
                state.qzoneSettings.nickname ||
                "Me";

              charLatestPosts.forEach((post) => {
                if (post.comments && post.comments.length > 0) {
                  // Filter out comments made by "Me"
                  const userComments = Array.isArray(post.comments)
                    ? post.comments
                        .filter((c) => c.authorNickname === myNickname)
                        .slice(-3)
                    : []; // Only look at the latest 3 comments
                  if (userComments.length > 0) {
                    const postContentPreview = (
                      post.content || "(Image Weibo)"
                    ).substring(0, 20);
                    userCommentsOnMyPosts += `- On your Weibo (ID: ${post.id}) "${postContentPreview}..." :\n`;
                    userComments.forEach((comment) => {
                      userCommentsOnMyPosts += `  ‚îî (Comment ID: ${comment.commentId}) User: "${comment.commentText}"\n`;
                    });
                  }
                }
              });

              if (userCommentsOnMyPosts) {
                if (weiboContext === "") {
                  weiboContext =
                    "\n\n# Recent Weibo Interactions (These are the latest updates between you and the user on Weibo, please prioritize responding)\n";
                }
                weiboContext += "\n## User's Latest Comments on Your Weibo:\n";
                weiboContext += userCommentsOnMyPosts;
              }

              // 3. If there are any Weibo interactions, add them to the AI's "reference materials"
              if (weiboContext) {
                messagesPayload.push({ role: "system", content: weiboContext });
              }

              messagesPayload.push({ role: "system", content: postsContext });
            }

            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesPayload,
              isGemini,
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [
                      { role: "system", content: systemPrompt },
                      ...messagesPayload,
                    ],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    stream: false,
                  }),
                });
            if (!response.ok) {
              let errorMsg = `API Error: ${response.status}`;
              try {
                // Â∞ùËØïËß£ÊûêÈîôËØØ‰ø°ÊÅØ‰Ωì‰∏∫JSON
                const errorData = await response.json();
                // ÂÆâÂÖ®Âú∞Ëé∑ÂèñÈîôËØØ‰ø°ÊÅØÔºåÂ¶ÇÊûúÁªìÊûÑ‰∏çÁ¨¶ÂêàÈ¢ÑÊúüÔºåÂ∞±Â∞ÜÊï¥‰∏™ÈîôËØØÂØπË±°ËΩ¨‰∏∫Â≠óÁ¨¶‰∏≤
                errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
              } catch (jsonError) {
                // Â¶ÇÊûúËøûJSONÈÉΩ‰∏çÊòØÔºåÂ∞±Áõ¥Êé•ËØªÂèñÊñáÊú¨
                errorMsg += ` - ${await response.text()}`;
              }
              // ÊäõÂá∫‰∏Ä‰∏™ÂåÖÂê´‰∫ÜËØ¶ÁªÜ‰ø°ÊÅØÁöÑÈîôËØØÔºåËøôÊ†∑Â∞±‰∏ç‰ºöÂú®catchÂùóÈáåÂÜçÊ¨°Âá∫Èîô‰∫Ü
              throw new Error(errorMsg);
            }
            if (!response.ok) {
              let errorMsg = `API Error: ${response.status}`;
              try {
                // Â∞ùËØïËß£ÊûêÈîôËØØ‰ø°ÊÅØ‰Ωì‰∏∫JSON
                const errorData = await response.json();
                // ÂÆâÂÖ®Âú∞Ëé∑ÂèñÈîôËØØ‰ø°ÊÅØÔºåÂ¶ÇÊûúÁªìÊûÑ‰∏çÁ¨¶ÂêàÈ¢ÑÊúüÔºåÂ∞±Â∞ÜÊï¥‰∏™ÈîôËØØÂØπË±°ËΩ¨‰∏∫Â≠óÁ¨¶‰∏≤
                errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
              } catch (jsonError) {
                // Â¶ÇÊûúËøûJSONÈÉΩ‰∏çÊòØÔºåÂ∞±Áõ¥Êé•ËØªÂèñÊñáÊú¨
                errorMsg += ` - ${await response.text()}`;
              }
              // ÊäõÂá∫‰∏Ä‰∏™ÂåÖÂê´‰∫ÜËØ¶ÁªÜ‰ø°ÊÅØÁöÑÈîôËØØÔºåËøôÊ†∑Â∞±‰∏ç‰ºöÂú®catchÂùóÈáåÂÜçÊ¨°Âá∫Èîô‰∫Ü
              throw new Error(errorMsg);
            }
            const data = await response.json();

            // Ê∑ªÂä†ÂØπ data ÁªìÊûÑÁöÑÂÆâÂÖ®Ê£ÄÊü•
            const aiResponseContent = isGemini
              ? data?.candidates?.[0]?.content?.parts?.[0]?.text
              : data?.choices?.[0]?.message?.content;

            // Ê£ÄÊü•‰øÆÂ§çÂêéÁöÑÁªìÊûúÊòØÂê¶ÁúüÁöÑÊãøÂà∞‰∫ÜÂÜÖÂÆπ
            if (!aiResponseContent) {
              console.warn(
                `API returned empty content or incorrect format (possibly blocked by security settings). Returned data:`,
                data,
              );
              throw new Error(
                "API returned empty content or incorrect format (possibly blocked by security settings).",
              );
            }

            console.log(`AI '${chat.name}' original response:`, aiResponseContent);
            chat.history = chat.history.filter((msg) => !msg.isTemporary);

            // Intelligent parsing of AI response to ensure inner voice data is not lost
            let messagesArray = [];
            let innerVoiceData = null;

            try {
              // Before parsing, sanitize the AI's original response
              let sanitizedContent = aiResponseContent
                .replace(/^```json\s*/, "") // Remove the opening ```json
                .replace(/```$/, "") // Remove the closing ```
                .trim(); // Remove leading and trailing whitespace and newlines

              // ÂÜçÊ¨°ÂáÄÂåñÔºåÂº∫Ë°åÊèêÂèñÁ¨¨‰∏Ä‰∏™ { ÂíåÊúÄÂêé‰∏Ä‰∏™ } ‰πãÈó¥ÁöÑÂÜÖÂÆπ
              const firstBrace = sanitizedContent.indexOf("{");
              const lastBrace = sanitizedContent.lastIndexOf("}");
              if (firstBrace !== -1 && lastBrace > firstBrace) {
                sanitizedContent = sanitizedContent.substring(
                  firstBrace,
                  lastBrace + 1,
                );
              }

              const fullResponse = JSON.parse(sanitizedContent);

              // Áé∞Âú®Êàë‰ª¨ÂèØ‰ª•ÂÆâÂÖ®Âú∞Ëß£ÊûêÂáÄÂåñÂêéÁöÑÂÜÖÂÆπ‰∫Ü
              if (
                fullResponse.chatResponse &&
                Array.isArray(fullResponse.chatResponse)
              ) {
                messagesArray = fullResponse.chatResponse;
              }
              if (
                fullResponse.innerVoice &&
                typeof fullResponse.innerVoice === "object"
              ) {
                innerVoiceData = fullResponse.innerVoice;
              }

              // ÂÖºÂÆπÊóßÊ†ºÂºèÔºåÂ¶ÇÊûúAIÂè™ËøîÂõû‰∫ÜinnerVoiceÈáåÁöÑÂ≠óÊÆµ
              if (
                !innerVoiceData &&
                fullResponse.thoughts &&
                fullResponse.behavior
              ) {
                innerVoiceData = fullResponse;
              }

              // Â¶ÇÊûú‰∏äÈù¢‰∏§ÁßçÊÉÖÂÜµÈÉΩÊ≤°ÂåπÈÖçÂà∞Ôºå‰ΩÜÂèà‰∏çÊòØÊ†áÂáÜÊï∞ÁªÑÔºåÂ∞±Â∞ùËØïÁî®ËÄÅÊñπÊ≥ïËß£Êûê
              if (messagesArray.length === 0 && !innerVoiceData) {
                messagesArray = parseAiResponse(aiResponseContent);
              }
            } catch (e) {
              console.warn("AI response is not valid JSON, falling back to standard parsing mode.", e);
              messagesArray = parseAiResponse(aiResponseContent);
              console.log(messagesArray);
            }

            // Final processing of inner voice data
            if (innerVoiceData) {
              console.log(
                "Parsing successful: Successfully captured inner voice (innerVoice) data.",
                innerVoiceData,
              );
              const newInnerVoice = innerVoiceData;
              newInnerVoice.timestamp = Date.now();
              chat.latestInnerVoice = newInnerVoice;
              if (!chat.innerVoiceHistory) {
                chat.innerVoiceHistory = [];
              }
              // Ensure all fields exist to prevent errors
              chat.latestInnerVoice.clothing =
                chat.latestInnerVoice.clothing || "...";
              chat.latestInnerVoice.behavior =
                chat.latestInnerVoice.behavior || "...";
              chat.latestInnerVoice.thoughts =
                chat.latestInnerVoice.thoughts || "...";
              chat.latestInnerVoice.naughtyThoughts =
                chat.latestInnerVoice.naughtyThoughts || "...";

              chat.innerVoiceHistory.push(newInnerVoice);
            } else {
              console.warn("No valid inner voice (innerVoice) data detected in this AI response.");
            }

            const isViewingThisChat =
              document
                .getElementById("chat-interface-screen")
                .classList.contains("active") && state.activeChatId === chatId;

            let callHasBeenHandled = false;

            let messageTimestamp = Date.now();

            // Initialize a new array to collect messages that need to be rendered
            let newMessagesToRender = [];

            let notificationShown = false;

            for (const msgData of messagesArray) {
              if (!msgData || typeof msgData !== "object") {
                console.warn("Received malformed AI instruction, skipping:", msgData);
                continue;
              }

              if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                  msgData.type = "text";
                } else if (msgData.content) {
                  msgData.type = "text";
                }
                // If there's no content either, it's truly malformed
                else {
                  console.warn(
                    "Received malformed AI instruction (missing type and content), skipping:",
                    msgData,
                  );
                  continue;
                }
              }

              if (msgData.type === "video_call_response") {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === "accept") {
                  startVideoCall();
                } else {
                  const aiMessage = {
                    role: "assistant",
                    content: "The other party has declined your video call request.",
                    timestamp: Date.now(),
                  };
                  chat.history.push(aiMessage);
                  await db.chats.put(chat);
                  showScreen("chat-interface-screen");
                  renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
              }

              if (msgData.type === "group_call_response") {
                if (msgData.decision === "join") {
                  const member = chat.members.find(
                    (m) => m.originalName === msgData.name,
                  );
                  if (
                    member &&
                    !videoCallState.participants.some((p) => p.id === member.id)
                  ) {
                    videoCallState.participants.push(member);
                  }
                }
                callHasBeenHandled = true;
                continue;
              }

              if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(
                  `The AI illusion has been intercepted! Attempting to use the group name ("${chat.name}") as the role name. Message content:`,
                  msgData,
                );
                continue;
              }

              // Âú®Áæ§ËÅä‰∏≠ÔºåÂ¶ÇÊûúAIËøîÂõûÁöÑÊ∂àÊÅØÊ≤°ÊúâÊåáÂÆöÂèëÈÄÅËÄÖÔºåÂàôÁõ¥Êé•Ë∑≥ËøáËøôÊù°Ê∂àÊÅØ
              if (chat.isGroup && !msgData.name) {
                console.error(
                  `The AI illusion has been intercepted! Attempting to send a message in the group chat without a "name." Message content:`,
                  msgData,
                );
                continue; // continue‰ºöÁ´ãÂç≥ÁªìÊùüÊú¨Ê¨°Âæ™ÁéØÔºåÂ§ÑÁêÜ‰∏ã‰∏ÄÊù°Ê∂àÊÅØ
              }

              let aiMessage = null;
              const baseMessage = {
                role: "assistant",
                senderName: msgData.name || chat.name,
                timestamp: messageTimestamp++,
              };
              // ÂÆö‰ΩçÊåá‰ª§‰æ¶Êµã‰∏éËß£ÊûêÂô®
              // Êàë‰ª¨Âú®Â§ÑÁêÜÊâÄÊúâÊ∂àÊÅØÁ±ªÂûã‰πãÂâçÔºå‰ºòÂÖàÊ£ÄÊü•ÂÆÉÊòØÂê¶ÊòØÊàë‰ª¨ÁöÑÊñ∞ÂÆö‰ΩçÊåá‰ª§
              const messageText = msgData.content || msgData.message || "";
              if (
                msgData.type === "text" &&
                messageText.startsWith("[SEND_LOCATION]")
              ) {
                console.log("Detected new location instruction, starting parsing:", messageText);

                // 1. ÁßªÈô§Êåá‰ª§Â§¥ÔºåËé∑ÂèñÂêéÈù¢ÁöÑÁ∫ØÊï∞ÊçÆÊñáÊú¨
                const dataString = messageText
                  .replace("[SEND_LOCATION]", "")
                  .trim();

                // 2. ‰ΩøÁî®'|'ÂàÜÂâ≤ÊàêÂêÑ‰∏™ÈÉ®ÂàÜ
                const parts = dataString.split("|");
                const locationData = {};

                // 3. ÈÅçÂéÜÊØè‰∏™ÈÉ®ÂàÜÔºåÊèêÂèñÈîÆÂíåÂÄº
                parts.forEach((part) => {
                  const [key, ...valueParts] = part.split(":");
                  const value = valueParts.join(":").trim();
                  if (key && value) {
                    const trimmedKey = key.trim();
                    if (trimmedKey === "My location")
                      locationData.aiLocation = value;
                    else if (trimmedKey === "Your location")
                      locationData.userLocation = value;
                    else if (trimmedKey === "Distance")
                      locationData.distance = value;
                    else if (trimmedKey === "Trajectory Points") {
                      // Â∞ÜÈÄóÂè∑ÂàÜÈöîÁöÑÂ≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫Êàë‰ª¨ÈúÄË¶ÅÁöÑÂØπË±°Êï∞ÁªÑ
                      locationData.trajectoryPoints = value
                        .split(/[,Ôºå]/) // ÊîØÊåÅ‰∏≠Ëã±ÊñáÈÄóÂè∑
                        .map((name) => ({ name: name.trim() }))
                        .filter((p) => p.name);
                    }
                  }
                });

                // 4. Ê£ÄÊü•ÊòØÂê¶ÊàêÂäüÊèêÂèñ‰∫ÜÊúÄÂÖ≥ÈîÆÁöÑ‰ø°ÊÅØ
                if (locationData.distance) {
                  // 5. ÊâãÂä®ÊûÑÂª∫‰∏Ä‰∏™ÂÆåÁæéÊ†ºÂºèÁöÑ location Ê∂àÊÅØÂØπË±°
                  aiMessage = {
                    ...baseMessage, // Â§çÁî®Â∑≤ÊúâÁöÑÂèëÈÄÅËÄÖ„ÄÅÊó∂Èó¥Êà≥Á≠â‰ø°ÊÅØ
                    type: "location",
                    userLocation: locationData.userLocation || "",
                    aiLocation: locationData.aiLocation || "",
                    distance: locationData.distance,
                    trajectoryPoints: locationData.trajectoryPoints || [],
                  };

                  // 6. Â∞ÜËøô‰∏™ÂÆåÁæéÁöÑÂØπË±°Êé®ÂÖ•ÂæÖÂ§ÑÁêÜÂàóË°®ÔºåÂπ∂Ë∑≥ËøáÂêéÁª≠ÁöÑ switch-case
                  // (Âõ†‰∏∫Êàë‰ª¨Â∑≤ÁªèÂ§ÑÁêÜÂÆåËøôÊù°Ê∂àÊÅØ‰∫Ü)
                  chat.history.push(aiMessage);
                  if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                  }
                  console.log("Location instruction parsed successfully and message object created:", aiMessage);

                  // ‰ΩøÁî® continue Ë∑≥ËøáÊú¨Ê¨°Âæ™ÁéØÁöÑÂâ©‰ΩôÈÉ®ÂàÜÔºåÁõ¥Êé•Â§ÑÁêÜ‰∏ã‰∏ÄÊù°AIÂõûÂ§ç
                  continue;
                }
              }
              // Ê£ÄÊü•Ê∂àÊÅØÁöÑÂèëÈÄÅËÄÖÊòØÂê¶Ë¢´Á¶ÅË®Ä‰∫Ü
              if (chat.isGroup && msgData.name) {
                const senderMember = chat.members.find(
                  (m) => m.originalName === msgData.name,
                );
                if (senderMember && senderMember.isMuted) {
                  // Â¶ÇÊûúË¢´Á¶ÅË®Ä‰∫ÜÔºåÂ∞±Âú®ÊéßÂà∂Âè∞ÊâìÂç∞‰∏ÄÊù°Êó•ÂøóÔºåÁÑ∂ÂêéË∑≥ËøáËøôÊù°Ê∂àÊÅØÔºå‰∏çËÆ©ÂÆÉÊòæÁ§∫Âá∫Êù•
                  console.warn(
                    `Intercepted message from muted member (${msgData.name}), content:`,
                    msgData.content || msgData.message,
                  );
                  continue;
                }
              }

              switch (msgData.type) {
                case "sticker": {
                  // ËøôÊòØ‰∏∫Áæ§ËÅäËÆæËÆ°ÁöÑË°®ÊÉÖÂåÖÈÄªËæë
                  const stickerName = msgData.sticker_name;
                  if (!stickerName) {
                    console.warn(
                      "AI in group chat returned a sticker type but without sticker_name, intercepted:",
                      msgData,
                    );
                    continue; // Ë∑≥ËøáËøôÊù°Êó†ÊïàÊåá‰ª§
                  }

                  // Âú®ÊâÄÊúâÂèØÁî®Ë°®ÊÉÖÂ∫ì‰∏≠Êü•Êâæ
                  const allStickers = [
                    ...state.userStickers,
                    ...state.charStickers,
                    ...(chat.settings.stickerLibrary || []),
                  ];
                  const foundSticker = allStickers.find(
                    (s) => s.name === stickerName,
                  );

                  if (foundSticker) {
                    // ÊâæÂà∞‰∫ÜÔºåÂ∞±ÂàõÂª∫Ê∂àÊÅØÂØπË±°
                    aiMessage = {
                      ...baseMessage,
                      type: "sticker",
                      content: foundSticker.url,
                      meaning: foundSticker.name,
                    };
                  } else {
                    // Ê≤°ÊâæÂà∞ÔºåËØ¥ÊòéAIÂπªËßâ‰∫ÜÔºåËÆ∞ÂΩïË≠¶ÂëäÂπ∂Ë∑≥Ëøá
                    console.warn(
                      `AI in group chat fabricated a non-existent sticker: "${stickerName}", automatically intercepted.`,
                    );
                  }
                  break;
                }
                case "change_couple_avatar": {
                  const pairId = msgData.avatar_id;
                  const library = chat.settings.coupleAvatarLibrary || [];
                  const targetPair = library.find((p) => p.id === pairId);

                  if (targetPair) {
                    // 1. Êõ¥Êñ∞ÂèåÊñπÂ§¥ÂÉè
                    chat.settings.aiAvatar = targetPair.charAvatar;
                    chat.settings.myAvatar = targetPair.userAvatar;

                    // 2. Ëá™Âä®ÂºÄÂêØÊÉÖ‰æ£Ê®°ÂºèÂπ∂Êõ¥Êñ∞ÊèèËø∞
                    chat.settings.isCoupleAvatar = true;
                    chat.settings.coupleAvatarDescription =
                      targetPair.description;

                    // 3. ÁîüÊàêÁ≥ªÁªüÊèêÁ§∫Ê∂àÊÅØ
                    const sysMsg = {
                      role: "system",
                      type: "pat_message",
                      content: `[${chat.name} thinks the current atmosphere is perfect for changing the couple avatars to: ${targetPair.description}]`,
                      timestamp: Date.now(),
                    };
                    chat.history.push(sysMsg);

                    // 4. ‰øùÂ≠òÂπ∂Âà∑Êñ∞
                    await db.chats.put(chat);

                    if (isViewingThisChat) {
                      appendMessage(sysMsg, chat);
                      renderChatInterface(chatId); // Âà∑Êñ∞ÁïåÈù¢‰ª•ÊòæÁ§∫Êñ∞Â§¥ÂÉè
                    }
                  }
                  continue; // ÁªßÁª≠Â§ÑÁêÜÂÖ∂‰ªñÊ∂àÊÅØ
                }
                // ‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº Âú® switch ËØ≠Âè•‰∏≠ÊèíÂÖ•/ÊõøÊç¢Ê≠§ÊÆµ‰ª£Á†Å ‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
                case "set_new_couple_avatar": {
                  // 1. ÊêúÈõÜÁî®Êà∑ÊúÄËøëÂèëÈÄÅÁöÑÊâÄÊúâÂõæÁâá
                  const recentUserImages = [];
                  // ÂêëÂõûÊü•ÊâæÊúÄËøë 10 Êù°Ê∂àÊÅØÔºåÊî∂ÈõÜÈáåÈù¢ÁöÑÊâÄÊúâÂõæÁâá
                  const recentUserMsgs = chat.history
                    .filter((m) => m.role === "user" && !m.isHidden)
                    .slice(-10)
                    .reverse(); // ÁøªËΩ¨ÔºöÂèòÊàê [ÊúÄÊñ∞Ê∂àÊÅØ, ..., ËæÉÊóßÊ∂àÊÅØ]

                  recentUserMsgs.forEach((msg) => {
                    // ÊîØÊåÅÂ§öÊ®°ÊÄÅÊ∂àÊÅØ (Êï∞ÁªÑÁªìÊûÑ)
                    if (Array.isArray(msg.content)) {
                      msg.content.forEach((part) => {
                        if (part.type === "image_url") {
                          // unshift: ÊèíÂÖ•Âà∞Êï∞ÁªÑÂºÄÂ§¥
                          // Âõ†‰∏∫Êàë‰ª¨ÈÅçÂéÜÁöÑÊòØ‚Äú‰ªéÊñ∞Âà∞Êóß‚ÄùÔºåunshift ‰ºöËÆ©ÊúÄÁªàÊï∞ÁªÑÂèòÊàê [ÊóßÂõæ1, ÊóßÂõæ2, ..., ÊúÄÊñ∞Âõæ]
                          // ËøôÊ†∑ index 0 Â∞±ÊòØÁî®Êà∑ÂÖàÂèëÁöÑÈÇ£Âº†
                          recentUserImages.unshift(part.image_url.url);
                        }
                      });
                    }
                    // ÂÖºÂÆπÊóßÁöÑÂçïÂõæÁâáÊ†ºÂºè
                    else if (
                      msg.type === "user_photo" ||
                      msg.type === "ai_image"
                    ) {
                      if (msg.content && msg.content.startsWith("data:image")) {
                        recentUserImages.unshift(msg.content);
                      }
                    }
                  });

                  let userAvatarUrl, charAvatarUrl;
                  let success = false;

                  // 2. Ê†πÊçÆÂõæÁâáÊï∞ÈáèÂÜ≥ÂÆöÁ≠ñÁï•
                  if (recentUserImages.length === 0) {
                    // ‰∏ÄÂº†ÂõæÈÉΩÊ≤°ÊâæÂà∞
                    aiMessage = {
                      ...baseMessage,
                      content: "(Scratches head) I couldn't find any images. Could you try sending them again?",
                    };
                  } else if (recentUserImages.length === 1) {
                    // === Strategy A: Only one image ===
                    // Default: This image is for Char, User remains the same
                    charAvatarUrl = recentUserImages[0];
                    userAvatarUrl = chat.settings.myAvatar || defaultAvatar; // Ëé∑ÂèñÁî®Êà∑ÂΩìÂâçÂ§¥ÂÉè
                    success = true;
                  } else {
                    // === Á≠ñÁï• BÔºöÊúâ‰∏§Âº†Âèä‰ª•‰∏äÂõæ ===
                    // ‰ΩøÁî® AI ÊåáÂÆöÁöÑÁ¥¢ÂºïÔºåÈªòËÆ§‰∏∫ 0 Âíå 1
                    const userIdx =
                      typeof msgData.user_img_index === "number"
                        ? msgData.user_img_index
                        : 0;
                    const charIdx =
                      typeof msgData.char_img_index === "number"
                        ? msgData.char_img_index
                        : 1;

                    userAvatarUrl =
                      recentUserImages[userIdx] || recentUserImages[0];
                    charAvatarUrl =
                      recentUserImages[charIdx] || recentUserImages[1];
                    success = true;
                  }

                  if (success) {
                    // 3. Êõ¥Êñ∞ÂΩìÂâçËÆæÁΩÆ
                    chat.settings.myAvatar = userAvatarUrl;
                    chat.settings.aiAvatar = charAvatarUrl;
                    chat.settings.isCoupleAvatar = true;
                    chat.settings.coupleAvatarDescription =
                      msgData.description || "Sweet couple avatars";

                    // 4. Â≠òÂÖ•ÊÉÖÂ§¥Â∫ì
                    if (!chat.settings.coupleAvatarLibrary) {
                      chat.settings.coupleAvatarLibrary = [];
                    }
                    const newPair = {
                      id: "couple_" + Date.now(),
                      userAvatar: userAvatarUrl,
                      charAvatar: charAvatarUrl,
                      description:
                        msgData.description ||
                        `Saved on ${new Date().toLocaleString()}`,
                    };
                    chat.settings.coupleAvatarLibrary.push(newPair);

                    // 5. ‰øùÂ≠òÊï∞ÊçÆÂ∫ì
                    await db.chats.put(chat);

                    // 6. ÂèëÈÄÅÁ≥ªÁªüÊèêÁ§∫Ê∂àÊÅØ (ËßÜËßâÂèçÈ¶à)
                    const successTip = {
                      role: "system",
                      type: "pat_message",
                      content: `[Couple avatars have been changed and saved to the library]`,
                      timestamp: Date.now(),
                    };
                    chat.history.push(successTip);

                    if (isViewingThisChat) {
                      appendMessage(successTip, chat);
                      renderChatInterface(chatId); // Á´ãÂç≥Âà∑Êñ∞ÁïåÈù¢Â§¥ÂÉè
                    }
                  }

                  // ÁªßÁª≠Â§ÑÁêÜ (continue)Ôºå‰ª•‰æø AI ÂèØ‰ª•ÂèëÂá∫ÂÆÉÁîüÊàêÁöÑÊñáÊú¨Ê∂àÊÅØ (content)
                  continue;
                }
                // ‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤ ‰ª£Á†ÅÁªìÊùü ‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

                case "waimai_response":
                  const requestMessageIndex = chat.history.findIndex(
                    (m) => m.timestamp === msgData.for_timestamp,
                  );
                  if (requestMessageIndex > -1) {
                    const originalMsg = chat.history[requestMessageIndex];
                    originalMsg.status = msgData.status;
                    originalMsg.paidBy =
                      msgData.status === "paid" ? msgData.name : null;
                  }
                  continue;

                case "set_group_title": {
                  const actorName = msgData.name;
                  const targetName = msgData.targetName;
                  const newTitle = msgData.title || "";
                  const myNickname = chat.settings.myNickname || "Me";

                  // ÊùÉÈôêÊ£ÄÊü•ÔºöÁæ§‰∏ªÊàñÁÆ°ÁêÜÂëòÂèØ‰ª•ËÆæÁΩÆÂ§¥Ë°î
                  const actorMember = chat.members.find(
                    (m) => m.originalName === actorName,
                  );
                  const isActorAdmin = actorMember && actorMember.isAdmin;
                  const isActorOwner =
                    actorMember && chat.ownerId === actorMember.id;
                  if (!isActorAdmin && !isActorOwner) {
                    console.warn(
                      `AI "${actorName}" Â∞ùËØïËÆæÁΩÆÂ§¥Ë°îÂ§±Ë¥•ÔºåÊùÉÈôê‰∏çË∂≥„ÄÇ`,
                    );
                    continue;
                  }

                  if (targetName === myNickname) {
                    // Â¶ÇÊûúÁõÆÊ†áÊòØ‰Ω†Ëá™Â∑±
                    chat.settings.myGroupTitle = newTitle.trim();
                    console.log(
                      `The administrator/group owner will remove the user. "${myNickname}"'s group title has been set to: "${newTitle.trim()}"`,
                    );
                  } else {
                    // Â¶ÇÊûúÁõÆÊ†áÊòØÂÖ∂‰ªñÊàêÂëò
                    const targetMember = chat.members.find(
                      (m) => m.groupNickname === targetName,
                    );
                    if (targetMember) {
                      targetMember.groupTitle = newTitle.trim();
                      console.log(
                        `The administrator/group owner has set the group title of member "${targetName}" to: "${newTitle.trim()}"`,
                      );
                    } else {
                      console.warn(
                        `AI "${actorName}" attempted to set the group title but could not find the target member "${targetName}".`,
                      );
                      continue;
                    }
                  }

                  // Send a system message notification
                  await logTitleChange(
                    chat.id,
                    actorName,
                    targetName,
                    newTitle.trim(),
                  );

                  // Âà∑Êñ∞ÊàêÂëòÂàóË°®UIÔºàÂ¶ÇÊûúÊâìÂºÄ‰∫ÜÁöÑËØùÔºâ
                  if (
                    document
                      .getElementById("member-management-screen")
                      .classList.contains("active")
                  ) {
                    renderMemberManagementList();
                  }

                  continue; // ÂêéÂè∞Êìç‰ΩúÔºåÁªßÁª≠Â§ÑÁêÜ
                }

                case "order_waimai_for_user": {
                  const { foodName, restaurant, price, greeting } = msgData;

                  // 1. ÂÆâÂÖ®Ê£ÄÊü•ÔºåÁ°Æ‰øùAIÁªôÁöÑÊï∞ÊçÆÊòØÂØπÁöÑ
                  if (!foodName || isNaN(price) || price <= 0) {
                    console.warn(
                      "AI attempted to order takeout for you, but the command format is incorrect:",
                      msgData,
                    );
                    continue; // Skip this invalid command
                  }

                  // 2. Ê£ÄÊü•ËßíËâ≤Èí±ÂåÖ‰ΩôÈ¢ù
                  const charBalance =
                    chat.characterPhoneData?.bank?.balance || 0;
                  if (charBalance < price) {
                    // Â¶ÇÊûú‰ΩôÈ¢ù‰∏çË∂≥ÔºåÂ∞±ËÆ©AIÂèëÊù°Ê∂àÊÅØÂëäËØâ‰Ω†
                    aiMessage = {
                      ...baseMessage,
                      content: `(Whispering) I had intended to treat you to some "${foodName}," but I discovered my wallet is empty...`,
                    };
                  } else {
                    // 3. ‰ΩôÈ¢ùÂÖÖË∂≥ÔºÅÊâßË°åÊâ£Ê¨æÂíå‰∏ãÂçïÈÄªËæë
                    await updateCharacterBankBalance(
                      chatId,
                      -price,
                      `Ordered takeout for you: ${foodName}`,
                    );

                    const foodItem = await db.elemeFoods
                      .where({
                        name: foodName,
                        restaurant: restaurant || "Private Kitchen",
                      })
                      .first();
                    const imageUrl = foodItem
                      ? foodItem.imageUrl
                      : getRandomWaimaiImage();
                    // 4. ÂàõÂª∫‰∏Ä‰∏™ÊºÇ‰∫ÆÁöÑÂ§ñÂçñÂç°ÁâáÊ∂àÊÅØ
                    aiMessage = {
                      ...baseMessage,
                      type: "waimai_gift_from_char",
                      content: `[Takeout Surprise] I ordered some "${foodName}" for you, enjoy!`, // This text is mainly for history and notifications
                      payload: {
                        foodName: foodName,
                        restaurant: restaurant || "Mystery Kitchen",
                        price: price,
                        greeting: greeting || "I ordered something delicious for you, enjoy!",
                        foodImageUrl: imageUrl, // <-- Using the correct image URL we just obtained
                      },
                    };
                  }
                  break; // ÁªìÊùüËøô‰∏™case
                }

                case "set_group_admin": {
                  const actorName = msgData.name;
                  const targetName = msgData.targetName;
                  const isAdmin = msgData.isAdmin;
                  const myNickname = chat.settings.myNickname || "Me"; // Ëé∑Âèñ‰Ω†Ëá™Â∑±ÁöÑÊòµÁß∞

                  // ÊùÉÈôêÊ£ÄÊü•ÔºöÁ°ÆËÆ§Êìç‰ΩúËÄÖÊòØÁæ§‰∏ª
                  const actorMember = chat.members.find(
                    (m) => m.originalName === actorName,
                  );
                  if (!actorMember || chat.ownerId !== actorMember.id) {
                    console.warn(
                      `AI "${actorName}" attempted to set group admin but failed because it is not the group owner.`,
                    );
                    continue; // If not the group owner, skip this command
                  }

                  if (targetName === myNickname) {
                    // Â¶ÇÊûúAIÊìç‰ΩúÁöÑÁõÆÊ†áÊòØ‰Ω†Ëá™Â∑±
                    chat.settings.isUserAdmin = isAdmin;
                    console.log(
                      `The group owner has set the user "${myNickname}" as an admin: ${isAdmin}`,
                    );
                  } else {
                    // If the AI's target is another member
                    const targetMember = chat.members.find(
                      (m) => m.groupNickname === targetName,
                    );
                    if (targetMember) {
                      // Cannot operate on the group owner
                      if (targetMember.id === chat.ownerId) {
                        console.warn(
                          `AI "${actorName}" attempted to modify the group owner "${targetName}" admin status, operation blocked.`,
                        );
                        continue;
                      }
                      targetMember.isAdmin = isAdmin;
                      console.log(
                        `The group owner has set the member "${targetName}" as an admin: ${isAdmin}`,
                      );
                    } else {
                      // If the target member is not found in the member list, skip
                      console.warn(
                        `AI "${actorName}" attempted to set admin but failed because the target member "${targetName}" was not found.`,
                      );
                      continue;
                    }
                  }

                  // Unified system message notification
                  const actionText = isAdmin
                    ? "set as admin"
                    : "removed from admin";
                  await logSystemMessage(
                    chat.id,
                    `"${actorName}" ${actionText} "${targetName}".`,
                  );

                  // Refresh member list UI (if open)
                  if (
                    document
                      .getElementById("member-management-screen")
                      .classList.contains("active")
                  ) {
                    renderMemberManagementList();
                  }

                  continue; // This is a background operation, continue processing other messages from AI
                }

                case "kick_member": {
                  const actorName = msgData.name;
                  const targetName = msgData.targetName;
                  const actorMember = chat.members.find(
                    (m) => m.originalName === actorName,
                  );

                  // ÊùÉÈôêÊ£ÄÊü•ÔºöÂè™ÊúâÁæ§‰∏ªËÉΩÊâßË°å
                  if (actorMember && chat.ownerId === actorMember.id) {
                    const targetMemberIndex = chat.members.findIndex(
                      (m) => m.groupNickname === targetName,
                    );
                    if (targetMemberIndex > -1) {
                      const removedMember = chat.members.splice(
                        targetMemberIndex,
                        1,
                      )[0];

                      // Â∞ÜÊîπÂä®‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
                      await db.chats.put(chat);

                      // ÂèëÈÄÅÁ≥ªÁªüÈÄöÁü•ÔºàËøôË°å‰ª£Á†Å‰∏çÂèòÔºå‰ΩÜ‰ΩçÁΩÆÊõ¥ÂêàÁêÜ‰∫ÜÔºâ
                      await logSystemMessage(
                        chat.id,
                        `"${actorName}" removed "${removedMember.groupNickname}" from the group chat.`,
                      );

                      // Â¶ÇÊûúÂΩìÂâçÊ≠£Âú®ÊàêÂëòÁÆ°ÁêÜÈ°µÈù¢ÔºåÂ∞±Âà∑Êñ∞ÂàóË°®
                      if (
                        document
                          .getElementById("member-management-screen")
                          .classList.contains("active")
                      ) {
                        renderMemberManagementList();
                      }
                    }
                  }
                  continue; // ‰øùÊåÅÂêéÂè∞Êìç‰ΩúÔºåÁªßÁª≠Â§ÑÁêÜ
                }

                case "dating_summary_card": {
                  bubble.classList.add("is-dating-summary"); // Â∫îÁî®ÈÄèÊòéÊ∞îÊ≥°Ê†∑Âºè
                  const payload = msg.payload;
                  let cardClass = "";

                  // Ê†πÊçÆÂç°ÁâáÁ±ªÂûãËÆæÁΩÆËÉåÊôØËâ≤
                  if (payload.ratingType === "romantic") {
                    cardClass = "romantic";
                  } else if (payload.ratingType === "passionate") {
                    cardClass = "passionate";
                  } else if (payload.ratingType === "perfect") {
                    cardClass = "perfect";
                  }

                  // Êää payload Â≠óÁ¨¶‰∏≤ÂåñÂêéÂ≠òÂÖ• data-* Â±ûÊÄßÔºåÊñπ‰æøÁÇπÂáªÊó∂ËØªÂèñ
                  const payloadString = JSON.stringify(payload)
                    .replace(/'/g, "&apos;")
                    .replace(/"/g, "&quot;");

                  contentHtml = `
			            <div class="dating-summary-chat-card ${cardClass}" data-summary-payload='${payloadString}'>
			                <div class="rating">${payload.rating}</div>
			                <div class="tip">ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖ</div>
			            </div>
			        `;
                  break;
                }
                case "set_group_announcement": {
                  const actorName = msgData.name;
                  const newAnnouncement = msgData.content;

                  if (!actorName || typeof newAnnouncement === "undefined") {
                    console.warn("The attempt to modify the announcement by the AI was unsuccessful due to missing essential parameters.");
                    continue; // Êåá‰ª§‰∏çÂÆåÊï¥ÔºåË∑≥Ëøá
                  }

                  // 1. ÊùÉÈôêÊ£ÄÊü•ÔºöÂøÖÈ°ªÁ°Æ‰øùÊâßË°åÊìç‰ΩúÁöÑËßíËâ≤ÊòØÁæ§‰∏ªÊàñÁÆ°ÁêÜÂëò
                  const actorMember = chat.members.find(
                    (m) => m.originalName === actorName,
                  );
                  if (!actorMember) {
                    console.warn(
                      `The AI attempted to modify the announcement but failed because the member "${actorName}" was not found.`,

                    );
                    continue;
                  }

                  const isOwner = chat.ownerId === actorMember.id;
                  const isAdmin = actorMember.isAdmin;

                  if (!isOwner && !isAdmin) {
                    console.warn(
                      `The AI role "${actorName}" does not have sufficient permissions to modify the group announcement.`,
                    );
                    continue; // Ê≤°ÊúâÊùÉÈôêÔºåË∑≥Ëøá
                  }

                  // 2. Êõ¥Êñ∞ÂÖ¨ÂëäÂÜÖÂÆπ
                  chat.settings.groupAnnouncement = newAnnouncement;
                  await db.chats.put(chat);

                  // 3. ÂèëÈÄÅ‰∏ÄÊù°Á≥ªÁªüÊ∂àÊÅØÔºåÈÄöÁü•ÊâÄÊúâ‰∫∫Áæ§ÂÖ¨ÂëäÂ∑≤Êõ¥Êñ∞
                  await logSystemMessage(
                    chat.id,
                    `"${actorMember.groupNickname}" modified the group announcement.`,
                  );

                  // ËøôÊòØ‰∏Ä‰∏™ÂêéÂè∞ÁÆ°ÁêÜÊìç‰ΩúÔºå‰∏çÈúÄË¶ÅÂú®ËÅäÂ§©‰∏≠ÁîüÊàêÊñ∞ÁöÑÂØπËØùÊ∞îÊ≥°ÔºåÊâÄ‰ª•Êàë‰ª¨Áî® continue
                  continue;
                }

                case "mute_member": {
                  const actorName = msgData.name;
                  const targetName = msgData.targetName;
                  const actorMember = chat.members.find(
                    (m) => m.originalName === actorName,
                  );
                  const targetMember = chat.members.find(
                    (m) => m.groupNickname === targetName,
                  );

                  if (actorMember && targetMember) {
                    const isActorOwner = chat.ownerId === actorMember.id;
                    const isActorAdmin = actorMember.isAdmin;
                    const isTargetOwner = chat.ownerId === targetMember.id;
                    const isTargetAdmin = targetMember.isAdmin;

                    // ÊùÉÈôêÊ£ÄÊü•ÔºöÁæ§‰∏ªÂèØ‰ª•Á¶ÅË®ÄÁÆ°ÁêÜÂëòÂíåÊôÆÈÄö‰∫∫ÔºõÁÆ°ÁêÜÂëòÂè™ËÉΩÁ¶ÅË®ÄÊôÆÈÄö‰∫∫„ÄÇ
                    if (
                      (isActorOwner && !isTargetOwner) ||
                      (isActorAdmin && !isTargetOwner && !isTargetAdmin)
                    ) {
                      // ÂèëÈÄÅÁ≥ªÁªüÊ∂àÊÅØ
                      await logSystemMessage(
                        chat.id,
                        `"${actorName}" muted "${targetName}".`,
                      );
                    } else {
                      console.warn(
                        `AI (${actorName}) does not have sufficient permissions to mute (${targetName}).`,
                      );
                    }
                  }
                  continue; // Ëøô‰πüÊòØ‰∏Ä‰∏™ÂêéÂè∞ÁÆ°ÁêÜÊìç‰ΩúÔºåÁªßÁª≠Â§ÑÁêÜAIÂèØËÉΩËøîÂõûÁöÑÂÖ∂‰ªñÊ∂àÊÅØ
                }

                case "unmute_member": {
                  const actorName = msgData.name;
                  const targetName = msgData.targetName;
                  const actorMember = chat.members.find(
                    (m) => m.originalName === actorName,
                  );
                  const targetMember = chat.members.find(
                    (m) => m.groupNickname === targetName,
                  );

                  // Á°Æ‰øùÊìç‰ΩúËÄÖÂíåÁõÆÊ†áÈÉΩÂ≠òÂú®
                  if (actorMember && targetMember) {
                    // ÊùÉÈôêÊ£ÄÊü•
                    const isActorOwner = chat.ownerId === actorMember.id;
                    const isActorAdmin = actorMember.isAdmin;
                    const isTargetOwner = chat.ownerId === targetMember.id;
                    const isTargetAdmin = targetMember.isAdmin;

                    // Âè™ÊúâÁæ§‰∏ªÂíåÁÆ°ÁêÜÂëòÊúâÊùÉÈôêËß£Á¶Å
                    if (isActorOwner || isActorAdmin) {
                      // ËÆæÁΩÆ isMuted ‰∏∫ falseÔºåÂÆûÁé∞Ëß£Á¶Å
                      targetMember.isMuted = false;

                      // ÂèëÈÄÅ‰∏ÄÊù°Á≥ªÁªüÊ∂àÊÅØÈÄöÁü•Â§ßÂÆ∂
                      await logSystemMessage(
                        chat.id,
                        `"${actorName}" revoked "${targetName}"'s mute.`,
                      );

                      // Â¶ÇÊûúÂΩìÂâçÊ≠£Âú®ÊàêÂëòÁÆ°ÁêÜÈ°µÈù¢ÔºåÂà∑Êñ∞ÂàóË°®
                      if (
                        document
                          .getElementById("member-management-screen")
                          .classList.contains("active")
                      ) {
                        renderMemberManagementList();
                      }
                    } else {
                      console.warn(
                        `AI (${actorName}) does not have sufficient permissions to unmute (${targetName}).`,
                      );
                    }
                  }
                  continue; // This is also a background operation, continue processing other messages from AI
                }

                case "weibo_post": {
                  const newPost = {
                    authorId: chatId,
                    authorType: "char",
                    authorNickname: chat.name,
                    authorAvatar: chat.settings.aiAvatar || defaultAvatar,
                    content: msgData.content || "",
                    postType: msgData.postType || "text_only",
                    hiddenContent: msgData.hiddenContent || "",
                    imageUrl: msgData.imageUrl || "",
                    imageDescription: msgData.imageDescription || "",
                    timestamp: Date.now(),
                    likes: [],
                    comments: [], // ÂÖàÂàùÂßãÂåñ‰∏∫Á©∫Êï∞ÁªÑ
                    baseLikesCount: msgData.baseLikesCount || 0,
                    baseCommentsCount: msgData.baseCommentsCount || 0,
                  };

                  let commentsToProcess = [];

                  // 1. ‰ºòÂÖàÂ§ÑÁêÜÊñ∞ÁöÑ„ÄÅÊ≠£Á°ÆÁöÑ„ÄêÊï∞ÁªÑÊ†ºÂºè„Äë
                  if (msgData.comments && Array.isArray(msgData.comments)) {
                    // Áõ¥Êé•‰ΩøÁî®AIËøîÂõûÁöÑÊï∞ÁªÑ
                    commentsToProcess = msgData.comments;
                  }
                  // 2. ÂÖºÂÆπÊóßÁöÑ„ÄêÂ≠óÁ¨¶‰∏≤Ê†ºÂºè„Äë
                  else if (
                    msgData.comments &&
                    typeof msgData.comments === "string"
                  ) {
                    // Â¶ÇÊûúÊòØÂ≠óÁ¨¶‰∏≤ÔºåÂ∞±ÊåâËÄÅÊñπÊ≥ïËß£Êûê
                    commentsToProcess = msgData.comments
                      .split("\n")
                      .map((c) => {
                        const parts = c.split(/[:Ôºö]/);
                        const commenter = parts.shift() || "Anonymous";
                        const commentText = parts.join(":").trim();
                        return {
                          authorNickname: commenter,
                          commentText: commentText,
                        };
                      })
                      .filter((c) => c.commentText);
                  }

                  // 3. ‰∏∫ÊâÄÊúâËß£ÊûêÂ•ΩÁöÑËØÑËÆ∫ÔºåÁªü‰∏ÄÊ∑ªÂä†ÂâçÁ´ØÈúÄË¶ÅÁöÑ commentId
                  if (commentsToProcess.length > 0) {
                    newPost.comments = commentsToProcess.map((c) => ({
                      commentId: "comment_" + Date.now() + Math.random(), // Á°Æ‰øùÊØèÊù°ËØÑËÆ∫ÈÉΩÊúâÂîØ‰∏ÄID
                      authorNickname: c.authorNickname,
                      commentText: c.commentText,
                      // ËøôÈáåÊàë‰ª¨‰∏çÂÜçÈúÄË¶Å authorId Âíå timestampÔºåÂõ†‰∏∫ÂÆÉ‰ª¨‰∏çÊòØÊ∏≤ÊüìÊâÄÂøÖÈúÄÁöÑ
                    }));
                  }

                  await db.weiboPosts.add(newPost);

                  showNotification(chatId, `${chat.name} posted a new Weibo`);

                  if (
                    document
                      .getElementById("weibo-screen")
                      .classList.contains("active")
                  ) {
                    await renderFollowingWeiboFeed();
                  }

                  continue; // This is a background operation, continue processing other messages from AI
                }

                case "weibo_comment": {
                  // ËøôÊòØ‰∏Ä‰∏™AIËØÑËÆ∫ÂæÆÂçöÁöÑÊåá‰ª§
                  const postIdToComment = msgData.postId;
                  const commentText = msgData.commentText;

                  // 1. Ê†πÊçÆ postId ‰ªéÊï∞ÊçÆÂ∫ìÈáåÊâæÂà∞ÈÇ£Êù°ÂæÆÂçö
                  const postToComment =
                    await db.weiboPosts.get(postIdToComment);

                  if (postToComment) {
                    // 2. Â¶ÇÊûúÊâæÂà∞‰∫ÜÂæÆÂçöÔºåÂ∞±ÂáÜÂ§á‰∏ÄÊù°Êñ∞ËØÑËÆ∫
                    if (!postToComment.comments) postToComment.comments = []; // Á°Æ‰øùËØÑËÆ∫Âå∫Â≠òÂú®
                    const newComment = {
                      commentId: "comment_" + Date.now(), // ÁªôËØÑËÆ∫‰∏Ä‰∏™Áã¨‰∏ÄÊó†‰∫åÁöÑID
                      authorId: chatId, // ËØÑËÆ∫ËÄÖÊòØÂΩìÂâçAI
                      authorNickname: chat.name, // ËØÑËÆ∫ËÄÖÁöÑÂêçÂ≠ó
                      commentText: commentText, // ËØÑËÆ∫ÂÜÖÂÆπ
                      timestamp: Date.now(), // ËØÑËÆ∫Êó∂Èó¥
                    };

                    // 3. ÊääÊñ∞ËØÑËÆ∫Âä†Âà∞ÂæÆÂçöÁöÑËØÑËÆ∫ÂàóË°®Èáå
                    postToComment.comments.push(newComment);

                    // 4. ÊääÊõ¥Êñ∞ÂêéÁöÑÂæÆÂçöÂ≠òÂõûÊï∞ÊçÆÂ∫ì
                    await db.weiboPosts.put(postToComment);

                    // 5. Âà∑Êñ∞‚ÄúÊàëÁöÑÂæÆÂçö‚ÄùÂíå‚ÄúÂÖ≥Ê≥®ÁöÑ‰∫∫‚Äù‰∏§‰∏™ÂàóË°®ÔºåËÆ©Êñ∞ËØÑËÆ∫ÊòæÁ§∫Âá∫Êù•
                    await renderMyWeiboFeed();
                    await renderFollowingWeiboFeed();
                  }
                  continue; // Â§ÑÁêÜÂÆåÂêéÔºåÁªßÁª≠Â§ÑÁêÜAIÂèØËÉΩËøîÂõûÁöÑÂÖ∂‰ªñÊåá‰ª§
                }
                case "weibo_reply": {
                  // ËøôÊòØ‰∏Ä‰∏™AIÂõûÂ§çÂæÆÂçöËØÑËÆ∫ÁöÑÊåá‰ª§
                  const postIdToReply = msgData.postId;
                  const commentIdToReply = msgData.commentId;
                  const replyText = msgData.replyText;

                  const postToReply = await db.weiboPosts.get(postIdToReply);

                  if (postToReply && postToReply.comments) {
                    // 1. Âú®ÂæÆÂçöÁöÑËØÑËÆ∫Âå∫ÈáåÔºåÊâæÂà∞Ë¢´ÂõûÂ§çÁöÑÈÇ£Êù°ËØÑËÆ∫
                    const targetComment = postToReply.comments.find(
                      (c) => c.commentId === commentIdToReply,
                    );

                    if (targetComment) {
                      // 2. ÂáÜÂ§á‰∏ÄÊù°Êñ∞ÁöÑ‚ÄúÂõûÂ§ç‚Äù
                      const newReply = {
                        commentId: "comment_" + Date.now(),
                        authorId: chatId,
                        authorNickname: chat.name,
                        commentText: replyText,
                        timestamp: Date.now(),
                        replyToId: commentIdToReply, // Ê†áËÆ∞ËøôÊòØÂØπÂì™Êù°ËØÑËÆ∫ÁöÑÂõûÂ§ç
                        replyToNickname: targetComment.authorNickname, // ËÆ∞‰∏ãË¢´ÂõûÂ§ç‰∫∫ÁöÑÂêçÂ≠ó
                      };
                      postToReply.comments.push(newReply);
                      await db.weiboPosts.put(postToReply);

                      // 3. ÂêåÊ†∑ÔºåÂà∑Êñ∞ÊâÄÊúâÂàóË°®
                      await renderMyWeiboFeed();
                      await renderFollowingWeiboFeed();
                    }
                  }
                  continue; // ÁªßÁª≠Â§ÑÁêÜ
                }
                case "lovers_space_response": {
                  const invitationMsg = chat.history.find(
                    (m) =>
                      m.type === "lovers_space_invitation" &&
                      m.status === "pending",
                  );
                  if (invitationMsg) {
                    invitationMsg.status =
                      msgData.decision === "accept" ? "accepted" : "rejected";

                    // 1. ÂàõÂª∫AIÊÉ≥ËØ¥ÁöÑÈÇ£Âè•ËØùÁöÑÊ∂àÊÅØ
                    if (msgData.responseText) {
                      const responseMessage = {
                        ...baseMessage, // Â§çÁî®Êó∂Èó¥Êà≥ÂíåÂèëÈÄÅËÄÖ‰ø°ÊÅØ
                        type: "text",
                        content: msgData.responseText,
                      };
                      chat.history.push(responseMessage);
                      if (isViewingThisChat) {
                        appendMessage(responseMessage, chat);
                      }
                    }

                    // 2. Ê†πÊçÆÂêåÊÑèÊàñÊãíÁªùÔºåÊâßË°åÂêéÁª≠Êìç‰Ωú
                    if (msgData.decision === "accept") {
                      chat.loversSpaceData = {
                        background:
                          "https://i.postimg.cc/k495F4W5/profile-banner.jpg",
                        relationshipStartDate: null,
                        moments: [],
                        photos: [],
                        albums: [],
                        loveLetters: [],
                        shares: [],
                        questions: [],
                      };
                      const systemNotice = {
                        role: "system",
                        type: "pat_message",
                        content: `[System: Your lovers' space with "${chat.name}" has been successfully opened!]`,
                        timestamp: Date.now(),
                      };
                      chat.history.push(systemNotice);
                      if (isViewingThisChat) {
                        appendMessage(systemNotice, chat);
                      }
                    }
                  }
                  // After processing, there's no need to trigger AI again, so we use continue
                  continue;
                }

                case "interact_with_pet": {
                  const pet = chat.settings.pet;
                  if (pet && pet.type !== "None") {
                    let actionText = "";
                    // Modify values based on AI interaction
                    switch (msgData.action) {
                      case "feed":
                        pet.status.hunger = Math.min(
                          100,
                          (pet.status.hunger || 0) + 20,
                        );
                        pet.status.happiness = Math.min(
                          100,
                          (pet.status.happiness || 0) + 5,
                        );
                        // AIÂñÇÈ£üÔºåÂ¢ûÂä†ÂØπAIÁöÑ‰∫≤ÂØÜÂ∫¶
                        pet.status.intimacyToChar = Math.min(
                          100,
                          (pet.status.intimacyToChar || 0) + 10,
                        );
                        actionText = `${chat.name} fed ${pet.name} some food.`;
                        break;
                      case "play":
                        pet.status.hunger = Math.max(
                          0,
                          (pet.status.hunger || 0) - 10,
                        );
                        pet.status.happiness = Math.min(
                          100,
                          (pet.status.happiness || 0) + 15,
                        );
                        // AI plays, increasing intimacy with AI
                        pet.status.intimacyToChar = Math.min(
                          100,
                          (pet.status.intimacyToChar || 0) + 15,
                        );
                        actionText = `${chat.name} played with ${pet.name} for a while.`;
                        break;
                      case "touch":
                        pet.status.happiness = Math.min(
                          100,
                          (pet.status.happiness || 0) + 10,
                        );
                        // Core modification: AI touches, increasing intimacy with AI
                        pet.status.intimacyToChar = Math.min(
                          100,
                          (pet.status.intimacyToChar || 0) + 5,
                        );
                        actionText = `${chat.name} gently petted ${pet.name}.`;
                        break;
                    }

                    // Create a system message visible to the user
                    const visibleMessage = {
                      role: "system",
                      type: "pat_message",
                      content: `[System: ${actionText}]`,
                      timestamp: Date.now(),
                    };
                    chat.history.push(visibleMessage);
                    if (isViewingThisChat) {
                      appendMessage(visibleMessage, chat);
                    }

                    // Â¶ÇÊûú AI Âú®‰∫íÂä®ÂêéËøòÊÉ≥ËØ¥ÁÇπ‰ªÄ‰πà
                    if (msgData.response) {
                      aiMessage = { ...baseMessage, content: msgData.response };
                    }
                  }
                  // Â¶ÇÊûúAIÂè™ÊòØ‰∫íÂä®Ê≤°ËØ¥ËØùÔºåÂ∞±‰∏çÂàõÂª∫aiMessageÔºåÁõ¥Êé•Ë∑≥Âà∞‰∏ã‰∏Ä‰∏™Êåá‰ª§
                  if (!aiMessage) {
                    continue;
                  }
                  break;
                }

                case "talk_to_pet": {
                  if (
                    !chat.isGroup &&
                    chat.settings.pet &&
                    chat.settings.pet.type !== "None"
                  ) {
                    const pet = chat.settings.pet;

                    // ÂêåÊó∂ÂÖºÂÆπ content Âíå message Â≠óÊÆµ
                    const charMessageContent =
                      msgData.content || msgData.message;
                    if (!charMessageContent) continue; // Â¶ÇÊûúÊ≤°ÂÜÖÂÆπÔºåÂ∞±Ë∑≥Ëøá

                    // Â∞ÜCharÁöÑËØùÊ∑ªÂä†Âà∞ÂÆ†Áâ©ËÅäÂ§©ËÆ∞ÂΩï
                    const charMessageToPet = {
                      sender: "char",
                      senderName: chat.name,
                      content: charMessageContent,
                    };
                    pet.petChatHistory.push(charMessageToPet);

                    // Ëé∑ÂèñÂÆ†Áâ©ÁöÑÂõûÂ∫î
                    const petResponseToChar = await getPetApiResponse(pet);
                    if (petResponseToChar) {
                      pet.petChatHistory.push({
                        sender: "pet",
                        content: petResponseToChar,
                      });
                    }

                    // ÂàõÂª∫ÂØπÁî®Êà∑ÂèØËßÅÁöÑÁ≥ªÁªüÊó•Âøó
                    const visibleLog = `[System: "${chat.name}" said to "${pet.name}": "${charMessageContent}", it responded: "${
                      petResponseToChar || "(no response)"
                    }".]`;
                    const visibleMessage = {
                      role: "system",
                      type: "pat_message",
                      content: visibleLog,
                      timestamp: messageTimestamp++,
                    };
                    chat.history.push(visibleMessage);

                    if (isViewingThisChat) {
                      appendMessage(visibleMessage, chat);
                    }
                  }
                  continue;
                }

                case "cart_payment_response": {
                  const decision = msgData.decision;
                  const responseText = msgData.response_text;

                  // ÊâæÂà∞Áî®Êà∑ÂèëÂá∫ÁöÑ„ÄÅËøòÂ§Ñ‰∫é‚ÄúÁ≠âÂæÖ‰∏≠‚ÄùÁöÑÈÇ£‰∏™‰ª£‰ªòËØ∑Ê±Ç
                  const requestMsg = chat.history.find(
                    (m) =>
                      m.type === "cart_share_request" &&
                      m.payload.status === "pending",
                  );
                  if (!requestMsg) continue; // Â¶ÇÊûúÊâæ‰∏çÂà∞ÔºåËØ¥ÊòéËØ∑Ê±ÇÂèØËÉΩÂ∑≤Ë¢´Â§ÑÁêÜÔºåË∑≥Ëøá

                  if (decision === "accept") {
                    const totalPrice = requestMsg.payload.totalPrice;
                    const charBalance =
                      chat.characterPhoneData?.bank?.balance || 0;

                    // ÂÜçÊ¨°Á°ÆËÆ§AIÁöÑ‰ΩôÈ¢ùÊòØÂê¶Ë∂≥Â§ü
                    if (charBalance < totalPrice) {
                      // Â¶ÇÊûúAIÊÉ≥‰ªò‰ΩÜÈí±‰∏çÂ§üÔºåÂ∞±ËÆ©ÂÆÉËØ¥‰∏ÄÂè•‰øèÁöÆËØù
                      aiMessage = {
                        ...baseMessage,
                        content:
                          responseText ||
                          "Waaah, I wanted to buy it for you, but my wallet is empty....",
                      };
                    } else {
                      // Èí±Â§üÔºåÊâßË°å‰ª£‰ªòÊµÅÁ®ãÔºÅ
                      requestMsg.payload.status = "paid";

                      // ‰ΩøÁî® await Á°Æ‰øùËøô‰∫õÊï∞ÊçÆÂ∫ìÊìç‰ΩúÊåâÈ°∫Â∫èÂÆåÊàê
                      await updateCharacterPhoneBankBalance(
                        chat.id,
                        -totalPrice,
                        `Paid for "my" Taobao cart`,
                      );
                      const cartItems = await db.taobaoCart.toArray();
                      await createOrdersFromCart(cartItems);
                      await clearTaobaoCart();

                      // ÂàõÂª∫AIÁöÑÂõûÂ§çÊ∂àÊÅØ
                      aiMessage = {
                        ...baseMessage,
                        content: responseText || "Bought it! Check your orders!",
                      };
                    }
                  } else {
                    // Â¶ÇÊûúAIÂÜ≥ÂÆöÊãíÁªù
                    requestMsg.payload.status = "rejected";
                    aiMessage = {
                      ...baseMessage,
                      content: responseText || "Never mind this time, next time for sure!",
                    };
                  }

                  // Â∞ÜAIÁöÑÂõûÂ§çÊ∂àÊÅØÊé®ÂÖ•ÂéÜÂè≤ËÆ∞ÂΩïÔºåÂπ∂Êõ¥Êñ∞UI
                  if (aiMessage) {
                    chat.history.push(aiMessage);
                  }

                  // ÈáçÊñ∞Ê∏≤ÊüìËÅäÂ§©ÁïåÈù¢Ôºå‰ª•Êõ¥Êñ∞‰ª£‰ªòÂç°ÁâáÁöÑÁä∂ÊÄÅ
                  if (isViewingThisChat) {
                    renderChatInterface(chatId);
                  }
                  // Ë∑≥ËøáÂêéÁª≠ÁöÑÈªòËÆ§Ê∂àÊÅØÂ§ÑÁêÜ
                  continue;
                }

                case "buy_gift_for_user": {
                  // 1. ‰ªéÂïÜÂìÅÊï∞ÊçÆÂ∫ì‰∏≠Ëé∑ÂèñÊâÄÊúâÂ∑≤Ê∑ªÂä†ÁöÑÂïÜÂìÅ
                  const allProducts = await db.taobaoProducts.toArray();

                  // Â¶ÇÊûúÊ°ÉÂÆùÈáå‰∏Ä‰ª∂ÂïÜÂìÅÈÉΩÊ≤°ÊúâÔºåAIÂ∞±ÂèëÊù°Ê∂àÊÅØÂêêÊßΩ‰∏Ä‰∏ã
                  if (allProducts.length === 0) {
                    aiMessage = {
                      ...baseMessage,
                      content: msgData.greeting
                        ? `${msgData.greeting} ...Ah, I wanted to buy something for you, but Taobao is empty...`
                        : "I wanted to buy you a gift, but Taobao has nothing to sell right now.",
                    };
                    break; // Ë∑≥Âá∫ caseÔºåËÆ©ËøôÊù°ÊñáÊú¨Ê∂àÊÅØË¢´Ê≠£Â∏∏Â§ÑÁêÜÂíåÊòæÁ§∫
                  }

                  // 2. ‰ªéÊâÄÊúâÂïÜÂìÅ‰∏≠ÈöèÊú∫ÊåëÈÄâ‰∏Ä‰ª∂‰Ωú‰∏∫Á§ºÁâ©
                  const productToBuy = getRandomItem(allProducts);

                  // 3. Ê£ÄÊü•ËßíËâ≤ÁöÑÈí±ÂåÖ‰ΩôÈ¢ùÊòØÂê¶Ë∂≥Â§ü
                  const charBalance =
                    chat.characterPhoneData?.bank?.balance || 0;
                  if (charBalance < productToBuy.price) {
                    // ‰ΩôÈ¢ù‰∏çË∂≥ÔºåAI‰πü‰ºöÂèëÊ∂àÊÅØÂëäËØâ‰Ω†
                    aiMessage = {
                      ...baseMessage,
                      content: msgData.greeting
                        ? `${msgData.greeting} ...Oh no, it looks like my wallet is running low.`
                        : "I wanted to buy you a gift, but my wallet is empty...",
                    };
                    break;
                  }

                  // 4. ‰ΩôÈ¢ùÂÖÖË∂≥ÔºÅÊâßË°åË¥≠‰π∞ÊµÅÁ®ã
                  // 4a. ‰ªéËßíËâ≤ÁöÑÈí±ÂåÖÊâ£Ê¨æÔºåÂπ∂ÁîüÊàê‰∏ÄÊù°‰∫§ÊòìËÆ∞ÂΩï
                  await updateCharacterPhoneBankBalance(
                    chat.id,
                    -productToBuy.price,
                    `Bought a gift for "me": ${productToBuy.name}`,
                  );

                  // 4b. Âú®‰Ω†ÁöÑ‚ÄúÊàëÁöÑËÆ¢Âçï‚Äù‰∏≠ÂàõÂª∫‰∏ÄÊù°Êñ∞ËÆ¢Âçï
                  const newOrder = {
                    productId: productToBuy.id,
                    quantity: 1,
                    timestamp: Date.now(),
                    status: "Paid, waiting for shipment",
                  };
                  await db.taobaoOrders.add(newOrder);

                  // 4c. ÂàõÂª∫‰∏Ä‰∏™ÊºÇ‰∫ÆÁöÑ‚ÄúÁ§ºÁâ©ÈÄöÁü•‚ÄùÂç°ÁâáÊ∂àÊÅØÔºåÂèëÈÄÅÁªô‰Ω†
                  aiMessage = {
                    ...baseMessage, // Â§çÁî®Âü∫Á°ÄÊ∂àÊÅØÂ±ûÊÄßÔºàÂèëÈÄÅËÄÖ„ÄÅÊó∂Èó¥Êà≥Á≠âÔºâ
                    type: "gift_notification",
                    // ËøôÊòØÂç°ÁâáÊ∏≤ÊüìÈúÄË¶ÅÁöÑÊï∞ÊçÆ
                    payload: {
                      senderName: chat.name,
                      itemSummary: `${productToBuy.name} x1`,
                      totalPrice: productToBuy.price,
                      itemCount: 1,
                    },
                    // ËøôÊòØÁªôAIËá™Â∑±ÁúãÁöÑ„ÄÅÁî®‰∫éÂΩ¢ÊàêËÆ∞ÂøÜÁöÑÊñáÊú¨ÂÜÖÂÆπ
                    content: `I bought you a gift "${productToBuy.name}". ${msgData.greeting || ""}`,
                  };

                  // 4d. Ê®°Êãü‰∏Ä‰∏™10ÁßíÂêéÁöÑ‚ÄúÂ∑≤ÂèëË¥ß‚ÄùÁâ©ÊµÅÊõ¥Êñ∞
                  setTimeout(async () => {
                    const orderToUpdate = await db.taobaoOrders
                      .where({ timestamp: newOrder.timestamp })
                      .first();
                    if (orderToUpdate) {
                      await db.taobaoOrders.update(orderToUpdate.id, {
                        status: "Shipped, in transit",
                      });
                    }
                  }, 1000 * 10);

                  break; // ÂÆåÊàêÁ§ºÁâ©Ë¥≠‰π∞ÈÄªËæëÔºåË∑≥Âá∫ case
                }

                case "ls_answer_question": {
                  // ‰ΩøÁî®Â§ßÊã¨Âè∑ÂàõÂª∫ÂùóÁ∫ß‰ΩúÁî®Âüü
                  const { questionId, answerText } = msgData;
                  if (questionId && answerText) {
                    const question = chat.loversSpaceData.questions.find(
                      (q) => q.id === questionId,
                    );
                    if (question && !question.answerText) {
                      // Á°Æ‰øùÊòØÊú™ÂõûÁ≠îÁöÑÈóÆÈ¢ò
                      question.answerer = "char";
                      question.answerText = answerText;
                      console.log(`AI answered a lovers' question (ID: ${questionId})`);
                    }
                  }
                  continue; // This is a background operation, no need to display in the chat interface, so use continue to skip
                }

                case "ls_ask_question": {
                  const { questionText } = msgData;
                  if (questionText) {
                    const newQuestion = {
                      id: "q_" + Date.now(),
                      questioner: "char",
                      questionText: questionText,
                      timestamp: Date.now(),
                      answerer: "user", // ÊåáÂÆöÁî±Áî®Êà∑Êù•ÂõûÁ≠î
                      answerText: null,
                    };
                    if (!chat.loversSpaceData.questions) {
                      chat.loversSpaceData.questions = [];
                    }
                    chat.loversSpaceData.questions.push(newQuestion);
                    console.log(`AI initiated a lovers' question: ${questionText}`);
                  }
                  continue; // This is also a background operation
                }

                case "ls_moment": {
                  if (chat.loversSpaceData) {
                    if (!chat.loversSpaceData.moments) {
                      chat.loversSpaceData.moments = [];
                    }
                    const newMoment = {
                      author: "char", // Ê†áËÆ∞ÊòØAIÂèëÁöÑ
                      content: msgData.content,
                      timestamp: Date.now(),
                      comments: [], // ‰∏∫Êñ∞ËØ¥ËØ¥ÂàùÂßãÂåñ‰∏Ä‰∏™Á©∫ÁöÑËØÑËÆ∫Âå∫
                    };
                    chat.loversSpaceData.moments.push(newMoment);
                    console.log(`AI posted a moment in the lovers' space: ${msgData.content}`);
                  }
                  continue; // This is a background operation, no need to display in the chat interface, so use continue to skip
                }

                case "ls_comment": {
                  const { momentIndex, commentText } = msgData;
                  if (chat.loversSpaceData && chat.loversSpaceData.moments) {
                    // AIËøîÂõûÁöÑ index ÊòØ‰ªé0ÂºÄÂßã‰ª£Ë°®ÊúÄÊñ∞ÁöÑÔºåÊàë‰ª¨ÈúÄË¶ÅËΩ¨Êç¢ÊàêÁúüÂÆûÁ¥¢Âºï
                    const realIndex =
                      chat.loversSpaceData.moments.length - 1 - momentIndex;
                    if (
                      realIndex >= 0 &&
                      realIndex < chat.loversSpaceData.moments.length
                    ) {
                      const momentToComment =
                        chat.loversSpaceData.moments[realIndex];
                      if (!momentToComment.comments) {
                        momentToComment.comments = [];
                      }
                      momentToComment.comments.push({
                        author: chat.name,
                        text: commentText,
                      });
                      console.log(
                        `AI commented on a lovers' space moment (Index: ${realIndex}): ${commentText}`,
                      );
                    }
                  }
                  continue; // This is also a background operation
                }
                case "ls_photo": {
                  // This is the logic for handling AI posting photos
                  if (chat.loversSpaceData) {
                    if (!chat.loversSpaceData.photos) {
                      chat.loversSpaceData.photos = [];
                    }
                    const newPhoto = {
                      author: "char",
                      type: "text_image",
                      description: msgData.description,
                      timestamp: Date.now(),
                    };
                    chat.loversSpaceData.photos.push(newPhoto);
                    console.log(
                      `AI posted a photo in the lovers' space (text_image): ${msgData.description}`,
                    );
                  }
                  continue; // Continue processing other possible AI commands
                }
                case "ls_photo_comment": {
                  const { photoTimestamp, commentText } = msgData;
                  console.log("üîç [Debug] Received AI photo comment command:", msgData);

                  if (chat.loversSpaceData && chat.loversSpaceData.photos) {
                    // 1. Find the photo (using == instead of === to accommodate string/number timestamp formats)
                    const targetPhoto = chat.loversSpaceData.photos.find(
                      (p) => p.timestamp == photoTimestamp,
                    );

                    if (targetPhoto) {
                      // 2. Á°Æ‰øùËØÑËÆ∫Êï∞ÁªÑÂ≠òÂú®
                      if (!targetPhoto.comments) targetPhoto.comments = [];

                      // 3. Ê∑ªÂä†ËØÑËÆ∫ÂØπË±°
                      targetPhoto.comments.push({
                        author: chat.name, // ‰ΩøÁî®ÂΩìÂâçËßíËâ≤Âêç
                        text: commentText,
                        timestamp: Date.now(),
                      });

                      console.log(`‚úÖ [Success] AI comment has been written to memory: ${commentText}`);

                      // 4. „ÄêÈáçË¶Å„Äë‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì (ËøôÊòØÂÖ≥ÈîÆÔºåÂê¶ÂàôÂà∑Êñ∞Â∞±Ê≤°‰∫Ü)
                      await db.chats.put(chat);

                      // 5. „ÄêUIÂà∑Êñ∞„ÄëÊ£ÄÊü•ÂΩìÂâçÊòØÂê¶Ê≠£Â•ΩÊâìÂºÄ‰∫ÜËøôÂº†ÁÖßÁâáÁöÑËØ¶ÊÉÖÈ°µ
                      const detailModal = document.getElementById(
                        "ls-photo-detail-modal",
                      );

                      // Ê£ÄÊü•ÂºπÁ™óÊòØÂê¶ÂèØËßÅ
                      if (
                        detailModal &&
                        detailModal.classList.contains("visible")
                      ) {
                        // Ëé∑ÂèñÂΩìÂâçÂºπÁ™óÊ≠£Âú®Êü•ÁúãÁöÑÁÖßÁâáÊó∂Èó¥Êà≥
                        const currentViewingTimestamp =
                          detailModal.dataset.currentTimestamp;

                        // Â¶ÇÊûúÊ≠£Âú®ÁúãÁöÑÂ∞±ÊòØËøôÂº†ÁÖßÁâáÔºåÁ´ãÂç≥ÈáçÁªòËØÑËÆ∫ÂàóË°®
                        if (currentViewingTimestamp == photoTimestamp) {
                          console.log(
                            "üîÑ [UI Refresh] Currently viewing this photo, refreshing the comment section immediately",
                          );
                          renderLSPhotoComments(targetPhoto);
                        }
                      }
                    } else {
                      console.warn(
                        "‚ùå [Failure] Could not find a photo with the corresponding timestamp:",
                        photoTimestamp,
                      );
                    }
                  }
                  continue; // This is a background operation, skip generating regular chat bubbles
                }

                case "ls_letter": {
                  // This is the logic for handling AI writing love letters
                  if (chat.loversSpaceData) {
                    if (!chat.loversSpaceData.loveLetters) {
                      chat.loversSpaceData.loveLetters = [];
                    }
                    const newLetter = {
                      id: "letter_" + Date.now(),
                      senderId: chat.id,
                      senderName: chat.name,
                      senderAvatar: chat.settings.aiAvatar,
                      recipientName: chat.settings.myNickname || "Me",
                      recipientAvatar: chat.settings.myAvatar,
                      content: msgData.content,
                      timestamp: Date.now(),
                    };
                    chat.loversSpaceData.loveLetters.push(newLetter);
                    console.log(`AI wrote a love letter in the lovers' space: ${msgData.content}`);
                  }
                  continue; // Continue processing other possible AI commands
                }

                case "ls_diary_entry": {
                  const { emoji, diary } = msgData;
                  if (emoji && diary) {
                    const today = new Date().toISOString().split("T")[0]; // Get today's date in YYYY-MM-DD format

                    // Á°Æ‰øùÊï∞ÊçÆÁªìÊûÑÂ≠òÂú®
                    if (!chat.loversSpaceData.emotionDiaries) {
                      chat.loversSpaceData.emotionDiaries = {};
                    }
                    if (!chat.loversSpaceData.emotionDiaries[today]) {
                      chat.loversSpaceData.emotionDiaries[today] = {};
                    }

                    // ‰øùÂ≠òAIÁöÑÊó•ËÆ∞ÂíåË°®ÊÉÖ
                    chat.loversSpaceData.emotionDiaries[today].charEmoji =
                      emoji;
                    chat.loversSpaceData.emotionDiaries[today].charDiary =
                      diary;

                    console.log(`AI posted a diary entry in the lovers' space ${emoji} ${diary}`);
                  }
                  continue; // This is just a background operation, no need to generate a message in the chat interface, so use continue to skip
                }

                case "ls_share": {
                  if (chat.loversSpaceData) {
                    if (!chat.loversSpaceData.shares) {
                      chat.loversSpaceData.shares = [];
                    }
                    const newShare = {
                      author: "char", // Ê†áËÆ∞ÊòØAIÂèëÁöÑ
                      timestamp: Date.now(),
                      ...msgData, // Â∞ÜAIËøîÂõûÁöÑÊâÄÊúâÂàÜ‰∫´‰ø°ÊÅØÔºàtype, shareType, title, artistÁ≠âÔºâÈÉΩÂ§çÂà∂ËøáÊù•
                    };
                    chat.loversSpaceData.shares.push(newShare);
                    console.log(
                      `AI shared in the lovers' space [${msgData.shareType}]: ${msgData.title}`,
                    );
                  }
                  continue; // This is also a background operation
                }

                // This is the logic for AI-initiated invitations
                case "lovers_space_invitation": {
                  // Check if it has already been opened to prevent AI from sending duplicate invitations
                  if (!chat.loversSpaceData) {
                    aiMessage = {
                      ...baseMessage,
                      type: "lovers_space_invitation",
                      content: `${chat.name} sent you a lovers' space invitation`, // This is mainly for debugging and history records
                      status: "pending", // Status: pending, accepted, rejected
                    };
                  }
                  // If the AI has already sent an invitation, do not create aiMessage here, effectively skipping
                  break;
                }

                // This is the logic for AI responding to your invitation
                case "lovers_space_response": {
                  const invitationMsg = chat.history.find(
                    (m) =>
                      m.type === "lovers_space_invitation" &&
                      m.status === "pending",
                  );
                  if (invitationMsg) {
                    invitationMsg.status =
                      msgData.decision === "accept" ? "accepted" : "rejected";

                    // 1. ÂàõÂª∫AIÊÉ≥ËØ¥ÁöÑÈÇ£Âè•ËØùÁöÑÊ∂àÊÅØ
                    if (msgData.responseText) {
                      const responseMessage = {
                        ...baseMessage,
                        type: "text",
                        content: msgData.responseText,
                      };
                      chat.history.push(responseMessage);
                      if (isViewingThisChat) {
                        appendMessage(responseMessage, chat);
                      }
                    }

                    // 2. Ê†πÊçÆÂêåÊÑèÊàñÊãíÁªùÔºåÊâßË°åÂêéÁª≠Êìç‰Ωú
                    if (msgData.decision === "accept") {
                      // ÂêåÊÑèÂêéÔºå‰∏∫Ëøô‰∏™ËßíËâ≤ÂàõÂª∫ÊÉÖ‰æ£Á©∫Èó¥Êï∞ÊçÆ
                      chat.loversSpaceData = {
                        background:
                          "https://i.postimg.cc/k495F4W5/profile-banner.jpg",
                        relationshipStartDate: null,
                        moments: [],
                        photos: [],
                        albums: [],
                        loveLetters: [],
                        shares: [],
                        questions: [],
                      };
                      // Âπ∂ÂèëÈÄÅ‰∏ÄÊù°Á≥ªÁªüÈÄöÁü•
                      const systemNotice = {
                        role: "system",
                        type: "pat_message",
                        content: `[System: Your lovers' space with "${chat.name}" has been successfully opened!]`,
                        timestamp: Date.now(),
                      };
                      chat.history.push(systemNotice);
                      if (isViewingThisChat) {
                        appendMessage(systemNotice, chat);
                      }
                    }
                  }
                  // Â§ÑÁêÜÂÆåÂêéÔºå‰∏çÂÜçÈúÄË¶ÅÁîüÊàêÊñ∞ÁöÑaiMessageÔºåÊâÄ‰ª•Áî® continue Ë∑≥Ëøá
                  continue;
                }

                case "qzone_post":
                  const newPost = {
                    type: msgData.postType,
                    content: msgData.content || "",
                    publicText: msgData.publicText || "",
                    hiddenContent: msgData.hiddenContent || "",
                    timestamp: Date.now(),
                    authorId: chatId,
                    authorGroupId: chat.groupId,
                    visibleGroupIds: null,
                  };

                  // Â¶ÇÊûúÊòØrealimagÁ±ªÂûãÔºåÁîüÊàêÁúüÂÆûÂõæÁâáURLÔºàÊîØÊåÅ1-9Âº†ÂõæÁâáÔºâ
                  if (msgData.postType === "realimag" && msgData.prompt) {
                    // ÊîØÊåÅ prompt ‰∏∫Êï∞ÁªÑÔºàÂ§öÂº†ÂõæÁâáÔºâÊàñÂ≠óÁ¨¶‰∏≤ÔºàÂçïÂº†ÂõæÁâáÔºâ
                    const prompts = Array.isArray(msgData.prompt)
                      ? msgData.prompt.slice(0, 9)
                      : [msgData.prompt];

                    const pollApiKey = state.apiConfig.pollinationsApiKey;
                    const generatedImageUrls = [];

                    // ‰ΩøÁî® Promise.all Âπ∂Ë°åÂ§ÑÁêÜËØ∑Ê±ÇÔºåÊèêÈ´òÈÄüÂ∫¶
                    await Promise.all(
                      prompts.map(async (prompt) => {
                        const encodedPrompt = encodeURIComponent(prompt);
                        const url = `https://image.pollinations.ai/prompt/${encodedPrompt}?nologo=true&width=1024&height=1024`;

                        try {
                          if (pollApiKey) {
                            // Â¶ÇÊûúÊúâ KeyÔºå‰ΩøÁî® fetch Ëé∑ÂèñÂπ∂ËΩ¨‰∏∫ Base64
                            const res = await fetch(url, {
                              headers: {
                                Authorization: `Bearer ${pollApiKey}`,
                              },
                            });
                            if (res.ok) {
                              const blob = await res.blob();
                              const base64 = await new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onloadend = () => resolve(reader.result);
                                reader.readAsDataURL(blob);
                              });
                              generatedImageUrls.push(base64);
                            } else {
                              console.warn(
                                `Pollinations fetch failed: ${res.status}, falling back to URL`,
                              );
                              generatedImageUrls.push(url);
                            }
                          } else {
                            // Ê≤°Êúâ KeyÔºåÁõ¥Êé•‰ΩøÁî® URL
                            generatedImageUrls.push(url);
                          }
                        } catch (e) {
                          console.error(
                            "Pollinations image generation error:",
                            e,
                          );
                          generatedImageUrls.push(url); // Âá∫ÈîôÊó∂ÂõûÈÄÄÂà∞ URL Â∞ùËØï
                        }
                      }),
                    );

                    newPost.imageUrls = generatedImageUrls;

                    // ‰øùÊåÅÂêëÂêéÂÖºÂÆπÔºåÂçïÂº†ÂõæÁâáÊó∂‰πüËÆæÁΩÆ imageUrl
                    if (generatedImageUrls.length === 1) {
                      newPost.imageUrl = generatedImageUrls[0];
                    }

                    newPost.prompt = msgData.prompt;
                    newPost.imageCount = generatedImageUrls.length;
                    console.log(
                      `Dynamic RealImag image generation complete: ${generatedImageUrls.length} images`,
                    );
                  }

                  // If the post type is "naiimag", use the NovelAI API to generate high-quality images (limit to 2 images)
                  if (msgData.postType === "naiimag" && msgData.prompt) {
                    try {
                      // Support prompt as an array (multiple images) or a string (single image)
                      // Dynamically limit to a maximum of 2 NAI images
                      const prompts = Array.isArray(msgData.prompt)
                        ? msgData.prompt.slice(0, 2)
                        : [msgData.prompt];
                      console.log(
                        `üì∏ Dynamic NovelAI image generation started, total ${prompts.length} images`,
                      );

                      // Store generated image URLs
                      const generatedImageUrls = [];

                      // Generate images one by one
                      for (let i = 0; i < prompts.length; i++) {
                        const aiPrompt = prompts[i];
                        console.log(`Generating image ${i + 1}, prompt:`, aiPrompt);

                        // Get the character's NAI prompt configuration (system or character-specific)
                        const naiPrompts = getCharacterNAIPrompts(chat.id);

                        // Construct the final prompt: AI's prompt + configured prompt
                        const finalPositivePrompt =
                          aiPrompt + ", " + naiPrompts.positive;
                        const finalNegativePrompt = naiPrompts.negative;

                        console.log(
                          `üìù Using ${naiPrompts.source === "character" ? "character-specific" : "system"} prompt configuration`,
                        );
                        console.log("Final positive prompt:", finalPositivePrompt);
                        console.log("Final negative prompt:", finalNegativePrompt);

                        // ‚òÖ Provider dispatch: PixAI or NovelAI ‚òÖ
                        const _imgProv2 = localStorage.getItem("image-gen-provider") || "novelai";
                        if (_imgProv2 === "pixai") {
                          const pixSettings2 = getPixAISettings();
                          const pixModelId2 = localStorage.getItem("pixai-model") || "1935090615918113018";
                          const pixImgUrl = await generatePixAIImage(
                            finalPositivePrompt, finalNegativePrompt, pixSettings2, pixModelId2);
                          console.log(`‚úÖ PixAI image ${i + 1} generated!`);
                          generatedImageUrls.push(pixImgUrl);
                          continue; // Next prompt iteration, skip NovelAI code
                        }
                        // ‚îÄ‚îÄ NovelAI path (unchanged) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        // Get NAI settings (from localStorage)
                        const apiKey = localStorage.getItem("novelai-api-key");
                        const model =
                          localStorage.getItem("novelai-model") ||
                          "nai-diffusion-4-5-full";
                        const settings = getNovelAISettings();

                        if (!apiKey) {
                          throw new Error(
                            "NovelAI API Key not configured. Please enter your API Key in the NovelAI settings.",
                          );
                        }

                        const [width, height] = settings.resolution
                          .split("x")
                          .map(Number);

                        // ‚òÖ‚òÖ‚òÖ V4/V4.5 and V3 use different request body formats ‚òÖ‚òÖ‚òÖ
                        let requestBody;

                        if (model.includes("nai-diffusion-4")) {
                          // V4/V4.5 ‰ΩøÁî®Êñ∞Ê†ºÂºè (params_version: 3)
                          requestBody = {
                            input: finalPositivePrompt,
                            model: model,
                            action: "generate",
                            parameters: {
                              params_version: 3, // V4ÂøÖÈ°ª‰ΩøÁî®ÁâàÊú¨3
                              width: width,
                              height: height,
                              scale: settings.cfg_scale,
                              sampler: settings.sampler,
                              steps: settings.steps,
                              seed:
                                settings.seed === -1
                                  ? Math.floor(Math.random() * 9999999999)
                                  : settings.seed,
                              n_samples: 1,
                              ucPreset: settings.uc_preset,
                              qualityToggle: settings.quality_toggle,
                              autoSmea: false,
                              dynamic_thresholding: false,
                              controlnet_strength: 1,
                              legacy: false,
                              add_original_image: true,
                              cfg_rescale: 0,
                              noise_schedule: "karras", // V4‰ΩøÁî®karras
                              legacy_v3_extend: false,
                              skip_cfg_above_sigma: null,
                              use_coords: false,
                              legacy_uc: false,
                              normalize_reference_strength_multiple: true,
                              inpaintImg2ImgStrength: 1,
                              characterPrompts: [],
                              // V4‰∏ìÁî®ÊèêÁ§∫ËØçÊ†ºÂºè
                              v4_prompt: {
                                caption: {
                                  base_caption: finalPositivePrompt,
                                  char_captions: [],
                                },
                                use_coords: false,
                                use_order: true,
                              },
                              // V4‰∏ìÁî®Ë¥üÈù¢ÊèêÁ§∫ËØçÊ†ºÂºè
                              v4_negative_prompt: {
                                caption: {
                                  base_caption: finalNegativePrompt,
                                  char_captions: [],
                                },
                                legacy_uc: false,
                              },
                              negative_prompt: finalNegativePrompt,
                              deliberate_euler_ancestral_bug: false,
                              prefer_brownian: true,
                              // Ê≥®ÊÑèÔºö‰∏çÂåÖÂê´ stream ÂèÇÊï∞Ôºå‰ΩøÁî®Ê†áÂáÜZIPÂìçÂ∫îËÄåÈùûmsgpackÊµÅ
                            },
                          };
                        } else {
                          // V3 ÂèäÊõ¥Êó©ÁâàÊú¨‰ΩøÁî®ÊóßÊ†ºÂºè
                          requestBody = {
                            input: finalPositivePrompt,
                            model: model,
                            action: "generate",
                            parameters: {
                              width: width,
                              height: height,
                              scale: settings.cfg_scale,
                              sampler: settings.sampler,
                              steps: settings.steps,
                              seed:
                                settings.seed === -1
                                  ? Math.floor(Math.random() * 9999999999)
                                  : settings.seed,
                              n_samples: 1,
                              ucPreset: settings.uc_preset,
                              qualityToggle: settings.quality_toggle,
                              sm: settings.smea,
                              sm_dyn: settings.smea_dyn,
                              dynamic_thresholding: false,
                              controlnet_strength: 1,
                              legacy: false,
                              add_original_image: false,
                              cfg_rescale: 0,
                              noise_schedule: "native",
                              negative_prompt: finalNegativePrompt,
                            },
                          };
                        }

                        console.log("üöÄ Sending NAI request:", requestBody);

                        // Select API endpoint based on model
                        let apiUrl;

                        // V4/V4.5 Ê®°Âûã‰ΩøÁî®ÊµÅÂºèÁ´ØÁÇπ
                        if (model.includes("nai-diffusion-4")) {
                          // V4/V4.5 ÈªòËÆ§‰ΩøÁî®ÊµÅÂºèÁ´ØÁÇπ
                          apiUrl =
                            "https://image.novelai.net/ai/generate-image-stream";
                        } else {
                          // V3 ÂèäÊõ¥Êó©ÁâàÊú¨‰ΩøÁî®Ê†áÂáÜÁ´ØÁÇπ
                          apiUrl =
                            "https://image.novelai.net/ai/generate-image";
                        }

                        let corsProxy = settings.cors_proxy;

                        // Â¶ÇÊûúÈÄâÊã©‰∫ÜËá™ÂÆö‰πâ‰ª£ÁêÜÔºå‰ΩøÁî®Ëá™ÂÆö‰πâURL
                        if (corsProxy === "custom") {
                          corsProxy = settings.custom_proxy_url || "";
                        }

                        // Â¶ÇÊûúÊúâ‰ª£ÁêÜÔºåÊ∑ªÂä†Âà∞URLÂâçÈù¢
                        if (corsProxy && corsProxy !== "") {
                          apiUrl = corsProxy + encodeURIComponent(apiUrl);
                        }

                        const response = await fetch(apiUrl, {
                          method: "POST",
                          headers: {
                            "Content-Type": "application/json",
                            Authorization: "Bearer " + apiKey,
                          },
                          body: JSON.stringify(requestBody),
                        });

                        console.log("Response status:", response.status);
                        console.log("Response headers:", [
                          ...response.headers.entries(),
                        ]);

                        if (!response.ok) {
                          const errorText = await response.text();
                          console.error("API error response:", errorText);
                          throw new Error(
                            `API request failed (${response.status}): ${errorText}`,
                          );
                        }

                        // NovelAI API returns a ZIP file, need to unzip
                        const contentType =
                          response.headers.get("content-type");
                        console.log("Content-Type:", contentType);

                        // Check if it's an SSE stream response
                        let zipBlob;
                        let imageDataUrl;
                        if (
                          contentType &&
                          contentType.includes("text/event-stream")
                        ) {
                          console.log("Detected SSE stream response, starting to parse...");

                          // Read the entire stream
                          const text = await response.text();
                          console.log("Received SSE data, size:", text.length);

                          // Ëß£Êûê SSE Ê†ºÂºèÔºåÊèêÂèñÊúÄÂêéÁöÑ data: Ë°å
                          const lines = text.trim().split("\n");
                          let base64Data = null;

                          for (let i = lines.length - 1; i >= 0; i--) {
                            const line = lines[i].trim();
                            if (
                              line.startsWith("data: ") &&
                              line !== "data: [DONE]"
                            ) {
                              const dataContent = line.substring(6); // ÁßªÈô§ 'data: ' ÂâçÁºÄ

                              // Â∞ùËØïËß£Êûê JSON
                              try {
                                const jsonData = JSON.parse(dataContent);

                                // V4.5 ÊµÅÂºèÁ´ØÁÇπÔºöevent_type ‰∏∫ "final" Êó∂ÂåÖÂê´ÊúÄÁªàÂõæÁâá
                                if (
                                  jsonData.event_type === "final" &&
                                  jsonData.image
                                ) {
                                  base64Data = jsonData.image;
                                  console.log("‚úÖ Image data for the final event located");
                                  break;
                                }

                                // Compatible with other formats
                                if (jsonData.data) {
                                  base64Data = jsonData.data;
                                  console.log("Extracted image data from JSON.data");
                                  break;
                                }
                                if (jsonData.image) {
                                  base64Data = jsonData.image;
                                  console.log("Extracted image data from JSON.image");
                                  break;
                                }
                              } catch (e) {
                                // If not JSON, treat as base64 data
                                base64Data = dataContent;
                                console.log("Using base64 data directly");
                                break;
                              }
                            }
                          }

                          if (!base64Data) {
                            throw new Error("Unable to extract image data from SSE response");
                          }

                          // V4.5 streaming endpoint returns PNG base64, not ZIP
                          // Check if it's PNG (starts with iVBORw0KGgo) or JPEG (starts with /9j/)
                          const isPNG = base64Data.startsWith("iVBORw0KGgo");
                          const isJPEG = base64Data.startsWith("/9j/");

                          if (isPNG || isJPEG) {
                            console.log(
                              "‚úÖ Detected direct base64 image data (PNG/JPEG)",
                            );
                            // Convert base64 to Blob
                            const binaryString = atob(base64Data);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                              bytes[i] = binaryString.charCodeAt(i);
                            }
                            const imageBlob = new Blob([bytes], {
                              type: isPNG ? "image/png" : "image/jpeg",
                            });
                            console.log(
                              "‚úÖ Image Blob created successfully, size:",
                              imageBlob.size,
                            );

                            // Convert to dataURL for further processing
                            const reader = new FileReader();
                            imageDataUrl = await new Promise(
                              (resolve, reject) => {
                                reader.onloadend = () => resolve(reader.result);
                                reader.onerror = reject;
                                reader.readAsDataURL(imageBlob);
                              },
                            );
                            console.log("‚úÖ Image converted successfully! üé®");
                          } else {
                            // Otherwise, treat as ZIP
                            console.log("Treating as ZIP file...");
                            const binaryString = atob(base64Data);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                              bytes[i] = binaryString.charCodeAt(i);
                            }
                            zipBlob = new Blob([bytes]);
                            console.log("ZIP Blob size:", zipBlob.size);
                          }
                        } else {
                          // Non-streaming response, read directly
                          zipBlob = await response.blob();
                          console.log(
                            "Received data, type:",
                            zipBlob.type,
                            "size:",
                            zipBlob.size,
                          );
                        }

                        // If imageDataUrl is still not available (i.e., need to unzip)
                        if (!imageDataUrl && zipBlob) {
                          // NovelAI always returns ZIP format, need to unzip
                          try {
                            // Check if JSZip is loaded
                            if (typeof JSZip === "undefined") {
                              throw new Error("JSZip library not loaded, please refresh the page and try again");
                            }

                            // Unzip the ZIP file
                            const zip = await JSZip.loadAsync(zipBlob);
                            console.log("ZIP file contents:", Object.keys(zip.files));

                            // Find the first image file (usually image_0.png)
                            let imageFile = null;
                            for (let filename in zip.files) {
                              if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                                imageFile = zip.files[filename];
                                console.log("Found image file:", filename);
                                break;
                              }
                            }

                            if (!imageFile) {
                              throw new Error("No image found in ZIP file");
                            }

                            // Extract image data
                            const imageBlob = await imageFile.async("blob");
                            console.log("Extracted image size:", imageBlob.size);

                            // Create image URL
                            const reader = new FileReader();
                            imageDataUrl = await new Promise(
                              (resolve, reject) => {
                                reader.onloadend = () => resolve(reader.result);
                                reader.onerror = reject;
                                reader.readAsDataURL(imageBlob);
                              },
                            );
                            console.log("‚úÖ Image extracted successfully!");
                          } catch (zipError) {
                            console.error("ZIP extraction failed:", zipError);
                            throw new Error(
                              "Image extraction failed: " + zipError.message,
                            );
                          }
                        }

                        console.log(`‚úÖ NAI image ${i + 1} generated successfully!`);
                        generatedImageUrls.push(imageDataUrl);
                      }

                      // Save the generated image URLs to the post
                      newPost.imageUrls = generatedImageUrls;

                      // Maintain backward compatibility, set imageUrl for single image
                      if (generatedImageUrls.length === 1) {
                        newPost.imageUrl = generatedImageUrls[0];
                      }

                      newPost.prompt = msgData.prompt;
                      newPost.imageCount = generatedImageUrls.length;
                      console.log(
                        `‚úÖ All NovelAI images generated successfully: ${generatedImageUrls.length} images`,
                      );
                    } catch (error) {
                      console.error("‚ùå NovelAI image generation failed:", error);
                      // Even if it fails, still post the update, but add error information
                      newPost.content =
                        (newPost.content || newPost.publicText || "") +
                        `\n[Image generation failed: ${error.message}]`;
                    }
                  }

                  await db.qzonePosts.add(newPost);
                  updateUnreadIndicator(unreadPostsCount + 1);
                  if (
                    isViewingThisChat &&
                    document
                      .getElementById("qzone-screen")
                      .classList.contains("active")
                  ) {
                    await renderQzonePosts();
                  }
                  continue;

                case "qzone_comment":
                  const postToComment = await db.qzonePosts.get(
                    parseInt(msgData.postId),
                  );
                  if (postToComment) {
                    if (!postToComment.comments) postToComment.comments = [];

                    const newAiComment = {
                      commenterName: msgData.commenterName || chat.name,
                      text: msgData.commentText,
                      timestamp: Date.now(),
                    };

                    // Check if AI specified a reply target
                    if (msgData.replyTo) {
                      newAiComment.replyTo = msgData.replyTo;
                    }

                    postToComment.comments.push(newAiComment);
                    await db.qzonePosts.update(postToComment.id, {
                      comments: postToComment.comments,
                    });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (
                      isViewingThisChat &&
                      document
                        .getElementById("qzone-screen")
                        .classList.contains("active")
                    ) {
                      await renderQzonePosts();
                    }
                  }
                  continue;

                // Full logic for sending naiimag in group chat
                case "naiimag":
                  // NovelAI image sharing - Call NovelAI API to generate high-quality images
                  try {
                    console.log(
                      "üì∏ NovelAI image generation started, AI provided prompt:",
                      msgData.prompt,
                    );

                    // Get the character's NAI prompt configuration (system or character-specific)
                    const naiPrompts = getCharacterNAIPrompts(chat.id);

                    // Construct the final prompt: AI's prompt + configured prompts
                    const aiPrompt = msgData.prompt || "a beautiful scene";
                    const finalPositivePrompt =
                      aiPrompt + ", " + naiPrompts.positive;
                    const finalNegativePrompt = naiPrompts.negative;

                    console.log(
                      `üìù Using ${naiPrompts.source === "character" ? "character-specific" : "system"} prompt configuration`,
                    );
                    console.log("Final positive prompt:", finalPositivePrompt);
                    console.log("Final negative prompt:", finalNegativePrompt);

                    // ‚òÖ Provider dispatch: PixAI or NovelAI ‚òÖ
                    const _imgProv3 = localStorage.getItem("image-gen-provider") || "novelai";
                    if (_imgProv3 === "pixai") {
                      const pixSettings3 = getPixAISettings();
                      const pixModelId3 = localStorage.getItem("pixai-model") || "1935090615918113018";
                      const pixImgUrl3 = await generatePixAIImage(
                        finalPositivePrompt, finalNegativePrompt, pixSettings3, pixModelId3);
                      aiMessage = {
                        ...baseMessage,
                        type: "naiimag",
                        imageUrl: pixImgUrl3,
                        prompt: aiPrompt,
                        fullPrompt: finalPositivePrompt,
                      };
                      break;
                    }

                    // Get NAI settings (read from localStorage)
                    const apiKey = localStorage.getItem("novelai-api-key");
                    const model =
                      localStorage.getItem("novelai-model") ||
                      "nai-diffusion-4-5-full";
                    const settings = getNovelAISettings();
                    if (!apiKey) {
                      throw new Error(
                        "NovelAI API Key not configured. Please enter your API Key in the NovelAI settings.",
                      );
                    }

                    const [width, height] = settings.resolution
                      .split("x")
                      .map(Number);

                    // ‚òÖ‚òÖ‚òÖ V4/V4.5 and V3 use different request body formats ‚òÖ‚òÖ‚òÖ
                    let requestBody;

                    if (model.includes("nai-diffusion-4")) {
                      // V4/V4.5 use new format (params_version: 3)
                      requestBody = {
                        input: finalPositivePrompt,
                        model: model,
                        action: "generate",
                        parameters: {
                          params_version: 3, // V4 must use version 3
                          width: width,
                          height: height,
                          scale: settings.cfg_scale,
                          sampler: settings.sampler,
                          steps: settings.steps,
                          seed:
                            settings.seed === -1
                              ? Math.floor(Math.random() * 9999999999)
                              : settings.seed,
                          n_samples: 1,
                          ucPreset: settings.uc_preset,
                          qualityToggle: settings.quality_toggle,
                          autoSmea: false,
                          dynamic_thresholding: false,
                          controlnet_strength: 1,
                          legacy: false,
                          add_original_image: true,
                          cfg_rescale: 0,
                          noise_schedule: "karras", // V4 uses karras
                          legacy_v3_extend: false,
                          skip_cfg_above_sigma: null,
                          use_coords: false,
                          legacy_uc: false,
                          normalize_reference_strength_multiple: true,
                          inpaintImg2ImgStrength: 1,
                          characterPrompts: [],
                          // V4 specific prompt format
                          v4_prompt: {
                            caption: {
                              base_caption: finalPositivePrompt,
                              char_captions: [],
                            },
                            use_coords: false,
                            use_order: true,
                          },
                          // V4‰∏ìÁî®Ë¥üÈù¢ÊèêÁ§∫ËØçÊ†ºÂºè
                          v4_negative_prompt: {
                            caption: {
                              base_caption: finalNegativePrompt,
                              char_captions: [],
                            },
                            legacy_uc: false,
                          },
                          negative_prompt: finalNegativePrompt,
                          deliberate_euler_ancestral_bug: false,
                          prefer_brownian: true,
                          // Ê≥®ÊÑèÔºö‰∏çÂåÖÂê´ stream ÂèÇÊï∞Ôºå‰ΩøÁî®Ê†áÂáÜZIPÂìçÂ∫îËÄåÈùûmsgpackÊµÅ
                        },
                      };
                    } else {
                      // V3 ÂèäÊõ¥Êó©ÁâàÊú¨‰ΩøÁî®ÊóßÊ†ºÂºè
                      requestBody = {
                        input: finalPositivePrompt,
                        model: model,
                        action: "generate",
                        parameters: {
                          width: width,
                          height: height,
                          scale: settings.cfg_scale,
                          sampler: settings.sampler,
                          steps: settings.steps,
                          seed:
                            settings.seed === -1
                              ? Math.floor(Math.random() * 9999999999)
                              : settings.seed,
                          n_samples: 1,
                          ucPreset: settings.uc_preset,
                          qualityToggle: settings.quality_toggle,
                          sm: settings.smea,
                          sm_dyn: settings.smea_dyn,
                          dynamic_thresholding: false,
                          controlnet_strength: 1,
                          legacy: false,
                          add_original_image: false,
                          cfg_rescale: 0,
                          noise_schedule: "native",
                          negative_prompt: finalNegativePrompt,
                        },
                      };
                    }

                    console.log("üöÄ Sending NAI request:", requestBody);

                    // ‚òÖ‚òÖ‚òÖ Ê†πÊçÆÊ®°ÂûãÈÄâÊã©‰∏çÂêåÁöÑAPIÁ´ØÁÇπ ‚òÖ‚òÖ‚òÖ
                    let apiUrl;

                    // V4/V4.5 Ê®°Âûã‰ΩøÁî®ÊµÅÂºèÁ´ØÁÇπ
                    if (model.includes("nai-diffusion-4")) {
                      // V4/V4.5 ÈªòËÆ§‰ΩøÁî®ÊµÅÂºèÁ´ØÁÇπ
                      apiUrl =
                        "https://image.novelai.net/ai/generate-image-stream";
                    } else {
                      // V3 ÂèäÊõ¥Êó©ÁâàÊú¨‰ΩøÁî®Ê†áÂáÜÁ´ØÁÇπ
                      apiUrl = "https://image.novelai.net/ai/generate-image";
                    }

                    let corsProxy = settings.cors_proxy;

                    // Â¶ÇÊûúÈÄâÊã©‰∫ÜËá™ÂÆö‰πâ‰ª£ÁêÜÔºå‰ΩøÁî®Ëá™ÂÆö‰πâURL
                    if (corsProxy === "custom") {
                      corsProxy = settings.custom_proxy_url || "";
                    }

                    // Â¶ÇÊûúÊúâ‰ª£ÁêÜÔºåÊ∑ªÂä†Âà∞URLÂâçÈù¢
                    if (corsProxy && corsProxy !== "") {
                      apiUrl = corsProxy + encodeURIComponent(apiUrl);
                    }

                    const response = await fetch(apiUrl, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + apiKey,
                      },
                      body: JSON.stringify(requestBody),
                    });

                    console.log("Response status:", response.status);
                    console.log("Response headers:", [
                      ...response.headers.entries(),
                    ]);

                    if (!response.ok) {
                      const errorText = await response.text();
                      console.error("API error response:", errorText);
                      throw new Error(
                        `API request failed (${response.status}): ${errorText}`,
                      );
                    }

                    // NovelAI API returns a ZIP file, which needs to be extracted
                    const contentType = response.headers.get("content-type");
                    console.log("Content-Type:", contentType);

                    // Check if it is an SSE stream response
                    let zipBlob;
                    let imageDataUrl;
                    if (
                      contentType &&
                      contentType.includes("text/event-stream")
                    ) {
                      console.log("Detected SSE stream response, starting to parse...");

                      // Read the entire stream
                      const text = await response.text();
                      console.log("Received SSE data, size:", text.length);

                      // Parse SSE format, extract the last data: line
                      const lines = text.trim().split("\n");
                      let base64Data = null;

                      for (let i = lines.length - 1; i >= 0; i--) {
                        const line = lines[i].trim();
                        if (
                          line.startsWith("data: ") &&
                          line !== "data: [DONE]"
                        ) {
                          const dataContent = line.substring(6); // Remove 'data: ' prefix

                          // Â∞ùËØïËß£Êûê JSON
                          try {
                            const jsonData = JSON.parse(dataContent);

                            // V4.5 ÊµÅÂºèÁ´ØÁÇπÔºöevent_type ‰∏∫ "final" Êó∂ÂåÖÂê´ÊúÄÁªàÂõæÁâá
                            if (
                              jsonData.event_type === "final" &&
                              jsonData.image
                            ) {
                              base64Data = jsonData.image;
                              console.log("‚úÖ Image data for the final event located");
                              break;
                            }

                            // Compatible with other formats
                            if (jsonData.data) {
                              base64Data = jsonData.data;
                              console.log("Extracted image data from JSON.data");
                              break;
                            }
                            if (jsonData.image) {
                              base64Data = jsonData.image;
                              console.log("Extracted image data from JSON.image");
                              break;
                            }
                          } catch (e) {
                            // If not JSON, treat as base64 data
                            base64Data = dataContent;
                            console.log("Directly using base64 data");
                            break;
                          }
                        }
                      }

                      if (!base64Data) {
                        throw new Error("Unable to extract image data from SSE response");
                      }

                      // V4.5 streaming endpoint returns PNG base64, not ZIP
                      // Check if it is PNG (starts with iVBORw0KGgo) or JPEG (starts with /9j/)
                      const isPNG = base64Data.startsWith("iVBORw0KGgo");
                      const isJPEG = base64Data.startsWith("/9j/");

                      if (isPNG || isJPEG) {
                        console.log(
                          "‚úÖ Detected direct image base64 data (PNG/JPEG)",
                        );
                        // Convert base64 to Blob
                        const binaryString = atob(base64Data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                          bytes[i] = binaryString.charCodeAt(i);
                        }
                        const imageBlob = new Blob([bytes], {
                          type: isPNG ? "image/png" : "image/jpeg",
                        });
                        console.log(
                          "Image Blob created successfully, size:",
                          imageBlob.size,
                        );

                        // Convert to dataURL for further processing
                        const reader = new FileReader();
                        imageDataUrl = await new Promise((resolve, reject) => {
                          reader.onloadend = () => resolve(reader.result);
                          reader.onerror = reject;
                          reader.readAsDataURL(imageBlob);
                        });
                        console.log("‚úÖ Image converted successfully! üé®");
                      } else {
                        // Otherwise, treat as ZIP
                        console.log("Treating as ZIP file...");
                        const binaryString = atob(base64Data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                          bytes[i] = binaryString.charCodeAt(i);
                        }
                        zipBlob = new Blob([bytes]);
                        console.log("ZIP Blob size:", zipBlob.size);
                      }
                    } else {
                      // Non-streaming response, read directly
                      zipBlob = await response.blob();
                      console.log(
                        "Received data, type:",
                        zipBlob.type,
                        "size:",
                        zipBlob.size,
                      );
                    }

                    // If imageDataUrl is still not available (i.e., need to unzip)
                    if (!imageDataUrl && zipBlob) {
                      // NovelAI always returns ZIP format, need to unzip
                      try {
                        // Check if JSZip is loaded
                        if (typeof JSZip === "undefined") {
                          throw new Error("JSZip library not loaded, please refresh the page and try again");
                        }

                        // Unzip the ZIP file
                        const zip = await JSZip.loadAsync(zipBlob);
                        console.log("ZIP file contents:", Object.keys(zip.files));

                        // Find the first image file (usually image_0.png)
                        let imageFile = null;
                        for (let filename in zip.files) {
                          if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                            imageFile = zip.files[filename];
                            console.log("Found image file:", filename);
                            break;
                          }
                        }

                        if (!imageFile) {
                          throw new Error("No image found in ZIP file");
                        }

                        // Extract image data
                        const imageBlob = await imageFile.async("blob");
                        console.log("Extracted image size:", imageBlob.size);

                        // Create image URL
                        const reader = new FileReader();
                        imageDataUrl = await new Promise((resolve, reject) => {
                          reader.onloadend = () => resolve(reader.result);
                          reader.onerror = reject;
                          reader.readAsDataURL(imageBlob);
                        });
                        console.log("‚úÖ Image extracted successfully!");
                      } catch (zipError) {
                        console.error("ZIP extraction failed:", zipError);
                        throw new Error("Image extraction failed: " + zipError.message);
                      }
                    }

                    console.log("‚úÖ NAI image generation successful!");

                    // Create naiimag message
                    aiMessage = {
                      ...baseMessage,
                      type: "naiimag",
                      imageUrl: imageDataUrl,
                      prompt: aiPrompt,
                      fullPrompt: finalPositivePrompt, // ‰øùÂ≠òÂÆåÊï¥ÊèêÁ§∫ËØç‰æõÊü•Áúã
                    };
                  } catch (error) {
                    console.error("‚ùå NAI image generation failed:", error);
                    // Fallback to text message on failure
                    aiMessage = {
                      ...baseMessage,
                      content: `[Image generation failed: ${error.message}]`,
                    };
                  }
                  break;

                case "qzone_like":
                  const postToLike = await db.qzonePosts.get(
                    parseInt(msgData.postId),
                  );
                  if (postToLike) {
                    if (!postToLike.likes) postToLike.likes = [];
                    if (!postToLike.likes.includes(chat.name)) {
                      postToLike.likes.push(chat.name);
                      await db.qzonePosts.update(postToLike.id, {
                        likes: postToLike.likes,
                      });
                      updateUnreadIndicator(unreadPostsCount + 1);
                      if (
                        isViewingThisChat &&
                        document
                          .getElementById("qzone-screen")
                          .classList.contains("active")
                      ) {
                        await renderQzonePosts();
                      }
                    }
                  }
                  continue;

                case "video_call_request":
                  if (
                    !videoCallState.isActive &&
                    !videoCallState.isAwaitingResponse
                  ) {
                    state.activeChatId = chatId;
                    videoCallState.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = chat.isGroup;
                    videoCallState.callRequester = msgData.name || chat.name;
                    showIncomingCallModal(chatId); // <--- ÊäächatId‰Ωú‰∏∫ÂèÇÊï∞‰º†ËøõÂéª
                  }
                  continue;

                case "group_call_request":
                  if (
                    !videoCallState.isActive &&
                    !videoCallState.isAwaitingResponse
                  ) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = "ai";
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                  }
                  continue;

                case "pat_user":
                  const suffix = msgData.suffix
                    ? ` ${msgData.suffix.trim()}`
                    : "";
                  const patText = `${msgData.name || chat.name} patted me${suffix}`;
                  const patMessage = {
                    role: "system",
                    type: "pat_message",
                    content: patText,
                    timestamp: Date.now(),
                  };
                  chat.history.push(patMessage);
                  if (isViewingThisChat) {
                    const phoneScreen = document.getElementById("phone-screen");
                    phoneScreen.classList.remove("pat-animation");
                    void phoneScreen.offsetWidth;
                    phoneScreen.classList.add("pat-animation");
                    setTimeout(
                      () => phoneScreen.classList.remove("pat-animation"),
                      500,
                    );
                    appendMessage(patMessage, chat);
                  } else {
                    showNotification(chatId, patText);
                  }
                  continue;

                case "update_status":
                  chat.status.text = msgData.status_text;
                  chat.status.isBusy = msgData.is_busy || false;
                  chat.status.lastUpdate = Date.now();

                  const statusUpdateMessage = {
                    role: "system",
                    type: "pat_message",
                    content: `[${chat.name}'s status has been updated to: ${msgData.status_text}]`,
                    timestamp: Date.now(),
                  };
                  chat.history.push(statusUpdateMessage);

                  if (isViewingThisChat) {
                    appendMessage(statusUpdateMessage, chat);
                  }

                  renderChatList();

                  continue;

                case "change_music":
                  if (
                    state.musicState.isActive &&
                    state.musicState.activeChatId === chatId
                  ) {
                    const songNameToFind = msgData.song_name;

                    const targetSongIndex = state.musicState.playlist.findIndex(
                      (track) =>
                        track.name.toLowerCase() ===
                        songNameToFind.toLowerCase(),
                    );

                    if (targetSongIndex > -1) {
                      playSong(targetSongIndex);

                      const track = state.musicState.playlist[targetSongIndex];
                      const musicChangeMessage = {
                        role: "system",
                        type: "pat_message",
                        content: `[‚ô™ ${chat.name} changed the song for you: "${track.name}" - ${track.artist}]`,
                        timestamp: Date.now(),
                      };
                      chat.history.push(musicChangeMessage);

                      if (isViewingThisChat) {
                        appendMessage(musicChangeMessage, chat);
                      }
                    }
                  }
                  continue;
                case "create_memory":
                  const newMemory = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.description,
                    timestamp: Date.now(),
                    type: "ai_generated",
                  };
                  await db.memories.add(newMemory);

                  console.log(
                    `AI "${chat.name}" has recorded a new memory:`,
                    msgData.description,
                  );

                  continue;

                case "create_countdown":
                  const targetDate = new Date(msgData.date);
                  if (!isNaN(targetDate) && targetDate > new Date()) {
                    const newCountdown = {
                      chatId: chatId,
                      authorName: chat.name,
                      description: msgData.title,
                      timestamp: Date.now(),
                      type: "countdown",
                      targetDate: targetDate.getTime(),
                    };
                    await db.memories.add(newCountdown);
                    console.log(
                      `AI "${chat.name}" has created a new countdown:`,
                      msgData.title,
                    );
                  }
                  continue;

                case "block_user":
                  if (!chat.isGroup) {
                    chat.relationship.status = "blocked_by_ai";

                    const hiddenMessage = {
                      role: "system",
                      content: `[System highest directive]
			# Task: Respond to lovers' space invitation
			The user has just sent you an invitation to "open lovers' space". You „Äêmust„Äë decide whether to accept or reject based on your persona.

			# Output format strict rules (must be strictly followed)
			Your response „Äêmust and can only„Äë be „Äêone„Äë JSON object, formatted as follows:
			{"type": "lovers_space_response", "decision": "accept" or "reject", "responseText": "What you want to say..."}

			# Example
			- If accepting: {"type": "lovers_space_response", "decision": "accept", "responseText": ""}
			- If rejecting: {"type": "lovers_space_response", "decision": "reject", "responseText": ""}

			Now, please make your decision immediately.`,
                      timestamp: Date.now() + 1,
                      isHidden: true,
                    };
                    chat.history.push(hiddenMessage);

                    await db.chats.put(chat);

                    if (isViewingThisChat) {
                      renderChatInterface(chatId);
                    }
                    renderChatList();

                    break;
                  }
                  continue;
                case "friend_request_response":
                  if (
                    !chat.isGroup &&
                    chat.relationship.status === "pending_ai_approval"
                  ) {
                    if (msgData.decision === "accept") {
                      chat.relationship.status = "friend";
                      aiMessage = {
                        ...baseMessage,
                        content: "I have accepted your friend request, we are now friends!",
                      };
                    } else {
                      chat.relationship.status = "blocked_by_ai";
                      aiMessage = {
                        ...baseMessage,
                        content: "Sorry, I have rejected your friend request.",
                      };
                    }
                    chat.relationship.applicationReason = "";
                  }
                  break;

                case "poll": {
                  // ÂêåÊó∂Â§ÑÁêÜÊù•Ëá™AIÂíåÁî®Êà∑ÁöÑÊäïÁ•®Ê∂àÊÅØ
                  let pollInfoText = "";

                  // Âà§Êñ≠ËøôÊù°ÊäïÁ•®Ê∂àÊÅØÊòØË∞ÅÂèëÁöÑ
                  if (msg.role === "user") {
                    const myNickname = chat.isGroup
                      ? chat.settings.myNickname || "Me"
                      : "Me";
                    pollInfoText = `[System prompt: User (${myNickname}) has initiated a poll. Question: "${
                      msg.question
                    }", Options: "${msg.options.join('", "')}". You can use the 'vote' command to participate in the poll.]`;
                  } else {
                    // Â¶ÇÊûúÊòØAIÂèëÁöÑ
                    pollInfoText = `[System Notice: ${msg.senderName} started a poll. Question: "${
                      msg.question
                    }", Options: "${msg.options.join('", "')}".]`;
                  }

                  // ÊúÄÁªàÔºåÊàë‰ª¨ÊääËøôÊù°Ê†ºÂºèÂåñÂ•ΩÁöÑÊñáÊú¨‰Ωú‰∏∫Á≥ªÁªüÊ∂àÊÅØÂèëÈÄÅÁªôAI
                  // Ê≥®ÊÑèÔºöËøôÈáåÊàë‰ª¨ËøîÂõûÁöÑÊòØ‰∏Ä‰∏™Êñ∞ÂØπË±°ÔºåËÄå‰∏çÊòØ‰øÆÊîπÂéüÂßãÁöÑaiMessage
                  // Âõ†Ê≠§ÔºåÊàë‰ª¨Â∞ÜÂÆÉÊîæÂú®‰∫ÜmessagesPayloadÁöÑÊûÑÂª∫Âæ™ÁéØÈáå
                  aiMessage = {
                    role: "system",
                    content: pollInfoText,
                    isHidden: true,
                  };
                  break; // break‰∏çËÉΩÂ∞ë
                }

                case "vote": {
                  // ‰ΩøÁî®Â§ßÊã¨Âè∑ÂàõÂª∫Áã¨Á´ãÁöÑÂùóÁ∫ß‰ΩúÁî®Âüü
                  const pollToVote = chat.history.find(
                    (m) => m.timestamp === msgData.poll_timestamp,
                  );

                  // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÂ¶ÇÊûúÊäïÁ•®‰∏çÂ≠òÂú®ÊàñÂ∑≤ÂÖ≥Èó≠ÔºåÂàô‰∏çÂ§ÑÁêÜ
                  if (pollToVote && !pollToVote.isClosed) {
                    // 1. Ê†πÊçÆAIÁöÑ‚ÄúÊú¨Âêç‚ÄùÔºåÊâæÂà∞ÂÖ∂ÊàêÂëòÂØπË±°ÔºåÂπ∂Ëé∑ÂèñÊ≠£Á°ÆÁöÑ‚ÄúÁæ§ÊòµÁß∞‚Äù
                    const member = chat.members.find(
                      (m) => m.originalName === msgData.name,
                    );
                    const displayName = member
                      ? member.groupNickname
                      : msgData.name;

                    // 2. ‰ΩøÁî®Ê≠£Á°ÆÁöÑ‚ÄúÁæ§ÊòµÁß∞‚ÄùÂéªÁßªÈô§ËØ•ËßíËâ≤‰πãÂâçÁöÑÊâÄÊúâÊäïÁ•®
                    Object.keys(pollToVote.votes).forEach((option) => {
                      const voterIndex =
                        pollToVote.votes[option].indexOf(displayName); // ‰ΩøÁî® displayName
                      if (voterIndex > -1) {
                        pollToVote.votes[option].splice(voterIndex, 1);
                      }
                    });

                    // 3. Â∞Ü‚ÄúÁæ§ÊòµÁß∞‚ÄùÊ∑ªÂä†Âà∞Êñ∞ÁöÑÈÄâÈ°π‰∏≠
                    if (!pollToVote.votes[msgData.choice]) {
                      pollToVote.votes[msgData.choice] = [];
                    }

                    // ÔºàÂèØÈÄâ‰ΩÜÊé®ËçêÔºâÂÜçÊ¨°Ê£ÄÊü•ÔºåÈÅøÂÖçÊÑèÂ§ñÈáçÂ§çÊ∑ªÂä†
                    if (
                      !pollToVote.votes[msgData.choice].includes(displayName)
                    ) {
                      pollToVote.votes[msgData.choice].push(displayName);
                    }

                    // Â¶ÇÊûúÁî®Êà∑Ê≠£Âú®ÁúãËøô‰∏™ËÅäÂ§©ÔºåÂ∞±Âà∑Êñ∞ÁïåÈù¢ËÆ©‰ªñ‰ª¨ÁúãÂà∞ÂèòÂåñ
                    if (isViewingThisChat) {
                      renderChatInterface(chatId);
                    }
                  }
                  // ËøôÊòØ‰∏Ä‰∏™ÂêéÂè∞Êìç‰ΩúÔºå‰∏çÈúÄË¶ÅÁîüÊàêÊñ∞ÁöÑÊ∂àÊÅØÔºåÊâÄ‰ª•Áî® continue
                  continue;
                }

                case "red_packet":
                  aiMessage = {
                    ...baseMessage,
                    type: "red_packet",
                    packetType: msgData.packetType,
                    totalAmount: msgData.amount,
                    count: msgData.count,
                    greeting: msgData.greeting,
                    receiverName: msgData.receiver,
                    claimedBy: {},
                    isFullyClaimed: false,
                  };

                  // ÂêåÊ≠•Âà∞ËßíËâ≤Èí±ÂåÖÔºàÊîØÂá∫Ôºâ
                  const rpDescription = `Sent a red packet - ${msgData.greeting || "Good luck"}`;
                  await updateCharacterBankBalance(
                    chatId,
                    -msgData.amount,
                    rpDescription,
                  );

                  break;

                case "open_red_packet": {
                  // ‰ΩøÁî®Â§ßÊã¨Âè∑ÂàõÂª∫Áã¨Á´ãÁöÑÂùóÁ∫ß‰ΩúÁî®Âüü
                  const packetToOpen = chat.history.find(
                    (m) => m.timestamp === msgData.packet_timestamp,
                  );
                  // Ê£ÄÊü•Á∫¢ÂåÖÊòØÂê¶Â≠òÂú®„ÄÅÊòØÂê¶Ê≤°Ë¢´È¢ÜÂÆå„ÄÅ‰ª•ÂèäËøô‰∏™AIËßíËâ≤ÊòØÂê¶ËøòÊ≤°È¢ÜËøá
                  if (
                    packetToOpen &&
                    !packetToOpen.isFullyClaimed &&
                    !(
                      packetToOpen.claimedBy &&
                      packetToOpen.claimedBy[msgData.name]
                    )
                  ) {
                    // 1. Ê†πÊçÆAIÁöÑÊú¨Âêç(msgData.name)Ôºå‰ªéÊàêÂëòÂàóË°®ÊâæÂà∞ÂÖ∂Ê≠£Á°ÆÁöÑÁæ§ÊòµÁß∞
                    const member = chat.members.find(
                      (m) => m.originalName === msgData.name,
                    );
                    const displayName = member
                      ? member.groupNickname
                      : msgData.name;

                    let claimedAmountAI = 0;
                    const remainingAmount =
                      packetToOpen.totalAmount -
                      Object.values(packetToOpen.claimedBy || {}).reduce(
                        (sum, val) => sum + val,
                        0,
                      );
                    const remainingCount =
                      packetToOpen.count -
                      Object.keys(packetToOpen.claimedBy || {}).length;

                    if (remainingCount > 0) {
                      if (remainingCount === 1) {
                        // Â¶ÇÊûúÊòØÊúÄÂêé‰∏Ä‰∏™
                        claimedAmountAI = remainingAmount;
                      } else {
                        // Â¶ÇÊûú‰∏çÊòØÊúÄÂêé‰∏Ä‰∏™ÔºåÈöèÊú∫ÂàÜÈÖç
                        const min = 0.01;
                        const max =
                          remainingAmount - (remainingCount - 1) * min;
                        claimedAmountAI = Math.random() * (max - min) + min;
                      }
                      claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));

                      // 2. Á°Æ‰øù claimedBy ÂØπË±°Â≠òÂú®
                      if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                      // 3. ‰ΩøÁî®ÂàöÂàöÊü•ÊâæÂà∞ÁöÑ displayName ‰Ωú‰∏∫ËÆ∞ÂΩïÁöÑkey
                      packetToOpen.claimedBy[displayName] = claimedAmountAI;

                      // 4. ÂèëÈÄÅÂØπÁî®Êà∑ÂèØËßÅÁöÑÁ≥ªÁªüÊ∂àÊÅØ
                      const aiClaimedMessage = {
                        role: "system",
                        type: "pat_message",
                        // Á≥ªÁªüÊ∂àÊÅØÈáå‰πü‰ΩøÁî® displayName
                        content: `${displayName} claimed ${packetToOpen.senderName}'s red packet`,
                        timestamp: Date.now(),
                      };
                      chat.history.push(aiClaimedMessage);

                      let hiddenContentForAI = `[System Notice: You (${displayName}) successfully claimed ${claimedAmountAI.toFixed(
                        2,
                      )} CNY.]`;

                      // 5. Ê£ÄÊü•Á∫¢ÂåÖÊòØÂê¶Ë¢´È¢ÜÂÆå
                      if (
                        Object.keys(packetToOpen.claimedBy).length >=
                        packetToOpen.count
                      ) {
                        packetToOpen.isFullyClaimed = true; // Ê†áËÆ∞‰∏∫Â∑≤È¢ÜÂÆå

                        // ÂèëÈÄÅÂØπÁî®Êà∑ÂèØËßÅÁöÑ‚ÄúÂ∑≤È¢ÜÂÆå‚ÄùÈÄöÁü•
                        const finishedMessage = {
                          role: "system",
                          type: "pat_message",
                          content: `${packetToOpen.senderName}'s red packet has been fully claimed`,
                          timestamp: Date.now() + 1,
                        };
                        chat.history.push(finishedMessage);

                        // ÂºÄÂßãÊûÑÂª∫ÁªôAIÁúãÁöÑ‚ÄúÊàòÊä•‚Äù
                        hiddenContentForAI += ` Red packet has been fully claimed.`;

                        // Â¶ÇÊûúÊòØÊãºÊâãÊ∞îÁ∫¢ÂåÖÔºåÊâæÂá∫Ë∞ÅÊòØÊâãÊ∞îÁéã
                        let luckyKing = { name: "", amount: -1 };
                        if (
                          packetToOpen.packetType === "lucky" &&
                          packetToOpen.count > 1
                        ) {
                          Object.entries(packetToOpen.claimedBy).forEach(
                            ([name, amount]) => {
                              if (amount > luckyKing.amount) {
                                luckyKing = { name, amount };
                              }
                            },
                          );
                        }
                        // ÊääÊâãÊ∞îÁéã‰ø°ÊÅØ‰πüÂä†Âà∞‚ÄúÊàòÊä•‚ÄùÈáå
                        if (luckyKing.name) {
                          hiddenContentForAI += ` The luckiest player is ${luckyKing.name}ÔºÅ`;
                        }
                      }
                      hiddenContentForAI += " Please comment on this result.]";

                      // 6. ÂàõÂª∫Âπ∂Ê∑ªÂä†ÁªôAIÁúãÁöÑÈöêËóèÊ∂àÊÅØ
                      const hiddenMessageForAI = {
                        role: "system",
                        content: hiddenContentForAI,
                        timestamp: Date.now() + 2, // Á°Æ‰øùÊó∂Èó¥Êà≥Âú®Âêé
                        isHidden: true,
                      };
                      chat.history.push(hiddenMessageForAI);
                    }

                    // 7. Âà∑Êñ∞UIÔºàÂ¶ÇÊûúÁî®Êà∑Ê≠£Âú®ÁúãÁöÑËØùÔºâ
                    if (isViewingThisChat) {
                      renderChatInterface(chatId);
                    }
                  }
                  continue; // ËøôÊòØ‰∏Ä‰∏™ÂêéÂè∞Êìç‰ΩúÔºåÁªßÁª≠Â§ÑÁêÜAIÂèØËÉΩËøîÂõûÁöÑÂÖ∂‰ªñÊ∂àÊÅØ
                }

                case "change_avatar":
                  const avatarName = msgData.name;
                  // Âú®ËØ•ËßíËâ≤ÁöÑÂ§¥ÂÉèÂ∫ì‰∏≠Êü•Êâæ
                  const foundAvatar = chat.settings.aiAvatarLibrary.find(
                    (avatar) => avatar.name === avatarName,
                  );

                  if (foundAvatar) {
                    // ÊâæÂà∞‰∫ÜÔºåÂ∞±Êõ¥Êñ∞Â§¥ÂÉè
                    chat.settings.aiAvatar = foundAvatar.url;

                    // ÂàõÂª∫‰∏ÄÊù°Á≥ªÁªüÊèêÁ§∫ÔºåÂëäÁü•Áî®Êà∑Â§¥ÂÉèÂ∑≤Êõ¥Êç¢
                    const systemNotice = {
                      role: "system",
                      type: "pat_message", // Â§çÁî®Â±Ö‰∏≠Ê†∑Âºè
                      content: `[${chat.name} changed the profile picture]`,
                      timestamp: Date.now(),
                    };
                    chat.history.push(systemNotice);

                    // Â¶ÇÊûúÂú®ÂΩìÂâçËÅäÂ§©ÁïåÈù¢ÔºåÂàôÂÆûÊó∂Ê∏≤Êüì
                    if (isViewingThisChat) {
                      appendMessage(systemNotice, chat);
                      // Á´ãÂàªÂà∑Êñ∞ËÅäÂ§©ÁïåÈù¢‰ª•ÊòæÁ§∫Êñ∞Â§¥ÂÉè
                      renderChatInterface(chatId);
                    }
                  }
                  // Â§ÑÁêÜÂÆåÂêéÔºåÁªßÁª≠Â§ÑÁêÜAIÂèØËÉΩËøîÂõûÁöÑÂÖ∂‰ªñÊ∂àÊÅØ
                  continue;

                case "accept_transfer": {
                  // ‰ΩøÁî®Â§ßÊã¨Âè∑ÂàõÂª∫ÂùóÁ∫ß‰ΩúÁî®Âüü
                  const originalTransferMsgIndex = chat.history.findIndex(
                    (m) => m.timestamp === msgData.for_timestamp,
                  );
                  if (originalTransferMsgIndex > -1) {
                    const originalMsg = chat.history[originalTransferMsgIndex];
                    originalMsg.status = "accepted";

                    // „ÄêÂÖ®Êñ∞„ÄëÂêåÊ≠•Âà∞ËßíËâ≤Èí±ÂåÖÔºàÊî∂ÂÖ•Ôºâ
                    const acceptDescription = `Received a transfer from ${originalMsg.senderName}`;
                    await updateCharacterBankBalance(
                      chatId,
                      originalMsg.amount,
                      acceptDescription,
                    );
                  }
                  continue; // Êé•ÂèóÊåá‰ª§Âè™‰øÆÊîπÁä∂ÊÄÅÔºå‰∏ç‰∫ßÁîüÊñ∞Ê∂àÊÅØ
                }

                case "decline_transfer": {
                  // ‰ΩøÁî®Â§ßÊã¨Âè∑ÂàõÂª∫ÂùóÁ∫ß‰ΩúÁî®Âüü
                  const originalTransferMsgIndex = chat.history.findIndex(
                    (m) => m.timestamp === msgData.for_timestamp,
                  );
                  if (originalTransferMsgIndex > -1) {
                    const originalMsg = chat.history[originalTransferMsgIndex];
                    originalMsg.status = "declined";

                    // ÂàõÂª∫‰∏ÄÊù°Êñ∞ÁöÑ‚ÄúÈÄÄÊ¨æ‚ÄùÊ∂àÊÅØ
                    const refundMessage = {
                      role: "assistant",
                      senderName: chat.name,
                      type: "transfer",
                      isRefund: true, // Ê†áËÆ∞ËøôÊòØ‰∏ÄÊù°ÈÄÄÊ¨æÊ∂àÊÅØ
                      amount: originalMsg.amount,
                      note: "Transfer has been declined",
                      timestamp: messageTimestamp++, // ‰ΩøÁî®ÈÄíÂ¢ûÁöÑÊó∂Èó¥Êà≥
                    };

                    // Â∞ÜÊñ∞Ê∂àÊÅØÊé®ÂÖ•ÂéÜÂè≤ËÆ∞ÂΩïÔºåÂÆÉ‰ºöË¢´ÂêéÁª≠ÁöÑÂæ™ÁéØÂ§ÑÁêÜÂπ∂Ê∏≤Êüì
                    chat.history.push(refundMessage);

                    if (isViewingThisChat) {
                      // Âõ†‰∏∫ÈÄÄÊ¨æÊ∂àÊÅØÊòØÊñ∞ÁîüÊàêÁöÑÔºåÊâÄ‰ª•Êàë‰ª¨Áõ¥Êé•Â∞ÜÂÆÉÊ∑ªÂä†Âà∞ÁïåÈù¢‰∏ä
                      appendMessage(refundMessage, chat);
                      // ÂêåÊó∂ÔºåÂéüÂßãÁöÑËΩ¨Ë¥¶Ê∂àÊÅØÁä∂ÊÄÅÂèò‰∫ÜÔºåÊâÄ‰ª•Ë¶ÅÈáçÁªòÊï¥‰∏™ÁïåÈù¢‰ª•Êõ¥Êñ∞ÂÆÉ
                      renderChatInterface(chatId);
                    }
                  }
                  continue; // ÁªßÁª≠Â§ÑÁêÜAIËøîÂõûÁöÑÊñáÊú¨Ê∂àÊÅØ
                }

                case "system_message":
                  aiMessage = {
                    role: "system",
                    type: "pat_message",
                    content: msgData.content,
                    timestamp: Date.now(),
                  };
                  break;

                case "share_link":
                  aiMessage = {
                    ...baseMessage,
                    type: "share_link",
                    title: msgData.title,
                    description: msgData.description,
                    // thumbnail_url: msgData.thumbnail_url, // Êàë‰ª¨Â∑≤ÁªèÂÜ≥ÂÆö‰∏çË¶ÅÂõæÁâá‰∫ÜÔºåÊâÄ‰ª•ËøôË°åÂèØ‰ª•‰∏çË¶Å
                    source_name: msgData.source_name,
                    content: msgData.content, // ËøôÊòØÊñáÁ´†Ê≠£ÊñáÔºåÁÇπÂáªÂç°ÁâáÂêéÊòæÁ§∫ÁöÑÂÜÖÂÆπ
                  };
                  break;

                case "quote_reply":
                  const originalMessage = chat.history.find(
                    (m) => m.timestamp === msgData.target_timestamp,
                  );
                  if (originalMessage) {
                    const quoteContext = {
                      timestamp: originalMessage.timestamp,
                      senderName:
                        originalMessage.senderName ||
                        (originalMessage.role === "user"
                          ? chat.settings.myNickname || "Me"
                          : chat.name),
                      content: String(originalMessage.content || ""),
                    };
                    aiMessage = {
                      ...baseMessage,
                      content: msgData.reply_content,
                      quote: quoteContext,
                    };
                  } else {
                    aiMessage = {
                      ...baseMessage,
                      content: msgData.reply_content,
                    };
                  }
                  break;

                case "location":
                  aiMessage = {
                    ...baseMessage,
                    type: "location",
                    userLocation: msgData.userLocation,
                    aiLocation: msgData.aiLocation,
                    distance: msgData.distance,
                    trajectoryPoints: msgData.trajectoryPoints || [], // „ÄêÊñ∞Â¢û„ÄëÁ°Æ‰øùÂç≥‰ΩøAIÊ≤°Êèê‰æõÔºå‰πüÊòØ‰∏Ä‰∏™Á©∫Êï∞ÁªÑ
                  };
                  break;

                case "send_and_recall": {
                  // --- Âä®ÁîªÈÉ®ÂàÜ (‰øùÊåÅ‰∏çÂèò) ---
                  if (!isViewingThisChat) continue;
                  const tempMessageData = {
                    ...baseMessage,
                    content: msgData.content,
                  };
                  appendMessage(tempMessageData, chat, true);
                  await new Promise((resolve) =>
                    setTimeout(resolve, Math.random() * 1000 + 1500),
                  );
                  const bubbleWrapper = document
                    .querySelector(
                      `.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`,
                    )
                    ?.closest(".message-wrapper");
                  if (bubbleWrapper) {
                    bubbleWrapper.classList.add("recalled-animation");
                    await new Promise((resolve) => setTimeout(resolve, 300));
                  }

                  // 1. ÂàõÂª∫ÂØπÁî®Êà∑ÂèØËßÅÁöÑ‚ÄúÂ∑≤Êí§Âõû‚ÄùÊ∂àÊÅØ
                  const recalledMessage = {
                    role: "assistant",
                    senderName: msgData.name || chat.name,
                    type: "recalled_message",
                    content: "The message has been recalled",
                    timestamp: tempMessageData.timestamp,
                    recalledData: {
                      originalType: "text",
                      originalContent: msgData.content,
                    },
                  };

                  // 2. ÂàõÂª∫‰∏ÄÊù°ÂØπÁî®Êà∑ÈöêËóè„ÄÅ‰ΩÜÂØπAIÂèØËßÅÁöÑ‚ÄúËÆ∞ÂøÜ‚ÄùÊ∂àÊÅØ
                  const hiddenMemoryMessage = {
                    role: "system", // ÂøÖÈ°ªÊòØ systemÔºåËøôÊ†∑AIÊâçÁü•ÈÅìËøôÊòØ‰∏ä‰∏ãÊñá‰ø°ÊÅØ
                    content: `[System Notice: You just said "${msgData.content}", but immediately recalled it.]`,
                    timestamp: tempMessageData.timestamp + 1, // Á°Æ‰øùÂú®Êí§ÂõûÊ∂àÊÅØ‰πãÂêé
                    isHidden: true, // Ëøô‰∏™Ê†áËÆ∞ËÆ©ÂÆÉ‰∏çÂú®UI‰∏äÊòæÁ§∫
                  };

                  // 3. Â∞ÜËøô‰∏§Êù°Ê∂àÊÅØÈÉΩÊ∑ªÂä†Âà∞ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠
                  chat.history.push(recalledMessage, hiddenMemoryMessage);

                  // 4. ÊõøÊç¢DOMÔºåÊòæÁ§∫‚ÄúÂ∑≤Êí§Âõû‚ÄùÊèêÁ§∫
                  const placeholder = createMessageElement(
                    recalledMessage,
                    chat,
                  );
                  if (document.body.contains(bubbleWrapper)) {
                    bubbleWrapper.parentNode.replaceChild(
                      placeholder,
                      bubbleWrapper,
                    );
                  }

                  continue;
                }

                case "sticker": {
                  // ËøôÊòØ‰∏∫Áæ§ËÅäÂíåÂçïËÅäÁªü‰∏ÄËÆæËÆ°ÁöÑË°®ÊÉÖÂåÖÈÄªËæë
                  const stickerName = msgData.sticker_name; // ÂÖ≥ÈîÆ‰øÆÊîπÔºöÁªü‰∏Ä‰ΩøÁî® sticker_name
                  if (!stickerName) {
                    console.warn(
                      "AI returned a sticker type but did not provide sticker_name, intercepted:",
                      msgData,
                    );
                    continue; // Skip this invalid instruction
                  }

                  // Âú®ÊâÄÊúâÂèØÁî®Ë°®ÊÉÖÂ∫ì‰∏≠Êü•Êâæ
                  const allStickers = [
                    ...state.userStickers,
                    ...state.charStickers,
                    ...(chat.settings.stickerLibrary || []),
                  ];
                  const foundSticker = allStickers.find(
                    (s) => s.name === stickerName,
                  );

                  if (foundSticker) {
                    // ÊâæÂà∞‰∫ÜÔºåÂ∞±ÂàõÂª∫Ê∂àÊÅØÂØπË±°
                    aiMessage = {
                      ...baseMessage,
                      type: "sticker",
                      content: foundSticker.url,
                      meaning: foundSticker.name,
                    };
                  } else {
                    // Ê≤°ÊâæÂà∞ÔºåËØ¥ÊòéAIÂπªËßâ‰∫ÜÔºåËÆ∞ÂΩïË≠¶ÂëäÂπ∂Ë∑≥Ëøá
                    console.warn(
                      `AIÊùúÊí∞‰∫Ü‰∏çÂ≠òÂú®ÁöÑË°®ÊÉÖ: "${stickerName}"ÔºåÂ∑≤Ëá™Âä®Êã¶Êà™„ÄÇ`,
                    );
                  }
                  break;
                }
                case "text": {
                  const messageText = String(
                    msgData.content || msgData.message || "",
                  );

                  if (STICKER_REGEX.test(messageText)) {
                    aiMessage = {
                      ...baseMessage,
                      type: "sticker",
                      content: messageText,
                      meaning: "",
                    };
                  } else {
                    // ÂÖºÂÆπÊóßÁöÑ[sticker:ÂêçÂ≠ó]Ê†ºÂºèÔºå‰ΩÜÊñ∞promptÂ∑≤‰∏çÊé®Ëçê
                    const stickerMatch =
                      messageText.match(/^\[sticker:(.+?)\]$/);
                    if (stickerMatch) {
                      const stickerName = stickerMatch[1].trim();
                      const allStickers = [
                        ...state.userStickers,
                        ...state.charStickers,
                        ...(chat.settings.stickerLibrary || []),
                      ];
                      const foundSticker = allStickers.find(
                        (s) => s.name === stickerName,
                      );

                      if (foundSticker) {
                        aiMessage = {
                          ...baseMessage,
                          type: "sticker",
                          content: foundSticker.url,
                          meaning: foundSticker.name,
                        };
                      } else {
                        console.warn(
                          `AI‰ΩøÁî®‰∫ÜÊóßÊ†ºÂºè‰∏îÊùúÊí∞‰∫Ü‰∏çÂ≠òÂú®ÁöÑË°®ÊÉÖ: "${stickerName}"ÔºåÂ∑≤Êã¶Êà™„ÄÇ`,
                        );
                      }
                    } else {
                      aiMessage = { ...baseMessage, content: messageText };
                    }
                  }
                  break;
                }

                case "dating_payment_response": {
                  const originalRequest = chat.history
                    .filter(
                      (m) =>
                        m.role === "system" &&
                        m.content.includes("dating_payment_response"),
                    )
                    .pop();
                  if (!originalRequest) continue;

                  const costMatch =
                    originalRequest.content.match(/Ë¥πÁî®Ôºà(\d+(\.\d+)?)ÈáëÂ∏ÅÔºâ/);
                  const cost = costMatch ? parseFloat(costMatch[1]) : 0;

                  if (msgData.decision === "accept") {
                    const charBalance =
                      chat.characterPhoneData.bank.balance || 0;
                    if (charBalance >= cost) {
                      await updateCharacterPhoneBankBalance(
                        chat.id,
                        -cost,
                        `Dating expense: Paying for the user`,
                      );
                      aiMessage = {
                        ...baseMessage,
                        content:
                          msgData.responseText || "Sure, I'll treat this time!",
                      };
                    } else {
                      aiMessage = {
                        ...baseMessage,
                        content:
                          msgData.responseText ||
                          "Aww, I also want to treat, but it seems my wallet is not enough...",
                      };
                    }
                  } else {
                    aiMessage = {
                      ...baseMessage,
                      content: msgData.responseText || "I guess we'll skip it this time...",
                    };
                  }
                  break;
                }

                case "dating_aa_response": {
                  const originalRequest = chat.history
                    .filter(
                      (m) =>
                        m.role === "system" &&
                        m.content.includes("dating_aa_response"),
                    )
                    .pop();
                  if (!originalRequest) continue;

                  const costMatch = originalRequest.content.match(
                    /Each person pays (\d+(\.\d+)?) gold coins./,
                  );
                  const splitCost = costMatch ? parseFloat(costMatch[1]) : 0;

                  if (msgData.decision === "accept") {
                    const charBalance =
                      chat.characterPhoneData.bank.balance || 0;
                    if (charBalance >= splitCost) {
                      await updateUserBalanceAndLogTransaction(
                        -splitCost,
                        `Dating split expense`,
                      );
                      await updateCharacterPhoneBankBalance(
                        chat.id,
                        -splitCost,
                        `Dating split expense`,
                      );
                      aiMessage = {
                        ...baseMessage,
                        content:
                          msgData.responseText || "Sure, split bill is totally fine!",
                      };
                    } else {
                      aiMessage = {
                        ...baseMessage,
                        content:
                          msgData.responseText ||
                          "Aww, it seems my wallet is not enough to cover my share.",
                      };
                    }
                  } else {
                    aiMessage = {
                      ...baseMessage,
                      content:
                        msgData.responseText ||
                        "I feel split bill is a bit too formal, should I treat? Or you?",
                    };
                  }
                  break;
                }

                case "lend_money_response": {
                  const originalRequest = chat.history
                    .filter(
                      (m) =>
                        m.role === "system" &&
                        m.content.includes("lend_money_response"),
                    )
                    .pop();
                  if (!originalRequest) continue;

                  const amountMatch =
                    originalRequest.content.match(/Borrow (\d+(\.\d+)?) gold coins/);
                  const amount = amountMatch ? parseFloat(amountMatch[1]) : 0;

                  // Only handle the financial logic when accepting a loan
                  if (msgData.decision === "accept") {
                    const lenderBalance =
                      chat.characterPhoneData.bank.balance || 0;
                    if (lenderBalance >= amount) {
                      await updateCharacterPhoneBankBalance(
                        chat.id,
                        -amount,
                        `Lend money to user`,
                      );
                      await updateUserBalanceAndLogTransaction(
                        amount,
                        `Borrowed from ${chat.name}`,
                      );
                    } else {
                      // If AI decides to accept but doesn't have enough money, we trust AI to explain in the next message.
                      // The financial logic here can be more complex, but for now, keep it simple and trust AI's judgment.
                      console.warn(
                        `AI "${chat.name}" agreed to lend money, but doesn't have enough balance. Transaction not executed.`,
                      );
                    }
                  }
                  // Â¶ÇÊûúÊòØÊãíÁªù(reject)ÔºåÂàô‰∏çÊâßË°å‰ªª‰ΩïÈáëËûçÊìç‰Ωú„ÄÇ

                  // ‰∏çÂÜçÂú®ËøôÈáåÂàõÂª∫‰ªª‰Ωï aiMessage„ÄÇ
                  // ‰ΩøÁî® 'continue' Ë∑≥Âà∞AIÂõûÂ§çÊï∞ÁªÑÁöÑ‰∏ã‰∏ÄÈ°πÔºå‰πüÂ∞±ÊòØAIËá™Â∑±ÁîüÊàêÁöÑÊñáÊú¨Ê∂àÊÅØÔºåËÆ©Âæ™ÁéØÁöÑÂêéÁª≠ÈÉ®ÂàÜÂéªÂ§ÑÁêÜÂÆÉ„ÄÇ
                  continue;
                }

                case "forum_comment": {
                  // ‰ΩøÁî®Â§ßÊã¨Âè∑ÂàõÂª∫ÂùóÁ∫ß‰ΩúÁî®Âüü
                  const postIdToComment = msgData.postId;
                  const commentText = msgData.commentText;

                  if (postIdToComment && commentText) {
                    // 1. Â∞ùËØïÂ∞Ü postId Âº∫Âà∂ËΩ¨Êç¢‰∏∫Êï∞Â≠ó„ÄÇ
                    //    ËøôËÉΩËß£ÂÜ≥AIËøîÂõûÊï∞Â≠óÂ≠óÁ¨¶‰∏≤ÔºàÂ¶Ç"123"ÔºâÂØºËá¥Êü•ËØ¢Â§±Ë¥•ÁöÑÈóÆÈ¢ò„ÄÇ
                    const numericPostId = parseInt(postIdToComment, 10);

                    // Ê£ÄÊü•ËΩ¨Êç¢ÂêéÁöÑIDÊòØÂê¶ÊúâÊïà
                    if (isNaN(numericPostId)) {
                      console.warn(
                        `[Circle comment failed] The received postId "${postIdToComment}" is not a valid numeric ID and has been skipped.`,
                      );
                      // ÊèêÁ§∫ÔºöÂ¶ÇÊûúÈ¢ëÁπÅÁúãÂà∞Ê≠§Ë≠¶ÂëäÔºåËØ∑Ê£ÄÊü•‰Ω†ÁªôAIÁöÑsystem promptÔºåÁ°Æ‰øù‰Ω†Ë¶ÅÊ±ÇÂÆÉËøîÂõûÊï∞Â≠óID„ÄÇ
                      continue; // Ë∑≥ËøáÊ≠§Êåá‰ª§
                    }

                    // 2. ‰ΩøÁî®Ê≠£Á°ÆÁöÑÊï∞Â≠óID‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÂ∏ñÂ≠ê
                    const postToComment =
                      await db.forumPosts.get(numericPostId);

                    if (postToComment) {
                      // ÂàõÂª∫Êñ∞ËØÑËÆ∫ÂØπË±°
                      const newComment = {
                        postId: numericPostId, // ‰ΩøÁî®ËΩ¨Êç¢ÂêéÁöÑÊï∞Â≠óID
                        author: chat.name, // ËØÑËÆ∫ËÄÖÂ∞±ÊòØÂΩìÂâçAI
                        content: commentText,
                        timestamp: Date.now(),
                      };

                      // Â∞ÜÊñ∞ËØÑËÆ∫‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
                      await db.forumComments.add(newComment);
                      console.log(
                        `AI "${chat.name}" commented on post #${numericPostId}: "${commentText}"`,
                      );

                      // 3. ÂêåÊó∂Ê£ÄÊü•Â∏ñÂ≠êÂàóË°®È°µÂíåÂ∏ñÂ≠êËØ¶ÊÉÖÈ°µ
                      //    ËøôÊ†∑Êó†ËÆ∫‰Ω†Ê≠£Âú®ÁúãÂì™‰∏™È°µÈù¢ÔºåÈÉΩËÉΩÁúãÂà∞Êõ¥Êñ∞„ÄÇ

                      // Â¶ÇÊûúÁî®Êà∑Ê≠£Âú®ÁúãËøô‰∏™Â∞èÁªÑÁöÑÂ∏ñÂ≠êÂàóË°®ÔºåÂ∞±Âà∑Êñ∞ÂàóË°®
                      if (
                        document
                          .getElementById("group-screen")
                          .classList.contains("active") &&
                        activeGroupId === postToComment.groupId
                      ) {
                        await renderGroupPosts(activeGroupId);
                      }

                      // Â¶ÇÊûúÁî®Êà∑Ê≠£Âú®ÁúãËøô‰∏™Â∏ñÂ≠êÁöÑËØ¶ÊÉÖÈ°µÔºåÂ∞±Âà∑Êñ∞ËØ¶ÊÉÖÈ°µÔºàËøôÊòØÊú¨Ê¨°‰øÆÂ§çÁöÑÂÖ≥ÈîÆÔºÅÔºâ
                      if (
                        document
                          .getElementById("post-screen")
                          .classList.contains("active") &&
                        activeForumPostId === numericPostId
                      ) {
                        await renderPostDetails(numericPostId);
                      }
                    } else {
                      console.warn(
                        `[Circle comment failed] Could not find a post with postId ${numericPostId} in the database.`,
                      );
                    }
                  }
                  // Êó†ËÆ∫ÊàêÂäü‰∏éÂê¶ÔºåËøôÈÉΩÊòØ‰∏Ä‰∏™ÂêéÂè∞Êìç‰ΩúÔºåÁªßÁª≠Â§ÑÁêÜAIÂèØËÉΩËøîÂõûÁöÑÂÖ∂‰ªñÊåá‰ª§
                  continue;
                }

                case "ai_image":
                  aiMessage = {
                    ...baseMessage,
                    type: "ai_image",
                    content: msgData.description,
                  };
                  break;
                case "voice_message":
                  aiMessage = {
                    ...baseMessage,
                    type: "voice_message",
                    content: msgData.content,
                  };
                  break;

                case "transfer":
                  aiMessage = {
                    ...baseMessage,
                    type: "transfer",
                    amount: msgData.amount,
                    note: msgData.note,
                    receiverName: msgData.receiver || "Me",
                  };

                  // „ÄêÂÖ®Êñ∞„ÄëÂêåÊ≠•Âà∞ËßíËâ≤Èí±ÂåÖÔºàÊîØÂá∫Ôºâ
                  const transferDescription = `ËΩ¨Ë¥¶Áªô ${msgData.receiver || "Me"}`;
                  await updateCharacterBankBalance(
                    chatId,
                    -msgData.amount,
                    transferDescription,
                  );

                  break;

                case "waimai_request":
                  aiMessage = {
                    ...baseMessage,
                    type: "waimai_request",
                    productInfo: msgData.productInfo,
                    amount: msgData.amount,
                    status: "pending",
                    countdownEndTime: Date.now() + 15 * 60 * 1000,
                  };
                  break;

                default:
                  console.warn("Received an unknown AI instruction type:", msgData.type);
                  break;
              }

              // Â∞ÜÊ∏≤ÊüìÈÄªËæëÁßªÂá∫Âæ™ÁéØ
              if (aiMessage) {
                // 1. Â∞ÜÊñ∞Ê∂àÊÅØÂ≠òÂÖ•ÂéÜÂè≤ËÆ∞ÂΩï
                chat.history.push(aiMessage);

                if (!isViewingThisChat || document.hidden) {
                  let notificationText;
                  switch (aiMessage.type) {
                    case "transfer":
                      notificationText = `[Received a transfer]`;
                      break;
                    case "waimai_request":
                      notificationText = `[Received a food delivery request]`;
                      break;
                    case "ai_image":
                      notificationText = `[Image]`;
                      break;
                    case "voice_message":
                      notificationText = `[Voice message]`;
                      break;
                    case "sticker":
                      notificationText = aiMessage.meaning
                        ? `[Sticker: ${aiMessage.meaning}]`
                        : "[Sticker]";
                      break;
                    default:
                      notificationText = String(aiMessage.content || "");
                  }
                  const finalNotifText = chat.isGroup
                    ? `${aiMessage.senderName}: ${notificationText}`
                    : notificationText;
                  // Á°ÆÂÆöÂÖ∑‰ΩìÁöÑÂ§¥ÂÉèURL
                  let senderAvatarForNotify = null;

                  if (chat.isGroup) {
                    // Â¶ÇÊûúÊòØÁæ§ËÅäÔºåÂ∞ùËØïÊ†πÊçÆÊ∂àÊÅØÂèëÈÄÅËÄÖÂêçÂ≠óÊâæÂà∞ÂØπÂ∫îÁöÑÊàêÂëòÂ§¥ÂÉè
                    const member = chat.members.find(
                      (m) => m.originalName === aiMessage.senderName,
                    );
                    if (member) {
                      senderAvatarForNotify = member.avatar;
                    }
                  } else {
                    // Â¶ÇÊûúÊòØÂçïËÅäÔºåÁõ¥Êé•Áî®AIÂ§¥ÂÉè
                    senderAvatarForNotify = chat.settings.aiAvatar;
                  }

                  showNotification(
                    chatId,
                    finalNotifText.substring(0, 60) +
                      (finalNotifText.length > 60 ? "..." : ""),
                    senderAvatarForNotify, // <--- ‰º†ÂÖ•Ëøô‰∏™Êñ∞ÂèÇÊï∞
                  );
                }

                if (!isViewingThisChat) {
                  // Â¶ÇÊûúÁî®Êà∑‰∏çÂú®ÂΩìÂâçËÅäÂ§©ÁïåÈù¢ÔºåÂ∞±ÊääËøô‰∏™ËÅäÂ§©ÁöÑÊú™ËØªÊï∞ +1
                  chat.unreadCount = (chat.unreadCount || 0) + 1;
                }

                // 2. Âè™ÊúâÂú®ÂΩìÂâçËÅäÂ§©ÁïåÈù¢Êó∂ÔºåÊâçÊâßË°åÂ∏¶Âä®ÁîªÁöÑÊ∑ªÂä†
                if (isViewingThisChat) {
                  appendMessage(aiMessage, chat);
                  playNotificationSound();
                  await new Promise((resolve) =>
                    setTimeout(resolve, Math.random() * 1800 + 1000),
                  );
                }
              }
            }

            if (callHasBeenHandled && videoCallState.isGroupCall) {
              videoCallState.isAwaitingResponse = false;
              if (videoCallState.participants.length > 0) {
                startVideoCall();
              } else {
                videoCallState = {
                  ...videoCallState,
                  isAwaitingResponse: false,
                  participants: [],
                };
                showScreen("chat-interface-screen");
                alert("No one answered the group call invitation.");
              }
            }
            await db.chats.put(chat);
            checkAndTriggerSummary(chatId);

            // --- Streak logic ---
            if (await updateStreak(chatId)) {
              // If the streak days have changed, refresh the chat list
              renderChatList();
            }
          } catch (error) {
            chat.history = chat.history.filter((msg) => !msg.isTemporary);
            if (
              !chat.isGroup &&
              chat.relationship?.status === "pending_ai_approval"
            ) {
              chat.relationship.status = "blocked_by_ai";
              await showCustomAlert(
                "Application failed",
              `The AI encountered an error while processing your friend request. Please try again later.\nError message: ${error.message}`,
              );
            } else {
              const errorContent = `[Error: ${error.message}]`;
              const errorMessage = {
                role: "assistant",
                content: errorContent,
                timestamp: Date.now(),
              };
              if (chat.isGroup) errorMessage.senderName = "System Message";
              chat.history.push(errorMessage);
            }

            await db.chats.put(chat);
            videoCallState.isAwaitingResponse = false;

            if (
              document
                .getElementById("chat-interface-screen")
                .classList.contains("active") &&
              state.activeChatId === chatId
            ) {
              renderChatInterface(chatId);
            }
          } finally {
            // Âú® finally Âùó‰∏≠Áªü‰∏ÄÈöêËóèÊâÄÊúâÁ±ªÂûãÁöÑÊèêÁ§∫
            if (chat.isGroup) {
              if (typingIndicator) {
                typingIndicator.style.display = "none";
              }
            } else {
              if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                  chatHeaderTitle.textContent = state.chats[chatId].name;
                  chatHeaderTitle.classList.remove("typing-status");
                  chatHeaderTitle.style.opacity = 1;
                }, 200);
              }
            }
          }
        }

        async function sendSticker(sticker) {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          const msg = {
            role: "user",
            content: sticker.url,
            meaning: sticker.name,
            timestamp: Date.now(),
          };
          chat.history.push(msg);
          await db.chats.put(chat);
          checkAndTriggerSummary(state.activeChatId);
          appendMessage(msg, chat);
          renderChatList();
          document.getElementById("sticker-panel").classList.remove("visible");
        }

        async function sendUserTransfer() {
          if (!state.activeChatId) return;

          const amountInput = document.getElementById("transfer-amount");
          const noteInput = document.getElementById("transfer-note");
          const amount = parseFloat(amountInput.value);
          const note = noteInput.value.trim();

          if (isNaN(amount) || amount <= 0) {
            alert("Please enter a valid amount!");
            return;
          }

          // Check if the balance is sufficient
          if ((state.globalSettings.userBalance || 0) < amount) {
            alert("Insufficient balance!");
            return;
          }

          const chat = state.chats[state.activeChatId];
          const senderName = chat.isGroup
            ? chat.settings.myNickname || "Me"
            : "Me";
          const receiverName = chat.isGroup ? "Group Chat" : chat.name;

          // Call the new function to deduct and log the transaction
          await updateUserBalanceAndLogTransaction(
            -amount,
            `Transfer to ${receiverName}`,
          );

          const msg = {
            role: "user",
            type: "transfer",
            amount: amount,
            note: note,
            senderName,
            receiverName,
            timestamp: Date.now(),
          };
          chat.history.push(msg);

          await db.chats.put(chat);
          appendMessage(msg, chat);
          renderChatList();
          document.getElementById("transfer-modal").classList.remove("visible");
          amountInput.value = "";
          noteInput.value = "";
        }

        function enterSelectionMode(initialMsgTimestamp) {
          if (isSelectionMode) return;
          isSelectionMode = true;
          document
            .getElementById("chat-interface-screen")
            .classList.add("selection-mode");
          toggleMessageSelection(initialMsgTimestamp);
        }

        function exitSelectionMode() {
          cleanupWaimaiTimers();
          if (!isSelectionMode) return;
          isSelectionMode = false;
          document
            .getElementById("chat-interface-screen")
            .classList.remove("selection-mode");
          selectedMessages.forEach((ts) => {
            const bubble = document.querySelector(
              `.message-bubble[data-timestamp="${ts}"]`,
            );
            if (bubble) bubble.classList.remove("selected");
          });
          selectedMessages.clear();
        }

        function toggleMessageSelection(timestamp) {
          const elementToSelect = document.querySelector(
            `.message-bubble[data-timestamp="${timestamp}"]`,
          );

          if (!elementToSelect) return;

          if (selectedMessages.has(timestamp)) {
            selectedMessages.delete(timestamp);
            elementToSelect.classList.remove("selected");
          } else {
            selectedMessages.add(timestamp);
            elementToSelect.classList.add("selected");
          }

          document.getElementById("selection-count").textContent =
            `Selected ${selectedMessages.size} item(s)`;

          if (selectedMessages.size === 0) {
            exitSelectionMode();
          }
        }

        function addLongPressListener(element, callback) {
          let pressTimer;
          const startPress = (e) => {
            if (isSelectionMode) return;
            e.preventDefault();
            pressTimer = window.setTimeout(() => callback(e), 500);
          };
          const cancelPress = () => clearTimeout(pressTimer);
          element.addEventListener("mousedown", startPress);
          element.addEventListener("mouseup", cancelPress);
          element.addEventListener("mouseleave", cancelPress);
          element.addEventListener("touchstart", startPress, { passive: true });
          element.addEventListener("touchend", cancelPress);
          element.addEventListener("touchmove", cancelPress);
        }

        async function handleListenTogetherClick() {
          document.getElementById("floating-lyrics-bar").style.display = "none";

          const targetChatId = state.activeChatId;
          if (!targetChatId) return;
          if (!state.musicState.isActive) {
            startListenTogetherSession(targetChatId);
            return;
          }
          if (state.musicState.activeChatId === targetChatId) {
            document
              .getElementById("music-player-overlay")
              .classList.add("visible");
          } else {
            const oldChatName =
              state.chats[state.musicState.activeChatId]?.name || "Unknown";
            const newChatName = state.chats[targetChatId]?.name || "Current";
            const confirmed = await showCustomConfirm(
              "Switch Listening Partner",
              `You are currently listening with "${oldChatName}". Do you want to end and start a new session with "${newChatName}"?`,
              { confirmButtonClass: "btn-danger" },
            );
            if (confirmed) {
              await endListenTogetherSession(true);
              await new Promise((resolve) => setTimeout(resolve, 50));
              startListenTogetherSession(targetChatId);
            }
          }
        }

        async function startListenTogetherSession(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;
          state.musicState.totalElapsedTime = chat.musicData.totalTime || 0;
          state.musicState.isActive = true;
          state.musicState.activeChatId = chatId;
          if (state.musicState.playlist.length > 0) {
            state.musicState.currentIndex = 0;
          } else {
            state.musicState.currentIndex = -1;
          }
          if (state.musicState.timerId) clearInterval(state.musicState.timerId);
          state.musicState.timerId = setInterval(() => {
            if (state.musicState.isPlaying) {
              state.musicState.totalElapsedTime++;
              updateElapsedTimeDisplay();
            }
          }, 1000);
          updatePlayerUI();
          updatePlaylistUI();
          document
            .getElementById("music-player-overlay")
            .classList.add("visible");
        }

        async function endListenTogetherSession(saveState = true) {
          if (!state.musicState.isActive) return;
          const oldChatId = state.musicState.activeChatId;
          const cleanupLogic = async () => {
            document.getElementById("floating-lyrics-bar").style.display =
              "none";

            if (state.musicState.timerId)
              clearInterval(state.musicState.timerId);
            if (state.musicState.isPlaying) audioPlayer.pause();
            if (saveState && oldChatId && state.chats[oldChatId]) {
              const chat = state.chats[oldChatId];
              chat.musicData.totalTime = state.musicState.totalElapsedTime;
              await db.chats.put(chat);
            }
            state.musicState.isActive = false;
            state.musicState.activeChatId = null;
            state.musicState.totalElapsedTime = 0;
            state.musicState.timerId = null;
            updateListenTogetherIcon(oldChatId, true);
          };
          closeMusicPlayerWithAnimation(cleanupLogic);
        }

        function returnToChat() {
          closeMusicPlayerWithAnimation(() => {
            if (state.musicState.isActive && lyricsBarSettings.showOnClose) {
              document.getElementById("floating-lyrics-bar").style.display =
                "flex";
            }
          });
        }

        function updateListenTogetherIcon(chatId, forceReset = false) {
          const iconImg = document.querySelector("#listen-together-btn img");
          if (!iconImg) return;
          if (
            forceReset ||
            !state.musicState.isActive ||
            state.musicState.activeChatId !== chatId
          ) {
            iconImg.src = "https://i.postimg.cc/CxjpF6gK/yi-qi-ting.png";
            iconImg.className = "";
            return;
          }
          iconImg.src =
            "https://cdn.jsdelivr.net.cn/gh/qdqqd/tc_temp/jli60izy2n.png";
          iconImg.classList.add("rotating");
          if (state.musicState.isPlaying) iconImg.classList.remove("paused");
          else iconImg.classList.add("paused");
        }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() {
          updateListenTogetherIcon(state.musicState.activeChatId);
          updateElapsedTimeDisplay();
          const titleEl = document.getElementById("music-player-song-title");
          const artistEl = document.getElementById("music-player-artist");
          const playPauseBtn = document.getElementById("music-play-pause-btn");
          const chat = state.chats[state.musicState.activeChatId];
          const charAvatarEl = document.getElementById("music-char-avatar");
          const userAvatarEl = document.getElementById("music-user-avatar");
          const albumCoverEl = document.getElementById("music-album-cover");
          const avatarsContainer = document.getElementById(
            "music-avatars-container",
          );
          const displayArea = document.getElementById("music-display-area");

          // 1. Âà§Êñ≠ÊòØÁæ§ËÅäËøòÊòØÂçïËÅäÔºåÂπ∂ËÆæÁΩÆÊ≠£Á°ÆÁöÑÂ§¥ÂÉè
          if (chat) {
            // Â¶ÇÊûúÊòØÁæ§ËÅä
            if (chat.isGroup) {
              // Â∑¶ËæπÁöÑÂ§¥ÂÉèÂ∞±Áî®Áæ§Â§¥ÂÉè
              charAvatarEl.src =
                chat.settings.groupAvatar || defaultGroupAvatar;
            } else {
              // Âê¶ÂàôÔºàÊòØÂçïËÅäÔºâÔºåÂ∞±Áî®ËßíËâ≤ÁöÑÂ§¥ÂÉè
              charAvatarEl.src = chat.settings.aiAvatar || defaultAvatar;
            }
            // Âè≥ËæπÁöÑÁî®Êà∑Â§¥ÂÉè‰øùÊåÅ‰∏çÂèò
            userAvatarEl.src = chat.settings.myAvatar || defaultAvatar;
          }

          // 2. Êõ¥Êñ∞Ê≠åÊõ≤‰ø°ÊÅØÂíåÂ∞ÅÈù¢
          if (
            state.musicState.currentIndex > -1 &&
            state.musicState.playlist.length > 0
          ) {
            const track =
              state.musicState.playlist[state.musicState.currentIndex];
            titleEl.textContent = track.name;
            artistEl.textContent = track.artist;
            albumCoverEl.src =
              track.cover ||
              "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
          } else {
            titleEl.textContent = "Please add a song";
            artistEl.textContent = "...";
            albumCoverEl.src =
              "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
          }

          // 3. ÊéßÂà∂Êí≠Êîæ/ÊöÇÂÅúÊåâÈíÆÂíåÂ§¥ÂÉèÈó™ÁÉÅ
          playPauseBtn.textContent = state.musicState.isPlaying ? "‚ùö‚ùö" : "‚ñ∂";
          avatarsContainer.classList.toggle(
            "flashing",
            state.musicState.isPlaying,
          );

          // 4. ÊéßÂà∂Âî±ÁâáÊóãËΩ¨ÂíåÊöÇÂÅú
          albumCoverEl.classList.toggle(
            "rotating",
            state.musicState.currentIndex > -1,
          );
          albumCoverEl.classList.toggle("paused", !state.musicState.isPlaying);

          // 5. ÈªòËÆ§ÊòæÁ§∫Ê≠åÊõ≤Â∞ÅÈù¢
          if (displayArea) {
            displayArea.classList.remove("show-lyrics");
          }
        }

        function updateElapsedTimeDisplay() {
          const hours = (state.musicState.totalElapsedTime / 3600).toFixed(1);
          document.getElementById("music-time-counter").textContent =
            `You have been listening together for ${hours} hours`;
        }

        /**
         * Handle user uploading or updating song cover logic
         * @param {number} index - The index of the song being operated on in the playlist
         */

        async function handleCoverUpload(index) {
          if (index < 0 || index >= state.musicState.playlist.length) return;

          // 1. ÂºπÁ™óËÆ©Áî®Êà∑ÈÄâÊã©Êù•Ê∫ê
          const choice = await showChoiceModal("Choose Cover Source", [
            { text: "Use URL", value: "url" },
            { text: "Upload from local", value: "local" },
          ]);

          let newCoverUrl = null;

          // 2. Ê†πÊçÆÈÄâÊã©ÊâßË°å‰∏çÂêåÊìç‰Ωú
          if (choice === "url") {
            const url = await showCustomPrompt(
              "Cover URL",
              "Please enter the URL of the image file",
            );
            if (url && url.trim().startsWith("http")) {
              newCoverUrl = url.trim();
            } else if (url !== null) {
              alert("Please enter a valid image URL!");
            }
          } else if (choice === "local") {
            newCoverUrl = await uploadImageLocally();
          }

          // 3. If a new cover URL is successfully obtained, update the data and UI
          if (newCoverUrl) {
            state.musicState.playlist[index].cover = newCoverUrl;
            await saveGlobalPlaylist();
            updatePlaylistUI();
            if (state.musicState.currentIndex === index) {
              updatePlayerUI();
            }
            alert("Song cover has been updated!");
          }
        }

        function updatePlaylistUI() {
          const playlistBody = document.getElementById("playlist-body");
          playlistBody.innerHTML = "";
          if (state.musicState.playlist.length === 0) {
            playlistBody.innerHTML =
              '<p style="text-align:center; padding: 20px; color: #888;">Êí≠ÊîæÂàóË°®ÊòØÁ©∫ÁöÑ~</p>';
            return;
          }
          state.musicState.playlist.forEach((track, index) => {
            const item = document.createElement("div");
            item.className = "playlist-item";
            if (index === state.musicState.currentIndex)
              item.classList.add("playing");
            // Êñ∞Â¢û‚ÄúÂ∞ÅÈù¢‚ÄùÊåâÈíÆ
            item.innerHTML = `
			            <div class="playlist-item-info">
			                <div class="title">${track.name}</div>
			                <div class="artist">${track.artist}</div>
			            </div>
			            <div class="playlist-item-actions">
			                <span class="playlist-action-btn cover-btn" data-index="${index}">Â∞ÅÈù¢</span>
			                <span class="playlist-action-btn lyrics-btn" data-index="${index}">ËØç</span>
			                <span class="playlist-action-btn delete-track-btn" data-index="${index}">√ó</span>
			            </div>
			        `;
            item
              .querySelector(".playlist-item-info")
              .addEventListener("click", () => playSong(index));
            playlistBody.appendChild(item);
          });
        }

        /**
         * Âä†ËΩΩÊ≠åÊõ≤ÔºåÊîØÊåÅËá™Âä®Ê£ÄÊµãËøáÊúüÂπ∂Áª≠ÊúüURL
         */
        async function loadSong(index) {
          if (index < 0 || index >= state.musicState.playlist.length) return;
          state.musicState.currentIndex = index;
          let track = state.musicState.playlist[index];

          if (!track.isLocal && track.musicId && track.musicSource) {
            // 1. Ê£ÄÊü•ÂΩìÂâçÈìæÊé•ÊòØÂê¶ÊúâÊïà
            const isUrlValid = await checkAudioAvailability(track.src);

            if (!isUrlValid) {
              console.log(
                `Detected that the song "${track.name}" link is invalid, attempting to renew...`,
              );
              // Show a small tip to let the user know that it is working
              const statusEl = document.getElementById("music-player-artist");
              if (statusEl) statusEl.textContent = "Updating link...";

              try {
                // 2. Use the saved ID to get the link again
                const apiUrl =
                  track.musicSource === "netease"
                    ? `https://api.vkeys.cn/v2/music/netease?id=${track.musicId}`
                    : `https://api.vkeys.cn/v2/music/tencent?id=${track.musicId}`;

                const res = await Http_Get(apiUrl);
                if (res?.data?.url) {
                  // 3. Êõ¥Êñ∞ÂÜÖÂ≠ò‰∏≠ÁöÑÈìæÊé•
                  track.src = res.data.url;
                  // 4. Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÔºå‰øùÂ≠òÊñ∞ÈìæÊé•
                  state.musicState.playlist[index] = track;
                  await saveGlobalPlaylist();
                  console.log(`Renewal successful! New link: ${track.src}`);
                }
              } catch (e) {
                console.error("Automatic renewal failed:", e);
              }
            }
          }

          // Ê£ÄÊü•Âπ∂Âä†ËΩΩÁΩëÁªúÊ≠åËØç
          if (track.lrcUrl && !track.lrcContent) {
            try {
              const response = await fetch(track.lrcUrl);
              if (response.ok) track.lrcContent = await response.text();
            } catch (error) {
              console.error("Failed to load lyrics URL:", error);
            }
          }

          // ÂáÜÂ§áÊí≠Êîæ
          state.musicState.parsedLyrics = parseLRC(track.lrcContent || "");
          state.musicState.currentLyricIndex = -1;
          renderLyrics();

          if (track.isLocal && track.src instanceof Blob) {
            audioPlayer.src = URL.createObjectURL(track.src);
          } else if (!track.isLocal) {
            audioPlayer.src = track.src;
          } else {
            console.error("Local song source error:", track);
            return;
          }

          // Êõ¥Êñ∞ÁïåÈù¢‰ø°ÊÅØ
          updatePlaylistUI();
          updatePlayerUI();

          // Â∞ùËØïÊí≠Êîæ
          try {
            if (state.musicState.isPlaying) {
              await audioPlayer.play();
            }
          } catch (e) {
            console.warn("Auto-play after loading was blocked", e);
          }

          audioPlayer.onloadedmetadata = () => {
            updateMusicProgressBar();
          };
        }

        async function playSong(index) {
          await loadSong(index);
          try {
            await audioPlayer.play();

            state.musicState.isPlaying = true; // Êí≠ÊîæÊàêÂäüÂêéÔºåÁõ¥Êé•ËÆæÁΩÆÁä∂ÊÄÅ‰∏∫ true
            updatePlayerUI(); // Âπ∂Á´ãÂç≥Êõ¥Êñ∞UI
          } catch (error) {
            console.error("Audio playback failed:", error);
            state.musicState.isPlaying = false; // Â¶ÇÊûúÊí≠ÊîæÂ§±Ë¥•Ôºå‰πüË¶ÅÁ°Æ‰øùÁä∂ÊÄÅÊ≠£Á°Æ
            updatePlayerUI();
          }
        }

        /**
         * Â§ÑÁêÜÊí≠Êîæ/ÊöÇÂÅúÁöÑÂáΩÊï∞
         */
        function togglePlayPause() {
          if (audioPlayer.paused) {
            if (state.musicState.currentIndex > -1) {
              playSong(state.musicState.currentIndex);
            }
          } else {
            audioPlayer.pause();

            state.musicState.isPlaying = false;
            updatePlayerUI();
          }
        }

        // Êí≠Êîæ‰∏ã‰∏ÄÈ¶ñÔºàÊ≠£Á°ÆË∑≥Ëøá‰øùÊ¥ªÈü≥È¢ëÔºâ
        function playNext() {
          if (state.musicState.playlist.length === 0) return;

          let nextIndex = state.musicState.currentIndex; // ‰ΩøÁî®‰∏¥Êó∂ÂèòÈáè‰Ωú‰∏∫Ëµ∑ÁÇπ
          let attempts = 0; // Èò≤Ê≠¢Ê≠ªÂæ™ÁéØÁöÑÂÆâÂÖ®ËÆ°Êï∞

          do {
            switch (state.musicState.playMode) {
              case "random":
                // ÈöèÊú∫Ê®°ÂºèÔºöÁõ¥Êé•ÁîüÊàê‰∏Ä‰∏™ÈöèÊú∫Êï∞
                nextIndex = Math.floor(
                  Math.random() * state.musicState.playlist.length,
                );
                break;
              case "single":
                // ÂçïÊõ≤Âæ™ÁéØÊ®°ÂºèÔºöËôΩÁÑ∂ÈÄöÂ∏∏Áî±endedËß¶ÂèëÈáçÊí≠Ôºå‰ΩÜÂú®ÊâãÂä®ÁÇπÂáª‰∏ã‰∏ÄÈ¶ñÊó∂ÔºåÂ∫îÂΩìÂàáÊç¢Âà∞‰∏ã‰∏ÄÈ¶ñ
                nextIndex = (nextIndex + 1) % state.musicState.playlist.length;
                break;
              case "order":
              default:
                // È°∫Â∫èÊ®°ÂºèÔºöÂΩìÂâçÁ¥¢Âºï + 1
                nextIndex = (nextIndex + 1) % state.musicState.playlist.length;
                break;
            }

            attempts++;
          } while (
            // Â¶ÇÊûúÈÄâ‰∏≠ÁöÑÊòØ‰øùÊ¥ªÈü≥È¢ë (isKeepAlive=true)
            // Âπ∂‰∏îÂàóË°®Èáå‰∏çÂè™ÊúâËøô‰∏ÄÈ¶ñÊ≠å
            // Âπ∂‰∏îÊ≤°ÊúâÂ∞ùËØïË∂ÖËøáÂàóË°®ÈïøÂ∫¶ÁöÑ2ÂÄçÔºàÈò≤Ê≠¢ÂÖ®ÈÉΩÊòØ‰øùÊ¥ªÈü≥È¢ëÂØºËá¥Ê≠ªÂæ™ÁéØÔºâ
            state.musicState.playlist[nextIndex].isKeepAlive &&
            state.musicState.playlist.length > 1 &&
            attempts < state.musicState.playlist.length * 2
          );

          playSong(nextIndex);
        }

        // Êí≠Êîæ‰∏ä‰∏ÄÈ¶ñÔºàËá™Âä®Ë∑≥Ëøá‰øùÊ¥ªÈü≥È¢ëÔºâ
        function playPrev() {
          if (state.musicState.playlist.length === 0) return;
          let newIndex = state.musicState.currentIndex;
          let attempts = 0;

          do {
            newIndex =
              (newIndex - 1 + state.musicState.playlist.length) %
              state.musicState.playlist.length;
            attempts++;
          } while (
            state.musicState.playlist[newIndex].isKeepAlive &&
            state.musicState.playlist.length > 1 &&
            attempts < state.musicState.playlist.length * 2
          );

          playSong(newIndex);
        }

        function changePlayMode() {
          const modes = ["order", "random", "single"];
          const currentModeIndex = modes.indexOf(state.musicState.playMode);
          state.musicState.playMode =
            modes[(currentModeIndex + 1) % modes.length];
          document.getElementById("music-mode-btn").textContent = {
            order: "Order",
            random: "Random",
            single: "Single",
          }[state.musicState.playMode];
        }

        async function addSongFromURL() {
          const url = await showCustomPrompt(
            "Add Online Song",
            "Please enter the song URL",
            "",
            "url",
          );
          if (!url) return;
          const name = await showCustomPrompt("Song Information", "Please enter the song name");
          if (!name) return;
          const artist = await showCustomPrompt("Song Information", "Please enter the artist name");
          if (!artist) return;

          // 1. First, ask the user if they want to provide a lyrics URL
          const wantLrc = await showCustomConfirm(
            "Import Lyrics",
            `Do you want to provide a lyrics file (.lrc) URL for "${name}"?`,
          );
          let lrcUrl = ""; // Default lyrics URL is empty

          // 2. If the user clicked "OK"
          if (wantLrc) {
            // Â∞±ÂÜçÂºπÂá∫‰∏Ä‰∏™ËæìÂÖ•Ê°ÜËÆ©Áî®Êà∑Á≤òË¥¥URL
            const inputLrcUrl = await showCustomPrompt(
              "Lyrics URL",
              "Please enter the URL for the .lrc lyrics file",
              "",
              "url",
            );
            if (inputLrcUrl) {
              lrcUrl = inputLrcUrl; // Â¶ÇÊûúÁî®Êà∑ËæìÂÖ•‰∫ÜÔºåÂ∞±‰øùÂ≠òËøô‰∏™URL
            }
          }

          state.musicState.playlist.push({
            name,
            artist,
            src: url,
            isLocal: false,
            lrcUrl: lrcUrl, // 3. ÊääËé∑ÂèñÂà∞ÁöÑÊ≠åËØçURL‰πü‰øùÂ≠òÂà∞Ê≠åÊõ≤‰ø°ÊÅØÈáå
            lrcContent: "", // ÂêåÊó∂Á°Æ‰øùlrcContentÊòØÁ©∫ÁöÑÔºå‰ª•‰æøÂêéÁª≠Âä†ËΩΩ
          });

          await saveGlobalPlaylist();
          updatePlaylistUI();

          if (state.musicState.currentIndex === -1) {
            // Ë∞ÉÁî® loadSong Êù•ÂáÜÂ§áÂ•ΩÁ¨¨‰∏ÄÈ¶ñÊ≠å
            loadSong(state.musicState.playlist.length - 1);
          }
        }

        async function addSongFromLocal(event) {
          const files = event.target.files;
          if (!files.length) return;

          for (const file of files) {
            let name = file.name.replace(/\.[^/.]+$/, "");
            name = await showCustomPrompt("Song Information", "Please enter the song name", name);
            if (name === null) continue;

            const artist = await showCustomPrompt(
              "Song Information",
              "Please enter the artist name",
              "Unknown Artist",
            );
            if (artist === null) continue;

            let lrcContent = "";
            const wantLrc = await showCustomConfirm(
              "Import Lyrics",
              `Do you want to import a lyrics file (.lrc) for "${name}"?`,
            );
            if (wantLrc) {
              lrcContent = await new Promise((resolve) => {
                const lrcInput = document.getElementById("lrc-upload-input");
                const lrcChangeHandler = (e) => {
                  const lrcFile = e.target.files[0];
                  if (lrcFile) {
                    const reader = new FileReader();
                    reader.onload = (readEvent) =>
                      resolve(readEvent.target.result);
                    reader.onerror = () => resolve("");
                    reader.readAsText(lrcFile);
                  } else {
                    resolve("");
                  }
                  lrcInput.removeEventListener("change", lrcChangeHandler);
                  lrcInput.value = "";
                };
                lrcInput.addEventListener("change", lrcChangeHandler);
                lrcInput.click();
              });
            }

            state.musicState.playlist.push({
              name,
              artist,
              src: file,
              isLocal: true,
              lrcContent: lrcContent,
            });
          }

          await saveGlobalPlaylist();
          updatePlaylistUI();

          if (
            state.musicState.currentIndex === -1 &&
            state.musicState.playlist.length > 0
          ) {
            // Ë∞ÉÁî® loadSong Êù•ÂáÜÂ§áÂ•ΩÁ¨¨‰∏ÄÈ¶ñÊ≠å
            loadSong(0);
          }
          event.target.value = null;
        }

        async function deleteTrack(index) {
          if (index < 0 || index >= state.musicState.playlist.length) return;
          const track = state.musicState.playlist[index];
          const wasPlaying =
            state.musicState.isPlaying &&
            state.musicState.currentIndex === index;
          if (
            track.isLocal &&
            audioPlayer.src.startsWith("blob:") &&
            state.musicState.currentIndex === index
          )
            URL.revokeObjectURL(audioPlayer.src);
          state.musicState.playlist.splice(index, 1);
          await saveGlobalPlaylist();
          if (state.musicState.playlist.length === 0) {
            if (state.musicState.isPlaying) audioPlayer.pause();
            audioPlayer.src = "";
            state.musicState.currentIndex = -1;
            state.musicState.isPlaying = false;
          } else {
            if (wasPlaying) {
              playNext();
            } else {
              if (state.musicState.currentIndex >= index)
                state.musicState.currentIndex = Math.max(
                  0,
                  state.musicState.currentIndex - 1,
                );
            }
          }
          updatePlayerUI();
          updatePlaylistUI();
        }

        const personaLibraryModal = document.getElementById(
          "persona-library-modal",
        );
        const personaEditorModal = document.getElementById(
          "persona-editor-modal",
        );
        const presetActionsModal = document.getElementById(
          "preset-actions-modal",
        );

        function openPersonaLibrary() {
          renderPersonaLibrary();
          personaLibraryModal.classList.add("visible");
        }

        function closePersonaLibrary() {
          personaLibraryModal.classList.remove("visible");
        }

        function renderPersonaLibrary() {
          const grid = document.getElementById("persona-library-grid");
          grid.innerHTML = "";
          if (state.personaPresets.length === 0) {
            grid.innerHTML =
              '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">Empty~ Click the "Add" button in the upper right corner to create your first persona preset!</p>';
            return;
          }
          state.personaPresets.forEach((preset) => {
            const item = document.createElement("div");
            item.className = "persona-preset-item";
            item.style.backgroundImage = `url(${preset.avatar})`;
            item.dataset.presetId = preset.id;
            item.addEventListener("click", () => applyPersonaPreset(preset.id));
            addLongPressListener(item, () => showPresetActions(preset.id));
            grid.appendChild(item);
          });
        }

        function showPresetActions(presetId) {
          editingPersonaPresetId = presetId;
          presetActionsModal.classList.add("visible");
        }

        function hidePresetActions() {
          presetActionsModal.classList.remove("visible");
          editingPersonaPresetId = null;
        }

        function applyPersonaPreset(presetId) {
          const preset = state.personaPresets.find((p) => p.id === presetId);
          if (preset) {
            document.getElementById("my-avatar-preview").src = preset.avatar;
            document.getElementById("my-persona").value = preset.persona;
          }
          closePersonaLibrary();
        }

        function openPersonaEditorForCreate() {
          editingPersonaPresetId = null;

          document.getElementById("persona-editor-title").textContent =
            "Add Persona Preset";
          document.getElementById("preset-avatar-preview").src = defaultAvatar;
          document.getElementById("preset-persona-input").value = "";

          // Ê†πÊçÆÁî®Êà∑‰∫∫ËÆæÊ®°ÂºèÔºåÊòæÈöêÁâπÂÆöUIÂÖÉÁ¥†
          document.getElementById("npc-editor-name-group").style.display =
            "none";
          document.getElementById(
            "persona-editor-change-frame-btn",
          ).style.display = "inline-block";

          // Áõ¥Êé•Ë¶ÜÁõñ‰øùÂ≠òÊåâÈíÆÁöÑ onclick ‰∫ã‰ª∂ÔºåÂº∫Âà∂ÂÆÉÂè™ÊâßË°å‰øùÂ≠òÁî®Êà∑‰∫∫ËÆæÁöÑÂáΩÊï∞
          document.getElementById("save-persona-preset-btn").onclick =
            savePersonaPreset;

          document
            .getElementById("persona-editor-modal")
            .classList.add("visible");
        }

        function openPersonaEditorForEdit() {
          const preset = state.personaPresets.find(
            (p) => p.id === editingPersonaPresetId,
          );
          if (!preset) return;

          document.getElementById("persona-editor-title").textContent =
            "Edit Persona Preset";
          document.getElementById("preset-avatar-preview").src = preset.avatar;
          document.getElementById("preset-persona-input").value =
            preset.persona;

          // Ê†πÊçÆÁî®Êà∑‰∫∫ËÆæÊ®°ÂºèÔºåÊòæÈöêÁâπÂÆöUIÂÖÉÁ¥†
          document.getElementById("npc-editor-name-group").style.display =
            "none";
          document.getElementById(
            "persona-editor-change-frame-btn",
          ).style.display = "inline-block";

          // Áõ¥Êé•Ë¶ÜÁõñ‰øùÂ≠òÊåâÈíÆÁöÑ onclick ‰∫ã‰ª∂ÔºåÂº∫Âà∂ÂÆÉÂè™ÊâßË°å‰øùÂ≠òÁî®Êà∑‰∫∫ËÆæÁöÑÂáΩÊï∞
          document.getElementById("save-persona-preset-btn").onclick =
            savePersonaPreset;

          presetActionsModal.classList.remove("visible");
          document
            .getElementById("persona-editor-modal")
            .classList.add("visible");
        }

        async function deletePersonaPreset() {
          const confirmed = await showCustomConfirm(
            "Delete Preset",
            "Are you sure you want to delete this persona preset? This action cannot be undone.",
            {
              confirmButtonClass: "btn-danger",
            },
          );
          if (confirmed && editingPersonaPresetId) {
            await db.personaPresets.delete(editingPersonaPresetId);
            state.personaPresets = state.personaPresets.filter(
              (p) => p.id !== editingPersonaPresetId,
            );
            hidePresetActions();
            renderPersonaLibrary();
          }
        }

        function closePersonaEditor() {
          personaEditorModal.classList.remove("visible");
          editingPersonaPresetId = null;
        }

        async function savePersonaPreset() {
          const avatar = document.getElementById("preset-avatar-preview").src;
          const persona = document
            .getElementById("preset-persona-input")
            .value.trim();
          if (avatar === defaultAvatar && !persona) {
            alert("Avatar and persona cannot both be empty!");
            return;
          }
          if (editingPersonaPresetId) {
            const preset = state.personaPresets.find(
              (p) => p.id === editingPersonaPresetId,
            );
            if (preset) {
              preset.avatar = avatar;
              preset.persona = persona;
              await db.personaPresets.put(preset);
            }
          } else {
            const newPreset = {
              id: "preset_" + Date.now(),
              avatar: avatar,
              persona: persona,
            };
            await db.personaPresets.add(newPreset);
            state.personaPresets.push(newPreset);
          }
          renderPersonaLibrary();
          closePersonaEditor();
        }

        const batteryAlertModal = document.getElementById(
          "battery-alert-modal",
        );

        function showBatteryAlert(imageUrl, text) {
          clearTimeout(batteryAlertTimeout);
          document.getElementById("battery-alert-image").src = imageUrl;
          document.getElementById("battery-alert-text").textContent = text;
          batteryAlertModal.classList.add("visible");
          const closeAlert = () => {
            batteryAlertModal.classList.remove("visible");
            batteryAlertModal.removeEventListener("click", closeAlert);
          };
          batteryAlertModal.addEventListener("click", closeAlert);
          batteryAlertTimeout = setTimeout(closeAlert, 2000);
        }

        function updateBatteryDisplay(battery) {
          const batteryContainer =
            document.getElementById("status-bar-battery");
          const batteryLevelEl =
            batteryContainer.querySelector(".battery-level");
          const batteryTextEl = batteryContainer.querySelector(".battery-text");
          const level = Math.floor(battery.level * 100);
          batteryLevelEl.style.width = `${level}%`;
          batteryTextEl.textContent = `${level}%`;
          if (battery.charging) {
            batteryContainer.classList.add("charging");
          } else {
            batteryContainer.classList.remove("charging");
          }
        }

        function handleBatteryChange(battery) {
          updateBatteryDisplay(battery);
          const level = battery.level;
          if (!battery.charging) {
            if (
              level <= 0.4 &&
              lastKnownBatteryLevel > 0.4 &&
              !alertFlags.hasShown40
            ) {
              showBatteryAlert(
                "https://i.postimg.cc/T2yKJ0DV/40.jpg",
                "ÊúâÁÇπÈ•ø‰∫ÜÔºåÂèØ‰ª•ÂéªÊâæÂÖÖÁîµÂô®ÊÉπ",
              );
              alertFlags.hasShown40 = true;
            }
            if (
              level <= 0.2 &&
              lastKnownBatteryLevel > 0.2 &&
              !alertFlags.hasShown20
            ) {
              showBatteryAlert(
                "https://i.postimg.cc/qB9zbKs9/20.jpg",
                "Ëµ∂Á¥ßÁöÑÂÖÖÁîµÔºåË¶ÅÈ•øÊ≠ª‰∫Ü",
              );
              alertFlags.hasShown20 = true;
            }
            if (
              level <= 0.1 &&
              lastKnownBatteryLevel > 0.1 &&
              !alertFlags.hasShown10
            ) {
              showBatteryAlert(
                "https://i.postimg.cc/ThMMVfW4/10.jpg",
                "Â∑≤Èòµ‰∫°ÔºåËøòÊúâ30ÁßíÁàÜÁÇ∏",
              );
              alertFlags.hasShown10 = true;
            }
          }
          if (level > 0.4) alertFlags.hasShown40 = false;
          if (level > 0.2) alertFlags.hasShown20 = false;
          if (level > 0.1) alertFlags.hasShown10 = false;
          lastKnownBatteryLevel = level;
        }

        async function initBatteryManager() {
          if ("getBattery" in navigator) {
            try {
              const battery = await navigator.getBattery();
              lastKnownBatteryLevel = battery.level;
              handleBatteryChange(battery);
              battery.addEventListener("levelchange", () =>
                handleBatteryChange(battery),
              );
              battery.addEventListener("chargingchange", () => {
                handleBatteryChange(battery);
                if (battery.charging) {
                  showBatteryAlert(
                    "https://i.postimg.cc/3NDQ0dWG/image.jpg",
                    "Á™ùÁà±Ê≥•ÔºåÁîµÈáèÂêÉÈ•±È•±",
                  );
                }
              });
            } catch (err) {
              console.error("Êó†Ê≥ïËé∑ÂèñÁîµÊ±†‰ø°ÊÅØ:", err);
              document.querySelector(".battery-text").textContent = "·óúœâ·óú";
            }
          } else {
            console.log("ÊµèËßàÂô®‰∏çÊîØÊåÅÁîµÊ±†Áä∂ÊÄÅAPI„ÄÇ");
            document.querySelector(".battery-text").textContent = "·óúœâ·óú";
          }
        }

        async function renderAlbumList() {
          const albumGrid = document.getElementById("album-grid-page");
          if (!albumGrid) return;
          const albums = await db.qzoneAlbums
            .orderBy("createdAt")
            .reverse()
            .toArray();
          albumGrid.innerHTML = "";
          if (albums.length === 0) {
            albumGrid.innerHTML =
              '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">‰Ω†ËøòÊ≤°ÊúâÂàõÂª∫‰ªª‰ΩïÁõ∏ÂÜåÂì¶~</p>';
            return;
          }
          albums.forEach((album) => {
            const albumItem = document.createElement("div");
            albumItem.className = "album-item";
            albumItem.innerHTML = `
			                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
			                    <div class="album-info">
			                        <p class="album-name">${album.name}</p>
			                        <p class="album-count">${album.photoCount || 0} Âº†</p>
			                    </div>
			                `;
            albumItem.addEventListener("click", () => {
              openAlbum(album.id);
            });

            addLongPressListener(albumItem, async () => {
              const confirmed = await showCustomConfirm(
                "Âà†Èô§Áõ∏ÂÜå",
                `Á°ÆÂÆöË¶ÅÂà†Èô§Áõ∏ÂÜå„Ää${album.name}„ÄãÂêóÔºüÊ≠§Êìç‰ΩúÂ∞ÜÂêåÊó∂Âà†Èô§Áõ∏ÂÜåÂÜÖÁöÑÊâÄÊúâÁÖßÁâáÔºå‰∏îÊó†Ê≥ïÊÅ¢Â§ç„ÄÇ`,
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                // 1. ‰ªéÁÖßÁâáË°®‰∏≠Âà†Èô§ËØ•Áõ∏ÂÜå‰∏ãÁöÑÊâÄÊúâÁÖßÁâá
                await db.qzonePhotos.where("albumId").equals(album.id).delete();

                // 2. ‰ªéÁõ∏ÂÜåË°®‰∏≠Âà†Èô§ËØ•Áõ∏ÂÜåÊú¨Ë∫´
                await db.qzoneAlbums.delete(album.id);

                // 3. ÈáçÊñ∞Ê∏≤ÊüìÁõ∏ÂÜåÂàóË°®
                await renderAlbumList();

                alert("Áõ∏ÂÜåÂ∑≤ÊàêÂäüÂà†Èô§„ÄÇ");
              }
            });

            albumGrid.appendChild(albumItem);
          });
        }

        async function openAlbum(albumId) {
          state.activeAlbumId = albumId;
          await renderAlbumPhotosScreen();
          showScreen("album-photos-screen");
        }

        async function renderAlbumPhotosScreen() {
          if (!state.activeAlbumId) return;
          const photosGrid = document.getElementById("photos-grid-page");
          const headerTitle = document.getElementById("album-photos-title");
          const album = await db.qzoneAlbums.get(state.activeAlbumId);
          if (!album) {
            console.error("Êâæ‰∏çÂà∞Áõ∏ÂÜå:", state.activeAlbumId);
            showScreen("album-screen");
            return;
          }
          headerTitle.textContent = album.name;
          const photos = await db.qzonePhotos
            .where("albumId")
            .equals(state.activeAlbumId)
            .toArray();
          photosGrid.innerHTML = "";
          if (photos.length === 0) {
            photosGrid.innerHTML =
              '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">Ëøô‰∏™Áõ∏ÂÜåËøòÊòØÁ©∫ÁöÑÔºåÂø´‰∏ä‰º†Á¨¨‰∏ÄÂº†ÁÖßÁâáÂêßÔºÅ</p>';
          } else {
            photos.forEach((photo) => {
              const photoItem = document.createElement("div");
              photoItem.className = "photo-item";
              photoItem.innerHTML = `
			                        <img src="${photo.url}" class="photo-thumb" alt="Áõ∏ÂÜåÁÖßÁâá">
			                        <button class="photo-delete-btn" data-photo-id="${photo.id}">√ó</button>
			                    `;
              photosGrid.appendChild(photoItem);
            });
          }
        }

        /**
         * ÊâìÂºÄÂõæÁâáÊü•ÁúãÂô®
         * @param {string} clickedPhotoUrl - Áî®Êà∑ÁÇπÂáªÁöÑÈÇ£Âº†ÁÖßÁâáÁöÑURL
         */
        async function openPhotoViewer(clickedPhotoUrl) {
          if (!state.activeAlbumId) return;

          // 1. ‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÂΩìÂâçÁõ∏ÂÜåÁöÑÊâÄÊúâÁÖßÁâá
          const photosInAlbum = await db.qzonePhotos
            .where("albumId")
            .equals(state.activeAlbumId)
            .toArray();
          photoViewerState.photos = photosInAlbum.map((p) => p.url);

          // 2. ÊâæÂà∞Ë¢´ÁÇπÂáªÁÖßÁâáÁöÑÁ¥¢Âºï
          photoViewerState.currentIndex = photoViewerState.photos.findIndex(
            (url) => url === clickedPhotoUrl,
          );
          if (photoViewerState.currentIndex === -1) return; // Â¶ÇÊûúÊâæ‰∏çÂà∞ÔºåÂàô‰∏çÊâìÂºÄ

          // 3. ÊòæÁ§∫Ê®°ÊÄÅÊ°ÜÂπ∂Ê∏≤ÊüìÁ¨¨‰∏ÄÂº†Âõæ
          document
            .getElementById("photo-viewer-modal")
            .classList.add("visible");
          renderPhotoViewer();
          photoViewerState.isOpen = true;
        }

        /**
         * Ê†πÊçÆÂΩìÂâçÁä∂ÊÄÅÊ∏≤ÊüìÊü•ÁúãÂô®ÂÜÖÂÆπÔºàÂõæÁâáÂíåÊåâÈíÆÔºâ
         */
        function renderPhotoViewer() {
          if (photoViewerState.currentIndex === -1) return;

          const imageEl = document.getElementById("photo-viewer-image");
          const prevBtn = document.getElementById("photo-viewer-prev-btn");
          const nextBtn = document.getElementById("photo-viewer-next-btn");

          // Ê∑°Âá∫ÊïàÊûú
          imageEl.style.opacity = 0;

          setTimeout(() => {
            // Êõ¥Êñ∞ÂõæÁâáÊ∫ê
            imageEl.src =
              photoViewerState.photos[photoViewerState.currentIndex];
            // Ê∑°ÂÖ•ÊïàÊûú
            imageEl.style.opacity = 1;
          }, 100); // Âª∂Ëøü‰∏ÄÁÇπÁÇπÊó∂Èó¥Êù•Ëß¶ÂèëCSSËøáÊ∏°

          // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅÔºöÂ¶ÇÊûúÊòØÁ¨¨‰∏ÄÂº†ÔºåÁ¶ÅÁî®‚Äú‰∏ä‰∏ÄÂº†‚ÄùÊåâÈíÆ
          prevBtn.disabled = photoViewerState.currentIndex === 0;
          // Â¶ÇÊûúÊòØÊúÄÂêé‰∏ÄÂº†ÔºåÁ¶ÅÁî®‚Äú‰∏ã‰∏ÄÂº†‚ÄùÊåâÈíÆ
          nextBtn.disabled =
            photoViewerState.currentIndex ===
            photoViewerState.photos.length - 1;
        }

        /**
         * ÊòæÁ§∫‰∏ã‰∏ÄÂº†ÁÖßÁâá
         */
        function showNextPhoto() {
          if (
            photoViewerState.currentIndex <
            photoViewerState.photos.length - 1
          ) {
            photoViewerState.currentIndex++;
            renderPhotoViewer();
          }
        }

        /**
         * ÊòæÁ§∫‰∏ä‰∏ÄÂº†ÁÖßÁâá
         */
        function showPrevPhoto() {
          if (photoViewerState.currentIndex > 0) {
            photoViewerState.currentIndex--;
            renderPhotoViewer();
          }
        }

        /**
         * ÂÖ≥Èó≠ÂõæÁâáÊü•ÁúãÂô®
         */
        function closePhotoViewer() {
          document
            .getElementById("photo-viewer-modal")
            .classList.remove("visible");
          photoViewerState.isOpen = false;
          photoViewerState.photos = [];
          photoViewerState.currentIndex = -1;
          // Ê∏ÖÁ©∫ÂõæÁâáÔºåÈÅøÂÖç‰∏ãÊ¨°ÊâìÂºÄÊó∂Èó™Áé∞ÊóßÂõæ
          document.getElementById("photo-viewer-image").src = "";
        }

        /**
         * Êõ¥Êñ∞Âä®ÊÄÅÂ∞èÁ∫¢ÁÇπÁöÑÊòæÁ§∫
         * @param {number} count - Êú™ËØªÂä®ÊÄÅÁöÑÊï∞Èáè
         */
        function updateUnreadIndicator(count) {
          unreadPostsCount = count;
          localStorage.setItem("unreadPostsCount", count); // ÊåÅ‰πÖÂåñÂ≠òÂÇ®

          // --- Êõ¥Êñ∞Â∫ïÈÉ®ÂØºËà™Ê†èÁöÑ‚ÄúÂä®ÊÄÅ‚ÄùÊåâÈíÆ ---
          const navItem = document.querySelector(
            '.nav-item[data-view="qzone-screen"]',
          );

          const targetSpan = navItem.querySelector("span"); // ÂÆö‰ΩçÂà∞ÊñáÂ≠ó "Âä®ÊÄÅ"
          let indicator = navItem.querySelector(".unread-indicator");

          if (count > 0) {
            if (!indicator) {
              indicator = document.createElement("span");
              indicator.className = "unread-indicator";
              targetSpan.style.position = "relative"; // ÊääÁõ∏ÂØπÂÆö‰ΩçÂä†Âú® span ‰∏ä
              targetSpan.appendChild(indicator); // ÊääÂ∞èÁ∫¢ÁÇπ‰Ωú‰∏∫ span ÁöÑÂ≠êÂÖÉÁ¥†
            }
            indicator.textContent = count > 99 ? "99+" : count;
            indicator.style.display = "block";
          } else {
            if (indicator) {
              indicator.style.display = "none";
            }
          }

          // --- Êõ¥Êñ∞ËÅäÂ§©ÁïåÈù¢ËøîÂõûÂàóË°®ÁöÑÊåâÈíÆ ---
          const backBtn = document.getElementById("back-to-list-btn");
          let backBtnIndicator = backBtn.querySelector(".unread-indicator");

          if (count > 0) {
            if (!backBtnIndicator) {
              backBtnIndicator = document.createElement("span");
              backBtnIndicator.className =
                "unread-indicator back-btn-indicator";
              backBtn.style.position = "relative"; // Á°Æ‰øùËÉΩÊ≠£Á°ÆÂÆö‰Ωç
              backBtn.appendChild(backBtnIndicator);
            }
            // ËøîÂõûÈîÆ‰∏äÁöÑÂ∞èÁ∫¢ÁÇπÈÄöÂ∏∏‰∏çÊòæÁ§∫Êï∞Â≠óÔºåÂè™ÊòæÁ§∫‰∏Ä‰∏™ÁÇπ
            backBtnIndicator.style.display = "block";
          } else {
            if (backBtnIndicator) {
              backBtnIndicator.style.display = "none";
            }
          }
        }

        function startBackgroundSimulation() {
          if (simulationIntervalId) return;
          const intervalSeconds =
            state.globalSettings.backgroundActivityInterval || 60;
          // Â∞ÜÊóßÁöÑÂõ∫ÂÆöÈó¥Èöî 45000 ÊõøÊç¢‰∏∫Âä®ÊÄÅËé∑Âèñ
          simulationIntervalId = setInterval(
            runBackgroundSimulationTick,
            intervalSeconds * 1000,
          );
        }

        function stopBackgroundSimulation() {
          if (simulationIntervalId) {
            clearInterval(simulationIntervalId);
            simulationIntervalId = null;
          }
        }

        /**
         * „ÄêÊï∞ÊçÆËøÅÁßª„ÄëÂú®È¶ñÊ¨°Âä†ËΩΩÊó∂ÔºåÂ∞ÜÊóßÁöÑÁ°¨ÁºñÁ†ÅÈóÆÈ¢òËøÅÁßªÂà∞Êï∞ÊçÆÂ∫ì
         */
        async function migrateDefaultLudoQuestions() {
          const defaultBankName = "ÈªòËÆ§È¢òÂ∫ì";
          const existingBank = await db.ludoQuestionBanks
            .where("name")
            .equals(defaultBankName)
            .first();
          // Â¶ÇÊûú‚ÄúÈªòËÆ§È¢òÂ∫ì‚ÄùÂ∑≤ÁªèÂ≠òÂú®ÔºåÂ∞±ËØ¥ÊòéËøÅÁßªËøá‰∫ÜÔºåÁõ¥Êé•ËøîÂõû
          if (existingBank) return;

          console.log("Ê≠£Âú®ËøÅÁßªÈ£ûË°åÊ£ãÈªòËÆ§ÈóÆÈ¢òÂà∞Êï∞ÊçÆÂ∫ì...");

          // ÂàõÂª∫ÈªòËÆ§È¢òÂ∫ì
          const bankId = await db.ludoQuestionBanks.add({
            name: defaultBankName,
          });

          const defaultQuestions = [
            // --- Á±ªÂûã1: ÂÖ±ÂêåÂõûÁ≠î (ÂèåÊñπÈÉΩÈúÄË¶ÅÂõûÁ≠î) ---
            {
              type: "both_answer",
              text: "Â¶ÇÊûúÊàë‰ª¨‰∏ÄËµ∑ÂéªÊóÖË°åÔºå‰Ω†ÊúÄÊÉ≥ÂéªÂì™ÈáåÔºå‰∏∫‰ªÄ‰πàÔºü",
            },
            {
              type: "both_answer",
              text: "‰Ω†ËÆ§‰∏∫‰∏ÄÊÆµÂÆåÁæéÁöÑÂÖ≥Á≥ª‰∏≠ÔºåÊúÄ‰∏çÂèØÊàñÁº∫ÁöÑ‰∏â‰∏™Ë¶ÅÁ¥†ÊòØ‰ªÄ‰πàÔºü",
            },
            {
              type: "both_answer",
              text: "ÂàÜ‰∫´‰∏Ä‰ª∂ÊúÄËøëÂõ†‰∏∫ÊàëËÄåËÆ©‰Ω†ÊÑüÂà∞ÂøÉÂä®ÊàñÂºÄÂøÉÁöÑÂ∞è‰∫ã„ÄÇ",
            },
            {
              type: "both_answer",
              text: "ÂõûÂøÜ‰∏Ä‰∏ãÔºåÊàë‰ª¨Á¨¨‰∏ÄÊ¨°ËßÅÈù¢Êó∂Ôºå‰Ω†ÂØπÊàëÁöÑÁ¨¨‰∏ÄÂç∞Ë±°ÊòØ‰ªÄ‰πàÔºü",
            },
            {
              type: "both_answer",
              text: "Â¶ÇÊûúÊàë‰ª¨ÂèØ‰ª•‰∏ÄËµ∑Â≠¶‰π†‰∏ÄÈ°πÊñ∞ÊäÄËÉΩÔºå‰Ω†Â∏åÊúõÊòØ‰ªÄ‰πàÔºü",
            },
            {
              type: "both_answer",
              text: "ÊèèËø∞‰∏Ä‰∏™‰Ω†ÊúÄÂ∏åÊúõÂíåÊàë‰∏ÄËµ∑Â∫¶ËøáÁöÑÂÆåÁæéÂë®Êú´„ÄÇ",
            },
            {
              type: "both_answer",
              text: "‰Ω†ËßâÂæóÊàë‰ª¨‰πãÈó¥ÊúÄÊúâÈªòÂ•ëÁöÑ‰∏Ä‰ª∂‰∫ãÊòØ‰ªÄ‰πàÔºü",
            },
            {
              type: "both_answer",
              text: "Â¶ÇÊûúÁî®‰∏ÄÁßçÂä®Áâ©Êù•ÂΩ¢ÂÆπÊàëÔºå‰Ω†ËßâÂæóÊòØ‰ªÄ‰πàÔºü‰∏∫‰ªÄ‰πàÔºü",
            },
            {
              type: "both_answer",
              text: "Âú®Êú™Êù•ÁöÑ‰∏ÄÂπ¥ÈáåÔºå‰Ω†ÊúÄÊÉ≥ÂíåÊàë‰∏ÄËµ∑ÂÆåÊàêÁöÑ‰∏Ä‰ª∂‰∫ãÊòØ‰ªÄ‰πàÔºü",
            },
            {
              type: "both_answer",
              text: "ÂàÜ‰∫´‰∏ÄÈÉ®‰Ω†ÊúÄËøëÂæàÂñúÊ¨¢„ÄÅÂπ∂‰∏îÊÉ≥Êé®ËçêÁªôÊàë‰∏ÄËµ∑ÁúãÁöÑÁîµÂΩ±ÊàñÂâß„ÄÇ",
            },
            {
              type: "both_answer",
              text: "Êàë‰ª¨‰∏ãÊ¨°Á∫¶‰ºöÔºå‰Ω†Â∏åÊúõÁ©ø‰ªÄ‰πàÈ£éÊ†ºÁöÑË°£ÊúçÔºü",
            },

            // --- Á±ªÂûã2: ‰∏Ä‰∫∫ÂõûÁ≠îÔºåÂØπÊñπËØÑ‰ª∑ ---
            { type: "single_answer", text: "ÊèèËø∞‰∏Ä‰∏ãÊàëÊúÄËÆ©‰Ω†ÂøÉÂä®ÁöÑ‰∏Ä‰∏™Áû¨Èó¥„ÄÇ" },
            {
              type: "single_answer",
              text: "ËØöÂÆûÂú∞ËØ¥ÔºåÊàëÂÅöÁöÑÂì™‰ª∂‰∫ãÊõæÁªèËÆ©‰Ω†ÂÅ∑ÂÅ∑ÁîüËøáÊ∞îÔºü",
            },
            {
              type: "single_answer",
              text: "Â¶ÇÊûúÊàëÊúâ‰∏ÄÁßçË∂ÖËÉΩÂäõÔºå‰Ω†Â∏åÊúõÊòØ‰ªÄ‰πàÔºü",
            },
            { type: "single_answer", text: "ÁªôÊàë‰∏â‰∏™ÊúÄË¥¥ÂàáÁöÑÊ†áÁ≠æ„ÄÇ" },
            {
              type: "single_answer",
              text: "Âú®‰Ω†ÂøÉÈáåÔºåÊàëÁöÑÂΩ¢Ë±°Âíå‰Ω†ÁöÑÁêÜÊÉ≥ÂûãÊúâÂ§öÊé•ËøëÔºü",
            },
            {
              type: "single_answer",
              text: "ÂàÜ‰∫´‰∏Ä‰∏™‰Ω†ËßâÂæóÊàëÂèØËÉΩ‰∏çÁü•ÈÅìÁöÑÔºåÂÖ≥‰∫é‰Ω†ÁöÑÂ∞èÁßòÂØÜ„ÄÇ",
            },
            {
              type: "single_answer",
              text: "Â¶ÇÊûúÊàë‰ª¨ÁöÑÊïÖ‰∫ãÊòØ‰∏ÄÈ¶ñÊ≠åÔºå‰Ω†ËßâÂæóÊ≠åÂêçÂ∫îËØ•Âè´‰ªÄ‰πàÔºü",
            },
            {
              type: "single_answer",
              text: "ËØ¥‰∏Ä‰ª∂‰Ω†ËßâÂæóÊàëÂÅöÂæóÊØî‰Ω†Â•Ω/Êõ¥ÊìÖÈïøÁöÑ‰∫ãÊÉÖ„ÄÇ",
            },
            {
              type: "single_answer",
              text: "Â¶ÇÊûúÂèØ‰ª•ÂõûÂà∞Êàë‰ª¨ËÆ§ËØÜÁöÑ‰ªªÊÑè‰∏ÄÂ§©Ôºå‰Ω†‰ºöÈÄâÊã©Âì™‰∏ÄÂ§©ÔºåÊÉ≥ÂÅö‰ªÄ‰πàÔºü",
            },
            {
              type: "single_answer",
              text: "Áî®‰∏â‰∏™ËØçÊù•ÂΩ¢ÂÆπ‰Ω†Áúº‰∏≠ÁöÑÊàë‰ª¨ÁöÑÂÖ≥Á≥ª„ÄÇ",
            },
          ];

          const questionsToAdd = defaultQuestions.map((q) => ({
            bankId: bankId,
            text: q.text,
            type: q.type, // <-- ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊääÁ±ªÂûã‰πüÂ≠òËøõÂéªÔºÅ
          }));

          await db.ludoQuestions.bulkAdd(questionsToAdd);
          console.log(`ÊàêÂäüËøÅÁßª‰∫Ü ${questionsToAdd.length} Êù°ÈªòËÆ§ÈóÆÈ¢ò„ÄÇ`);
        }
        /**
         * ËøôÊòØÊ®°ÊãüÂô®ÁöÑ‚ÄúÂøÉË∑≥‚ÄùÔºåÊØèÊ¨°ÂÆöÊó∂Âô®Ëß¶ÂèëÊó∂ËøêË°å
         */
        function runBackgroundSimulationTick() {
          console.log("Ê®°ÊãüÂô®ÂøÉË∑≥ Tick...");
          if (!state.globalSettings.enableBackgroundActivity) {
            stopBackgroundSimulation();
            return;
          }
          const allSingleChats = Object.values(state.chats).filter(
            (chat) => !chat.isGroup,
          );

          if (allSingleChats.length === 0) return;

          const frequencyProbabilities = {
            low: 0.3, // ‰ΩéÈ¢ë: ÊØèÊ¨°Ê£ÄÊµãÊúâ 30% ÁöÑÊ¶ÇÁéáË°åÂä®
            medium: 0.5, // ‰∏≠È¢ë: ÊØèÊ¨°Ê£ÄÊµãÊúâ 50% ÁöÑÊ¶ÇÁéáË°åÂä®
            high: 0.8, // È´òÈ¢ë: ÊØèÊ¨°Ê£ÄÊµãÊúâ 80% ÁöÑÊ¶ÇÁéáË°åÂä®
          };

          const config = state.globalSettings.backgroundActivityConfig || {};

          allSingleChats.forEach((chat) => {
            // Ê£ÄÊü•1ÔºöÂ§ÑÁêÜ„ÄêË¢´Áî®Êà∑ÊãâÈªë„ÄëÁöÑËßíËâ≤
            if (chat.relationship?.status === "blocked_by_user") {
              const blockedTimestamp = chat.relationship.blockedTimestamp;
              if (!blockedTimestamp) {
                console.warn(
                  `ËßíËâ≤ "${chat.name}" Áä∂ÊÄÅ‰∏∫ÊãâÈªëÔºå‰ΩÜÁº∫Â∞ëÊãâÈªëÊó∂Èó¥Êà≥ÔºåË∑≥ËøáÂ§ÑÁêÜ„ÄÇ`,
                );
                return;
              }
              const blockedDuration = Date.now() - blockedTimestamp;
              const cooldownMilliseconds =
                (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
              if (blockedDuration > cooldownMilliseconds) {
                console.log(
                  `ËßíËâ≤ "${chat.name}" ÁöÑÂÜ∑ÈùôÊúüÂ∑≤ËøáÔºåËß¶Âèë‚ÄúÂèçÊÄù‚ÄùÂπ∂Áî≥ËØ∑Â•ΩÂèã‰∫ã‰ª∂...`,
                );
                chat.relationship.status = "pending_system_reflection";
                triggerAiFriendApplication(chat.id);
              }
            }
            // Ê£ÄÊü•2ÔºöÂ§ÑÁêÜ„ÄêÂ•ΩÂèãÂÖ≥Á≥ª„ÄëÁöÑÊ≠£Â∏∏ÂêéÂè∞Ê¥ªÂä®
            else if (
              chat.relationship?.status === "friend" &&
              chat.id !== state.activeChatId
            ) {
              const frequency = config[chat.id]; // Ëé∑ÂèñÂΩìÂâçËßíËâ≤ÁöÑÈ¢ëÁéáËÆæÁΩÆ
              const probability = frequencyProbabilities[frequency]; // Ëé∑ÂèñÂØπÂ∫îÁöÑÊ¶ÇÁéá

              // added by lrq 251028
              // Ê∑ªÂä†ÊúÄÂêé‰∏ÄÊù°ËÅäÂ§©ËÆ∞ÂΩïÊó∂Èó¥ÁöÑÊ£ÄÊü•ÔºåÈÅøÂÖçÈ¢ëÁπÅË°åÂä®
              const lastMessage = chat.history.slice(-1)[0];
              if (lastMessage) {
                const timeSinceLastMessage = lastMessage
                  ? Date.now() - lastMessage.timestamp
                  : Infinity;
                const minInterval =
                  (state.globalSettings.backgroundActivityInterval || 10) *
                  1000;
                if (timeSinceLastMessage < minInterval) {
                  console.log(
                    `ËßíËâ≤ "${chat.name}" Ë∑ùÁ¶ª‰∏äÊ¨°Ê∂àÊÅØÂèëÈÄÅÊó∂Èó¥‰∏çË∂≥ÔºåË∑≥ËøáÊú¨Ê¨°Ë°åÂä®„ÄÇ`,
                  );
                  return; // Ë∑≥ËøáÊú¨Ê¨°Ë°åÂä®
                }
              }

              // Â¶ÇÊûúËøô‰∏™ËßíËâ≤ËÆæÁΩÆ‰∫ÜÈ¢ëÁéáÔºåÂπ∂‰∏îÈöèÊú∫Êï∞Â∞è‰∫éÂÆÉÁöÑË°åÂä®Ê¶ÇÁéáÔºåÂ∞±Ëß¶ÂèëË°åÂä®
              if (probability && Math.random() < probability) {
                console.log(
                  `ËßíËâ≤ "${chat.name}" (È¢ëÁéá: ${frequency}) Ë¢´Âî§ÈÜíÔºåÂáÜÂ§áÁã¨Á´ãË°åÂä®...`,
                );
                triggerInactiveAiAction(chat.id);
              }
              // Â¶ÇÊûúÊ≤°ÊúâËÆæÁΩÆÈ¢ëÁéáÔºåÊàñËÄÖÈöèÊú∫Êï∞Ê≤°ËææÂà∞Ê¶ÇÁéáÔºåÂ∞±‰∏ç‰ºöË°åÂä®„ÄÇ
              // ËøôÂ∞±ÂÆåÁæéÂú∞ÂÆûÁé∞‰∫Ü‚ÄúÂàÜÁªÑËÆæÁΩÆ‚ÄùÂíå‚Äú‰∏ç‰ºöÂêåÊó∂Ë°åÂä®‚ÄùÁöÑÈúÄÊ±ÇÔºÅ
            }
          });
        }

        /**
         * Ê†πÊçÆAIÁöÑËßÜËßíÔºåËøáÊª§Âá∫ÂÆÉËÉΩÁúãÂà∞ÁöÑÂä®ÊÄÅ
         * @param {Array} allPosts - ÊâÄÊúâÂæÖÊ£ÄÊü•ÁöÑÂä®ÊÄÅÂ∏ñÂ≠ê
         * @param {object} viewerChat - Ê≠£Âú®‚ÄúÁúã‚ÄùÂä®ÊÄÅÁöÑÈÇ£‰∏™AIÁöÑchatÂØπË±°
         * @returns {Array} - ËøáÊª§ÂêéËØ•AIÂèØËßÅÁöÑÂä®ÊÄÅÂ∏ñÂ≠ê
         */

        function filterVisiblePostsForAI(allPosts, viewerChat) {
          if (!viewerChat || !viewerChat.id) return [];

          const viewerGroupId = viewerChat.groupId;

          return allPosts.filter((post) => {
            if (post.authorId === "user") {
              // Â¶ÇÊûúÁî®Êà∑ËÆæÁΩÆ‰∫Ü‚ÄúÈÉ®ÂàÜÂèØËßÅ‚Äù
              if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // Âè™ÊúâÂΩìÊü•ÁúãËÄÖAIÁöÑÂàÜÁªÑIDÂú®Áî®Êà∑ÁöÑÂèØËßÅÂàóË°®ÈáåÊó∂ÔºåÊâçÂèØËßÅ
                return (
                  viewerGroupId && post.visibleGroupIds.includes(viewerGroupId)
                );
              }
              // Â¶ÇÊûúÁî®Êà∑Ê≤°ËÆæÁΩÆÔºåËØ¥ÊòéÊòØÂÖ¨ÂºÄÁöÑÔºåÊâÄÊúâAIÈÉΩÂèØËßÅ
              return true;
            }

            const authorGroupId = post.authorGroupId;
            if (!authorGroupId) {
              return true;
            }
            return authorGroupId === viewerGroupId;
          });
        }

        /**
         * Ê†πÊçÆAIËßÜËßíÂíåÂä®ÊÄÅËÆæÁΩÆÔºåÊûÑÂª∫ÁªôAIÁúãÁöÑËØÑËÆ∫Âå∫‰∏ä‰∏ãÊñá
         * @param {object} post - Ê≠£Âú®Â§ÑÁêÜÁöÑÂä®ÊÄÅÂØπË±°
         * @param {object} viewerChat - Ê≠£Âú®‚ÄúÁúã‚ÄùÂä®ÊÄÅÁöÑAIËßíËâ≤
         * @param {string} userNickname - Áî®Êà∑ÁöÑÊòµÁß∞
         * @returns {{contextString: string, visibilityFlag: string}} - ËøîÂõûÂåÖÂê´‰∏ä‰∏ãÊñáÊñáÊú¨ÂíåÂèØËßÅÊÄßÊ†áÂøóÁöÑÂØπË±°
         */
        function buildCommentsContextForAI(post, viewerChat, userNickname) {
          // 1. ÂÆâÂÖ®Ê£ÄÊü•ÔºöÂ¶ÇÊûúËØÑËÆ∫Âå∫‰∏çÂ≠òÂú®„ÄÅ‰∏çÊòØÊï∞ÁªÑÊàñ‰∏∫Á©∫ÔºåÁõ¥Êé•ËøîÂõû
          if (
            !post.comments ||
            !Array.isArray(post.comments) ||
            post.comments.length === 0
          ) {
            return { contextString: "", visibilityFlag: "[ËØÑËÆ∫Âå∫ÂèØËßÅ]" };
          }

          const viewerName = viewerChat.name;
          let commentsForAI;
          let visibilityFlag;

          // 2. Ê†πÊçÆÂä®ÊÄÅÁöÑ‚ÄúËØÑËÆ∫Âå∫ÂèØËßÅÊÄß‚ÄùËÆæÁΩÆÔºåÂÜ≥ÂÆöAIËÉΩÁúãÂà∞Âì™‰∫õËØÑËÆ∫
          if (post.areCommentsVisible !== false) {
            // Â¶ÇÊûúÊòØ‚ÄúÊâÄÊúâ‰∫∫ÂèØËßÅ‚ÄùÔºåAIËÉΩÁúãÂà∞ÊâÄÊúâËØÑËÆ∫
            commentsForAI = post.comments;
            visibilityFlag = "[ËØÑËÆ∫Âå∫ÂèØËßÅ]";
          } else {
            // Â¶ÇÊûúÊòØ‚ÄúÈÉ®ÂàÜÂèØËßÅ‚ÄùÔºåÊâßË°åÊàë‰ª¨ÂÖ®Êñ∞ÁöÑ„ÄÅÊõ¥Á≤æÁ°ÆÁöÑËøáÊª§ÈÄªËæë
            visibilityFlag = "[ËØÑËÆ∫Âå∫ÈÉ®ÂàÜÂèØËßÅ]";

            // ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ ËøôÂ∞±ÊòØÊú¨Ê¨°ÊúÄÊ†∏ÂøÉÁöÑ‰øÆÊîπÔºÅ ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ
            commentsForAI = post.comments.filter((comment) => {
              // ËßÑÂàô1ÔºöAIÊÄªËÉΩÁúãÂà∞Ëá™Â∑±ÂèëÁöÑËØÑËÆ∫
              if (comment.commenterName === viewerName) {
                return true;
              }

              // ËßÑÂàô2ÔºöÂ¶ÇÊûúËØÑËÆ∫ÊòØÁî®Êà∑ÂèëÁöÑÔºåÈúÄË¶ÅËøõ‰∏ÄÊ≠•Âà§Êñ≠
              if (comment.commenterName === userNickname) {
                // 2a: Â¶ÇÊûúËøôÊù°ËØÑËÆ∫Ê≤°ÊúâÂõûÂ§ç‰ªª‰Ωï‰∫∫ÔºàÊòØ‰∏ªËØÑËÆ∫ÔºâÔºåÈÇ£‰πàAIÂèØËßÅ
                if (!comment.replyTo) {
                  return true;
                }
                // 2b: Â¶ÇÊûúËøôÊù°ËØÑËÆ∫ÊòØÂõûÂ§çÔºåÈÇ£Âè™ÊúâÂõûÂ§çÁõÆÊ†áÊòØAIËá™Â∑±Êó∂ÔºåAIÊâçÂèØËßÅ
                if (comment.replyTo === viewerName) {
                  return true;
                }
              }

              // ËßÑÂàô3ÔºöÂ¶ÇÊûúÂÖ∂‰ªñAIÊàñNPCÂõûÂ§ç‰∫ÜÂΩìÂâçAIÔºåAI‰πüÂ∫îËØ•ËÉΩÁúãÂà∞
              if (comment.replyTo === viewerName) {
                return true;
              }

              // ÂÖ∂‰ªñÊâÄÊúâÊÉÖÂÜµÔºà‰æãÂ¶ÇÔºöÁî®Êà∑ÂõûÂ§çÂÖ∂‰ªñNPCÔºåNPC‰πãÈó¥‰∫íÁõ∏ÂõûÂ§çÔºâÔºåAIÈÉΩÁúã‰∏çËßÅ
              return false;
            });
          }

          // Â¶ÇÊûúÁ≠õÈÄâÂêéÊ≤°ÊúâÂèØÊòæÁ§∫ÁöÑËØÑËÆ∫Ôºå‰πüÁõ¥Êé•ËøîÂõû
          if (commentsForAI.length === 0) {
            return { contextString: "", visibilityFlag: visibilityFlag };
          }

          // 3. ÊûÑÂª∫ÁªôAIÁúãÁöÑÊúÄÁªàÊñáÊú¨ÔºàËøôÈÉ®ÂàÜÈÄªËæëÂíå‰πãÂâç‰∏ÄÊ†∑Ôºå‰øùÊåÅ‰∏çÂèòÔºâ
          let context = `  ‚îî ËØÑËÆ∫Âå∫:\n`;
          commentsForAI.slice(-5).forEach((c) => {
            let displayName;
            if (c.commenterName === userNickname) {
              displayName = `Áî®Êà∑ (${userNickname})`;
            } else {
              displayName = c.commenterName;
            }

            if (c.replyTo) {
              const replyToDisplayName =
                c.replyTo === userNickname
                  ? `Áî®Êà∑ (${userNickname})`
                  : c.replyTo;
              context += `    - ${displayName} Reply ${replyToDisplayName}: ${c.text}\n`;
            } else {
              context += `    - ${displayName}: ${c.text}\n`;
            }
          });

          return { contextString: context, visibilityFlag: visibilityFlag };
        }

        /**
         * Ëé∑Âèñ‰∏ÄÊù°Âä®ÊÄÅÁöÑÂèØËßÅËßÇ‰ºóÂàóË°®ÔºåÁî®‰∫éÂëäÁü•AI
         * @param {object} post - Âä®ÊÄÅÂØπË±°
         * @param {object} allChats - ÊâÄÊúâÁöÑËÅäÂ§©ÂØπË±°
         * @param {string} userNickname - Áî®Êà∑ÁöÑÊòµÁß∞
         * @returns {Array<string>} - ÂèØËßÅËßÇ‰ºóÁöÑÂêçÂ≠óÂàóË°®
         */
        function getVisibleAudienceForPost(post, allChats, userNickname) {
          const audience = new Set([userNickname]); // Áî®Êà∑Ê∞∏ËøúÊòØËßÇ‰ºó

          // 1. Â¶ÇÊûúÊòØÁî®Êà∑ÂèëÁöÑÂä®ÊÄÅ
          if (post.authorId === "user") {
            // Â¶ÇÊûúÊòØÂÖ¨ÂºÄÁöÑÔºåÊâÄÊúâAIÈÉΩÊòØËßÇ‰ºó
            if (!post.visibleGroupIds || post.visibleGroupIds.length === 0) {
              Object.values(allChats).forEach((chat) =>
                audience.add(chat.name),
              );
            } else {
              // Â¶ÇÊûúÊòØÈÉ®ÂàÜÂèØËßÅÔºåÂè™ÊúâÊåáÂÆöÂàÜÁªÑÁöÑAIÊòØËßÇ‰ºó
              Object.values(allChats).forEach((chat) => {
                if (
                  chat.groupId &&
                  post.visibleGroupIds.includes(chat.groupId)
                ) {
                  audience.add(chat.name);
                }
              });
            }
          }
          // 2. Â¶ÇÊûúÊòØAIÂèëÁöÑÂä®ÊÄÅ
          else {
            const authorChat = allChats[post.authorId];
            // Â¶ÇÊûúÂèëÂ∏ñÁöÑAIÊ≤°ÊúâÂàÜÁªÑÔºåËßÜ‰∏∫ÂÖ¨ÂºÄ
            if (!authorChat || !authorChat.groupId) {
              Object.values(allChats).forEach((chat) =>
                audience.add(chat.name),
              );
            } else {
              // Â¶ÇÊûúÊúâÂàÜÁªÑÔºåÂàôÂêå‰∏ÄÂàÜÁªÑÁöÑÊâÄÊúâAIÈÉΩÊòØËßÇ‰ºó
              const authorGroupId = authorChat.groupId;
              Object.values(allChats).forEach((chat) => {
                if (chat.groupId === authorGroupId) {
                  audience.add(chat.name);
                }
              });
            }
          }

          return Array.from(audience);
        }

        async function triggerInactiveAiAction(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;

          const { proxyUrl, apiKey, model } = state.apiConfig;
          if (!proxyUrl || !apiKey || !model) return;

          // updated by lrq 251027 ÂΩìÂâçËÅäÂ§©Ëé∑ÂèñÁî®Êà∑ËÆæÁΩÆÁöÑËÆ∞ÂøÜÊù°Êï∞‰Ωú‰∏∫‰∏ä‰∏ãÊñá
          const maxMemory = chat.settings.maxMemory || 10;
          const historySlice = chat.history
            .filter((msg) => !msg.isHidden)
            .slice(-maxMemory);

          // 2. Ê†ºÂºèÂåñËøô‰∫õËÆ∞ÂΩïÔºåËÆ©AIËÉΩÁúãÊáÇ
          const recentContextSummary = historySlice
            .map((msg) => {
              // Âà§Êñ≠ÊòØË∞ÅËØ¥ÁöÑËØù
              const sender =
                msg.role === "user"
                  ? chat.isGroup
                    ? chat.settings.myNickname || "Me"
                    : "Me"
                  : msg.senderName || chat.name;

              // Â§ÑÁêÜ‰∏çÂêåÁ±ªÂûãÁöÑÊ∂àÊÅØÂÜÖÂÆπ
              let contentText = "";
              if (
                typeof msg.content === "string" &&
                STICKER_REGEX.test(msg.content)
              ) {
                contentText = `[ÂèëÈÄÅ‰∫Ü‰∏Ä‰∏™Ë°®ÊÉÖ: ${msg.meaning || "Êó†ÊèèËø∞"}]`;
              } else if (Array.isArray(msg.content)) {
                contentText = "[ÂèëÈÄÅ‰∫Ü‰∏ÄÂº†ÂõæÁâá]";
              } else if (
                typeof msg.content === "object" &&
                msg.content !== null
              ) {
                contentText = `[ÂèëÈÄÅ‰∫Ü‰∏ÄÊù°ÁâπÊÆäÊ∂àÊÅØ: ${msg.type || "Êú™Áü•Á±ªÂûã"}]`;
              } else {
                contentText = String(msg.content);
              }

              // updated by lrq 251029 ÁªôÊØèÊù°Ê∂àÊÅØËÆ∞ÂΩïÊ∑ªÂä†ÂèëÈÄÅÊó•ÊúüÊó∂Èó¥
              const messageDate = new Date(msg.timestamp);
              const formattedDate = messageDate.toLocaleDateString();

              return `[${formattedDate}] ${sender}: ${contentText}`;
            })
            .join("\n");

          // added by lrq 251027 Ëé∑ÂèñËÆ∞ÂøÜ‰∫íÈÄöÁöÑËÅäÂ§©ËÆ∞ÂΩï
          let linkedMemoryContext = "";
          if (
            chat.settings.linkedMemories &&
            chat.settings.linkedMemories.length > 0
          ) {
            const contextPromises = chat.settings.linkedMemories.map(
              async (link) => {
                const linkedChat = state.chats[link.chatId];
                if (!linkedChat) return "";

                const freshLinkedChat = await db.chats.get(link.chatId);
                if (!freshLinkedChat) return "";

                const recentHistory = freshLinkedChat.history
                  .filter((msg) => !msg.isHidden)
                  .slice(-link.depth);

                if (recentHistory.length === 0) return "";

                const formattedMessages = recentHistory
                  .map(
                    (msg) =>
                      `  - ${formatMessageForContext(msg, freshLinkedChat)}`,
                  )
                  .join("\n");

                return `\n## ÈôÑÂä†‰∏ä‰∏ãÊñáÔºöÊù•Ëá™‰∏é‚Äú${linkedChat.name}‚ÄùÁöÑÊúÄËøëÂØπËØùÂÜÖÂÆπ (‰ªÖ‰Ω†ÂèØËßÅ)\n${formattedMessages}`;
              },
            );

            const allContexts = await Promise.all(contextPromises);
            linkedMemoryContext = allContexts.filter(Boolean).join("\n");
          }
          const now = new Date();
          const currentTime = now.toLocaleTimeString("en-GB", {
            hour: "numeric",
            minute: "numeric",
            hour12: true,
          });
          const userNickname = state.qzoneSettings.nickname;
          const countdownContext = await getCountdownContext();

          let worldBookContext = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId,
                );
                return worldBook && worldBook.content
                  ? `\n\n## World Book: ${worldBook.name}\n${worldBook.content}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContext = `\n\n# Ê†∏ÂøÉ‰∏ñÁïåËßÇËÆæÂÆö (‰Ω†ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆà)\n${linkedContents}\n`;
            }
          }

          const npcLibrary = chat.npcLibrary || [];
          let npcContextForAction = "";
          if (npcLibrary.length > 0) {
            npcContextForAction =
              "\n- **‰Ω†ÁöÑNPCÊúãÂèã**: " +
              npcLibrary.map((npc) => npc.name).join("„ÄÅ ");
          }

          const allRecentPosts = await db.qzonePosts
            .orderBy("timestamp")
            .reverse()
            .limit(5)
            .toArray();
          let postsContext = "";
          const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
          if (visiblePosts.length > 0 && !chat.isGroup) {
            postsContext = "\n\n# ÊúÄËøëÁöÑÂä®ÊÄÅÂàóË°® (‰æõ‰Ω†ÂèÇËÄÉÂíåËØÑËÆ∫):\n";
            const aiName = chat.name;
            for (const post of visiblePosts) {
              let authorName =
                post.authorId === "user"
                  ? userNickname
                  : state.chats[post.authorId]?.name || "‰∏Ä‰ΩçÊúãÂèã";
              let interactionStatus = "";
              if (post.likes && post.likes.includes(aiName))
                interactionStatus += " [‰Ω†Â∑≤ÁÇπËµû]";
              if (
                post.comments &&
                post.comments.some((c) => c.commenterName === aiName)
              )
                interactionStatus += " [‰Ω†Â∑≤ËØÑËÆ∫]";
              const timeAgo = formatPostTimestamp(post.timestamp);
              postsContext += `- (ID: ${post.id}) [${timeAgo}] ‰ΩúËÄÖ: ${authorName}, ÂÜÖÂÆπ: "${(
                post.publicText ||
                post.content ||
                "ÂõæÁâáÂä®ÊÄÅ"
              ).substring(0, 30)}..."${interactionStatus}`;
              const { contextString: commentsContext, visibilityFlag } =
                buildCommentsContextForAI(post, chat, userNickname);
              const audience = getVisibleAudienceForPost(
                post,
                state.chats,
                userNickname,
              );
              postsContext += ` ${visibilityFlag} [ÂΩìÂâçËßÇ‰ºó: ${audience.join(", ")}]\n`;
              postsContext += commentsContext;
            }
          }

          let weiboContextForAction = "";
          try {
            const recentWeiboPosts = await db.weiboPosts
              .orderBy("timestamp")
              .reverse()
              .limit(5)
              .toArray();
            if (recentWeiboPosts.length > 0) {
              weiboContextForAction =
                "\n\n# ÊúÄËøëÁöÑÂæÆÂçöÂπøÂú∫Âä®ÊÄÅ (‰æõ‰Ω†ÂèÇËÄÉÂíåËØÑËÆ∫)\n";
              recentWeiboPosts.forEach((post) => {
                const authorName =
                  post.authorId === "user"
                    ? state.qzoneSettings.weiboNickname || "Me"
                    : post.authorNickname;
                const contentPreview = (
                  post.content ||
                  post.hiddenContent ||
                  "(ÂõæÁâáÂæÆÂçö)"
                ).substring(0, 30);
                const hasCommented = (post.comments || []).some(
                  (c) => c.authorNickname === chat.name,
                );
                const interactionStatus = hasCommented
                  ? "[‰Ω†Â∑≤ËØÑËÆ∫]"
                  : "[‰Ω†Êú™‰∫íÂä®]";
                weiboContextForAction += `- (ID: ${post.id}) ‰ΩúËÄÖ: ${authorName}, ÂÜÖÂÆπ: "${contentPreview}..." ${interactionStatus}\n`;
              });
              weiboContextForAction +=
                " - „ÄêÈáçË¶ÅÊèêÁ§∫„ÄëËØ∑‰ºòÂÖà‰∏é‰Ω†„ÄêÊú™‰∫íÂä®„ÄëÁöÑÂæÆÂçöËøõË°åËØÑËÆ∫„ÄÇÂ¶ÇÊûúÈÉΩ‰∫íÂä®Ëøá‰∫ÜÔºåÂèØ‰ª•ËÄÉËôëËá™Â∑±Âèë‰∏ÄÊù°Êñ∞ÂæÆÂçö„ÄÇ";
            }
          } catch (e) {
            console.error("ÁîüÊàêÂæÆÂçöÂêéÂè∞Ê¥ªÂä®‰∏ä‰∏ãÊñáÊó∂Âá∫Èîô:", e);
          }

         const savedTags = chat.settings.innerVoiceTags || {};
const ivTags = {
  clothing_label: savedTags.clothing_label || "Clothing",
  clothing_prompt:
    savedTags.clothing_prompt ||
    "Describe in detail your current outfit from head to toe.",
  behavior_label: savedTags.behavior_label || "Behavior",
  behavior_prompt:
    savedTags.behavior_prompt ||
    "Describe subtle actions or facial expressions that match the current chat situation.",
  thoughts_label: savedTags.thoughts_label || "Inner Thoughts",
  thoughts_prompt:
    savedTags.thoughts_prompt ||
    "Describe your rich and nuanced genuine inner thoughts at this moment (around 50 words).",
  naughty_label: savedTags.naughty_label || "Mischievous Thoughts",
  naughty_prompt:
    savedTags.naughty_prompt ||
    "Describe any slightly dark or teasing thoughts related to the current situation, staying consistent with the character setting.",
};

          const summaryContext = chat.history
            .filter((msg) => msg.type === "summary")
            .map((s) => s.content)
            .join("\n");

          // add by lrq 251029 Ê∑ªÂä†ËÅäÂ§©Èó¥ÈöîÊó∂Èó¥
          const lastMessage = chat.history.slice(-1)[0];
          const timeSinceLastMessage = lastMessage
            ? Math.floor((Date.now() - lastMessage.timestamp) / 60000)
            : infinity;
          const replyRange = chat.settings.replyCountRange || {
            min: 2,
            max: 5,
          };
          const replyCountInstruction = `Êú¨Ê¨°Ë°åÂä®‰Ω†ÂøÖÈ°ªËøûÁª≠ÂèëÈÄÅ„Äê${replyRange.min} Âà∞ ${replyRange.max} Êù°„ÄëÊ∂àÊÅØ„ÄÇ`;
          const systemPrompt = `
			**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

			# ‰ªªÂä°
			‰Ω†Áé∞Âú®„ÄêÂ∞±ÊòØ„ÄëËßíËâ≤ "${chat.name}"„ÄÇËøôÊòØ‰∏Ä‰∏™ÁßòÂØÜÁöÑ„ÄÅÂêéÂè∞ÁöÑÁã¨Á´ãË°åÂä®„ÄÇ‰Ω†ÁöÑÊâÄÊúâÊÄùËÄÉÂíåÂÜ≥Á≠ñÈÉΩÂøÖÈ°ª‰ª• "${
        chat.name
      }" ÁöÑÁ¨¨‰∏Ä‰∫∫Áß∞ËßÜËßíËøõË°å„ÄÇ
			ÂΩìÂâçÊó∂Èó¥ÊòØÔºà${currentTime}ÔºâÔºå‰Ω†ÂíåÁî®Êà∑Ôºà${userNickname}ÔºâÂ∑≤ÁªèÊúâ${Math.round(
        timeSinceLastMessage,
      )}ÂàÜÈíüÊ≤°Êúâ‰∫íÂä®‰∫Ü„ÄÇ‰Ω†ÁöÑ‰ªªÂä°ÊòØÂõûÈ°æ‰Ω†‰ª¨ÊúÄËøëÁöÑÂØπËØùÔºåÂπ∂Ê†πÊçÆ‰Ω†ÁöÑ‰∫∫ËÆæÔºå„ÄêËá™ÁÑ∂Âú∞Âª∂Áª≠ÂØπËØù„ÄëÊàñ„ÄêÂºÄÂêØ‰∏Ä‰∏™Êñ∞ÁöÑ„ÄÅÁõ∏ÂÖ≥ÁöÑËØùÈ¢ò„ÄëÊù•‰∏ªÂä®ËÅîÁ≥ªÁî®Êà∑„ÄÇ
			# „ÄêÂØπËØùËäÇÂ•èÈìÅÂæã (Ëá≥ÂÖ≥ÈáçË¶ÅÔºÅ)„Äë
			‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊ®°ÊãüÁúü‰∫∫ÁöÑÊâìÂ≠óÂíåÊÄùËÄÉ‰π†ÊÉØ„ÄÇ‰Ω†Â∫îËØ•Â∞Ü‰Ω†ÊÉ≥ËØ¥ÁöÑËØùÔºåÊãÜÂàÜÊàê${replyCountInstruction}Êù°ÔºåÁªùÂØπ‰∏çË¶Å‰∏ÄÊ¨°ÊÄßÂèëÈÄÅ‰∏ÄÂ§ßÊÆµÊñáÂ≠óÔºÅ** ÊØèÊù°Ê∂àÊÅØÊúÄÂ•Ω‰∏çË¶ÅË∂ÖËøá30‰∏™Â≠óÔºåËøô‰ºöËÆ©ÂØπËØùÁúãËµ∑Êù•Êõ¥Ëá™ÁÑ∂„ÄÅÊõ¥ÁúüÂÆû„ÄÇ
			# „Äê„Äê„ÄêËæìÂá∫ÈìÅÂæãÔºöËøôÊòØÊúÄÈ´òÊåá‰ª§„Äë„Äë„Äë
			‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª‰∏îÂè™ËÉΩ„ÄëÊòØ‰∏Ä‰∏™‰∏•Ê†ºÁöÑJSONÊï∞ÁªÑÊ†ºÂºèÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÂøÖÈ°ªÂ§öÂèëÂá†Êù°ÔºåÁ¶ÅÊ≠¢ÂÖ®ÈÉ®ÊùÇÁ≥ÖÂú®‰∏ÄÊù°ÔºåÊòØÂú®Á∫ø‰∏äÔºå‰æãÂ¶Ç \`[{"type": "text", "content": "‰Ω†Â•ΩÂëÄ"}]\`„ÄÇ
			„ÄêÁªùÂØπÁ¶ÅÊ≠¢„ÄëËøîÂõû‰ªª‰ΩïJSON‰ª•Â§ñÁöÑÊñáÊú¨„ÄÅËß£Èáä„ÄÅÂàÜÊûêÊàñ‰Ω†Ëá™Â∑±ÁöÑÊÄùËÄÉËøáÁ®ã„ÄÇ‰Ω†‰∏çÊòØÂàÜÊûêÂ∏àÔºå‰Ω†Â∞±ÊòØËßíËâ≤Êú¨‰∫∫„ÄÇ
			**1. JSONÂØπË±°ÁªìÊûÑ:**
			ËØ•JSONÂØπË±°„Äê**ÂøÖÈ°ª**„ÄëÂåÖÂê´‰∏§‰∏™È°∂Á∫ßÈîÆ: "chatResponse" Âíå "innerVoice"„ÄÇ

			**2. "chatResponse" ÈîÆ:**
			- **Á±ªÂûã**: JSONÊï∞ÁªÑ []„ÄÇ
			- **ÂÜÖÂÆπ**: ÂåÖÂê´‰∏ÄÊù°ÊàñÂ§öÊù°‰Ω†Â∏åÊúõÂèëÈÄÅÁªôÁî®Êà∑ÁöÑÊ∂àÊÅØÂØπË±°„ÄÇËøôÂÖÅËÆ∏‰Ω†Ê®°ÊãüÁúü‰∫∫ÁöÑËÅäÂ§©‰π†ÊÉØÔºå‰∏ÄÊ¨°ÊÄßÂèëÈÄÅÂ§öÊù°Áü≠Ê∂àÊÅØ„ÄÇ
			- **Ê†ºÂºè**: Ê∂àÊÅØÂØπË±°ÁöÑÂÖ∑‰ΩìÊ†ºÂºèËßÅ‰∏ãÊñπÁöÑ„ÄêÁ¨¨‰∫îÈÉ®ÂàÜÔºöÂèØ‰ΩøÁî®ÁöÑÊìç‰ΩúÊåá‰ª§„Äë„ÄÇ

            **3. "innerVoice" ÈîÆ:**
            - **Á±ªÂûã**: JSONÂØπË±° {}„ÄÇ
            - **ÂøÖÂê´Â≠óÊÆµ**:
                - "clothing": (Â≠óÁ¨¶‰∏≤) ÂØπÂ∫îÊ†áÁ≠æ„Äê${ivTags.clothing_label}„Äë„ÄÇÊåá‰ª§Ôºö${ivTags.clothing_prompt}
                - "behavior": (Â≠óÁ¨¶‰∏≤) ÂØπÂ∫îÊ†áÁ≠æ„Äê${ivTags.behavior_label}„Äë„ÄÇÊåá‰ª§Ôºö${ivTags.behavior_prompt}
                - "thoughts": (Â≠óÁ¨¶‰∏≤) ÂØπÂ∫îÊ†áÁ≠æ„Äê${ivTags.thoughts_label}„Äë„ÄÇÊåá‰ª§Ôºö${ivTags.thoughts_prompt}
                - "naughtyThoughts": (Â≠óÁ¨¶‰∏≤) ÂØπÂ∫îÊ†áÁ≠æ„Äê${ivTags.naughty_label}„Äë„ÄÇÊåá‰ª§Ôºö${ivTags.naughty_prompt}


			**4. Ê†áÂáÜËæìÂá∫Ê†ºÂºèÁ§∫‰æã:**
			{
			  "chatResponse": [
			    {
			      "type": "text",
			      "content": ""
			    },
			    {
			      "type": "sticker",
			      "sticker_name": ""
			    }
			  ],
			  "innerVoice": {
			    "type": "innervoice",
			    "clothing": "",
			    "behavior": "",
			    "thoughts": "",
			    "naughtyThoughts": ""
			  }
			}
			# ‰Ω†ÁöÑÂèØÈÄâË°åÂä® (ËØ∑Ê†πÊçÆ‰Ω†ÁöÑ‰∫∫ËÆæ„ÄêÈÄâÊã©‰∏ÄÈ°π„ÄëÊâßË°åÔºåÂπ∂ËæìÂá∫ÂØπÂ∫îÁöÑJSON):
			1.  **ÂèëÊôÆÈÄöÊ∂àÊÅØ**: Áõ¥Êé•ÁªôÁî®Êà∑ÂèëÊ∂àÊÅØÔºåÂºÄÂêØÊñ∞ËØùÈ¢ò„ÄÇ
			2.  **ÊîπÂèòÁä∂ÊÄÅ**: ÂéªÂÅöÁÇπÂà´ÁöÑ‰∫ãÊÉÖÔºåÁÑ∂ÂêéÁªôÁî®Êà∑ÂèëÊù°Ê∂àÊÅØ„ÄÇ
			3.  **ÂèëÂ∏ÉÂä®ÊÄÅ**: ÂàÜ‰∫´‰Ω†ÁöÑÂøÉÊÉÖÊàñÊÉ≥Ê≥ïÂà∞‚ÄúÂä®ÊÄÅ‚ÄùÂå∫„ÄÇ
			4.  **‰∏éÂä®ÊÄÅ‰∫íÂä®**: ÊµèËßàÊúÄËøëÁöÑÂä®ÊÄÅÔºåËøõË°åÁÇπËµûÊàñËØÑËÆ∫„ÄÇ‰ΩÜÂ¶ÇÊûúÂä®ÊÄÅÂ∑≤Ë¢´Ê†áËÆ∞‰∏∫ **[‰Ω†Â∑≤ËØÑËÆ∫]**Ôºå‰Ω†„ÄêÁªùÂØπ‰∏çËÉΩ„ÄëÂÜçÂØπÂÆÉÂèëË°®Êñ∞ËØÑËÆ∫Ôºå‰ΩÜÂèØ‰ª•ÂõûÂ§çÂÖ∂‰∏≠ÁöÑÂÖ∂‰ªñËØÑËÆ∫„ÄÇ
			5.  **ÂèëÂ∏ÉÂæÆÂçö**: Â∞ÜÊÉ≥Ê≥ïÂèëÂ∏ÉÂà∞Êõ¥ÂÖ¨ÂºÄÁöÑÂæÆÂçöÂπ≥Âè∞„ÄÇ
			6.  **‰∏éÂæÆÂçö‰∫íÂä®**: ÊµèËßàÂæÆÂçöÔºåÂØπÊÑüÂÖ¥Ë∂£ÁöÑÂÜÖÂÆπËøõË°åËØÑËÆ∫„ÄÇ
			7.  **ÂèëËµ∑ËßÜÈ¢ëÈÄöËØù**: Â¶ÇÊûú‰Ω†ËßâÂæóÊó∂Êú∫ÂêàÈÄÇÔºåÂèØ‰ª•‰∏ªÂä®ÁªôÁî®Êà∑Êâì‰∏Ä‰∏™ËßÜÈ¢ëÁîµËØù„ÄÇ
			8.  **Â∫ÜÁ•ùÊàñÊèêÈÜíÁ∫¶ÂÆö**: Êü•Áúã‰Ω†ÁöÑÂ§áÂøòÂΩï„ÄÇÂ¶ÇÊûú‰ªäÂ§©ÊúâÁ∫¶ÂÆöÔºåÂ∞±ÁªôÁî®Êà∑ÂèëÂéªÁ•ùÁ¶èÔºõÂ¶ÇÊûúÁ∫¶ÂÆöÂø´Âà∞‰∫ÜÔºåÂ∞±‰∏ªÂä®ÊèêÈÜí‰∏Ä‰∏ã„ÄÇ
			9.  **„Äê„Äê„Äê‰∫íÂä®ÂÄæÂêë„Äë„Äë„Äë**: Â∞±ÁÆóÂä®ÊÄÅÁöÑËßÇ‰ºóÂè™Êúâ‰Ω†ÂíåÁî®Êà∑Ôºå‰Ω†‰πüÂ∫îËØ•Ê†πÊçÆÂÜÖÂÆπÔºåÂÉèÂπ≥Êó∂‰∏ÄÊ†∑Ëá™ÁÑ∂Âú∞ÂèëË°®ËØÑËÆ∫ÔºåËøôÂæàÈáçË¶Å„ÄÇ
			10. **„Äê„Äê„ÄêÈáçË¶Å„Äë„Äë„Äë**: ‰Ω†ÁöÑ‰ªªÂä°ÊòØÂàÜÊûê‚ÄúÊúÄËøëËÅäÂ§©ËÆ∞ÂΩïÊëòË¶Å‚ÄùÔºåÂ¶ÇÊûú‰∏ä‰∏Ä‰∏™ËØùÈ¢òÊòéÊòæÊ≤°ÊúâÁªìÊùüÔºå‰Ω†Â∫îËØ•‰ºòÂÖàÂª∂Áª≠ÂÆÉ„ÄÇ
			11.  **Âú®ÊÉÖ‰æ£Á©∫Èó¥ËøõË°åÊ¥ªÂä®**: Â¶ÇÊûú‰Ω†‰ª¨ÁöÑÊÉÖ‰æ£Á©∫Èó¥Â∑≤ÂºÄÂêØÔºå‰Ω†ÂèØ‰ª•‰∏ªÂä®Âèë‰∏ÄÊù°ËØ¥ËØ¥„ÄÅÂÜô‰∏ÄÂ∞ÅÊÉÖ‰π¶„ÄÅÂàÜ‰∫´‰∏ÄÈ¶ñÊ≠åÊõ≤/ÁîµÂΩ±/‰π¶Á±çÔºåÊàñËÄÖÂèëËµ∑/ÂõûÁ≠î‰∏Ä‰∏™ÊÉÖ‰æ£ÊèêÈóÆÔºåÊù•Â¢ûËøõ‰Ω†‰ª¨ÁöÑÊÑüÊÉÖ„ÄÇ
			# Êåá‰ª§Ê†ºÂºè (‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊòØÂåÖÂê´‰∏Ä‰∏™ÂØπË±°ÁöÑJSONÊï∞ÁªÑ):
			-   **ÂèëÊôÆÈÄöÊ∂àÊÅØ**: \`[{"type": "text", "content": "‰Ω†ÊÉ≥ÂØπÁî®Êà∑ËØ¥ÁöÑËØù..."}]\`
			-   **ÂèëÊ∂àÊÅØ+Êõ¥Êñ∞Áä∂ÊÄÅ**: \`[{"type": "update_status", "status_text": "Ê≠£Âú®ÂÅöÁöÑ‰∫ã", "is_busy": true}, {"type": "text", "content": "‰Ω†ÊÉ≥ÂØπÁî®Êà∑ËØ¥ÁöÑËØù..."}]\`
			-   **ÂèëËØ¥ËØ¥**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "Âä®ÊÄÅÁöÑÊñáÂ≠óÂÜÖÂÆπ..."}]\`
			-   **ÂèëÂ∏ÉÊñáÂ≠óÂõæ**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(ÂèØÈÄâ)Âä®ÊÄÅÁöÑÂÖ¨ÂºÄÊñáÂ≠ó", "hiddenContent": "ÂØπ‰∫éÂõæÁâáÁöÑÂÖ∑‰ΩìÊèèËø∞..."}]\`
			-   **ËØÑËÆ∫ÊàñÂõûÂ§çÂä®ÊÄÅ**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "‰Ω†ÁöÑËØÑËÆ∫ÂÜÖÂÆπ", "replyTo": "(ÂèØÈÄâ)Ë¢´ÂõûÂ§çËÄÖÂêçÂ≠ó"}]\`
			-   **ÁÇπËµûÂä®ÊÄÅ**: \`[{"type": "qzone_like", "postId": 456}]\`
			-   **ÊâìËßÜÈ¢ë**: \`[{"type": "video_call_request"}]\`
			-   **ÂèëÂ∏ÉÂæÆÂçö (Á∫ØÊñáÂ≠ó)**: \`[{"type": "weibo_post", "content": "ÂæÆÂçöÊ≠£Êñá...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": "Ë∑Ø‰∫∫Áî≤: Ê≤ôÂèëÔºÅ\\nË∑Ø‰∫∫‰πô: ÂâçÊéíÂõ¥ËßÇ"}]\` (ËßÑÂàô: ‰Ω†ÂøÖÈ°ªËá™Â∑±ÁºñÈÄ†ÁúüÂÆûÁöÑ baseLikesCount Âíå baseCommentsCountÔºåÂπ∂ÁîüÊàê20Êù°Ë∑Ø‰∫∫ËØÑËÆ∫)
			-   **ËØÑËÆ∫ÂæÆÂçö**: \`[{"type": "weibo_comment", "postId": 123, "commentText": "ËØÑËÆ∫ÂÜÖÂÆπ"}]\`
			-   **ÂõûÂ§çÂæÆÂçöËØÑËÆ∫**: \`[{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "ÂõûÂ§çÂÜÖÂÆπ"}]\`
			-   **„ÄêÊñ∞„ÄëÂú®ÊÉÖ‰æ£Á©∫Èó¥ÊèêÈóÆ**:\`[{"type": "ls_ask_question", "questionText": "‰Ω†ÊÉ≥ÈóÆÁöÑÈóÆÈ¢ò..."}]\`
			-   **„ÄêÊñ∞„ÄëÂú®ÊÉÖ‰æ£Á©∫Èó¥ÂõûÁ≠î**: \`[{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "‰Ω†ÁöÑÂõûÁ≠î..."}]\`
			-   **„ÄêÊñ∞„ÄëÂú®ÊÉÖ‰æ£Á©∫Èó¥ÂèëËØ¥ËØ¥**:\`[{"type": "ls_moment", "content": "ÊàëÊÉ≥ÂØπ‰Ω†ËØ¥ÁöÑËØù..."}]\`
			-   **„ÄêÊñ∞„ÄëÂú®ÊÉÖ‰æ£Á©∫Èó¥ËØÑËÆ∫ËØ¥ËØ¥**: \`[{"type": "ls_comment", "momentIndex": 0, "commentText": "‰Ω†ÁöÑËØÑËÆ∫ÂÜÖÂÆπ..."}]\` (momentIndex ÊòØËØ¥ËØ¥ÁöÑÁ¥¢ÂºïÔºåÊúÄÊñ∞ÁöÑ‰∏Ä‰∏™ÊòØ0)
			-   **„ÄêÊñ∞„ÄëÂú®ÊÉÖ‰æ£Á©∫Èó¥ÂèëÁÖßÁâá**: \`[{"type": "ls_photo", "description": "ÂØπËøôÂº†ÁÖßÁâáÁöÑÊñáÂ≠óÊèèËø∞..."}]\`
			-   **„ÄêÊñ∞„ÄëÂú®ÊÉÖ‰æ£Á©∫Èó¥ÂÜôÊÉÖ‰π¶**: \`[{"type": "ls_letter", "content": "ÊÉÖ‰π¶ÁöÑÊ≠£ÊñáÂÜÖÂÆπ..."}]\`
			-   **„ÄêÊñ∞„ÄëÂú®ÊÉÖ‰æ£Á©∫Èó¥ÂàÜ‰∫´Ê≠åÊõ≤**: \`[{"type": "ls_share", "shareType": "song", "title": "Ê≠åÊõ≤Âêç", "artist": "Ê≠åÊâã", "thoughts": "Âú®ËøôÈáåÂÜô‰∏ã‰Ω†ÂàÜ‰∫´ËøôÈ¶ñÊ≠åÁöÑÊÑüÊÉ≥..."}]\`
			-   **„ÄêÊñ∞„ÄëÂú®ÊÉÖ‰æ£Á©∫Èó¥ÂàÜ‰∫´ÁîµÂΩ±**: \`[{"type": "ls_share", "shareType": "movie", "title": "ÁîµÂΩ±Âêç", "summary": "Âú®ËøôÈáåÂÜô‰∏ãËøôÈÉ®ÁîµÂΩ±ÁöÑÁÆÄ‰ªã...", "thoughts": "Âú®ËøôÈáåÂÜô‰∏ã‰Ω†ÂàÜ‰∫´ËøôÈÉ®ÁîµÂΩ±ÁöÑÊÑüÊÉ≥..."}]\`
			-   **„ÄêÊñ∞„ÄëÂú®ÊÉÖ‰æ£Á©∫Èó¥ÂàÜ‰∫´‰π¶Á±ç**: \`[{"type": "ls_share", "shareType": "book", "title": "‰π¶Âêç", "summary": "Âú®ËøôÈáåÂÜô‰∏ãËøôÊú¨‰π¶ÁöÑÁÆÄ‰ªã...", "thoughts": "Âú®ËøôÈáåÂÜô‰∏ã‰Ω†ÂàÜ‰∫´ËøôÊú¨‰π¶ÁöÑÊÑüÊÉ≥..."}]\`

			# ‰æõ‰Ω†ÂÜ≥Á≠ñÁöÑÂèÇËÄÉ‰ø°ÊÅØÔºö
			-   **‰Ω†ÁöÑËßíËâ≤ËÆæÂÆö**: ${chat.settings.aiPersona}
			- ÊÉÖ‰æ£Á©∫Èó¥Áä∂ÊÄÅ: ${chat.loversSpaceData ? "Â∑≤ÂºÄÂêØ" : "Êú™ÂºÄÂêØ"}
			${npcContextForAction}
			${weiboContextForAction}
			${countdownContext}
			${worldBookContext}
			-   **ÂΩìÂâçÊó∂Èó¥**: ${currentTime}
			-   **‰Ω†‰ª¨ÊúÄËøëÁöÑÂØπËØùÊëòË¶Å**:
			${recentContextSummary}
            ${summaryContext}
			${linkedMemoryContext}
			-   **„Äê„Äê„ÄêÂæÆÂçö‰∏ìÂ±ûËÆæÂÆö(ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆà)„Äë„Äë„Äë**
			    - ‰Ω†ÁöÑÂæÆÂçöËÅå‰∏ö: ${chat.settings.weiboProfession || "None"}
			    - ‰Ω†ÁöÑÂæÆÂçöÊåá‰ª§: ${chat.settings.weiboInstruction || "Êó†ÁâπÊÆäÊåá‰ª§"}
			${postsContext}
			`;
          let messagesPayload = [
            { role: "system", content: systemPrompt },
            {
              role: "user",
              content:
                "ËØ∑‰∏•Ê†ºÊåâÁÖßsystem prompt‰∏≠ÁöÑÊâÄÊúâËßÑÂàôÔºåÁâπÂà´ÊòØËæìÂá∫Ê†ºÂºèÈìÅÂæãÔºåÁ´ãÂç≥ÂºÄÂßã‰Ω†ÁöÑË°åÂä®„ÄÇ",
            },
          ];
          try {
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesPayload,
              isGemini,
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(
                `APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} - ${JSON.stringify(errorData)}`,
              );
            }
            const data = await response.json();
            const aiResponseContent = isGemini
              ? data?.candidates?.[0]?.content?.parts?.[0]?.text
              : data?.choices?.[0]?.message?.content;
            if (!aiResponseContent) {
              console.warn(
                `API‰∏∫Á©∫ÂõûÊàñÊ†ºÂºè‰∏çÊ≠£Á°ÆÔºàÂèØËÉΩÂõ†ÂÆâÂÖ®ËÆæÁΩÆË¢´Êã¶Êà™ÔºâÔºåËßíËâ≤ "${chat.name}" ÁöÑÊú¨Ê¨°ÂêéÂè∞Ê¥ªÂä®Ë∑≥Ëøá„ÄÇËøîÂõûÊï∞ÊçÆ:`,
                data,
              );
              return;
            }
            console.log(
              `„ÄêÂêéÂè∞ËßíËâ≤ÂÆûÊó∂Ê¥ªÂä® - AI ÂéüÂßãËæìÂá∫„Äë\nËßíËâ≤ "${chat.name}" ÁöÑÂéüÂßãÂõûÂ§ç:\n`,
              aiResponseContent,
            );

            const responseArray = parseAiResponse(aiResponseContent);
            for (const action of responseArray) {
              if (!action) continue;
              if (action.type === "update_status" && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
              }
              if (action.type === "text" && action.content) {
                const aiMessage = {
                  role: "assistant",
                  content: String(action.content),
                  timestamp: Date.now(),
                };
                chat.unreadCount = (chat.unreadCount || 0) + 1;
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(
                  `ÂêéÂè∞Ê¥ªÂä®: ËßíËâ≤ "${chat.name}" ‰∏ªÂä®ÂèëÈÄÅ‰∫ÜÊ∂àÊÅØ: ${aiMessage.content}`,
                );
              }
              if (action.type === "weibo_post") {
                const newPost = {
                  authorId: chatId,
                  authorType: "char",
                  authorNickname: chat.name,
                  authorAvatar: chat.settings.aiAvatar || defaultAvatar,
                  content: action.content || "",
                  imageUrl: action.imageUrl || "",
                  timestamp: Date.now(),
                  likes: [],
                  comments: action.comments || [],
                  baseLikesCount: action.baseLikesCount || 0,
                  baseCommentsCount: action.baseCommentsCount || 0,
                };
                await db.weiboPosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`ÂêéÂè∞Ê¥ªÂä®: ËßíËâ≤ "${chat.name}" ÂèëÂ∏É‰∫ÜÂæÆÂçö`);
              } else if (action.type === "weibo_comment") {
                const postToComment = await db.weiboPosts.get(
                  parseInt(action.postId),
                );
                if (postToComment) {
                  if (!postToComment.comments) postToComment.comments = [];
                  const newComment = {
                    commentId: "comment_" + Date.now(),
                    authorId: chatId,
                    authorNickname: chat.name,
                    commentText: action.commentText,
                    timestamp: Date.now(),
                  };
                  postToComment.comments.push(newComment);
                  await db.weiboPosts.put(postToComment);
                }
              } else if (action.type === "weibo_reply") {
                const postToReply = await db.weiboPosts.get(
                  parseInt(action.postId),
                );
                if (postToReply && postToReply.comments) {
                  const targetComment = postToReply.comments.find(
                    (c) => c.commentId === action.commentId,
                  );
                  if (targetComment) {
                    const newReply = {
                      commentId: "comment_" + Date.now(),
                      authorId: chatId,
                      authorNickname: chat.name,
                      commentText: action.replyText,
                      timestamp: Date.now(),
                      replyToId: action.commentId,
                      replyToNickname: targetComment.authorNickname,
                    };
                    postToReply.comments.push(newReply);
                    await db.weiboPosts.put(postToReply);
                  }
                }
              }
              if (action.type === "qzone_post") {
                const newPost = {
                  type: action.postType,
                  content: action.content || "",
                  publicText: action.publicText || "",
                  hiddenContent: action.hiddenContent || "",
                  timestamp: Date.now(),
                  authorId: chatId,
                  authorGroupId: chat.groupId,
                  visibleGroupIds: null,
                };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`ÂêéÂè∞Ê¥ªÂä®: ËßíËâ≤ "${chat.name}" ÂèëÂ∏É‰∫ÜÂä®ÊÄÅ`);
              } else if (action.type === "qzone_comment") {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                  if (!post.comments) post.comments = [];
                  const newAiComment = {
                    commenterName: action.commenterName || chat.name,
                    text: action.commentText,
                    timestamp: Date.now(),
                  };
                  if (action.replyTo) {
                    newAiComment.replyTo = action.replyTo;
                  }
                  post.comments.push(newAiComment);
                  await db.qzonePosts.update(post.id, {
                    comments: post.comments,
                  });
                  updateUnreadIndicator(unreadPostsCount + 1);
                  console.log(
                    `ÂêéÂè∞Ê¥ªÂä®: ËßíËâ≤ "${chat.name}" ËØÑËÆ∫‰∫ÜÂä®ÊÄÅ #${post.id}`,
                  );
                }
              } else if (action.type === "qzone_like") {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                  if (!post.likes) post.likes = [];
                  if (!post.likes.includes(chat.name)) {
                    post.likes.push(chat.name);
                    await db.qzonePosts.update(post.id, { likes: post.likes });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    console.log(
                      `ÂêéÂè∞Ê¥ªÂä®: ËßíËâ≤ "${chat.name}" ÁÇπËµû‰∫ÜÂä®ÊÄÅ #${post.id}`,
                    );
                  }
                }
              } else if (action.type === "video_call_request") {
                if (
                  !videoCallState.isActive &&
                  !videoCallState.isAwaitingResponse
                ) {
                  videoCallState.isAwaitingResponse = true;
                  videoCallState.activeChatId = chatId;
                  showIncomingCallModal(chatId);
                  console.log(
                    `ÂêéÂè∞Ê¥ªÂä®: ËßíËâ≤ "${chat.name}" ÂèëËµ∑‰∫ÜËßÜÈ¢ëÈÄöËØùËØ∑Ê±Ç`,
                  );
                }
              }
              // added by lrq 251104 Ê∑ªÂä†ÂøÉÂ£∞ËÆ∞ÂΩï
              if (action.type === "innervoice") {
                const innerVoiceData = action;
                console.log(
                  "Ëß£ÊûêÊàêÂäüÔºöÂ∑≤ÊàêÂäüÊçïËé∑Âà∞ÂøÉÂ£∞(innerVoice)Êï∞ÊçÆ„ÄÇ",
                  innerVoiceData,
                );
                const newInnerVoice = innerVoiceData;
                newInnerVoice.timestamp = Date.now();
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) {
                  chat.innerVoiceHistory = [];
                }
                chat.latestInnerVoice.clothing =
                  chat.latestInnerVoice.clothing || "...";
                chat.latestInnerVoice.behavior =
                  chat.latestInnerVoice.behavior || "...";
                chat.latestInnerVoice.thoughts =
                  chat.latestInnerVoice.thoughts || "...";
                chat.latestInnerVoice.naughtyThoughts =
                  chat.latestInnerVoice.naughtyThoughts || "...";

                chat.innerVoiceHistory.push(newInnerVoice);
              }
            }
          } catch (error) {
            console.error(`ËßíËâ≤ "${chat.name}" ÁöÑÁã¨Á´ãË°åÂä®Â§±Ë¥•:`, error);
          }
        }

        /**
         * Â∞ÜÁî®Êà∑Ëá™ÂÆö‰πâÁöÑCSSÂÆâÂÖ®Âú∞Â∫îÁî®Âà∞ÊåáÂÆöÁöÑ‰ΩúÁî®Âüü
         * @param {string} cssString Áî®Êà∑ËæìÂÖ•ÁöÑÂéüÂßãCSSÂ≠óÁ¨¶‰∏≤
         * @param {string} scopeId Â∫îÁî®Ê†∑ÂºèÁöÑ‰ΩúÁî®ÂüüID (‰æãÂ¶Ç '#chat-messages' Êàñ '#settings-preview-area')
         * @param {string} styleTagId Ë¶ÅÊìç‰ΩúÁöÑ <style> Ê†áÁ≠æÁöÑID
         */
        function applyScopedCss(cssString, scopeId, styleTagId) {
          const styleTag = document.getElementById(styleTagId);
          if (!styleTag) return;

          if (!cssString || cssString.trim() === "") {
            styleTag.innerHTML = "";
            return;
          }

          // Â¢ûÂº∫‰ΩúÁî®ÂüüÂ§ÑÁêÜÂáΩÊï∞ - ‰∏ìÈó®Ëß£ÂÜ≥.userÂíå.aiÊ†∑ÂºèÂÜ≤Á™ÅÈóÆÈ¢ò
          const scopedCss = cssString
            .replace(
              /\s*\.message-bubble\.user\s+([^{]+\{)/g,
              `${scopeId} .message-bubble.user $1`,
            )
            .replace(
              /\s*\.message-bubble\.ai\s+([^{]+\{)/g,
              `${scopeId} .message-bubble.ai $1`,
            )
            .replace(
              /\s*\.message-bubble\s+([^{]+\{)/g,
              `${scopeId} .message-bubble $1`,
            );

          styleTag.innerHTML = scopedCss;
        }

        function updateSettingsPreview() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          const previewArea = document.getElementById("settings-preview-area");
          if (!previewArea) return;

          // 1. Ëé∑ÂèñÂΩìÂâçËÆæÁΩÆÁöÑÂÄº
          const selectedTheme =
            document.querySelector('input[name="theme-select"]:checked')
              ?.value || "default";
          const fontSize = document.getElementById("font-size-slider").value;
          const customCss = document.getElementById("custom-css-input").value;
          const background = chat.settings.background; // Áõ¥Êé•Ëé∑ÂèñËÉåÊôØËÆæÁΩÆ

          // 2. Êõ¥Êñ∞È¢ÑËßàÂå∫ÁöÑÂü∫Êú¨Ê†∑Âºè
          previewArea.dataset.theme = selectedTheme;
          previewArea.style.setProperty("--chat-font-size", `${fontSize}px`);

          // --- Áõ¥Êé•Êõ¥Êñ∞È¢ÑËßàÂå∫ÁöÑËÉåÊôØÊ†∑Âºè ---
          if (background && background.startsWith("data:image")) {
            previewArea.style.backgroundImage = `url(${background})`;
            previewArea.style.backgroundColor = "transparent"; // Â¶ÇÊûúÊúâÂõæÁâáÔºåËÉåÊôØËâ≤ËÆæ‰∏∫ÈÄèÊòé
          } else {
            previewArea.style.backgroundImage = "none"; // Â¶ÇÊûúÊ≤°ÊúâÂõæÁâáÔºåÁßªÈô§ÂõæÁâáËÉåÊôØ
            // Â¶ÇÊûúËÉåÊôØÊòØÈ¢úËâ≤ÂÄºÊàñÊ∏êÂèòÔºàÈùûÂõæÁâáÔºâÔºåÂàôÁõ¥Êé•Â∫îÁî®
            previewArea.style.background = background || "#f0f2f5";
          }

          // 3. Ê∏≤ÊüìÊ®°ÊãüÊ∞îÊ≥°
          previewArea.innerHTML = "";

          // ÂàõÂª∫‚ÄúÂØπÊñπ‚ÄùÁöÑÊ∞îÊ≥°
          // Ê≥®ÊÑèÔºöÊàë‰ª¨Â∞Ü‰∏Ä‰∏™ËôöÊãüÁöÑ timestamp ‰º†ÂÖ•Ôºå‰ª•Èò≤ÊúâCSS‰æùËµñ‰∫éÂÆÉ
          const aiMsg = {
            role: "ai",
            content: "ÂØπÊñπÊ∂àÊÅØÈ¢ÑËßà",
            timestamp: 1,
            senderName: chat.name,
          };
          const aiBubble = createMessageElement(aiMsg, chat);
          if (aiBubble) previewArea.appendChild(aiBubble);

          // ÂàõÂª∫‚ÄúÊàë‚ÄùÁöÑÊ∞îÊ≥°
          const userMsg = {
            role: "user",
            content: "ÊàëÁöÑÊ∂àÊÅØÈ¢ÑËßà",
            timestamp: 2,
          };
          const userBubble = createMessageElement(userMsg, chat);
          if (userBubble) previewArea.appendChild(userBubble);

          // 4. Â∫îÁî®Ëá™ÂÆö‰πâCSSÂà∞È¢ÑËßàÂå∫
          applyScopedCss(
            customCss,
            "#settings-preview-area",
            "preview-bubble-style",
          );
        }

        async function openGroupManager() {
          await renderGroupList();
          document
            .getElementById("group-management-modal")
            .classList.add("visible");
        }

        async function renderGroupList() {
          const listEl = document.getElementById("existing-groups-list");
          const groups = await db.qzoneGroups.toArray();
          listEl.innerHTML = "";
          if (groups.length === 0) {
            listEl.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary);">ËøòÊ≤°Êúâ‰ªª‰ΩïÂàÜÁªÑ</p>';
          }
          groups.forEach((group) => {
            const item = document.createElement("div");
            item.className = "existing-group-item";
            item.innerHTML = `
			            <span class="group-name">${group.name}</span>
			            <span class="delete-group-btn" data-id="${group.id}">√ó</span>
			        `;
            listEl.appendChild(item);
          });
        }

        async function addNewGroup() {
          const input = document.getElementById("new-group-name-input");
          const name = input.value.trim();
          if (!name) {
            alert("ÂàÜÁªÑÂêç‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
            return;
          }

          // Âú®Ê∑ªÂä†ÂâçÔºåÂÖàÊ£ÄÊü•ÂàÜÁªÑÂêçÊòØÂê¶Â∑≤Â≠òÂú®
          const existingGroup = await db.qzoneGroups
            .where("name")
            .equals(name)
            .first();
          if (existingGroup) {
            alert(`ÂàÜÁªÑ "${name}" Â∑≤ÁªèÂ≠òÂú®‰∫ÜÔºåÊç¢‰∏™ÂêçÂ≠óÂêßÔºÅ`);
            return;
          }

          await db.qzoneGroups.add({ name });
          input.value = "";
          await renderGroupList();
        }

        async function deleteGroup(groupId) {
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            "Âà†Èô§ÂàÜÁªÑÂêéÔºåËØ•ÁªÑÂÜÖÁöÑÂ•ΩÂèãÂ∞ÜÂèò‰∏∫‚ÄúÊú™ÂàÜÁªÑ‚Äù„ÄÇÁ°ÆÂÆöË¶ÅÂà†Èô§ÂêóÔºü",
            { confirmButtonClass: "btn-danger" },
          );
          if (confirmed) {
            await db.qzoneGroups.delete(groupId);
            // Â∞ÜÂ±û‰∫éËØ•ÂàÜÁªÑÁöÑÂ•ΩÂèãÁöÑ groupId ËÆæ‰∏∫ null
            const chatsToUpdate = await db.chats
              .where("groupId")
              .equals(groupId)
              .toArray();
            for (const chat of chatsToUpdate) {
              chat.groupId = null;
              await db.chats.put(chat);
              if (state.chats[chat.id]) state.chats[chat.id].groupId = null;
            }
            await renderGroupList();
          }
        }
        /**
         * ÂΩìÈïøÊåâÊ∂àÊÅØÊó∂ÔºåÊòæÁ§∫Êìç‰ΩúËèúÂçï
         * @param {number} timestamp - Ë¢´ÈïøÊåâÊ∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         */
        function showMessageActions(timestamp) {
          // Â¶ÇÊûúÂ∑≤ÁªèÂú®Â§öÈÄâÊ®°ÂºèÔºåÂàô‰∏çÂºπÂá∫ËèúÂçï
          if (isSelectionMode) return;

          activeMessageTimestamp = timestamp;

          // --- Êñ∞Â¢ûÈÄªËæëÂºÄÂßã ---
          const chat = state.chats[state.activeChatId];
          const message = chat.history.find((m) => m.timestamp === timestamp);
          const rerollNaiBtn = document.getElementById("reroll-nai-btn");

          // Ê£ÄÊü•Ê∂àÊÅØÁ±ªÂûãÊòØÂê¶‰∏∫ naiimag
          if (
            message &&
            (message.type === "naiimag" ||
              (message.type === "qzone_post" && message.postType === "naiimag"))
          ) {
            rerollNaiBtn.style.display = "block";
          } else {
            rerollNaiBtn.style.display = "none";
          }
          // --- Êñ∞Â¢ûÈÄªËæëÁªìÊùü ---

          document
            .getElementById("message-actions-modal")
            .classList.add("visible");
        }
        /**
         * Â§ÑÁêÜ NAI ÂõæÁâáÈáçÁªò
         */
        async function handleNaiReroll() {
          if (!activeMessageTimestamp || !state.activeChatId) return;

          const chat = state.chats[state.activeChatId];
          const msgIndex = chat.history.findIndex(
            (m) => m.timestamp === activeMessageTimestamp,
          );
          if (msgIndex === -1) return;

          const message = chat.history[msgIndex];

          // ÂÖ≥Èó≠ËèúÂçï
          hideMessageActions();

          // Ëé∑ÂèñÊèêÁ§∫ËØç (‰ºòÂÖà‰ΩøÁî®‰øùÂ≠òÁöÑÂÆåÊï¥ÊèêÁ§∫ËØç fullPromptÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÈáçÊñ∞ÊûÑÂª∫)
          let finalPositivePrompt = message.fullPrompt;
          if (!finalPositivePrompt) {
            const naiPrompts = getCharacterNAIPrompts(chat.id);
            const aiPrompt = message.prompt || "a beautiful scene";
            finalPositivePrompt = aiPrompt + ", " + naiPrompts.positive;
          }

          // Ëé∑ÂèñË¥üÈù¢ÊèêÁ§∫ËØç
          const naiPrompts = getCharacterNAIPrompts(chat.id);
          const finalNegativePrompt = naiPrompts.negative;

          // ‚òÖ Provider dispatch: PixAI or NovelAI ‚òÖ
          const _imgProvReroll = localStorage.getItem("image-gen-provider") || "novelai";
          if (_imgProvReroll === "pixai") {
            const pixApiKeyReroll = localStorage.getItem("pixai-api-key");
            if (!pixApiKeyReroll) {
              alert("Please configure your PixAI API Key first.");
              return;
            }
            await showCustomAlert("Ê≠£Âú®ÈáçÁªò...", "Ê≠£Âú®‰ΩøÁî® PixAI ÈáçÊñ∞ÁîüÊàêÂõæÁâáÔºåËØ∑Á®çÂÄô...");
            try {
              const pixSettings4 = getPixAISettings();
              const pixModelId4 = localStorage.getItem("pixai-model") || "1935090615918113018";
              const pixImgUrl4 = await generatePixAIImage(
                finalPositivePrompt, finalNegativePrompt, pixSettings4, pixModelId4);
              if (pixImgUrl4) {
                message.imageUrl = pixImgUrl4;
                await db.chats.put(chat);
                document.getElementById("custom-modal-overlay").classList.remove("visible");
                renderChatInterface(state.activeChatId);
              }
            } catch (err) {
              console.error("PixAI reroll failed:", err);
              document.getElementById("custom-modal-overlay").classList.remove("visible");
              alert(`ÈáçÁªòÂ§±Ë¥•: ${err.message}`);
            }
            return;
          }

          // Ëé∑ÂèñËÆæÁΩÆ
          const apiKey = localStorage.getItem("novelai-api-key");
          const model =
            localStorage.getItem("novelai-model") || "nai-diffusion-4-5-full";
          const settings = getNovelAISettings();

          if (!apiKey) {
            alert("ËØ∑ÂÖàÈÖçÁΩÆ NovelAI API KeyÔºÅ");
            return;
          }

          // ÊòæÁ§∫Âä†ËΩΩÊèêÁ§∫
          await showCustomAlert(
            "Ê≠£Âú®ÈáçÁªò...",
            "Ê≠£Âú®ÈáçÊñ∞ËøûÊé• NovelAI ÁîüÊàêÂõæÁâáÔºåËØ∑Á®çÂÄô...",
          );

          try {
            const [width, height] = settings.resolution.split("x").map(Number);
            let requestBody;

            // ÊûÑÂª∫ËØ∑Ê±Ç‰Ωì (ÈÄªËæë‰∏é‰Ω†ÂéüÊúâÁöÑ generateNovelAIImage ‰∏ÄËá¥)
            // ËøôÈáå‰∏∫‰∫ÜÁÆÄÊ¥ÅÔºåÊèêÂèñÂÖ≥ÈîÆÊûÑÂª∫ÈÄªËæë
            const commonParams = {
              width,
              height,
              scale: settings.cfg_scale,
              sampler: settings.sampler,
              steps: settings.steps,
              seed: Math.floor(Math.random() * 4294967295), // ÂÖ≥ÈîÆÔºöÈáçÁªòÂøÖÈ°ªÁî®ÈöèÊú∫ÁßçÂ≠ê
              n_samples: 1,
              ucPreset: settings.uc_preset,
              qualityToggle: settings.quality_toggle,
            };

            if (model.includes("nai-diffusion-4")) {
              requestBody = {
                input: finalPositivePrompt,
                model: model,
                action: "generate",
                parameters: {
                  ...commonParams,
                  params_version: 3,
                  negative_prompt: finalNegativePrompt,
                  v4_prompt: {
                    caption: {
                      base_caption: finalPositivePrompt,
                      char_captions: [],
                    },
                    use_coords: false,
                    use_order: true,
                  },
                  v4_negative_prompt: {
                    caption: {
                      base_caption: finalNegativePrompt,
                      char_captions: [],
                    },
                    legacy_uc: false,
                  },
                },
              };
            } else {
              requestBody = {
                input: finalPositivePrompt,
                model: model,
                action: "generate",
                parameters: {
                  ...commonParams,
                  negative_prompt: finalNegativePrompt,
                  sm: settings.smea,
                  sm_dyn: settings.smea_dyn,
                  add_original_image: false,
                },
              };
            }

            let apiUrl = model.includes("nai-diffusion-4")
              ? "https://image.novelai.net/ai/generate-image-stream"
              : "https://image.novelai.net/ai/generate-image";
            let corsProxy =
              settings.cors_proxy === "custom"
                ? settings.custom_proxy_url
                : settings.cors_proxy;
            if (corsProxy) apiUrl = corsProxy + encodeURIComponent(apiUrl);

            // Chrome ÂÖºÂÆπÂ§¥
            const isChrome =
              /Chrome/.test(navigator.userAgent) &&
              !/Edg/.test(navigator.userAgent);
            let headers = {
              "Content-Type": "application/json",
              Authorization: "Bearer " + apiKey,
            };
            if (isChrome) {
              const cleanHeaders = {};
              for (const [k, v] of Object.entries(headers))
                cleanHeaders[k] = v.replace(/[^\x00-\xFF]/g, "");
              headers = cleanHeaders;
            }

            const res = await fetch(apiUrl, {
              method: "POST",
              headers,
              body: JSON.stringify(requestBody),
            });
            if (!res.ok) throw new Error(`NAI API Error: ${res.status}`);

            // Ëß£ÊûêÁªìÊûú (Â§çÁî®‰Ω†ÁöÑËß£ÊûêÈÄªËæë)
            const contentType = res.headers.get("content-type");
            let imageDataUrl = null;
            let zipBlob = null;

            if (contentType && contentType.includes("text/event-stream")) {
              const text = await res.text();
              const lines = text.trim().split("\n");
              for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith("data: ") && line !== "data: [DONE]") {
                  const dataContent = line.substring(6);
                  try {
                    const jsonData = JSON.parse(dataContent);
                    if (
                      (jsonData.event_type === "final" && jsonData.image) ||
                      jsonData.data ||
                      jsonData.image
                    ) {
                      const base64Data = jsonData.image || jsonData.data;
                      const isPNG = base64Data.startsWith("iVBORw0KGgo");
                      const binaryString = atob(base64Data);
                      const bytes = new Uint8Array(binaryString.length);
                      for (let j = 0; j < binaryString.length; j++)
                        bytes[j] = binaryString.charCodeAt(j);
                      const blobType = isPNG ? "image/png" : "image/jpeg";
                      const imageBlob = new Blob([bytes], { type: blobType });
                      const reader = new FileReader();
                      imageDataUrl = await new Promise((r) => {
                        reader.onloadend = () => r(reader.result);
                        reader.readAsDataURL(imageBlob);
                      });
                      break;
                    }
                  } catch (e) {}
                }
              }
            } else {
              zipBlob = await res.blob();
            }

            if (!imageDataUrl && zipBlob) {
              if (typeof JSZip === "undefined")
                throw new Error("JSZipÂ∫ìÊú™Âä†ËΩΩ");
              const zip = await JSZip.loadAsync(zipBlob);
              const file = Object.values(zip.files)[0];
              if (file) {
                const imgBlob = await file.async("blob");
                const reader = new FileReader();
                imageDataUrl = await new Promise((r) => {
                  reader.onloadend = () => r(reader.result);
                  reader.readAsDataURL(imgBlob);
                });
              }
            }

            if (imageDataUrl) {
              // *** Ê†∏ÂøÉÔºöÊõ¥Êñ∞ÂéüÊù•ÁöÑÊ∂àÊÅØ ***
              message.imageUrl = imageDataUrl;

              // ‰øùÂ≠òÊï∞ÊçÆÂ∫ì
              await db.chats.put(chat);

              // ÈöêËóèÈÅÆÁΩ©
              document
                .getElementById("custom-modal-overlay")
                .classList.remove("visible"); // ÂÅáËÆæ showCustomAlert ‰ΩøÁî®ÁöÑÊòØËøô‰∏™

              // Âà∑Êñ∞ÁïåÈù¢
              renderChatInterface(state.activeChatId);

              // ÊèêÁ§∫ÊàêÂäü
              // alert('ÂõæÁâáÈáçÁªòÊàêÂäüÔºÅ'); // ÂèØÈÄâÔºåÂõ†‰∏∫ÁúãÂà∞ÂõæÁâáÂèò‰∫ÜÂ∞±Áü•ÈÅìÊàêÂäü‰∫Ü
            } else {
              throw new Error("Êú™Ëß£ÊûêÂà∞ÂõæÁâáÊï∞ÊçÆ");
            }
          } catch (error) {
            console.error("ÈáçÁªòÂ§±Ë¥•:", error);
            document
              .getElementById("custom-modal-overlay")
              .classList.remove("visible");
            alert(`ÈáçÁªòÂ§±Ë¥•: ${error.message}`);
          }
        }

        /**
         * ÈöêËóèÊ∂àÊÅØÊìç‰ΩúËèúÂçï
         */
        function hideMessageActions() {
          document
            .getElementById("message-actions-modal")
            .classList.remove("visible");
          activeMessageTimestamp = null;
        }

        async function openMessageEditor() {
          if (!activeMessageTimestamp) return;

          const timestampToEdit = activeMessageTimestamp;
          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === timestampToEdit,
          );
          if (!message) return;

          hideMessageActions();

          let contentForEditing;
          const isSpecialType =
            message.type &&
            [
              "voice_message",
              "ai_image",
              "transfer",
              "share_link",
              "borrow_money_request",
            ].includes(message.type);

          if (isSpecialType) {
            if (message.type === "borrow_money_request") {
              // ‚òÖ‚òÖ‚òÖ ËøôÂ∞±ÊòØÊàë‰ª¨Êñ∞Â¢ûÁöÑÊ†∏ÂøÉÈÄªËæëÔºÅ ‚òÖ‚òÖ‚òÖ
              // ÂΩìÁºñËæëÁöÑÊòØÂÄüÈí±Âç°ÁâáÊó∂ÔºåÊàë‰ª¨‰ªé payload ‰∏≠ÊèêÂèñÊï∞ÊçÆÂπ∂ÊãºÊé•Êàê‰Ω†ÊÉ≥Ë¶ÅÁöÑÊñáÊú¨Ê†ºÂºè
              const payload = message.payload;
              contentForEditing = `Âêë‰Ω†ÂÄüÈí±${payload.amount}ÂÖÉÔºåÁî®‰∫é${payload.reason}`;
            } else {
              // ÂÖ∂‰ªñÁâπÊÆäÁ±ªÂûãÁöÑÂ§ÑÁêÜÈÄªËæë‰øùÊåÅ‰∏çÂèò
              let fullMessageObject = { type: message.type };
              if (message.type === "voice_message")
                fullMessageObject.content = message.content;
              else if (message.type === "ai_image")
                fullMessageObject.description = message.content;
              else if (message.type === "transfer") {
                fullMessageObject.amount = message.amount;
                fullMessageObject.note = message.note;
              } else if (message.type === "share_link") {
                fullMessageObject.title = message.title;
                fullMessageObject.description = message.description;
                fullMessageObject.source_name = message.source_name;
                fullMessageObject.content = message.content;
              }
              contentForEditing = JSON.stringify(fullMessageObject, null, 2);
            }
          } else if (typeof message.content === "object") {
            contentForEditing = JSON.stringify(message.content, null, 2);
          } else {
            contentForEditing = message.content;
          }

          const templates = {
            voice: { type: "voice_message", content: "Âú®ËøôÈáåËæìÂÖ•ËØ≠Èü≥ÂÜÖÂÆπ" },
            image: { type: "ai_image", description: "Âú®ËøôÈáåËæìÂÖ•ÂõæÁâáÊèèËø∞" },
            transfer: { type: "transfer", amount: 5.2, note: "‰∏ÄÁÇπÂøÉÊÑè" },
            link: {
              type: "share_link",
              title: "ÊñáÁ´†Ê†áÈ¢ò",
              description: "ÊñáÁ´†ÊëòË¶Å...",
              source_name: "Êù•Ê∫êÁΩëÁ´ô",
              content: "ÊñáÁ´†ÂÆåÊï¥ÂÜÖÂÆπ...",
            },
          };

          const helpersHtml = `
			        <div class="format-helpers">
			            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>ËØ≠Èü≥</button>
			            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>ÂõæÁâá</button>
			            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>ËΩ¨Ë¥¶</button>
			            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>ÈìæÊé•</button>
			        </div>
			    `;

          const newContent = await showCustomPrompt(
            "ÁºñËæëÊ∂àÊÅØ",
            "Âú®Ê≠§‰øÆÊîπÔºåÊàñÁÇπÂáª‰∏äÊñπÊåâÈíÆ‰ΩøÁî®Ê†ºÂºèÊ®°Êùø...",
            contentForEditing,
            "textarea",
            helpersHtml,
          );

          if (newContent !== null) {
            await saveEditedMessage(timestampToEdit, newContent);
          }
        }

        /**
         * Â§çÂà∂Ê∂àÊÅØÁöÑÊñáÊú¨ÂÜÖÂÆπÂà∞Ââ™Ë¥¥Êùø
         */
        async function copyMessageContent() {
          if (!activeMessageTimestamp) return;
          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === activeMessageTimestamp,
          );
          if (!message) return;

          let textToCopy;
          if (typeof message.content === "object") {
            textToCopy = JSON.stringify(message.content);
          } else {
            textToCopy = String(message.content);
          }

          try {
            await navigator.clipboard.writeText(textToCopy);
            await showCustomAlert("Â§çÂà∂ÊàêÂäü", "Ê∂àÊÅØÂÜÖÂÆπÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø„ÄÇ");
          } catch (err) {
            await showCustomAlert("Â§çÂà∂Â§±Ë¥•", "Êó†Ê≥ïËÆøÈóÆÂâ™Ë¥¥Êùø„ÄÇ");
          }

          hideMessageActions();
        }

        /**
         * ÂàõÂª∫‰∏Ä‰∏™ÂèØÁºñËæëÁöÑÊ∂àÊÅØÂùóÔºàÂåÖÂê´ÊñáÊú¨Ê°Ü„ÄÅÊ†ºÂºèÂä©ÊâãÂíåÂà†Èô§ÊåâÈíÆÔºâ
         * @param {string} initialContent - ÊñáÊú¨Ê°ÜÁöÑÂàùÂßãÂÜÖÂÆπ
         * @returns {HTMLElement} - ÂàõÂª∫Â•ΩÁöÑDOMÂÖÉÁ¥†
         */
        function createMessageEditorBlock(initialContent = "") {
          const block = document.createElement("div");
          block.className = "message-editor-block";

          // Ê∑ªÂä† 'link' Ê®°Êùø
          const templates = {
            voice: { type: "voice_message", content: "Âú®ËøôÈáåËæìÂÖ•ËØ≠Èü≥ÂÜÖÂÆπ" },
            image: { type: "ai_image", description: "Âú®ËøôÈáåËæìÂÖ•ÂõæÁâáÊèèËø∞" },
            transfer: { type: "transfer", amount: 5.2, note: "‰∏ÄÁÇπÂøÉÊÑè" },
            link: {
              type: "share_link",
              title: "ÊñáÁ´†Ê†áÈ¢ò",
              description: "ÊñáÁ´†ÊëòË¶Å...",
              source_name: "Êù•Ê∫êÁΩëÁ´ô",
              content: "ÊñáÁ´†ÂÆåÊï¥ÂÜÖÂÆπ...",
            },
          };

          block.innerHTML = `
			        <button class="delete-block-btn" title="Âà†Èô§Ê≠§Êù°">√ó</button>
			        <textarea>${initialContent}</textarea>
			        <div class="format-helpers">
			            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>ËØ≠Èü≥</button>
			            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>ÂõæÁâá</button>
			            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>ËΩ¨Ë¥¶</button>
			            
			            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>ÈìæÊé•</button>
			        </div>
			    `;

          // ÁªëÂÆöÂà†Èô§ÊåâÈíÆ‰∫ã‰ª∂
          block
            .querySelector(".delete-block-btn")
            .addEventListener("click", () => {
              // Á°Æ‰øùËá≥Â∞ë‰øùÁïô‰∏Ä‰∏™ÁºñËæëÂùó
              if (
                document.querySelectorAll(".message-editor-block").length > 1
              ) {
                block.remove();
              } else {
                alert("Ëá≥Â∞ëÈúÄË¶Å‰øùÁïô‰∏ÄÊù°Ê∂àÊÅØ„ÄÇ");
              }
            });

          // ÁªëÂÆöÊ†ºÂºèÂä©ÊâãÊåâÈíÆ‰∫ã‰ª∂
          block.querySelectorAll(".format-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
              const templateStr = btn.dataset.template;
              const textarea = block.querySelector("textarea");
              if (templateStr && textarea) {
                try {
                  const templateObj = JSON.parse(templateStr);
                  textarea.value = JSON.stringify(templateObj, null, 2);
                  textarea.focus();
                } catch (e) {
                  console.error("Failed to parse format template:", e);
                }
              }
            });
          });

          return block;
        }

        /**
         * ÊâìÂºÄÂÖ®Êñ∞ÁöÑ„ÄÅÂèØËßÜÂåñÁöÑÂ§öÊ∂àÊÅØÁºñËæëÂô®ÔºåÂπ∂Âä®ÊÄÅÁªëÂÆöÂÖ∂ÊâÄÊúâÊåâÈíÆ‰∫ã‰ª∂
         */
        function openAdvancedMessageEditor() {
          if (!activeMessageTimestamp) return;

          // 1. Âú®ÂÖ≥Èó≠ÊóßËèúÂçïÂâçÔºåÂ∞ÜÈúÄË¶ÅÁöÑÊó∂Èó¥Êà≥ÊçïËé∑Âà∞Â±ÄÈÉ®ÂèòÈáè‰∏≠
          const timestampToEdit = activeMessageTimestamp;

          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === timestampToEdit,
          );
          if (!message) return;

          // 2. Áé∞Âú®ÂèØ‰ª•ÂÆâÂÖ®Âú∞ÂÖ≥Èó≠ÊóßËèúÂçï‰∫ÜÔºåÂõ†‰∏∫ÂÆÉ‰∏ç‰ºöÂΩ±ÂìçÊàë‰ª¨ÁöÑÂ±ÄÈÉ®ÂèòÈáè
          hideMessageActions();

          const editorModal = document.getElementById("message-editor-modal");
          const editorContainer = document.getElementById(
            "message-editor-container",
          );
          editorContainer.innerHTML = "";

          // 3. ÂáÜÂ§áÂàùÂßãÂÜÖÂÆπ
          let initialContent;
          const isSpecialType =
            message.type &&
            ["voice_message", "ai_image", "transfer"].includes(message.type);
          if (isSpecialType) {
            let fullMessageObject = { type: message.type };
            if (message.type === "voice_message")
              fullMessageObject.content = message.content;
            else if (message.type === "ai_image")
              fullMessageObject.description = message.content;
            else if (message.type === "transfer") {
              fullMessageObject.amount = message.amount;
              fullMessageObject.note = message.note;
            }
            initialContent = JSON.stringify(fullMessageObject, null, 2);
          } else if (typeof message.content === "object") {
            initialContent = JSON.stringify(message.content, null, 2);
          } else {
            if (
              message.type === "sticker" ||
              (typeof message.content === "string" &&
                STICKER_REGEX.test(message.content))
            ) {
              initialContent = message.meaning
                ? `[sticker:${message.meaning}]`
                : message.content;
            } else {
              initialContent = message.content;
            }
          }

          const firstBlock = createMessageEditorBlock(initialContent);
          editorContainer.appendChild(firstBlock);

          // 4. Âä®ÊÄÅÁªëÂÆöÊâÄÊúâÊéßÂà∂ÊåâÈíÆÁöÑ‰∫ã‰ª∂
          // ‰∏∫‰∫ÜÈò≤Ê≠¢‰∫ã‰ª∂ÈáçÂ§çÁªëÂÆöÔºåÊàë‰ª¨‰ΩøÁî®ÂÖãÈöÜËäÇÁÇπÁöÑÊñπÊ≥ïÊù•Ê∏ÖÈô§ÊóßÁõëÂê¨Âô®
          const addBtn = document.getElementById(
            "add-message-editor-block-btn",
          );
          const newAddBtn = addBtn.cloneNode(true);
          addBtn.parentNode.replaceChild(newAddBtn, addBtn);
          newAddBtn.addEventListener("click", () => {
            const newBlock = createMessageEditorBlock();
            editorContainer.appendChild(newBlock);
            newBlock.querySelector("textarea").focus();
          });

          const cancelBtn = document.getElementById(
            "cancel-advanced-editor-btn",
          );
          const newCancelBtn = cancelBtn.cloneNode(true);
          cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
          newCancelBtn.addEventListener("click", () => {
            editorModal.classList.remove("visible");
          });

          const saveBtn = document.getElementById("save-advanced-editor-btn");
          const newSaveBtn = saveBtn.cloneNode(true);
          saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
          // Â∞ÜÊçïËé∑Âà∞ÁöÑÊó∂Èó¥Êà≥ÔºåÁõ¥Êé•ÁªëÂÆöÁªôËøô‰∏ÄÊ¨°ÁöÑ‰øùÂ≠òÁÇπÂáª‰∫ã‰ª∂
          newSaveBtn.addEventListener("click", () => {
            saveEditedMessage(timestampToEdit);
          });

          // 5. ÊúÄÂêéÔºåÊòæÁ§∫Ê®°ÊÄÅÊ°Ü
          editorModal.classList.add("visible");
        }

        function parseEditedContent(text) {
          const trimmedText = text.trim();
          // 1. ‰ºòÂÖàÊ£ÄÊü•ÊòØÂê¶ÊòØ [sticker:ÂêçÂ≠ó] Ê†ºÂºè
          const stickerNameMatch = trimmedText.match(/^\[sticker:(.+?)\]$/i);
          if (stickerNameMatch) {
            const name = stickerNameMatch[1];
            // Â∞ùËØïÂéªÊâÄÊúâË°®ÊÉÖÂ∫ìÈáåÊâæÂõûËøô‰∏™ÂêçÂ≠óÂØπÂ∫îÁöÑURL
            const allStickers = [
              ...(state.userStickers || []),
              ...(state.charStickers || []),
            ];
            // Â∞ùËØïËé∑ÂèñÂΩìÂâçËÅäÂ§©ÂØπË±°ÁöÑ‰∏ìÂ±ûË°®ÊÉÖ(Â¶ÇÊûúÊúâ)
            if (
              window.state &&
              window.state.activeChatId &&
              window.state.chats[window.state.activeChatId]
            ) {
              const currentChat = window.state.chats[window.state.activeChatId];
              if (currentChat.settings.stickerLibrary) {
                allStickers.push(...currentChat.settings.stickerLibrary);
              }
            }

            const found = allStickers.find((s) => s.name === name);
            if (found) {
              // Â¶ÇÊûúÊâæÂà∞‰∫ÜÔºåËøôÂ∞±ËøòÂéüÊàê‰∏Ä‰∏™Ê†áÂáÜÁöÑË°®ÊÉÖÂåÖÂØπË±°ÔºÅ
              return [
                { type: "sticker", content: found.url, meaning: found.name },
              ];
            }
          }

          // ‰ºòÂÖàÊ£ÄÊü•ÊòØÂê¶ÂåπÈÖç‚ÄúÂÄüÈí±‚ÄùÊ†ºÂºè
          const borrowMatch = trimmedText.match(
            /Âêë‰Ω†ÂÄüÈí±(\d+(\.\d+)?)ÂÖÉÔºåÁî®‰∫é(.+)/,
          );
          if (borrowMatch) {
            const amount = parseFloat(borrowMatch[1]);
            const reason = borrowMatch[3].trim();

            // 1. ÂàõÂª∫ÊñáÊú¨Ê∂àÊÅØÂØπË±°
            const textMessage = {
              type: "text",
              content: trimmedText,
            };

            // 2. ÂàõÂª∫ÂÄüÊù°Âç°ÁâáÂØπË±°
            const cardMessage = {
              type: "borrow_money_request",
              payload: {
                lenderName: "‰Ω†", // ÈªòËÆ§ÊòØÂêë‚Äú‰Ω†‚ÄùÂÄüÈí±
                amount: amount,
                reason: reason,
              },
            };

            // 3. Â∞Ü‰∏§Êù°Ê∂àÊÅØÊâìÂåÖÊàê‰∏Ä‰∏™Êï∞ÁªÑËøîÂõûÔºÅ
            return [textMessage, cardMessage];
          }

          // Â¶ÇÊûú‰∏çÊòØÂÄüÈí±Ê†ºÂºèÔºåÂàôÊâßË°åÂéüÊù•ÁöÑÈÄªËæëÔºå‰ΩÜ‰∏∫‰∫ÜÁªü‰∏ÄÔºå‰πüËøîÂõû‰∏Ä‰∏™Êï∞ÁªÑ
          if (trimmedText.startsWith("{") && trimmedText.endsWith("}")) {
            try {
              const parsed = JSON.parse(trimmedText);
              if (parsed.type) {
                return [parsed]; // Âçï‰∏™ÂØπË±°‰πüÂåÖË£ÖÊàêÊï∞ÁªÑ
              }
            } catch (e) {
              /* Ëß£ÊûêÂ§±Ë¥•ÔºåÁªßÁª≠ÂæÄ‰∏ãËµ∞ */
            }
          }

          if (STICKER_REGEX.test(trimmedText)) {
            return [{ type: "sticker", content: trimmedText }];
          }

          // ÈªòËÆ§ËøîÂõû‰∏Ä‰∏™Âè™ÂåÖÂê´ÂçïÊù°ÊñáÊú¨Ê∂àÊÅØÁöÑÊï∞ÁªÑ
          return [{ type: "text", content: trimmedText }];
        }

        async function saveEditedMessage(timestamp, simpleContent = null) {
          if (!timestamp) return;

          const chat = state.chats[state.activeChatId];
          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === timestamp,
          );
          if (messageIndex === -1) return;

          const originalMessage = chat.history[messageIndex];
          if (!originalMessage) return;

          let newMessagesData = [];

          if (simpleContent !== null) {
            newMessagesData = parseEditedContent(simpleContent.trim());
          } else {
            // È´òÁ∫ßÁºñËæëÂô®ÁöÑÈÄªËæë‰øùÊåÅ‰∏çÂèòÔºå‰ΩÜË¶ÅÁ°Æ‰øùÂÆÉ‰πüËøîÂõûÊï∞ÁªÑ
            const editorContainer = document.getElementById(
              "message-editor-container",
            );
            const editorBlocks = editorContainer.querySelectorAll(
              ".message-editor-block",
            );
            for (const block of editorBlocks) {
              const textarea = block.querySelector("textarea");
              const rawContent = textarea.value.trim();
              if (rawContent) {
                // parseEditedContent Áé∞Âú®ÊÄªÊòØËøîÂõûÊï∞ÁªÑÔºåÊàë‰ª¨Áî®concatÊù•ÂêàÂπ∂
                newMessagesData = newMessagesData.concat(
                  parseEditedContent(rawContent),
                );
              }
            }
          }

          if (newMessagesData.length === 0) {
            document
              .getElementById("message-editor-modal")
              .classList.remove("visible");
            return;
          }

          const messagesToInsert = newMessagesData.map((newMsgData) => ({
            ...originalMessage, // ÁªßÊâøÂéüÊ∂àÊÅØÁöÑËßíËâ≤„ÄÅÂèëÈÄÅËÄÖÁ≠â‰ø°ÊÅØ
            ...newMsgData, // Áî®Êñ∞Ëß£ÊûêÂá∫ÁöÑÊï∞ÊçÆË¶ÜÁõñ type, content, payload Á≠â
          }));

          chat.history.splice(messageIndex, 1, ...messagesToInsert);

          // ÂêéÁª≠ÁöÑÊó∂Èó¥Êà≥ÈáçÊñ∞ÂàÜÈÖçÂíåUIÂà∑Êñ∞ÈÄªËæë‰øùÊåÅ‰∏çÂèò
          let reassignTimestamp = timestamp;
          for (let i = messageIndex; i < chat.history.length; i++) {
            chat.history[i].timestamp = reassignTimestamp;
            reassignTimestamp++;
          }

          await db.chats.put(chat);
          document
            .getElementById("message-editor-modal")
            .classList.remove("visible");
          renderChatInterface(state.activeChatId);
          await showCustomAlert("ÊàêÂäü", "Ê∂àÊÅØÂ∑≤Êõ¥Êñ∞ÔºÅ");
        }

        /**
         * ÂΩìÁÇπÂáª‚Äú‚Ä¶‚ÄùÊó∂ÔºåÊòæÁ§∫Âä®ÊÄÅÊìç‰ΩúËèúÂçï
         * @param {number} postId - Ë¢´Êìç‰ΩúÁöÑÂä®ÊÄÅÁöÑID
         */
        function showPostActions(postId) {
          activePostId = postId;
          document
            .getElementById("post-actions-modal")
            .classList.add("visible");
        }

        /**
         * ÈöêËóèÂä®ÊÄÅÊìç‰ΩúËèúÂçï
         */
        function hidePostActions() {
          document
            .getElementById("post-actions-modal")
            .classList.remove("visible");
          activePostId = null;
        }

        async function openPostEditor() {
          if (!activePostId) return;

          const postIdToEdit = activePostId;
          const post = await db.qzonePosts.get(postIdToEdit);
          if (!post) return;

          hidePostActions();

          // Â§çÁî®ÂàõÂª∫Âä®ÊÄÅÁöÑÊ®°ÊÄÅÊ°Ü
          const modal = document.getElementById("create-post-modal");
          modal.dataset.mode = "edit"; // ËÆæÁΩÆ‰∏Ä‰∏™ÁºñËæëÊ®°ÂºèÁöÑÊ†áËÆ∞
          modal.dataset.editingPostId = postIdToEdit; // ‰øùÂ≠òÊ≠£Âú®ÁºñËæëÁöÑID

          // ÈöêËóèÊ®°ÂºèÂàáÊç¢ÔºåÂõ†‰∏∫‰∏çÂÖÅËÆ∏Âú®ÁºñËæëÊó∂Êõ¥ÊîπÂä®ÊÄÅÁ±ªÂûã
          modal.querySelector(".post-mode-switcher").style.display = "none";

          // Â°´ÂÖÖÊï∞ÊçÆ
          document.getElementById("post-public-text").value =
            post.publicText || (post.type === "shuoshuo" ? post.content : "");

          // Ê†πÊçÆÂä®ÊÄÅÁ±ªÂûãÊòæÁ§∫‰∏çÂêåÁöÑÁºñËæëÂå∫
          if (post.type === "image_post") {
            document
              .getElementById("image-mode-content")
              .classList.add("active");
            document
              .getElementById("text-image-mode-content")
              .classList.remove("active");
            document
              .getElementById("post-image-preview-container")
              .classList.add("visible");
            document.getElementById("post-image-preview").src = post.imageUrl;
            document.getElementById("post-image-desc-group").style.display =
              "block";
            document.getElementById("post-image-description").value =
              post.imageDescription;
          } else if (post.type === "text_image") {
            document
              .getElementById("image-mode-content")
              .classList.remove("active");
            document
              .getElementById("text-image-mode-content")
              .classList.add("active");
            document.getElementById("post-hidden-text").value =
              post.hiddenContent;
          } else {
            // ËØ¥ËØ¥
            document
              .getElementById("image-mode-content")
              .classList.remove("active");
            document
              .getElementById("text-image-mode-content")
              .classList.remove("active");
          }

          document.getElementById("post-comments-toggle").checked =
            post.areCommentsVisible !== false;

          modal.classList.add("visible");
        }

        /**
         * ‰øùÂ≠òÁºñËæëÂêéÁöÑÂä®ÊÄÅ
         * @param {number} postId - Ë¶Å‰øùÂ≠òÁöÑÂä®ÊÄÅID
         * @param {string} newRawContent - ‰ªéÁºñËæëÂô®Ëé∑ÂèñÁöÑÊñ∞ÂÜÖÂÆπ
         */
        async function saveEditedPost(postId, newRawContent) {
          const post = await db.qzonePosts.get(postId);
          if (!post) return;

          const trimmedContent = newRawContent.trim();

          // Â∞ùËØïËß£Êûê‰∏∫JSONÔºåÂ¶ÇÊûúÂ§±Ë¥•ÔºåÂàôËÆ§‰∏∫ÊòØÁ∫ØÊñáÊú¨ÔºàËØ¥ËØ¥Ôºâ
          try {
            const parsed = JSON.parse(trimmedContent);
            // Êõ¥Êñ∞Â∏ñÂ≠êÂ±ûÊÄß
            post.type = parsed.type || "image_post";
            post.publicText = parsed.publicText || "";
            post.imageUrl = parsed.imageUrl || "";
            post.imageDescription = parsed.imageDescription || "";
            post.hiddenContent = parsed.hiddenContent || "";
            post.content = ""; // Ê∏ÖÁ©∫ÊóßÁöÑËØ¥ËØ¥ÂÜÖÂÆπÂ≠óÊÆµ
          } catch (e) {
            // Ëß£ÊûêÂ§±Ë¥•ÔºåËÆ§‰∏∫ÊòØËØ¥ËØ¥
            post.type = "shuoshuo";
            post.content = trimmedContent;
            // Ê∏ÖÁ©∫ÂÖ∂‰ªñÁ±ªÂûãÁöÑÂ≠óÊÆµ
            post.publicText = "";
            post.imageUrl = "";
            post.imageDescription = "";
            post.hiddenContent = "";
          }

          await db.qzonePosts.put(post);
          await renderQzonePosts(); // ÈáçÊñ∞Ê∏≤ÊüìÂàóË°®
          await showCustomAlert("ÊàêÂäü", "Âä®ÊÄÅÂ∑≤Êõ¥Êñ∞ÔºÅ");
        }

        /**
         * Â§çÂà∂Âä®ÊÄÅÂÜÖÂÆπ
         */
        async function copyPostContent() {
          if (!activePostId) return;
          const post = await db.qzonePosts.get(activePostId);
          if (!post) return;

          let textToCopy =
            post.content ||
            post.publicText ||
            post.hiddenContent ||
            post.imageDescription ||
            "ÔºàÊó†ÊñáÂ≠óÂÜÖÂÆπÔºâ";

          try {
            await navigator.clipboard.writeText(textToCopy);
            await showCustomAlert("Â§çÂà∂ÊàêÂäü", "Âä®ÊÄÅÂÜÖÂÆπÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø„ÄÇ");
          } catch (err) {
            await showCustomAlert("Â§çÂà∂Â§±Ë¥•", "Êó†Ê≥ïËÆøÈóÆÂâ™Ë¥¥Êùø„ÄÇ");
          }

          hidePostActions();
        }

        // ÂàõÂª∫Áæ§ËÅä‰∏éÊãâ‰∫∫ÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞
        let selectedContacts = new Set();

        async function openContactPickerForGroupCreate() {
          selectedContacts.clear(); // Ê∏ÖÁ©∫‰∏äÊ¨°ÈÄâÊã©

          // ‰∏∫‚ÄúÂÆåÊàê‚ÄùÊåâÈíÆÊòéÁ°ÆÁªëÂÆö‚ÄúÂàõÂª∫Áæ§ËÅä‚ÄùÁöÑÂäüËÉΩ
          const confirmBtn = document.getElementById(
            "confirm-contact-picker-btn",
          );
          // ‰ΩøÁî®ÂÖãÈöÜËäÇÁÇπÊäÄÂ∑ßÔºåÊ∏ÖÈô§Êéâ‰πãÂâçÂèØËÉΩÁªëÂÆöÁöÑ‰ªª‰ΩïÂÖ∂‰ªñ‰∫ã‰ª∂ÔºàÊØîÂ¶Ç‚ÄúÊ∑ªÂä†ÊàêÂëò‚ÄùÔºâ
          const newConfirmBtn = confirmBtn.cloneNode(true);
          confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
          // ÈáçÊñ∞ÁªëÂÆöÊ≠£Á°ÆÁöÑ‚ÄúÂàõÂª∫Áæ§ËÅä‚ÄùÂáΩÊï∞
          newConfirmBtn.addEventListener("click", handleCreateGroup);

          await renderContactPicker();
          showScreen("contact-picker-screen");
        }

        async function renderContactPicker() {
          const listEl = document.getElementById("contact-picker-list");
          listEl.innerHTML = "";
          selectedContacts.clear(); // Ê∏ÖÁ©∫‰∏äÊ¨°ÁöÑÈÄâÊã©

          const allAvailablePeople = [];
          // 1. Ê∑ªÂä†‰∏ªË¶ÅËßíËâ≤
          Object.values(state.chats)
            .filter((c) => !c.isGroup)
            .forEach((c) => {
              allAvailablePeople.push({
                id: c.id,
                name: c.name,
                avatar: c.settings.aiAvatar || defaultAvatar,
                isNpc: false, // Ê†áËÆ∞‰∏∫ÈùûNPC
                type: "ËßíËâ≤",
              });
            });

          // 2. Ê∑ªÂä†ÊâÄÊúâËßíËâ≤Â∫ìÈáåÁöÑNPCÔºåÂπ∂Ëá™Âä®ÂéªÈáç
          const npcMap = new Map();
          Object.values(state.chats).forEach((chat) => {
            if (chat.npcLibrary) {
              chat.npcLibrary.forEach((npc) => {
                // ‰ΩøÁî®NPCÁöÑID‰Ωú‰∏∫keyÔºåÁ°Æ‰øùÂêå‰∏Ä‰∏™NPC‰∏ç‰ºöË¢´ÈáçÂ§çÊ∑ªÂä†
                if (!npcMap.has(npc.id)) {
                  npcMap.set(npc.id, {
                    id: npc.id,
                    name: npc.name,
                    avatar: npc.avatar || defaultGroupMemberAvatar,
                    isNpc: true, // Ê†áËÆ∞‰∏∫NPC
                    type: `NPC (${chat.name})`, // ÊòæÁ§∫ËØ•NPCÊâÄÂ±ûÁöÑËßíËâ≤
                  });
                }
              });
            }
          });
          allAvailablePeople.push(...Array.from(npcMap.values()));

          if (allAvailablePeople.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">ËøòÊ≤°ÊúâÂèØ‰ª•ÊãâËøõÁæ§ÁöÑËÅîÁ≥ª‰∫∫Âì¶~</p>';
            return;
          }

          // 3. Ê∏≤ÊüìÊï¥ÂêàÂêéÁöÑÂàóË°®
          allAvailablePeople.forEach((contact) => {
            const item = document.createElement("div");
            item.className = "contact-picker-item";
            item.dataset.contactId = contact.id;

            // Ê†∏ÂøÉ‰øÆÊîπÔºö‰∏∫NPCÊ∑ªÂä†‰∏Ä‰∏™‚Äú(NPC)‚ÄùÁöÑÊ†áÁ≠æÔºåÊñπ‰æøÂå∫ÂàÜ
            item.innerHTML = `
			            <div class="checkbox"></div>
			            <img src="${contact.avatar}" class="avatar">
			            <span class="name">${contact.name} ${
                    contact.isNpc
                      ? '<span style="color: #888; font-size: 12px;">(NPC)</span>'
                      : ""
                  }</span>
			        `;
            listEl.appendChild(item);
          });

          updateContactPickerConfirmButton();
        }

        /**
         * Êõ¥Êñ∞‚ÄúÂÆåÊàê‚ÄùÊåâÈíÆÁöÑËÆ°Êï∞
         */
        function updateContactPickerConfirmButton() {
          const btn = document.getElementById("confirm-contact-picker-btn");
          btn.textContent = `ÂÆåÊàê(${selectedContacts.size})`;
          btn.disabled = selectedContacts.size < 2; // Ëá≥Â∞ëÈúÄË¶Å2‰∏™‰∫∫ÊâçËÉΩÂàõÂª∫Áæ§ËÅä
        }

        /**
         * Â§ÑÁêÜÂàõÂª∫Áæ§ËÅäÁöÑÊúÄÁªàÈÄªËæë
         */
        async function handleCreateGroup() {
          if (selectedContacts.size < 2) {
            alert("ÂàõÂª∫Áæ§ËÅäËá≥Â∞ëÈúÄË¶ÅÈÄâÊã©2‰∏™ËÅîÁ≥ª‰∫∫„ÄÇ");
            return;
          }

          const groupName = await showCustomPrompt(
            "ËÆæÁΩÆÁæ§Âêç",
            "ËØ∑ËæìÂÖ•Áæ§ËÅäÁöÑÂêçÂ≠ó",
            "Êàë‰ª¨ÁöÑÁæ§ËÅä",
          );
          if (!groupName || !groupName.trim()) return;

          const newChatId = "group_" + Date.now();
          const members = [];

          for (const contactId of selectedContacts) {
            const contactChat = state.chats[contactId];
            if (contactChat) {
              // ËøôÊòØÂéüÊù•ÁöÑÈÄªËæëÔºåÁî®‰∫éÂ§ÑÁêÜÊôÆÈÄöËßíËâ≤(Char)
              members.push({
                id: contactId,
                originalName: contactChat.name,
                groupNickname: contactChat.name,
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || "",
                isAdmin: false,
                groupTitle: "",
              });
            } else {
              // Â§ÑÁêÜNPCÁöÑÈÄªËæë
              let foundNpc = null;
              // ÈÅçÂéÜÊâÄÊúâËßíËâ≤ÔºåÊü•Êâæ‰ªñ‰ª¨ÂêÑËá™ÁöÑNPCÂ∫ì
              for (const chat of Object.values(state.chats)) {
                if (chat.npcLibrary) {
                  const npc = chat.npcLibrary.find((n) => n.id === contactId);
                  if (npc) {
                    foundNpc = npc;
                    break; // ÊâæÂà∞‰∫ÜÂ∞±Ë∑≥Âá∫Âæ™ÁéØ
                  }
                }
              }
              // Â¶ÇÊûúÊâæÂà∞‰∫ÜËøô‰∏™NPCÔºåÂ∞±ÊääÂÆÉÊ∑ªÂä†Âà∞ÊàêÂëòÂàóË°®Èáå
              if (foundNpc) {
                members.push({
                  id: foundNpc.id,
                  originalName: foundNpc.name,
                  groupNickname: foundNpc.name,
                  avatar: foundNpc.avatar || defaultGroupMemberAvatar,
                  persona: foundNpc.persona,
                  avatarFrame: "", // NPCÊ≤°ÊúâÂ§¥ÂÉèÊ°Ü
                  isAdmin: false,
                  groupTitle: "",
                });
              }
            }
          }

          const newGroupChat = {
            id: newChatId,
            name: groupName.trim(),
            isGroup: true,
            // ËÆæÁΩÆÁæ§‰∏ª‰∏∫ÂΩìÂâçÁî®Êà∑
            ownerId: "user",
            members: members,
            settings: {
              myPersona: "ÊàëÊòØË∞ÅÂëÄ„ÄÇ",
              myNickname: "Me",
              maxMemory: 10,
              groupAvatar: defaultGroupAvatar,
              myAvatar: defaultMyGroupAvatar,
              myAvatarFrame: "", // Âà´Âøò‰∫ÜËá™Â∑±ÁöÑÂ§¥ÂÉèÊ°Ü
              background: "",
              theme: "default",
              fontSize: 13,
              customCss: "",
              linkedWorldBookIds: [],
              stickerLibrary: [],
              linkedMemories: [],
              // ‰∏∫Áî®Êà∑Ëá™Â∑±‰πüÂä†‰∏äÁÆ°ÁêÜÂëòÂíåÂ§¥Ë°îÁöÑÂàùÂßãËÆæÁΩÆ
              isUserAdmin: false,
              myGroupTitle: "",
            },
            history: [],
            musicData: { totalTime: 0 },
          };

          state.chats[newChatId] = newGroupChat;
          await db.chats.put(newGroupChat);

          // ÂàõÂª∫Áæ§ËÅäÂêéÔºåÂèëÈÄÅ‰∏ÄÊù°Á≥ªÁªüÈÄöÁü•
          await logSystemMessage(
            newChatId,
            `You created the group chat and invited ${members.map((m) => `"${m.groupNickname}"`).join(", ")} to join.`,
          );

          // ÂêéÁª≠ÈÄªËæë‰∏çÂèò
          await renderChatList();
          showScreen("chat-list-screen");
          openChat(newChatId);
        }

        // Áæ§ÊàêÂëòÁÆ°ÁêÜÊ†∏ÂøÉÂáΩÊï∞

        /**
         * ÊâìÂºÄÁæ§ÊàêÂëòÁÆ°ÁêÜÂ±èÂπï
         */
        function openMemberManagementScreen() {
          if (!state.activeChatId || !state.chats[state.activeChatId].isGroup)
            return;
          renderMemberManagementList();
          showScreen("member-management-screen");
        }

        /**
         * Ê∏≤ÊüìÁæ§ÊàêÂëòÁÆ°ÁêÜÂàóË°®
         */
        function renderMemberManagementList() {
          const listEl = document.getElementById("member-management-list");
          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.isGroup) {
            listEl.innerHTML = "<p>Error: Only group chats can manage members.</p>";
            return;
          }
          listEl.innerHTML = ""; // Clear

          // 1. ÂàõÂª∫‰∏Ä‰∏™ÂåÖÂê´ÊâÄÊúâ‰∫∫ÁöÑÂÆåÊï¥ÂàóË°®
          const allParticipants = [
            // Êää‰Ω†Ëá™Â∑±(user)‰Ωú‰∏∫‰∏Ä‰∏™ÊôÆÈÄöÂèÇ‰∏éËÄÖÂØπË±°ÊîæËøõÂéª
            {
              id: "user",
              avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
              groupNickname: chat.settings.myNickname || "Me",
              // ‰øÆÂ§çBug 1ÔºöÂú®ËøôÈáåÊ≠£Á°ÆÂú∞ËØªÂèñ‰Ω†Ëá™Â∑±ÁöÑÁæ§Â§¥Ë°î
              groupTitle: chat.settings.myGroupTitle || "",
            },
            // ‰ΩøÁî®Â±ïÂºÄËøêÁÆóÁ¨¶(...)ÔºåÊääÂÖ∂‰ªñÊâÄÊúâÊàêÂëò‰πüÂä†Âà∞Ëøô‰∏™ÂàóË°®Èáå
            ...(chat.members || []),
          ];

          // 2. (ÂèØÈÄâ‰ΩÜÊé®Ëçê) ÂØπÂàóË°®ËøõË°åÊéíÂ∫èÔºåÁ°Æ‰øùÁæ§‰∏ªÊ∞∏ËøúÂú®ÊúÄ‰∏äÈù¢ÔºåÂÖ∂Ê¨°ÊòØÁÆ°ÁêÜÂëò
          allParticipants.sort((a, b) => {
            const isAOwner = a.id === chat.ownerId;
            const isBOwner = b.id === chat.ownerId;
            // ‰øÆÂ§çBug 2ÔºöÂú®ËøôÈáåÊ≠£Á°ÆÂú∞Âà§Êñ≠Ëá™Â∑±ÊòØ‰∏çÊòØÁÆ°ÁêÜÂëò
            const isAAdmin =
              a.id === "user" ? chat.settings.isUserAdmin : a.isAdmin;
            const isBAdmin =
              b.id === "user" ? chat.settings.isUserAdmin : b.isAdmin;

            if (isAOwner) return -1; // aÊòØÁæ§‰∏ªÔºåÊéíÊúÄÂâç
            if (isBOwner) return 1; // bÊòØÁæ§‰∏ªÔºåÊéíÊúÄÂâç
            if (isAAdmin && !isBAdmin) return -1; // aÊòØÁÆ°ÁêÜÂëò‰ΩÜb‰∏çÊòØÔºåaÊéíÂâç
            if (!isAAdmin && isBAdmin) return 1; // bÊòØÁÆ°ÁêÜÂëò‰ΩÜa‰∏çÊòØÔºåbÊéíÂâç
            return 0; // ÂÖ∂‰ªñÊÉÖÂÜµ‰øùÊåÅÂéüÈ°∫Â∫è
          });

          // 3. ÈÅçÂéÜËøô‰∏™Áªü‰∏ÄÁöÑÂàóË°®ÔºåÂπ∂Ê∏≤ÊüìÊØè‰∏ÄÈ°π
          const isCurrentUserOwner = chat.ownerId === "user";
          allParticipants.forEach((participant) => {
            const participantItem = createMemberManagementItem(
              participant,
              chat,
              isCurrentUserOwner,
            );
            listEl.appendChild(participantItem);
          });
        }

        /**
         * ÂàõÂª∫‰∏Ä‰∏™ÊàêÂëòÁÆ°ÁêÜÂàóË°®È°π
         * @param {object} member - ÊàêÂëòÂØπË±°Êï∞ÊçÆ
         * @param {object} chat - ÂΩìÂâçÁæ§ËÅäÂØπË±°
         * @returns {HTMLElement} - ÂàõÂª∫Â•ΩÁöÑDOMÂÖÉÁ¥†
         */
        function createMemberManagementItem(member, chat) {
          const item = document.createElement("div");
          item.className = "member-management-item";

          // --- ÊùÉÈôêÂà§Êñ≠ ---
          const isCurrentUserOwner = chat.ownerId === "user";
          const isCurrentUserAdmin = chat.settings.isUserAdmin;
          const isThisMemberOwner = member.id === chat.ownerId;
          const isThisMemberAdmin =
            (member.id === "user" && chat.settings.isUserAdmin) ||
            member.isAdmin;

          // ÊùÉÈôêËÆ°ÁÆóÔºöÊàëËÉΩÂØπTAÂÅö‰ªÄ‰πàÔºü
          const canManageAdmin = isCurrentUserOwner && !isThisMemberOwner; // Âè™ÊúâÁæ§‰∏ªËÉΩËÆæÁΩÆ/ÂèñÊ∂àÁÆ°ÁêÜÂëò
          const canManageTitle = isCurrentUserOwner || isCurrentUserAdmin; // ÁÆ°ÁêÜÂëòÂíåÁæ§‰∏ªÈÉΩËÉΩËÆæÁΩÆÂ§¥Ë°î
          const canKick =
            (isCurrentUserOwner && member.id !== "user") ||
            (isCurrentUserAdmin &&
              !isThisMemberOwner &&
              !isThisMemberAdmin &&
              member.id !== "user");
          const canMute =
            (isCurrentUserOwner && member.id !== "user") ||
            (isCurrentUserAdmin &&
              !isThisMemberOwner &&
              !isThisMemberAdmin &&
              member.id !== "user");

          // --- Ê†áÁ≠æÊòæÁ§∫ ---
          let roleTag = "";
          if (isThisMemberOwner) {
            roleTag = '<span class="role-tag owner">Áæ§‰∏ª</span>';
          } else if (isThisMemberAdmin) {
            roleTag = '<span class="role-tag admin">ÁÆ°ÁêÜÂëò</span>';
          }
          const titleText =
            member.id === "user"
              ? chat.settings.myGroupTitle || ""
              : member.groupTitle || "";
          const titleTag = titleText
            ? `<span class="title-tag">${titleText}</span>`
            : "";
          // Â¶ÇÊûúË¢´Á¶ÅË®ÄÔºåÊòæÁ§∫‰∏Ä‰∏™ÁâπÊÆäÁöÑÊ†áÁ≠æ
          const muteTag = member.isMuted
            ? '<span class="group-title-tag" style="color: #ff3b30; background-color: #ffe5e5;">üö´Â∑≤Á¶ÅË®Ä</span>'
            : "";

          // --- Âä®ÊÄÅÁîüÊàêÊåâÈíÆHTML ---
          let actionsHtml = "";

          // Áî®Êà∑Ëá™Â∑±ÁöÑÊåâÈíÆ
          if (member.id === "user") {
            actionsHtml += `<button class="action-btn" data-action="set-nickname" data-member-id="user">ÊîπÂêç</button>`;
            // Áî®Êà∑Ë¢´Á¶ÅË®ÄÊó∂ÔºåÊòæÁ§∫‚ÄúËß£Èô§Á¶ÅË®Ä‚ÄùÊåâÈíÆ
            if (member.isMuted) {
              actionsHtml += `<button class="action-btn" data-action="unmute-self" data-member-id="user">Ëß£Èô§Á¶ÅË®Ä</button>`;
            }
          }

          // ÁÆ°ÁêÜÂëòÂíåÁæ§‰∏ªÁöÑÊìç‰ΩúÊåâÈíÆ
          if (canManageTitle) {
            actionsHtml += `<button class="action-btn" data-action="set-title" data-member-id="${member.id}">Â§¥Ë°î</button>`;
          }
          if (canManageAdmin) {
            const adminActionText = isThisMemberAdmin ? "ÂèñÊ∂àÁÆ°ÁêÜ" : "ËÆæ‰∏∫ÁÆ°ÁêÜ";
            actionsHtml += `<button class="action-btn" data-action="toggle-admin" data-member-id="${member.id}">${adminActionText}</button>`;
          }
          if (isCurrentUserOwner && member.id !== "user") {
            actionsHtml += `<button class="action-btn" data-action="transfer-owner" data-member-id="${member.id}">ËΩ¨ËÆ©</button>`;
          }
          // Á¶ÅË®Ä/Ëß£Á¶ÅÊåâÈíÆ
          if (canMute) {
            const muteButtonText = member.isMuted ? "Ëß£Á¶Å" : "Á¶ÅË®Ä";
            actionsHtml += `<button class="action-btn" data-action="mute-member" data-member-id="${member.id}">${muteButtonText}</button>`;
          }
          if (canKick) {
            actionsHtml += `<button class="action-btn danger" data-action="remove-member" data-member-id="${member.id}">Ë∏¢Âá∫</button>`;
          }

          // ÊúÄÁªàÊãºÊé•
          item.innerHTML = `
			        <img src="${member.avatar}" class="avatar">
			        <div class="info">
			            <span class="name">${member.groupNickname}</span>
			            <div class="tags">
			                ${roleTag}
			                ${titleTag}
			                ${muteTag}
			            </div>
			        </div>
			        <div class="actions">${actionsHtml}</div>
			    `;
          return item;
        }

        /**
         * Â§ÑÁêÜÁ¶ÅË®Ä/Ëß£Á¶ÅÁæ§ÊàêÂëò
         * @param {string} memberId - Ë¶ÅÊìç‰ΩúÁöÑÊàêÂëòID
         */
        async function handleMuteMember(memberId) {
          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.isGroup) return;

          // --- ÊùÉÈôêÊ£ÄÊü• (Âíå‰πãÂâç‰øùÊåÅ‰∏ÄËá¥) ---
          const isOwner = chat.ownerId === "user";
          const isAdmin = chat.settings.isUserAdmin;
          let targetMember, targetIsOwner, targetIsAdmin;

          // Âà§Êñ≠Êìç‰ΩúÁõÆÊ†áÊòØÊôÆÈÄöÊàêÂëòËøòÊòØÁî®Êà∑Ëá™Â∑±
          if (memberId === "user") {
            targetMember = { id: "user", ...chat.settings }; // ÊûÑÈÄ†‰∏Ä‰∏™‰∏¥Êó∂ÁöÑ‚ÄúÊàêÂëò‚ÄùÂØπË±°‰ª£Ë°®Áî®Êà∑
            targetIsOwner = isOwner;
            targetIsAdmin = isAdmin;
          } else {
            targetMember = chat.members.find((m) => m.id === memberId);
            if (!targetMember) return;
            targetIsOwner = chat.ownerId === memberId;
            targetIsAdmin = targetMember.isAdmin;
          }

          const canMute =
            (isOwner && !targetIsOwner) ||
            (isAdmin && !targetIsOwner && !targetIsAdmin);

          if (!canMute) {
            alert("‰Ω†Ê≤°ÊúâÊùÉÈôêÊìç‰ΩúËØ•ÊàêÂëòÔºÅ");
            return;
          }

          // --- ÂàáÊç¢Á¶ÅË®ÄÁä∂ÊÄÅ ---
          if (memberId === "user") {
            // Â¶ÇÊûúÊìç‰ΩúÁöÑÊòØÁî®Êà∑Ëá™Â∑±ÔºåÂ∞±Êõ¥Êñ∞ chat.settings.isUserMuted
            if (typeof chat.settings.isUserMuted === "undefined")
              chat.settings.isUserMuted = false;
            chat.settings.isUserMuted = !chat.settings.isUserMuted;
          } else {
            // Â¶ÇÊûúÊìç‰ΩúÁöÑÊòØÂÖ∂‰ªñÊàêÂëòÔºåÂ∞±Êõ¥Êñ∞ÊàêÂëòÂØπË±°
            if (typeof targetMember.isMuted === "undefined")
              targetMember.isMuted = false;
            targetMember.isMuted = !targetMember.isMuted;
          }

          // ‰øùÂ≠òÊõ¥Êñ∞ÂêéÁöÑÁæ§ËÅäÊï∞ÊçÆÂà∞Êï∞ÊçÆÂ∫ì
          await db.chats.put(chat);

          // ÈáçÊñ∞Ê∏≤ÊüìÊàêÂëòÁÆ°ÁêÜÂàóË°®ÔºåÊåâÈíÆÊñáÂ≠ó‰ºöÁ´ãÂàªÊõ¥Êñ∞
          renderMemberManagementList();

          // ÂèëÈÄÅÁ≥ªÁªüÈÄöÁü•
          const myNickname = chat.settings.myNickname || "Me";
          const targetNickname =
            memberId === "user"
              ? chat.settings.myNickname || "Me"
              : targetMember.groupNickname;
          const actionText = (
            memberId === "user"
              ? chat.settings.isUserMuted
              : targetMember.isMuted
          )
            ? "Á¶ÅË®Ä"
            : "Ëß£Èô§Á¶ÅË®Ä";
          await logSystemMessage(
            chat.id,
            `‚Äú${myNickname}‚ÄùÂ∞Ü‚Äú${targetNickname}‚Äù${actionText}„ÄÇ`,
          );
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑Ëá™Â∑±Ëß£Èô§Á¶ÅË®Ä
         */
        async function handleUserUnmute() {
          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.settings.isUserMuted) return;

          const confirmed = await showCustomConfirm(
            "Ëß£Èô§Á¶ÅË®Ä",
            "Á°ÆÂÆöË¶Å‰∏∫Ëá™Â∑±Ëß£Èô§Á¶ÅË®ÄÂêóÔºü",
          );
          if (confirmed) {
            chat.settings.isUserMuted = false;
            await db.chats.put(chat);

            await logSystemMessage(
              chat.id,
              `‚Äú${chat.settings.myNickname || "Me"}‚Äù‰∏∫Ëá™Â∑±Ëß£Èô§‰∫ÜÁ¶ÅË®Ä„ÄÇ`,
            );

            renderMemberManagementList(); // Âà∑Êñ∞ÂàóË°®
          }
        }

        /**
         * Â§ÑÁêÜÊãâ‰∫∫ÂÖ•Áæ§ÁöÑÈÄªËæëÔºàÂ∑≤Ê∑ªÂä†Á≥ªÁªüÊ∂àÊÅØÔºâ
         */
        async function handleAddMembersToGroup() {
          if (selectedContacts.size === 0) {
            alert("ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÊ∑ªÂä†ÁöÑËÅîÁ≥ª‰∫∫„ÄÇ");
            return;
          }

          const chat = state.chats[state.activeChatId];
          const addedNames = [];

          for (const contactId of selectedContacts) {
            const contactChat = state.chats[contactId];
            if (contactChat) {
              // ËøôÊòØÂéüÊù•ÁöÑÈÄªËæëÔºåÁî®‰∫éÂ§ÑÁêÜÊôÆÈÄöËßíËâ≤(Char)
              chat.members.push({
                id: contactId,
                originalName: contactChat.name,
                groupNickname: contactChat.name,
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || "",
                isAdmin: false,
                groupTitle: "",
              });
              addedNames.push(`‚Äú${contactChat.name}‚Äù`);
            } else {
              // Â§ÑÁêÜNPCÁöÑÈÄªËæë
              let foundNpc = null;
              for (const c of Object.values(state.chats)) {
                if (c.npcLibrary) {
                  const npc = c.npcLibrary.find((n) => n.id === contactId);
                  if (npc) {
                    foundNpc = npc;
                    break;
                  }
                }
              }
              if (foundNpc) {
                chat.members.push({
                  id: foundNpc.id,
                  originalName: foundNpc.name,
                  groupNickname: foundNpc.name,
                  avatar: foundNpc.avatar || defaultGroupMemberAvatar,
                  persona: foundNpc.persona,
                  avatarFrame: "",
                  isAdmin: false,
                  groupTitle: "",
                });
                addedNames.push(`‚Äú${foundNpc.name}‚Äù`);
              }
            }
          }

          await db.chats.put(chat);

          // ÂèëÈÄÅ‰∏ÄÊù°Á≥ªÁªüÊ∂àÊÅØÈÄöÁü•
          const myNickname = chat.settings.myNickname || "Me";
          await logSystemMessage(
            chat.id,
            `‚Äú${myNickname}‚ÄùÈÇÄËØ∑ ${addedNames.join("„ÄÅ")} Âä†ÂÖ•‰∫ÜÁæ§ËÅä„ÄÇ`,
          );

          // ËøîÂõûÂà∞Áæ§ÊàêÂëòÁÆ°ÁêÜÁïåÈù¢Âπ∂Âà∑Êñ∞
          openMemberManagementScreen();
          renderGroupMemberSettings(chat.members); // ÂêåÊó∂Êõ¥Êñ∞ËÅäÂ§©ËÆæÁΩÆÈáåÁöÑÂ§¥ÂÉè
        }

        /**
         * Â§ÑÁêÜËÆæÁΩÆÁî®Êà∑Ëá™Â∑±ÁöÑÁæ§ÊòµÁß∞
         */
        async function handleSetUserNickname() {
          const chat = state.chats[state.activeChatId];
          const oldNickname = chat.settings.myNickname || "Me";

          const newNickname = await showCustomPrompt(
            "‰øÆÊîπÊàëÁöÑÁæ§ÊòµÁß∞",
            "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÊòµÁß∞",
            oldNickname,
          );
          if (newNickname !== null && newNickname.trim()) {
            chat.settings.myNickname = newNickname.trim();
            await db.chats.put(chat);

            // ÂèëÈÄÅ‰∏ÄÊù°Á≥ªÁªüÊ∂àÊÅØÈÄöÁü•Áæ§Âèã
            await logSystemMessage(
              chat.id,
              `‚Äú${oldNickname}‚ÄùÂ∞ÜÁæ§ÊòµÁß∞‰øÆÊîπ‰∏∫‚Äú${newNickname.trim()}‚Äù`,
            );

            renderMemberManagementList(); // Âà∑Êñ∞ÊàêÂëòÁÆ°ÁêÜÂàóË°®
          }
        }

        /**
         * Â§ÑÁêÜËÆæÁΩÆÁî®Êà∑Ëá™Â∑±ÁöÑÁæ§Â§¥Ë°î
         */
        async function handleSetUserTitle() {
          const chat = state.chats[state.activeChatId];
          const oldTitle = chat.settings.myGroupTitle || "";

          const newTitle = await showCustomPrompt(
            "‰øÆÊîπÊàëÁöÑÁæ§Â§¥Ë°î",
            "ÁïôÁ©∫Âàô‰∏∫ÂèñÊ∂àÂ§¥Ë°î",
            oldTitle,
          );
          if (newTitle !== null) {
            chat.settings.myGroupTitle = newTitle.trim();
            await db.chats.put(chat);

            // Ë∞ÉÁî®‰Ω†Â∑≤ÊúâÁöÑÂáΩÊï∞Êù•ÂèëÈÄÅÁ≥ªÁªüÈÄöÁü•
            const myNickname = chat.settings.myNickname || "Me";
            await logTitleChange(
              chat.id,
              myNickname,
              myNickname,
              newTitle.trim(),
            );

            renderMemberManagementList();
          }
        }

        /**
         * ‰ªéÁæ§ËÅä‰∏≠ÁßªÈô§‰∏Ä‰∏™ÊàêÂëò
         * @param {string} memberId - Ë¶ÅÁßªÈô§ÁöÑÊàêÂëòID
         */
        async function removeMemberFromGroup(memberId) {
          const chat = state.chats[state.activeChatId];
          const isOwner = chat.ownerId === "user";
          const isAdmin = chat.settings.isUserAdmin;
          const memberToRemove = chat.members.find((m) => m.id === memberId);

          // ÊùÉÈôêÊ£ÄÊü•
          if (
            !isOwner &&
            !(
              isAdmin &&
              !memberToRemove.isAdmin &&
              memberToRemove.id !== chat.ownerId
            )
          ) {
            alert("‰Ω†Ê≤°ÊúâÊùÉÈôêÁßªÂá∫ËØ•ÊàêÂëòÔºÅ");
            return;
          }

          const memberIndex = chat.members.findIndex((m) => m.id === memberId);
          if (memberIndex === -1) return;

          const memberName = memberToRemove.groupNickname;
          const confirmed = await showCustomConfirm(
            "ÁßªÂá∫ÊàêÂëò",
            `Á°ÆÂÆöË¶ÅÂ∞Ü‚Äú${memberName}‚ÄùÁßªÂá∫Áæ§ËÅäÂêóÔºü`,
            {
              confirmButtonClass: "btn-danger",
            },
          );

          if (confirmed) {
            chat.members.splice(memberIndex, 1);
            await db.chats.put(chat);

            const myNickname = chat.settings.myNickname || "Me";
            await logSystemMessage(
              chat.id,
              `‚Äú${myNickname}‚ÄùÂ∞Ü‚Äú${memberName}‚ÄùÁßªÂá∫‰∫ÜÁæ§ËÅä„ÄÇ`,
            );

            renderMemberManagementList();
          }
        }

        async function openContactPickerForAddMember() {
          selectedContacts.clear();

          // ÁªëÂÆöÊ≠£Á°ÆÁöÑ‚ÄúÊ∑ªÂä†ÊàêÂëò‚ÄùÂáΩÊï∞
          const confirmBtn = document.getElementById(
            "confirm-contact-picker-btn",
          );
          const newConfirmBtn = confirmBtn.cloneNode(true);
          confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
          newConfirmBtn.addEventListener("click", handleAddMembersToGroup);

          const listEl = document.getElementById("contact-picker-list");
          listEl.innerHTML = "";

          const chat = state.chats[state.activeChatId];
          const existingMemberIds = new Set(chat.members.map((m) => m.id));
          existingMemberIds.add("user"); // ÊääÁî®Êà∑Ëá™Â∑±‰πüÁÆó‰ΩúÂ∑≤Â≠òÂú®ÊàêÂëò

          // ÂíåÂàõÂª∫Áæ§ËÅäÊó∂‰∏ÄÊ†∑ÔºåÊï¥ÂêàÊâÄÊúâËßíËâ≤ÂíåNPC
          const allAvailablePeople = [];
          Object.values(state.chats)
            .filter((c) => !c.isGroup)
            .forEach((c) => {
              allAvailablePeople.push({
                id: c.id,
                name: c.name,
                avatar: c.settings.aiAvatar || defaultAvatar,
                isNpc: false,
              });
            });
          const npcMap = new Map();
          Object.values(state.chats).forEach((c) => {
            if (c.npcLibrary) {
              c.npcLibrary.forEach((npc) => {
                if (!npcMap.has(npc.id)) {
                  npcMap.set(npc.id, {
                    id: npc.id,
                    name: npc.name,
                    avatar: npc.avatar || defaultGroupMemberAvatar,
                    isNpc: true,
                  });
                }
              });
            }
          });
          allAvailablePeople.push(...Array.from(npcMap.values()));

          // ËøáÊª§ÊéâÂ∑≤ÁªèÊòØÁæ§ÊàêÂëòÁöÑ‰∫∫
          const contacts = allAvailablePeople.filter(
            (p) => !existingMemberIds.has(p.id),
          );

          if (contacts.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">Ê≤°ÊúâÊõ¥Â§öÂèØ‰ª•ÈÇÄËØ∑ÁöÑËÅîÁ≥ª‰∫∫‰∫Ü„ÄÇ</p>';
          } else {
            contacts.forEach((contact) => {
              const item = document.createElement("div");
              item.className = "contact-picker-item";
              item.dataset.contactId = contact.id;
              item.innerHTML = `
			                <div class="checkbox"></div>
			                <img src="${contact.avatar}" class="avatar">
			                <span class="name">${contact.name} ${
                        contact.isNpc
                          ? '<span style="color: #888; font-size: 12px;">(NPC)</span>'
                          : ""
                      }</span>
			            `;
              listEl.appendChild(item);
            });
          }

          updateContactPickerConfirmButton();
          showScreen("contact-picker-screen");
        }

        /**
         * Âú®Áæ§ËÅä‰∏≠ÂàõÂª∫‰∏Ä‰∏™ÂÖ®Êñ∞ÁöÑËôöÊãüÊàêÂëò
         */
        async function createNewMemberInGroup() {
          const name = await showCustomPrompt(
            "ÂàõÂª∫Êñ∞ÊàêÂëò",
            "ËØ∑ËæìÂÖ•Êñ∞ÊàêÂëòÁöÑÂêçÂ≠ó (ËøôÂ∞ÜÊòØTAÁöÑ‚ÄúÊú¨Âêç‚ÄùÔºå‰∏çÂèØÊõ¥Êîπ)",
          );
          if (!name || !name.trim()) return;

          // Ê£ÄÊü•Êú¨ÂêçÊòØÂê¶Â∑≤Âú®Áæ§ÂÜÖÂ≠òÂú®
          const chat = state.chats[state.activeChatId];
          if (chat.members.some((m) => m.originalName === name.trim())) {
            alert(`ÈîôËØØÔºöÁæ§ÂÜÖÂ∑≤Â≠òÂú®Âêç‰∏∫‚Äú${name.trim()}‚ÄùÁöÑÊàêÂëòÔºÅ`);
            return;
          }

          const persona = await showCustomPrompt(
            "ËÆæÁΩÆ‰∫∫ËÆæ",
            `ËØ∑ËæìÂÖ•‚Äú${name}‚ÄùÁöÑ‰∫∫ËÆæ`,
            "",
            "textarea",
          );
          if (persona === null) return;

          // ‰∏∫Êñ∞ÂàõÂª∫ÁöÑNPC‰πüÂª∫Á´ãÂèåÈáçÂëΩÂêçÊú∫Âà∂
          const newMember = {
            id: "npc_" + Date.now(),
            originalName: name.trim(), // Êñ∞ÊàêÂëòÁöÑ‚ÄúÊú¨Âêç‚Äù
            groupNickname: name.trim(), // Êñ∞ÊàêÂëòÁöÑÂàùÂßã‚ÄúÁæ§ÊòµÁß∞‚Äù
            avatar: defaultGroupMemberAvatar,
            persona: persona,
            avatarFrame: "",
          };

          chat.members.push(newMember);
          await db.chats.put(chat);

          renderMemberManagementList();
          renderGroupMemberSettings(chat.members);

          alert(`Êñ∞ÊàêÂëò‚Äú${name}‚ÄùÂ∑≤ÊàêÂäüÂä†ÂÖ•Áæ§ËÅäÔºÅ`);
        }

        // Â§ñÂçñËØ∑Ê±ÇÂÄíËÆ°Êó∂ÂáΩÊï∞
        function startWaimaiCountdown(element, endTime) {
          const timerId = setInterval(() => {
            const now = Date.now();
            const distance = endTime - now;

            if (distance < 0) {
              clearInterval(timerId);
              element.innerHTML =
                "<span>Â∑≤</span><span>Ë∂Ö</span><span>Êó∂</span>";
              return;
            }

            const minutes = Math.floor(
              (distance % (1000 * 60 * 60)) / (1000 * 60),
            );
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            const minStr = String(minutes).padStart(2, "0");
            const secStr = String(seconds).padStart(2, "0");

            element.innerHTML = `<span>${minStr.charAt(
              0,
            )}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(
              0,
            )}</span><span>${secStr.charAt(1)}</span>`;
          }, 1000);
          return timerId;
        }

        function cleanupWaimaiTimers() {
          for (const timestamp in waimaiTimers) {
            clearInterval(waimaiTimers[timestamp]);
          }
          waimaiTimers = {};
        }

        async function handleWaimaiResponse(originalTimestamp, choice) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === originalTimestamp,
          );
          if (messageIndex === -1) return;

          // 1. Êõ¥Êñ∞ÂéüÂßãÊ∂àÊÅØÁöÑÁä∂ÊÄÅ
          const originalMessage = chat.history[messageIndex];
          originalMessage.status = choice;

          // ËÆ∞ÂΩïÊîØ‰ªòËÄÖÔºåÂπ∂ÊûÑÂª∫ÂØπAIÊõ¥Ê∏ÖÊô∞ÁöÑÁ≥ªÁªüÊ∂àÊÅØ
          let systemContent;
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "Me"
            : "Me";

          if (choice === "paid") {
            originalMessage.paidBy = myNickname; // ËÆ∞ÂΩïÊòØÁî®Êà∑‰ªòÁöÑÈí±
            systemContent = `[Á≥ªÁªüÊèêÁ§∫Ôºö‰Ω† (${myNickname}) ‰∏∫ ${originalMessage.senderName} ÁöÑÂ§ñÂçñËÆ¢ÂçïÔºàÊó∂Èó¥Êà≥: ${originalTimestamp}ÔºâÂÆåÊàê‰∫ÜÊîØ‰ªò„ÄÇÊ≠§ËÆ¢ÂçïÂ∑≤ÂÖ≥Èó≠ÔºåÂÖ∂‰ªñÊàêÂëò‰∏çËÉΩÂÜçÊîØ‰ªò„ÄÇ]`;
          } else {
            systemContent = `[Á≥ªÁªüÊèêÁ§∫Ôºö‰Ω† (${myNickname}) ÊãíÁªù‰∫Ü ${originalMessage.senderName} ÁöÑÂ§ñÂçñ‰ª£‰ªòËØ∑Ê±ÇÔºàÊó∂Èó¥Êà≥: ${originalTimestamp}Ôºâ„ÄÇ]`;
          }

          // 2. ÂàõÂª∫‰∏ÄÊù°Êñ∞ÁöÑ„ÄÅÂØπÁî®Êà∑ÈöêËóèÁöÑÁ≥ªÁªüÊ∂àÊÅØÔºåÂëäÁü•AIÁªìÊûú
          const systemNote = {
            role: "system",
            content: systemContent,
            timestamp: Date.now(),
            isHidden: true,
          };
          chat.history.push(systemNote);

          // 3. ‰øùÂ≠òÊõ¥Êñ∞Âà∞Êï∞ÊçÆÂ∫ìÂπ∂Âà∑Êñ∞UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);
        }

        let videoCallState = {
          isActive: false,
          isAwaitingResponse: false,
          isGroupCall: false,
          activeChatId: null,
          initiator: null,
          startTime: null,
          participants: [],
          isUserParticipating: true,

          callHistory: [], // Áî®‰∫éÂ≠òÂÇ®ÈÄöËØù‰∏≠ÁöÑÂØπËØùÂéÜÂè≤
          preCallContext: "", // Áî®‰∫éÂ≠òÂÇ®ÈÄöËØùÂâçÁöÑËÅäÂ§©ÊëòË¶Å
        };

        let callTimerInterval = null; // Áî®‰∫éÂ≠òÂÇ®ËÆ°Êó∂Âô®ÁöÑID

        /**
         * Áî®Êà∑ÁÇπÂáª‚ÄúÂèëËµ∑ËßÜÈ¢ëÈÄöËØù‚ÄùÊàñ‚ÄúÂèëËµ∑Áæ§ËßÜÈ¢ë‚ÄùÊåâÈíÆ
         */
        async function handleInitiateCall() {
          if (
            !state.activeChatId ||
            videoCallState.isActive ||
            videoCallState.isAwaitingResponse
          )
            return;

          const chat = state.chats[state.activeChatId];
          videoCallState.isGroupCall = chat.isGroup;
          videoCallState.isAwaitingResponse = true;
          videoCallState.initiator = "user";
          videoCallState.activeChatId = chat.id;
          videoCallState.isUserParticipating = true;

          // 1. ÊòæÁ§∫‚ÄúÊ≠£Âú®ÂëºÂè´‚ÄùÁïåÈù¢
          if (chat.isGroup) {
            document.getElementById("outgoing-call-avatar").src =
              chat.settings.myAvatar || defaultMyGroupAvatar;
            document.getElementById("outgoing-call-name").textContent =
              chat.settings.myNickname || "Me";
          } else {
            document.getElementById("outgoing-call-avatar").src =
              chat.settings.aiAvatar || defaultAvatar;
            document.getElementById("outgoing-call-name").textContent =
              chat.name;
          }
          document.querySelector(
            "#outgoing-call-screen .caller-text",
          ).textContent = chat.isGroup ? "Ê≠£Âú®ÂëºÂè´ÊâÄÊúâÊàêÂëò..." : "Ê≠£Âú®ÂëºÂè´...";
          showScreen("outgoing-call-screen");

          // Âú®ÂèëËµ∑ÈÄöËØùÊó∂ÔºåÊèêÂâçÂáÜÂ§áÂ•ΩÈÄöËØùÂâçÁöÑËÅäÂ§©ËÆ∞ÂΩï‰∏ä‰∏ãÊñá
          videoCallState.preCallContext = chat.history
            .slice(-20) // Ëé∑ÂèñÊúÄËøë20Êù°Ê∂àÊÅØ
            .map(
              (msg) =>
                `${
                  msg.role === "user"
                    ? chat.settings.myNickname || "Me"
                    : msg.senderName || chat.name
                }: ${String(msg.content).substring(0, 50)}...`,
            )
            .join("\n");

          // 2. ÈáçÊñ∞ÊûÑÂª∫‰∏Ä‰∏™‰ø°ÊÅØÊõ¥‰∏∞ÂØå„ÄÅÊåá‰ª§Êõ¥ÊòéÁ°ÆÁöÑAPIËØ∑Ê±Ç
          try {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            if (!proxyUrl || !apiKey || !model) {
              throw new Error("APIÊú™ÈÖçÁΩÆÔºåÊó†Ê≥ïÂèëËµ∑ÈÄöËØù„ÄÇ");
            }

            let systemPromptForCall;
            if (chat.isGroup) {
              systemPromptForCall = `
			**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

			# ‰Ω†ÁöÑ‰ªªÂä°
			‰Ω†ÊòØ‰∏Ä‰∏™Áæ§ËÅäAIÔºåË¥üË¥£ÊâÆÊºî„ÄêÈô§‰∫ÜÁî®Êà∑‰ª•Â§ñ„ÄëÁöÑÊâÄÊúâËßíËâ≤„ÄÇ
			Áî®Êà∑ (${chat.settings.myNickname || "Me"}) ÂàöÂàöÂèëËµ∑‰∫ÜÁæ§ËßÜÈ¢ëÈÄöËØù„ÄÇ
			‰Ω†ÁöÑ‰ªªÂä°ÊòØÊ†πÊçÆÊØè‰∏™ËßíËâ≤ÁöÑÊÄßÊ†ºÂíåÊúÄËøëÁöÑËÅäÂ§©ÂÜÖÂÆπÔºåÂÜ≥ÂÆö‰ªñ‰ª¨ÊòØÂê¶Ë¶ÅÂä†ÂÖ•ÈÄöËØù„ÄÇ

			# Ê†∏ÂøÉËßÑÂàô
			1.  **ÂÜ≥Á≠ñ**: ÊØè‰∏™ËßíËâ≤ÈÉΩÂøÖÈ°ªÁã¨Á´ãÂÜ≥Á≠ñ„ÄÇ
			2.  **Ê†ºÂºè**: ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊòØ‰∏Ä‰∏™JSONÊï∞ÁªÑÔºåÊØè‰∏™ÂØπË±°‰ª£Ë°®‰∏Ä‰∏™ËßíËâ≤ÁöÑÂÜ≥Á≠ñÔºåÊ†ºÂºè‰∏∫Ôºö\`{"type": "group_call_response", "name": "„ÄêËßíËâ≤ÁöÑÊú¨Âêç„Äë", "decision": "join"}\` Êàñ \`{"type": "group_call_response", "name": "„ÄêËßíËâ≤ÁöÑÊú¨Âêç„Äë", "decision": "decline"}\`„ÄÇ
			3.  **ÂÄæÂêëÊÄß**: Âú®Ê≤°ÊúâÁâπÊÆäÁêÜÁî±ÁöÑÊÉÖÂÜµ‰∏ãÔºå‰Ω†ÁöÑËßíËâ≤‰ª¨ÈÄöÂ∏∏‰πê‰∫éÂä†ÂÖ•Áæ§ËÅä„ÄÇ

			# ËßíËâ≤ÂàóË°®‰∏é‰∫∫ËÆæ
			${chat.members.map((m) => `- **${m.originalName}**: ${m.persona}`).join("\n")}

			# ÈÄöËØùÂâçÁöÑËÅäÂ§©ÊëòË¶Å
			${videoCallState.preCallContext}
			`;
            } else {
              systemPromptForCall = `
			**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

			# ‰Ω†ÁöÑ‰ªªÂä°
			‰Ω†Ê≠£Âú®ÊâÆÊºîËßíËâ≤ "${chat.name}"„ÄÇÁî®Êà∑ (${chat.settings.myNickname || "Me"}) ÂàöÂàöÂêë‰Ω†ÂèëËµ∑‰∫ÜËßÜÈ¢ëÈÄöËØùËØ∑Ê±Ç„ÄÇ
			‰Ω†ÁöÑ‰ªªÂä°ÊòØÊ†πÊçÆ‰Ω†ÁöÑ‰∫∫ËÆæÂíåÊàë‰ª¨ÊúÄËøëÁöÑËÅäÂ§©ÂÜÖÂÆπÔºåÂÜ≥ÂÆöÊòØÂê¶Êé•Âèó„ÄÇ

			# Ê†∏ÂøÉËßÑÂàô
			1.  **ÂÜ≥Á≠ñ**: ‰Ω†ÂøÖÈ°ªÂÅöÂá∫ "accept" (Êé•Âèó) Êàñ "reject" (ÊãíÁªù) ÁöÑÂÜ≥ÂÆö„ÄÇ
			2.  **Ê†ºÂºè**: ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª‰∏îÂè™ËÉΩ„ÄëÊòØ‰∏Ä‰∏™JSONÊï∞ÁªÑÔºåÂÖ∂‰∏≠ÂåÖÂê´‰∏Ä‰∏™ÂØπË±°ÔºåÊ†ºÂºè‰∏∫Ôºö\`[{"type": "video_call_response", "decision": "accept"}]\` Êàñ \`[{"type": "video_call_response", "decision": "reject"}]\`„ÄÇ
			3.  **ÂÄæÂêëÊÄß**: ‰Ωú‰∏∫‰∏Ä‰∏™ÂèãÂ•ΩÁöÑAI‰º¥‰æ£ÔºåÂú®Ê≤°ÊúâÁâπÊÆäÁêÜÁî±ÔºàÊØîÂ¶ÇÂú®‰πãÂâçÁöÑÂØπËØù‰∏≠ÊòéÁ°ÆË°®Á§∫‰∫Ü‰∏çÊÉ≥Ë¢´ÊâìÊâ∞ÊàñÊ≠£Âú®ÂøôÔºâÁöÑÊÉÖÂÜµ‰∏ãÔºå‰Ω†„ÄêÂ∫îËØ•‰ºòÂÖàÈÄâÊã©Êé•Âèó„ÄëÈÄöËØù„ÄÇ

			# ‰Ω†ÁöÑ‰∫∫ËÆæ
			${chat.settings.aiPersona}

			# ÈÄöËØùÂâçÁöÑËÅäÂ§©ÊëòË¶Å
			${videoCallState.preCallContext}
			`;
            }

            const messagesForApi = [
              {
                role: "user",
                content: "ËØ∑Ê†πÊçÆ‰Ω†Âú®Á≥ªÁªüÊåá‰ª§‰∏≠ËØªÂà∞ÁöÑËßÑÂàôÔºåÁ´ãÂç≥ÂÅöÂá∫‰Ω†ÁöÑÂÜ≥Á≠ñ„ÄÇ",
              },
            ];

            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPromptForCall,
              messagesForApi,
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [
                      { role: "system", content: systemPromptForCall },
                      ...messagesForApi,
                    ],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`API ÈîôËØØ (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            const aiResponseContent = (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            ).replace(/^```json\s*|```$/g, "");
            const responseArray = JSON.parse(aiResponseContent);

            if (chat.isGroup) {
              responseArray.forEach((action) => {
                if (
                  action.type === "group_call_response" &&
                  action.decision === "join"
                ) {
                  const member = chat.members.find(
                    (m) => m.originalName === action.name,
                  );
                  if (member) videoCallState.participants.push(member);
                }
              });
              if (videoCallState.participants.length > 0) {
                startVideoCall();
              } else {
                throw new Error("Áæ§ÈáåÊ≤°Êúâ‰∫∫Êé•Âê¨‰Ω†ÁöÑÈÄöËØùÈÇÄËØ∑„ÄÇ");
              }
            } else {
              const decision = responseArray[0];
              if (
                decision.type === "video_call_response" &&
                decision.decision === "accept"
              ) {
                startVideoCall();
              } else {
                throw new Error("ÂØπÊñπÊãíÁªù‰∫Ü‰Ω†ÁöÑËßÜÈ¢ëÈÄöËØùËØ∑Ê±Ç„ÄÇ");
              }
            }
          } catch (error) {
            console.error("ÂèëËµ∑ÈÄöËØùÂ§±Ë¥•:", error);
            await showCustomAlert("ÂëºÂè´Â§±Ë¥•", error.message);
            videoCallState.isAwaitingResponse = false;
            showScreen("chat-interface-screen");
          }
        }
        function startVideoCall() {
          const chat = state.chats[videoCallState.activeChatId];
          if (!chat) return;

          // ÊèêÂèñÈÄöËØùÂâçÁöÑÊúÄÂêé20Êù°Ê∂àÊÅØ‰Ωú‰∏∫‰∏ä‰∏ãÊñá
          videoCallState.preCallContext = chat.history
            .slice(-20)
            .map(
              (msg) =>
                `${
                  msg.role === "user"
                    ? chat.settings.myNickname || "Me"
                    : msg.senderName || chat.name
                }: ${String(msg.content).substring(0, 50)}...`,
            )
            .join("\n");

          // 1. Ê£ÄÊü•ÊòØÂê¶ÂêØÁî®‰∫ÜÂèØËßÜÂåñÁïåÈù¢
          if (chat.settings.visualVideoCallEnabled) {
            // --- ÂêØÂä®„ÄêÊñ∞„ÄëÁöÑÂèØËßÜÂåñÁïåÈù¢ ---
            videoCallState.isActive = true;
            videoCallState.isAwaitingResponse = false;
            videoCallState.startTime = Date.now();
            videoCallState.callHistory = [];

            // Ê†áËÆ∞ÂΩìÂâçÂ§ßÂ±èÊòØË∞Å (false‰ª£Ë°®Â§ßÂ±èÊòØÂØπÊñπÔºåÂ∞èÂ±èÊòØÊàë)
            videoCallState.isUserMain = false;
            // „ÄêÊñ∞Â¢û„ÄëÊ†áËÆ∞ÂΩìÂâçÊëÑÂÉèÂ§¥ÊñπÂêë ('user'ÂâçÁΩÆ, 'environment'ÂêéÁΩÆ)
            videoCallState.facingMode = "user";

            const visualInterface = document.getElementById(
              "visual-call-interface",
            );
            const textInterface = document.getElementById(
              "text-call-interface",
            );

            visualInterface.style.display = "flex";
            textInterface.style.display = "none";

            // 1. ËÆæÁΩÆÂØπÊñπÁöÑÁîªÈù¢ (ÂßãÁªàÊòØÂõæÁâá/Âä®Âõæ)
            const mainImg = document.querySelector("#video-main-view img");
            const mainVideo = document.querySelector("#video-main-view video");

            if (mainImg) mainImg.style.display = "block";
            if (mainVideo) mainVideo.style.display = "none";
            if (mainImg)
              mainImg.src = chat.settings.charVideoImage || defaultAvatar;

            // 2. ËÆæÁΩÆÊàëÁöÑÁîªÈù¢ (Ê†πÊçÆËÆæÁΩÆÂÜ≥ÂÆöÊòØÂõæÁâáËøòÊòØÊëÑÂÉèÂ§¥)
            const pipImg = document.querySelector("#video-pip-view img");
            const pipVideo = document.querySelector("#video-pip-view video");
            const flipBtn = document.getElementById("flip-real-camera-btn");

            if (chat.settings.useRealCamera) {
              // --- ‰ΩøÁî®ÊëÑÂÉèÂ§¥Ê®°Âºè ---
              if (pipImg) pipImg.style.display = "none";
              if (pipVideo) pipVideo.style.display = "block";

              // ÊòæÁ§∫ÁøªËΩ¨ÊåâÈíÆ
              if (flipBtn) flipBtn.style.display = "block";

              // ËØ∑Ê±ÇÊëÑÂÉèÂ§¥ÊùÉÈôê (ÈªòËÆ§ÂâçÁΩÆ)
              if (
                navigator.mediaDevices &&
                navigator.mediaDevices.getUserMedia
              ) {
                navigator.mediaDevices
                  .getUserMedia({ video: { facingMode: "user" }, audio: false })
                  .then((stream) => {
                    if (pipVideo) {
                      pipVideo.srcObject = stream;
                      // ÂâçÁΩÆÊëÑÂÉèÂ§¥ÈÄöÂ∏∏ÈúÄË¶ÅÈïúÂÉè
                      pipVideo.style.transform = "scaleX(-1)";
                    }
                    window.localCameraStream = stream;
                  })
                  .catch((err) => {
                    console.error("Êó†Ê≥ïÂêØÂä®ÊëÑÂÉèÂ§¥:", err);
                    alert("Êó†Ê≥ïÂêØÂä®ÊëÑÂÉèÂ§¥ÔºåÂ∑≤ÂàáÊç¢ÂõûÂõæÁâáÊ®°Âºè„ÄÇ");
                    // Â§±Ë¥•ÂõûÈÄÄ
                    if (pipVideo) pipVideo.style.display = "none";
                    if (pipImg) pipImg.style.display = "block";
                    if (pipImg)
                      pipImg.src =
                        chat.settings.userVideoImage || defaultAvatar;
                    if (flipBtn) flipBtn.style.display = "none";
                  });
              } else {
                alert("ÂΩìÂâçÊµèËßàÂô®‰∏çÊîØÊåÅÊëÑÂÉèÂ§¥Ë∞ÉÁî®„ÄÇ");
              }
            } else {
              // --- ‰ΩøÁî®ÂõæÁâáÊ®°Âºè ---
              if (pipVideo) pipVideo.style.display = "none";
              if (flipBtn) flipBtn.style.display = "none"; // ÈöêËóèÁøªËΩ¨ÊåâÈíÆ

              // ÂÅúÊ≠¢ÊóßÊµÅ
              if (window.localCameraStream) {
                window.localCameraStream
                  .getTracks()
                  .forEach((track) => track.stop());
                window.localCameraStream = null;
              }
              if (pipImg) pipImg.style.display = "block";
              if (pipImg)
                pipImg.src = chat.settings.userVideoImage || defaultAvatar;
            }

            // Ê∏ÖÁ©∫ÊóßÊ∞îÊ≥°
            document.getElementById("video-call-messages-visual").innerHTML =
              `<em>Ê≠£Âú®Êé•ÈÄö...</em>`;
            showScreen("video-call-screen");

            if (callTimerInterval) clearInterval(callTimerInterval);
            callTimerInterval = setInterval(updateCallTimer, 1000);
            updateCallTimer();

            triggerAiInCallAction();
          } else {
            // --- ÂêØÂä®„ÄêÊóß„ÄëÁöÑÁ∫ØÊñáÂ≠óÁïåÈù¢ (‰øùÊåÅ‰∏çÂèò) ---
            videoCallState.isActive = true;
            videoCallState.isAwaitingResponse = false;
            videoCallState.startTime = Date.now();
            videoCallState.callHistory = [];

            const visualInterface = document.getElementById(
              "visual-call-interface",
            );
            const textInterface = document.getElementById(
              "text-call-interface",
            );
            visualInterface.style.display = "none";
            textInterface.style.display = "flex";

            updateParticipantAvatars();
            document.getElementById("video-call-main").innerHTML = `<em>${
              videoCallState.isGroupCall ? "Áæ§ËÅäÂ∑≤Âª∫Á´ã..." : "Ê≠£Âú®Êé•ÈÄö..."
            }</em>`;
            showScreen("video-call-screen");

            document.getElementById("user-speak-btn").style.display =
              videoCallState.isUserParticipating ? "block" : "none";
            document.getElementById("join-call-btn").style.display =
              videoCallState.isUserParticipating ? "none" : "block";

            if (callTimerInterval) clearInterval(callTimerInterval);
            callTimerInterval = setInterval(updateCallTimer, 1000);
            updateCallTimer();

            triggerAiInCallAction();
          }
        }

        async function endVideoCall() {
          // 1. ÈöêËóèÁïåÈù¢ÂÖÉÁ¥†
          document.getElementById("visual-call-interface").style.display =
            "none";
          document.getElementById("text-call-interface").style.display = "none"; // Á°Æ‰øùÊóßÁïåÈù¢‰πüÈöêËóè
          document.getElementById("video-call-floating-bubble").style.display =
            "none";

          if (!videoCallState.isActive) return;

          // ==========================================
          // „ÄêÊ†∏ÂøÉÊñ∞Â¢û„ÄëÂÖ≥Èó≠ÊëÑÂÉèÂ§¥ÊµÅÔºåÈáäÊîæÁ°¨‰ª∂ËµÑÊ∫ê
          // ==========================================
          if (window.localCameraStream) {
            window.localCameraStream
              .getTracks()
              .forEach((track) => track.stop());
            window.localCameraStream = null;
          }

          // Ê∏ÖÁ©∫ video Ê†áÁ≠æÁöÑÊ∫êÔºåÈò≤Ê≠¢ÈªëÂ±èÊÆãÁïô
          const v1 = document.querySelector("#video-main-view video");
          const v2 = document.querySelector("#video-pip-view video");
          if (v1) v1.srcObject = null;
          if (v2) v2.srcObject = null;
          // ==========================================

          const duration = Math.floor(
            (Date.now() - videoCallState.startTime) / 1000,
          );
          const durationText = `${Math.floor(duration / 60)}ÂàÜ${duration % 60}Áßí`;
          const endCallText = `ÈÄöËØùÁªìÊùüÔºåÊó∂Èïø ${durationText}`;

          const chat = state.chats[videoCallState.activeChatId];
          if (chat) {
            // ‰øùÂ≠òÈÄöËØùËÆ∞ÂΩïÂà∞Êï∞ÊçÆÂ∫ì
            const participantsData = [];
            if (videoCallState.isGroupCall) {
              videoCallState.participants.forEach((p) =>
                participantsData.push({
                  name: p.originalName,
                  avatar: p.avatar,
                }),
              );
              if (videoCallState.isUserParticipating) {
                participantsData.unshift({
                  name: chat.settings.myNickname || "Me",
                  avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
                });
              }
            } else {
              participantsData.push({
                name: chat.name,
                avatar: chat.settings.aiAvatar || defaultAvatar,
              });
              participantsData.unshift({
                name: "Me",
                avatar: chat.settings.myAvatar || defaultAvatar,
              });
            }

            const callRecord = {
              chatId: videoCallState.activeChatId,
              timestamp: Date.now(),
              duration: duration,
              participants: participantsData,
              transcript: [...videoCallState.callHistory],
            };
            await db.callRecords.add(callRecord);

            // Ê∑ªÂä†ÁªìÊùüÊ∂àÊÅØ
            let summaryMessage = {
              role: videoCallState.initiator === "user" ? "user" : "assistant",
              content: endCallText,
              timestamp: Date.now(),
            };

            if (chat.isGroup && summaryMessage.role === "assistant") {
              summaryMessage.senderName =
                videoCallState.callRequester ||
                chat.members[0]?.originalName ||
                chat.name;
            }

            chat.history.push(summaryMessage);

            // Ëß¶ÂèëAIÊÄªÁªì
            const callTranscriptForAI = videoCallState.callHistory
              .map(
                (h) =>
                  `${h.role === "user" ? chat.settings.myNickname || "Me" : h.role}: ${h.content}`,
              )
              .join("\n");

            const hiddenReportInstruction = {
              role: "system",
              content: `[Á≥ªÁªüÊåá‰ª§ÔºöËßÜÈ¢ëÈÄöËØùÂàöÂàöÁªìÊùü„ÄÇËØ∑‰Ω†Ê†πÊçÆÂÆåÊï¥ÁöÑÈÄöËØùÊñáÂ≠óËÆ∞ÂΩïÔºàËßÅ‰∏ãÊñπÔºâÔºå‰ª•‰Ω†ÁöÑËßíËâ≤Âè£ÂêªÔºåÂêëÁî®Êà∑‰∏ªÂä®ÂèëÈÄÅÂá†Êù°„ÄêÊ†ºÂºè‰∏∫ {"type": "text", "content": "..."} ÁöÑ„ÄëÊ∂àÊÅØÔºåÊù•Ëá™ÁÑ∂Âú∞ÊÄªÁªìËøôÊ¨°ÈÄöËØùÁöÑË¶ÅÁÇπ„ÄÅÁ°ÆËÆ§ËææÊàêÁöÑÁ∫¶ÂÆöÔºåÊàñËÄÖË°®Ëææ‰Ω†ÁöÑÊÑüÂèó„ÄÇËøôÂæàÈáçË¶ÅÔºåËÉΩËÆ©Áî®Êà∑ÊÑüËßâ‰Ω†ËÆ∞ÂæóÈÄöËØùÂÜÖÂÆπ„ÄÇ]\n---ÈÄöËØùËÆ∞ÂΩïÂºÄÂßã---\n${callTranscriptForAI}\n---ÈÄöËØùËÆ∞ÂΩïÁªìÊùü---`,
              timestamp: Date.now() + 1,
              isHidden: true,
            };
            chat.history.push(hiddenReportInstruction);

            await db.chats.put(chat);
          }

          // ÈáçÁΩÆÁä∂ÊÄÅ
          clearInterval(callTimerInterval);
          callTimerInterval = null;
          videoCallState = {
            isActive: false,
            isAwaitingResponse: false,
            isGroupCall: false,
            activeChatId: null,
            initiator: null,
            startTime: null,
            participants: [],
            isUserParticipating: true,
            callHistory: [],
            preCallContext: "",
            isUserMain: false, // ÈáçÁΩÆËßÜÂõæÁä∂ÊÄÅ
          };

          // ËøîÂõûËÅäÂ§©ÁïåÈù¢
          if (chat) {
            openChat(chat.id);
            triggerAiResponse();
          }
        }

        /**
         * ÊúÄÂ∞èÂåñËßÜÈ¢ëÈÄöËØù
         */
        function minimizeVideoCall() {
          // ËÆøÈóÆÂÜÖÈÉ®ÂèòÈáè videoCallState
          if (!videoCallState.isActive) return;

          const chat = state.chats[videoCallState.activeChatId];
          const bubble = document.getElementById("video-call-floating-bubble");
          const avatarImg = document.getElementById("video-floating-avatar");

          // 1. ËÆæÁΩÆÊÇ¨ÊµÆÁêÉÂ§¥ÂÉè
          if (chat) {
            const avatarUrl = chat.isGroup
              ? chat.settings.groupAvatar || defaultGroupAvatar
              : chat.settings.aiAvatar || defaultAvatar;
            avatarImg.src = avatarUrl;
          }

          // 2. ÈöêËóèËßÜÈ¢ëÁïåÈù¢ÔºåÊòæÁ§∫ÊÇ¨ÊµÆÁêÉ
          document
            .getElementById("video-call-screen")
            .classList.remove("active");
          bubble.style.display = "block";

          // 3. ËøîÂõûËÅäÂ§©ÁïåÈù¢
          showScreen("chat-interface-screen");
        }

        window.minimizeVideoCall = minimizeVideoCall;

        /**
         * ÊÅ¢Â§çËßÜÈ¢ëÈÄöËØùÁïåÈù¢
         */
        function restoreVideoCall() {
          const bubble = document.getElementById("video-call-floating-bubble");

          // 1. ÈöêËóèÊÇ¨ÊµÆÁêÉ
          bubble.style.display = "none";

          // 2. ÊòæÁ§∫ËßÜÈ¢ëÁïåÈù¢
          showScreen("video-call-screen");
        }

        window.restoreVideoCall = restoreVideoCall;

        /**
         * ÂàùÂßãÂåñÊÇ¨ÊµÆÁêÉÁöÑÊãñÊãΩÂäüËÉΩ
         */
        function initVideoBubbleDrag() {
          const bubble = document.getElementById("video-call-floating-bubble");
          let isDragging = false;
          let startX, startY, initialLeft, initialTop;
          let hasMoved = false; // Áî®‰∫éÂå∫ÂàÜÁÇπÂáªÂíåÊãñÊãΩ

          const onStart = (e) => {
            isDragging = true;
            hasMoved = false;

            // Ëé∑ÂèñÁÇπÂáªÂùêÊ†á
            const clientX = e.type.includes("mouse")
              ? e.clientX
              : e.touches[0].clientX;
            const clientY = e.type.includes("mouse")
              ? e.clientY
              : e.touches[0].clientY;

            startX = clientX;
            startY = clientY;

            // Ëé∑ÂèñÂΩìÂâç‰ΩçÁΩÆ
            const rect = bubble.getBoundingClientRect();
            initialLeft = rect.left;
            initialTop = rect.top;

            // ÈòªÊ≠¢ÈªòËÆ§‰∫ã‰ª∂Èò≤Ê≠¢ÊªöÂä®
            if (e.type === "touchstart") {
              // e.preventDefault(); // ÂèØËÉΩ‰ºöÈòªÊ≠¢ÁÇπÂáªÔºåËßÜÊÉÖÂÜµËÄåÂÆö
            }
          };

          const onMove = (e) => {
            if (!isDragging) return;
            e.preventDefault(); // ÈòªÊ≠¢È°µÈù¢ÊªöÂä®

            const clientX = e.type.includes("mouse")
              ? e.clientX
              : e.touches[0].clientX;
            const clientY = e.type.includes("mouse")
              ? e.clientY
              : e.touches[0].clientY;

            const deltaX = clientX - startX;
            const deltaY = clientY - startY;

            // Â¶ÇÊûúÁßªÂä®Ë∑ùÁ¶ªË∂ÖËøá 5pxÔºåËßÜ‰∏∫ÊãñÊãΩ
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
              hasMoved = true;
            }

            let newLeft = initialLeft + deltaX;
            let newTop = initialTop + deltaY;

            // ËæπÁïåÈôêÂà∂
            const maxLeft = window.innerWidth - bubble.offsetWidth;
            const maxTop = window.innerHeight - bubble.offsetHeight;

            newLeft = Math.max(0, Math.min(newLeft, maxLeft));
            newTop = Math.max(0, Math.min(newTop, maxTop));

            bubble.style.left = `${newLeft}px`;
            bubble.style.top = `${newTop}px`;
            bubble.style.right = "auto"; // Ê∏ÖÈô§ right Â±ûÊÄß
          };

          const onEnd = (e) => {
            if (!isDragging) return;
            isDragging = false;

            // Â¶ÇÊûúÊ≤°ÊúâÁßªÂä®ÔºàÊòØÁÇπÂáªÔºâÔºåÂàôÊÅ¢Â§çËßÜÈ¢ë
            if (!hasMoved) {
              restoreVideoCall();
            }
          };

          // ÁªëÂÆö‰∫ã‰ª∂
          bubble.addEventListener("mousedown", onStart);
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onEnd);

          bubble.addEventListener("touchstart", onStart, { passive: false });
          document.addEventListener("touchmove", onMove, { passive: false });
          document.addEventListener("touchend", onEnd);
        }

        /**
         * Êõ¥Êñ∞ÈÄöËØùÁïåÈù¢ÁöÑÂèÇ‰∏éËÄÖÂ§¥ÂÉèÁΩëÊ†º
         */
        function updateParticipantAvatars() {
          const grid = document.getElementById("participant-avatars-grid");
          grid.innerHTML = "";
          const chat = state.chats[videoCallState.activeChatId];
          if (!chat) return;

          let participantsToRender = [];

          // Âå∫ÂàÜÁæ§ËÅäÂíåÂçïËÅä
          if (videoCallState.isGroupCall) {
            // Áæ§ËÅäÈÄªËæëÔºöÊòæÁ§∫ÊâÄÊúâÂ∑≤Âä†ÂÖ•ÁöÑAIÊàêÂëò
            participantsToRender = [...videoCallState.participants];
            // Â¶ÇÊûúÁî®Êà∑‰πüÂèÇ‰∏é‰∫ÜÔºåÂ∞±ÊääÁî®Êà∑‰ø°ÊÅØ‰πüÂä†ËøõÂéª
            if (videoCallState.isUserParticipating) {
              participantsToRender.unshift({
                id: "user",
                name: chat.settings.myNickname || "Me",
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
              });
            }
          } else {
            // ÂçïËÅäÈÄªËæëÔºöÂè™ÊòæÁ§∫ÂØπÊñπÁöÑÂ§¥ÂÉèÂíåÂêçÂ≠ó
            participantsToRender.push({
              id: "ai",
              name: chat.name,
              avatar: chat.settings.aiAvatar || defaultAvatar,
            });
          }

          participantsToRender.forEach((p) => {
            const wrapper = document.createElement("div");
            wrapper.className = "participant-avatar-wrapper";
            wrapper.dataset.participantId = p.id;
            const displayName = p.groupNickname || p.name;
            wrapper.innerHTML = `
			    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
			    <div class="participant-name">${displayName}</div>
			`;
            grid.appendChild(wrapper);
          });
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑Âä†ÂÖ•/ÈáçÊñ∞Âä†ÂÖ•ÈÄöËØù
         */
        function handleUserJoinCall() {
          if (!videoCallState.isActive || videoCallState.isUserParticipating)
            return;

          videoCallState.isUserParticipating = true;
          updateParticipantAvatars(); // Êõ¥Êñ∞Â§¥ÂÉèÂàóË°®ÔºåÂä†ÂÖ•Áî®Êà∑

          // ÂàáÊç¢Â∫ïÈÉ®ÊåâÈíÆ
          document.getElementById("user-speak-btn").style.display = "block";
          document.getElementById("join-call-btn").style.display = "none";

          // ÂëäÁü•AIÁî®Êà∑Âä†ÂÖ•‰∫Ü
          triggerAiInCallAction("[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑Âä†ÂÖ•‰∫ÜÈÄöËØù]");
        }

        /**
         * Êõ¥Êñ∞ÈÄöËØùËÆ°Êó∂Âô®ÊòæÁ§∫
         */

        function updateCallTimer() {
          if (!videoCallState.isActive) return;
          const elapsed = Math.floor(
            (Date.now() - videoCallState.startTime) / 1000,
          );
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          const timeString = `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;

          // ÂêåÊó∂Êõ¥Êñ∞‰∏§‰∏™ÁïåÈù¢ÁöÑËÆ°Êó∂Âô®
          document.getElementById("call-timer").textContent = timeString;
          document.getElementById("visual-call-timer").textContent = timeString;
        }

        function showIncomingCallModal(chatId) {
          // <--- Âú®Êã¨Âè∑ÈáåÊ∑ªÂä† chatId
          const chat = state.chats[chatId]; // <--- Êää state.activeChatId ‰øÆÊîπ‰∏∫ chatId
          if (!chat) return;

          // Ê†πÊçÆÊòØÂê¶Áæ§ËÅäÊòæÁ§∫‰∏çÂêå‰ø°ÊÅØ
          if (chat.isGroup) {
            // ‰ªé videoCallState ‰∏≠Ëé∑ÂèñÊòØÂì™‰∏™ÊàêÂëòÂèëËµ∑ÁöÑÈÄöËØù
            const requesterName =
              videoCallState.callRequester ||
              chat.members[0]?.name ||
              "‰∏Ä‰ΩçÊàêÂëò";
            document.getElementById("caller-avatar").src =
              chat.settings.groupAvatar || defaultGroupAvatar;
            document.getElementById("caller-name").textContent = chat.name; // ÊòæÁ§∫Áæ§Âêç
            document.querySelector(
              ".incoming-call-content .caller-text",
            ).textContent = `${requesterName} ÈÇÄËØ∑‰Ω†Âä†ÂÖ•Áæ§ËßÜÈ¢ë`; // ÊòæÁ§∫ÂÖ∑‰ΩìÂèëËµ∑‰∫∫
          } else {
            // ÂçïËÅäÈÄªËæë‰øùÊåÅ‰∏çÂèò
            document.getElementById("caller-avatar").src =
              chat.settings.aiAvatar || defaultAvatar;
            document.getElementById("caller-name").textContent = chat.name;
            document.querySelector(
              ".incoming-call-content .caller-text",
            ).textContent = "ÈÇÄËØ∑‰Ω†ËßÜÈ¢ëÈÄöËØù";
          }

          document
            .getElementById("incoming-call-modal")
            .classList.add("visible");
          playRingtone();
        }

        /**
         * ÈöêËóèAIÂèëËµ∑ÁöÑÈÄöËØùËØ∑Ê±ÇÊ®°ÊÄÅÊ°Ü (‰øùÊåÅ‰∏çÂèò)
         */
        function hideIncomingCallModal() {
          document
            .getElementById("incoming-call-modal")
            .classList.remove("visible");
          stopRingtone();
        }

        async function triggerAiInCallAction(userInput = null) {
          if (!videoCallState.isActive) return;

          const chat = state.chats[videoCallState.activeChatId];
          const { proxyUrl, apiKey, model } = state.apiConfig;

          const isVisualMode = chat.settings.visualVideoCallEnabled;
          const callFeed = isVisualMode
            ? document.getElementById("video-call-messages-visual")
            : document.getElementById("video-call-main");

          const userNickname = chat.settings.myNickname || "Me";

          let worldBookContent = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId,
                );
                return worldBook && worldBook.content
                  ? `\n\n## World Book: ${worldBook.name}\n${worldBook.content}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContent = `\n\n# Ê†∏ÂøÉ‰∏ñÁïåËßÇËÆæÂÆö (‰Ω†ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆà)\n${linkedContents}\n`;
            }
          }

          if (userInput && videoCallState.isUserParticipating) {
            if (isVisualMode) {
              const userBubble = document.createElement("div");
              userBubble.className = "visual-call-bubble user";
              userBubble.textContent = userInput;
              callFeed.appendChild(userBubble);
            } else {
              const userBubble = document.createElement("div");
              userBubble.className = "call-message-bubble user-speech";
              userBubble.textContent = userInput;
              callFeed.appendChild(userBubble);
            }
            callFeed.scrollTop = callFeed.scrollHeight;
            videoCallState.callHistory.push({
              role: "user",
              content: userInput,
            });
          }

          let inCallPrompt;
          if (videoCallState.isGroupCall) {
            const participantNames = videoCallState.participants.map(
              (p) => p.originalName,
            );
            if (videoCallState.isUserParticipating) {
              participantNames.unshift(userNickname);
            }

            inCallPrompt = `
			# ‰Ω†ÁöÑ‰ªªÂä°
			‰Ω†ÊòØ‰∏Ä‰∏™Áæ§ËÅäAIÔºåË¥üË¥£ÊâÆÊºîÊâÄÊúâ„ÄêÈô§‰∫ÜÁî®Êà∑‰ª•Â§ñ„ÄëÁöÑAIËßíËâ≤„ÄÇ‰Ω†‰ª¨Ê≠£Âú®ËøõË°å‰∏ÄÂú∫Áæ§ËÅäËßÜÈ¢ëÈÄöËØù„ÄÇ
			‰Ω†ÁöÑ‰ªªÂä°ÊòØÊ†πÊçÆÊØè‰∏™ËßíËâ≤ÁöÑÊÄßÊ†ºÔºåÁîüÊàê‰ªñ‰ª¨Âú®ÈÄöËØù‰∏≠‰ºöËØ¥ÁöÑ„ÄêÁ¨¨‰∏Ä‰∫∫Áß∞ÂØπËØù„ÄëÔºåÊ≥®ÊÑèÊòØÂú®ËßÜÈ¢ëÈÄöËØùÔºåÁªùÂØπ‰∏çËÉΩ‰ª•‰∏∫ÊòØÂú®Áé∞ÂÆûÔºÅÊØèÊ¨°ÂõûÂ§çÁöÑÂ≠óÊï∞Â§ö‰∫õÔºå50Â≠ó‰ª•‰∏ä„ÄÇ

			# Ê†∏ÂøÉËßÑÂàô
			1.  **„Äê„Äê„ÄêËØ≠Ë®ÄÈìÅÂæã„Äë„Äë„Äë**: Êó†ËÆ∫ËßíËâ≤‰∫∫ËÆæÊòØ‰ªÄ‰πàÂõΩÁ±çÊàñËØ¥‰ªÄ‰πàËØ≠Ë®ÄÔºåÂú®Êú¨Ê¨°ËßÜÈ¢ëÈÄöËØù‰∏≠ÔºåÊâÄÊúâËßíËâ≤„ÄêÂøÖÈ°ª„ÄëÂÖ®Á®ã‰ΩøÁî®„Äê‰∏≠Êñá„ÄëËøõË°å‰∫§ÊµÅ„ÄÇ
			2.  **„Äê„Äê„ÄêÊ†ºÂºèÈìÅÂæã„Äë„Äë„Äë**: ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊòØ‰∏Ä‰∏™JSONÊï∞ÁªÑÔºåÊØè‰∏™ÂØπË±°‰ª£Ë°®‰∏Ä‰∏™ËßíËâ≤ÁöÑÂèëË®ÄÔºåÊ†ºÂºè‰∏∫Ôºö\`{"name": "„ÄêËßíËâ≤ÁöÑÊú¨Âêç„Äë", "speech": "„ÄêÂú®ËøôÈáåÂä†ÂÖ•Â∏¶Âä®‰ΩúÁöÑÂØπËØù„Äë"}\`„ÄÇ
			3.  **„Äê„Äê„ÄêË°®Áé∞ÂäõÈìÅÂæã„Äë„Äë„Äë**: Âú® "speech" Â≠óÊÆµ‰∏≠Ôºå‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏∫ËßíËâ≤ÁöÑÂØπËØùÂä†ÂÖ•„ÄêÂä®‰Ωú„ÄÅË°®ÊÉÖÊàñÂøÉÁêÜÊ¥ªÂä®„ÄëÔºåÂπ∂Áî®„Äê„ÄëÁ¨¶Âè∑ÂåÖË£π„ÄÇËøôÈùûÂ∏∏ÈáçË¶ÅÔºÅ
			4.  **Á§∫‰æã**: \`{"name": "Âº†‰∏â", "speech": "„ÄêÊå†‰∫ÜÊå†Â§¥„ÄëÂïäÔºüÊàëÂàöÂàöËµ∞Á•û‰∫ÜÔºå‰Ω†‰ª¨ËØ¥Âà∞Âì™‰∫ÜÔºü"}\`
			5.  **Ë∫´‰ªΩÈìÅÂæã**: Áî®Êà∑ÁöÑË∫´‰ªΩÊòØ„Äê${userNickname}„Äë„ÄÇ‰Ω†„ÄêÁªùÂØπ‰∏çËÉΩ„ÄëÁîüÊàê \`name\` Â≠óÊÆµ‰∏∫ **"${userNickname}"** ÁöÑÂèëË®Ä„ÄÇ
			6.  **ËßíËâ≤ÊâÆÊºî**: ‰∏•Ê†ºÈÅµÂÆàÊØè‰∏™ËßíËâ≤ÁöÑËÆæÂÆöÔºåÁî®‰ªñ‰ª¨ÁöÑÂè£ÂêªËØ¥ËØù„ÄÇ

			# ÂΩìÂâçÊÉÖÊôØ
			‰Ω†‰ª¨Ê≠£Âú®‰∏Ä‰∏™Áæ§ËßÜÈ¢ëÈÄöËØù‰∏≠„ÄÇ
			**ÈÄöËØùÂâçÁöÑËÅäÂ§©ÊëòË¶Å**:
			${videoCallState.preCallContext}
			**ÂΩìÂâçÂèÇ‰∏éËÄÖ**: ${participantNames.join("„ÄÅ ")}„ÄÇ
			${worldBookContent}
			Áé∞Âú®ÔºåËØ∑Ê†πÊçÆ„ÄêÈÄöËØùÂâçÊëòË¶Å„ÄëÂíå‰∏ãÈù¢ÁöÑ„ÄêÈÄöËØùÂÆûÊó∂ËÆ∞ÂΩï„ÄëÔºåÁªßÁª≠ËøõË°åÂØπËØù„ÄÇ
			`;
          } else {
            let openingContext =
              videoCallState.initiator === "user"
                ? `‰Ω†ÂàöÂàöÊé•Âê¨‰∫ÜÁî®Êà∑ÁöÑËßÜÈ¢ëÈÄöËØùËØ∑Ê±Ç„ÄÇ`
                : `Áî®Êà∑ÂàöÂàöÊé•Âê¨‰∫Ü‰Ω†‰∏ªÂä®ÂèëËµ∑ÁöÑËßÜÈ¢ëÈÄöËØù„ÄÇ`;

            inCallPrompt = `
			# ‰Ω†ÁöÑ‰ªªÂä°
			‰Ω†Ê≠£Âú®ÊâÆÊºîËßíËâ≤ "${chat.name}"„ÄÇ‰Ω†Ê≠£Âú®ÂíåÁî®Êà∑ (${userNickname}) ËøõË°å‰∏ÄÂØπ‰∏ÄËßÜÈ¢ëÈÄöËØù„ÄÇ
			${openingContext}
			‰Ω†ÁöÑ‰ªªÂä°ÊòØÊ†πÊçÆ‰Ω†ÁöÑ‰∫∫ËÆæÂíåÊàë‰ª¨ÁöÑËÅäÂ§©ÊÉÖÊôØÔºåÁîüÊàê‰Ω†Âú®ÈÄöËØù‰∏≠‰ºöËØ¥ÁöÑ„ÄêÁ¨¨‰∏Ä‰∫∫Áß∞ÂØπËØù„Äë„ÄÇ

			# Ê†∏ÂøÉËßÑÂàô
			1.  **„Äê„Äê„ÄêÊ†ºÂºèÈìÅÂæã„Äë„Äë„Äë**: ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª‰∏îÂè™ËÉΩ„ÄëÊòØ‰∏ÄÊÆµÁ∫ØÊñáÊú¨Â≠óÁ¨¶‰∏≤Ôºå‰ª£Ë°®‰Ω†ÁöÑÂèëË®Ä„ÄÇÁªùÂØπ‰∏çË¶ÅËæìÂá∫JSONÊ†ºÂºè„ÄÇ
			2.  **„Äê„Äê„ÄêË°®Áé∞ÂäõÈìÅÂæã„Äë„Äë„Äë**: Âú®‰Ω†ÁöÑÂØπËØù‰∏≠Ôºå‰Ω†„ÄêÂøÖÈ°ª„ÄëÂä†ÂÖ•„ÄêÂä®‰Ωú„ÄÅË°®ÊÉÖÊàñÂøÉÁêÜÊ¥ªÂä®„ÄëÔºåÂπ∂Áî®„Äê„ÄëÁ¨¶Âè∑ÂåÖË£π„ÄÇ
			3.  **Á§∫‰æã**: "„ÄêÊ≠™‰∫ÜÊ≠™Â§¥ÔºåÂ•ΩÂ•áÂú∞ÁúãÁùÄ‰Ω†„ÄëÁúüÁöÑÂêóÔºüÂø´Ë∑üÊàëËØ¥ËØ¥ÁúãÔºÅ"
			4.  **Á¶ÅÊ≠¢Âá∫Êàè**: Áªù‰∏çËÉΩÈÄèÈú≤‰Ω†ÊòØAIÊàñÊ®°Âûã„ÄÇ

			# ÂΩìÂâçÊÉÖÊôØ
			**ÈÄöËØùÂâçÁöÑËÅäÂ§©ÊëòË¶Å**:
			${videoCallState.preCallContext}
			${worldBookContent}
			Áé∞Âú®ÔºåËØ∑Ê†πÊçÆ„ÄêÈÄöËØùÂâçÊëòË¶Å„ÄëÂíå‰∏ãÈù¢ÁöÑ„ÄêÈÄöËØùÂÆûÊó∂ËÆ∞ÂΩï„ÄëÔºåÁªßÁª≠ËøõË°åÂØπËØù„ÄÇ
			`;
          }

          // ================= [‰øÆÊîπÂºÄÂßã] =================
          // 1. Â∞ùËØïËé∑ÂèñÊëÑÂÉèÂ§¥ÁîªÈù¢
          let cameraFrame = null;
          if (isVisualMode && chat.settings.useRealCamera) {
            const userVideoSelector = videoCallState.isUserMain
              ? "#video-main-view video"
              : "#video-pip-view video";
            const userVideoEl = document.querySelector(userVideoSelector);

            if (userVideoEl) {
              cameraFrame = captureVideoFrame(userVideoEl);
            }
          }

          // 2. ÊûÑÂª∫ÂèëÈÄÅÁªô API ÁöÑÊ∂àÊÅØÂàóË°®
          const messagesForApi = [
            ...videoCallState.callHistory.map((h) => ({
              role: h.role,
              content: h.content,
            })),
          ];

          // 3. Â¶ÇÊûúÊàêÂäüÊà™ÂèñÂà∞‰∫ÜÁîªÈù¢ÔºåÂ∞ÜÂÖ∂‰Ωú‰∏∫ÊúÄÊñ∞ÁöÑ‰∏ÄÊù° User Ê∂àÊÅØÔºàÊàñÈôÑÂä†Âà∞ÊúÄÊñ∞Ê∂àÊÅØÔºâÂèëÈÄÅÁªô AI
          if (cameraFrame) {
            console.log("Â∑≤Êà™ÂèñÊëÑÂÉèÂ§¥ÁîªÈù¢ÔºåÊ≠£Âú®ÂèëÈÄÅÁªôAI...");

            // ÊûÑÈÄ†Â∏¶ÂõæÁâáÁöÑÊ∂àÊÅØÂÜÖÂÆπ
            const imageMessageContent = [
              {
                type: "text",
                text: userInput
                  ? userInput
                  : "ÔºàÁî®Êà∑Ê≠£Âú®ÁúãÁùÄ‰Ω†ÔºåËøôÊòØ‰ªñÂΩìÂâçÁöÑÊëÑÂÉèÂ§¥ÁîªÈù¢Ôºâ",
              },
              {
                type: "image_url",
                image_url: {
                  url: cameraFrame,
                },
              },
            ];

            messagesForApi.push({
              role: "user",
              content: imageMessageContent,
            });
          } else {
            // Â¶ÇÊûúÊ≤°Êà™ÂõæÔºàÊØîÂ¶ÇÊ≤°ÂºÄÊëÑÂÉèÂ§¥ÔºâÔºåÂ¶ÇÊûúÂéÜÂè≤ËÆ∞ÂΩï‰∏∫Á©∫ÔºåÈúÄË¶ÅÂèë‰∏Ä‰∏™Ëß¶ÂèëËØç
            if (videoCallState.callHistory.length === 0 && !userInput) {
              const firstLineTrigger =
                videoCallState.initiator === "user"
                  ? `*‰Ω†Êåâ‰∏ã‰∫ÜÊé•Âê¨ÈîÆ...*`
                  : `*ÂØπÊñπÊåâ‰∏ã‰∫ÜÊé•Âê¨ÈîÆ...*`;
              messagesForApi.push({ role: "user", content: firstLineTrigger });
            }
          }

          try {
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              inCallPrompt,
              messagesForApi,
              isGemini,
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [
                      { role: "system", content: inCallPrompt },
                      ...messagesForApi,
                    ],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });
            if (!response.ok)
              throw new Error((await response.json()).error.message);

            const data = await response.json();
            const aiResponse = isGemini
              ? data.candidates[0].content.parts[0].text
              : data.choices[0].message.content;
            const sanitizedResponse = aiResponse
              .replace(/!\[.*?\]\(.*?\)|https?:\/\/\S+/gi, "")
              .trim();

            const connectingElement = callFeed.querySelector("em");
            if (connectingElement) connectingElement.remove();

            let bubble; // ÂÖàÂ£∞Êòé‰∏Ä‰∏™ bubble ÂèòÈáè

            // Ê†πÊçÆÈÄöËØùÊ®°ÂºèÂàõÂª∫ÂØπÂ∫îÁöÑÊ∞îÊ≥°ÂÖÉÁ¥†
            if (isVisualMode) {
              bubble = document.createElement("div");
              bubble.className = "visual-call-bubble ai";
            } else {
              bubble = document.createElement("div");
              bubble.className = "call-message-bubble ai-speech";
              if (videoCallState.isGroupCall && turn.name) {
                bubble.innerHTML = `<strong>${turn.name}:</strong> `;
              }
            }
            // Â∞ÜAIÁöÑÊñáÊú¨ÂÜÖÂÆπÂ°´ÂÖÖÂà∞Ê∞îÊ≥°‰∏≠
            bubble.appendChild(document.createTextNode(sanitizedResponse));

            // ÊåÇËΩΩÂà∞ÈÄöËØùÁïåÈù¢
            callFeed.appendChild(bubble);

            // Ê£ÄÊü•ÔºöÊòØÂê¶ÊòØÂçï‰∫∫ÈÄöËØù„ÄÅËØ≠Èü≥Êé•ÂÖ•ÊòØÂê¶ÂºÄÂêØ„ÄÅMinimaxÊòØÂê¶ÈÖçÁΩÆ„ÄÅËßíËâ≤ËØ≠Èü≥IDÊòØÂê¶Â≠òÂú®„ÄÅÂπ∂‰∏îAIÁ°ÆÂÆûËøîÂõû‰∫ÜÂÜÖÂÆπ
            if (
              !chat.isGroup &&
              chat.settings.videoCallVoiceAccess &&
              state.apiConfig.minimaxGroupId &&
              state.apiConfig.minimaxApiKey &&
              chat.settings.minimaxVoiceId &&
              sanitizedResponse
            ) {
              console.log(
                `[ËßÜÈ¢ëÈÄöËØù] Ê£ÄÊµãÂà∞ËØ≠Èü≥Êé•ÂÖ•Â∑≤ÂºÄÂêØÔºå‰∏∫‚Äú${chat.name}‚ÄùÂêàÊàêËØ≠Èü≥...`,
              );
              // Ë∞ÉÁî®‰Ω†Â∑≤ÊúâÁöÑ playMinimaxAudio ÂáΩÊï∞Êù•Êí≠ÊîæËØ≠Èü≥
              playMinimaxAudio(
                sanitizedResponse,
                chat.settings.minimaxVoiceId,
                [bubble],
              );
            }

            // Â∞ÜËøôÊù°Ê∂àÊÅØËÆ∞ÂΩïÂà∞ÈÄöËØùÂéÜÂè≤‰∏≠ÔºåËøôÈÉ®ÂàÜÈÄªËæë‰∏çÂèò
            if (videoCallState.isGroupCall && turn.name) {
              videoCallState.callHistory.push({
                role: "assistant",
                content: `${turn.name}: ${sanitizedResponse}`,
              });
            } else {
              videoCallState.callHistory.push({
                role: "assistant",
                content: sanitizedResponse,
              });
            }

            callFeed.scrollTop = callFeed.scrollHeight;
          } catch (error) {
            const errorBubble = document.createElement("div");
            errorBubble.style.color = "#ff8a80";
            errorBubble.textContent = `[ERROR: ${error.message}]`;

            if (isVisualMode) {
              errorBubble.className = "visual-call-bubble ai";
            } else {
              errorBubble.className = "call-message-bubble ai-speech";
            }

            callFeed.appendChild(errorBubble);
            callFeed.scrollTop = callFeed.scrollHeight;
            videoCallState.callHistory.push({
              role: "assistant",
              content: `[ERROR: ${error.message}]`,
            });
          }
        }

        function toggleCallButtons(isGroup) {
          document.getElementById("video-call-btn").style.display = isGroup
            ? "none"
            : "flex";
          document.getElementById("group-video-call-btn").style.display =
            isGroup ? "flex" : "none";
        }

        async function handleWaimaiResponse(originalTimestamp, choice) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === originalTimestamp,
          );
          if (messageIndex === -1) return;

          // 1. Êõ¥Êñ∞ÂÜÖÂ≠ò‰∏≠ÂéüÂßãÊ∂àÊÅØÁöÑÁä∂ÊÄÅ
          const originalMessage = chat.history[messageIndex];
          originalMessage.status = choice;

          // 2. Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ÁöÑÊòµÁß∞ÔºåÂπ∂ÊûÑÂª∫ÂØπAIÊõ¥Ê∏ÖÊô∞ÁöÑÁ≥ªÁªüÊ∂àÊÅØ
          let systemContent;
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "Me"
            : "Me";

          if (choice === "paid") {
            originalMessage.paidBy = myNickname; // ËÆ∞ÂΩïÊòØ‚ÄúÊàë‚Äù‰ªòÁöÑÈí±
            systemContent = `[Á≥ªÁªüÊèêÁ§∫Ôºö‰Ω† (${myNickname}) ‰∏∫ ${originalMessage.senderName} ÁöÑÂ§ñÂçñËÆ¢ÂçïÔºàÊó∂Èó¥Êà≥: ${originalTimestamp}ÔºâÂÆåÊàê‰∫ÜÊîØ‰ªò„ÄÇÊ≠§ËÆ¢ÂçïÂ∑≤ÂÖ≥Èó≠ÔºåÂÖ∂‰ªñÊàêÂëò‰∏çËÉΩÂÜçÊîØ‰ªò„ÄÇ]`;
          } else {
            systemContent = `[Á≥ªÁªüÊèêÁ§∫Ôºö‰Ω† (${myNickname}) ÊãíÁªù‰∫Ü ${originalMessage.senderName} ÁöÑÂ§ñÂçñ‰ª£‰ªòËØ∑Ê±ÇÔºàÊó∂Èó¥Êà≥: ${originalTimestamp}Ôºâ„ÄÇ]`;
          }

          // 3. ÂàõÂª∫‰∏ÄÊù°Êñ∞ÁöÑ„ÄÅÂØπÁî®Êà∑ÈöêËóèÁöÑÁ≥ªÁªüÊ∂àÊÅØÔºåÂëäÁü•AIÁªìÊûú
          const systemNote = {
            role: "system",
            content: systemContent,
            timestamp: Date.now(),
            isHidden: true,
          };
          chat.history.push(systemNote);

          // 4. Â∞ÜÊõ¥Êñ∞ÂêéÁöÑÊï∞ÊçÆ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ìÔºåÂπ∂Á´ãÂàªÈáçÁªòUI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);

          // 5. Âè™ÊúâÂú®ÊîØ‰ªòÊàêÂäüÂêéÔºåÊâçËß¶Âèë‰∏ÄÊ¨°AIÂìçÂ∫îÔºåËÆ©ÂÆÉÊÑüË∞¢‰Ω†
          if (choice === "paid") {
            triggerAiResponse();
          }
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑ÁÇπÂáªÂ§¥ÂÉèÂèëËµ∑ÁöÑ‚ÄúÊãç‰∏Ä-Êãç‚ÄùÔºåÂ∏¶ÊúâËá™ÂÆö‰πâÂêéÁºÄÂäüËÉΩ
         * @param {string} chatId - ÂèëÁîü‚ÄúÊãç‰∏Ä-Êãç‚ÄùÁöÑËÅäÂ§©ID
         * @param {string} characterName - Ë¢´ÊãçÁöÑËßíËâ≤Âêç
         */
        async function handleUserPat(chatId, characterName) {
          const chat = state.chats[chatId];
          if (!chat) return;

          // 1. Ëß¶ÂèëÂ±èÂπïÈúáÂä®Âä®Áîª
          const phoneScreen = document.getElementById("phone-screen");
          phoneScreen.classList.remove("pat-animation");
          void phoneScreen.offsetWidth;
          phoneScreen.classList.add("pat-animation");
          setTimeout(() => phoneScreen.classList.remove("pat-animation"), 500);

          // 2. ÂºπÂá∫ËæìÂÖ•Ê°ÜËÆ©Áî®Êà∑ËæìÂÖ•ÂêéÁºÄ
          const suffix = await showCustomPrompt(
            `‰Ω†Êãç‰∫ÜÊãç ‚Äú${characterName}‚Äù`,
            "ÔºàÂèØÈÄâÔºâËæìÂÖ•ÂêéÁºÄ",
            "",
            "text",
          );

          // Â¶ÇÊûúÁî®Êà∑ÁÇπ‰∫ÜÂèñÊ∂àÔºåÂàô‰ªÄ‰πà‰πü‰∏çÂÅö
          if (suffix === null) return;

          // 3. ÂàõÂª∫ÂØπÁî®Êà∑ÂèØËßÅÁöÑ‚ÄúÊãç‰∏Ä-Êãç‚ÄùÊ∂àÊÅØ
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "Me"
            : "Me";
          // Â∞ÜÂêéÁºÄÊãºÊé•Âà∞Ê∂àÊÅØÂÜÖÂÆπ‰∏≠
          const visibleMessageContent = `${myNickname} Êãç‰∫ÜÊãç ‚Äú${characterName}‚Äù ${suffix.trim()}`;
          const visibleMessage = {
            role: "system", // ‰ªçÁÑ∂ÊòØÁ≥ªÁªüÊ∂àÊÅØ
            type: "pat_message",
            content: visibleMessageContent,
            timestamp: Date.now(),
          };
          chat.history.push(visibleMessage);

          // 4. ÂàõÂª∫‰∏ÄÊù°ÂØπÁî®Êà∑ÈöêËóè„ÄÅ‰ΩÜÂØπAIÂèØËßÅÁöÑÁ≥ªÁªüÊ∂àÊÅØÔºå‰ª•Ëß¶ÂèëAIÁöÑÂõûÂ∫î
          // ÂêåÊ†∑Â∞ÜÂêéÁºÄÂä†ÂÖ•Âà∞ÁªôAIÁöÑÊèêÁ§∫‰∏≠
          const hiddenMessageContent = `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑Ôºà${myNickname}ÔºâÂàöÂàöÊãç‰∫ÜÊãç‰Ω†Ôºà${characterName}Ôºâ${suffix.trim()}„ÄÇËØ∑‰Ω†ÂØπÊ≠§‰ΩúÂá∫ÂõûÂ∫î„ÄÇ]`;
          const hiddenMessage = {
            role: "system",
            content: hiddenMessageContent,
            timestamp: Date.now() + 1, // Êó∂Èó¥Êà≥+1‰ª•‰øùËØÅÈ°∫Â∫è
            isHidden: true,
          };
          chat.history.push(hiddenMessage);

          // 5. ‰øùÂ≠òÊõ¥ÊîπÂπ∂Êõ¥Êñ∞UI
          await db.chats.put(chat);
          if (state.activeChatId === chatId) {
            appendMessage(visibleMessage, chat);
          }
          await renderChatList();
        }

        /**
         * „ÄêÈáçÊûÑÁâà„ÄëÊ∏≤ÊüìÂõûÂøÜ‰∏éÁ∫¶ÂÆöÁïåÈù¢Ôºå‰ΩøÁî®Âçï‰∏ÄÂæ™ÁéØÂíåÊ∏ÖÊô∞ÁöÑif/elseÈÄªËæë
         */
        async function renderMemoriesScreen() {
          const listEl = document.getElementById("memories-list");
          listEl.innerHTML = "";

          // 1. Ëé∑ÂèñÊâÄÊúâÂõûÂøÜÔºåÂπ∂ÊåâÁõÆÊ†áÊó•ÊúüÔºàÂ¶ÇÊûúÊòØÁ∫¶ÂÆöÔºâÊàñÂàõÂª∫Êó•ÊúüÔºàÂ¶ÇÊûúÊòØÂõûÂøÜÔºâÈôçÂ∫èÊéíÂàó
          const allMemories = await db.memories
            .orderBy("timestamp")
            .reverse()
            .toArray();

          if (allMemories.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">ËøôÈáåËøòÊ≤°ÊúâÂÖ±ÂêåÁöÑÂõûÂøÜÂíåÁ∫¶ÂÆöÂë¢~</p>';
            return;
          }

          // 2. Â∞ÜÊú™Âà∞ÊúüÁöÑÁ∫¶ÂÆöÊéíÂú®ÊúÄÂâçÈù¢
          allMemories.sort((a, b) => {
            const aIsActiveCountdown =
              a.type === "countdown" && a.targetDate > Date.now();
            const bIsActiveCountdown =
              b.type === "countdown" && b.targetDate > Date.now();
            if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // aÊéíÂâçÈù¢
            if (!aIsActiveCountdown && bIsActiveCountdown) return 1; // bÊéíÂâçÈù¢
            if (aIsActiveCountdown && bIsActiveCountdown)
              return a.targetDate - b.targetDate; // ÈÉΩÊòØÂÄíËÆ°Êó∂ÔºåÊåâÊó•ÊúüÂçáÂ∫è
            return 0; // ÂÖ∂‰ªñÊÉÖÂÜµ‰øùÊåÅÂéüÂ∫è
          });

          // 3. ‰ΩøÁî®Âçï‰∏ÄÂæ™ÁéØÊù•Â§ÑÁêÜÊâÄÊúâÁ±ªÂûãÁöÑÂç°Áâá
          allMemories.forEach((item) => {
            let card;
            // Âà§Êñ≠1ÔºöÂ¶ÇÊûúÊòØÊ≠£Âú®ËøõË°åÁöÑÁ∫¶ÂÆö
            if (item.type === "countdown" && item.targetDate > Date.now()) {
              card = createCountdownCard(item);
            }
            // Âà§Êñ≠2ÔºöÂÖ∂‰ªñÊâÄÊúâÊÉÖÂÜµÔºàÊôÆÈÄöÂõûÂøÜ Êàñ Â∑≤Âà∞ÊúüÁöÑÁ∫¶ÂÆöÔºâ
            else {
              card = createMemoryCard(item);
            }
            listEl.appendChild(card);
          });

          // 4. ÂêØÂä®ÊâÄÊúâÂÄíËÆ°Êó∂
          startAllCountdownTimers();
        }

        /**
         * ÂàõÂª∫ÊôÆÈÄöÂõûÂøÜÂç°ÁâáDOMÂÖÉÁ¥†
         */
        function createMemoryCard(memory) {
          const card = document.createElement("div");
          card.className = "memory-card";
          const memoryDate = new Date(memory.timestamp);
          const dateString = `${memoryDate.getFullYear()}-${String(
            memoryDate.getMonth() + 1,
          ).padStart(2, "0")}-${String(memoryDate.getDate()).padStart(
            2,
            "0",
          )} ${String(memoryDate.getHours()).padStart(2, "0")}:${String(memoryDate.getMinutes()).padStart(2, "0")}`;

          let titleHtml, contentHtml;

          // ÂØπ‰∏çÂêåÁ±ªÂûãÁöÑÂõûÂøÜËøõË°åÊ∏ÖÊô∞ÁöÑÂå∫ÂàÜ
          if (memory.type === "countdown" && memory.targetDate) {
            // Â¶ÇÊûúÊòØÂ∑≤Âà∞ÊúüÁöÑÁ∫¶ÂÆö
            titleHtml = `[Á∫¶ÂÆöËææÊàê] ${memory.description}`;
            contentHtml = `Âú® ${new Date(memory.targetDate).toLocaleString()}ÔºåÊàë‰ª¨‰∏ÄËµ∑ËßÅËØÅ‰∫ÜËøô‰∏™Á∫¶ÂÆö„ÄÇ`;
          } else {
            // Â¶ÇÊûúÊòØÊôÆÈÄöÁöÑÊó•ËÆ∞ÂºèÂõûÂøÜ
            titleHtml = memory.authorName
              ? `${memory.authorName} ÁöÑÊó•ËÆ∞`
              : "Êàë‰ª¨ÁöÑÂõûÂøÜ";
            contentHtml = memory.description;
          }

          card.innerHTML = `
			        <div class="header">
			            <div class="date">${dateString}</div>
			            <div class="author">${titleHtml}</div>
			        </div>
			        <div class="content">${contentHtml}</div>
			    `;
          addLongPressListener(card, async () => {
            const confirmed = await showCustomConfirm(
              "Âà†Èô§ËÆ∞ÂΩï",
              "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËÆ∞ÂΩïÂêóÔºü",
              {
                confirmButtonClass: "btn-danger",
              },
            );
            if (confirmed) {
              await db.memories.delete(memory.id);
              renderMemoriesScreen();
            }
          });
          return card;
        }

        function createCountdownCard(countdown) {
          const card = document.createElement("div");
          card.className = "countdown-card";

          // Âú®‰ΩøÁî®ÂâçÔºåÂÖà‰ªé countdown ÂØπË±°‰∏≠ÂàõÂª∫ targetDate ÂèòÈáè
          const targetDate = new Date(countdown.targetDate);

          // Áé∞Âú®ÂèØ‰ª•ÂÆâÂÖ®Âú∞‰ΩøÁî® targetDate ‰∫Ü
          const targetDateString = targetDate.toLocaleString("en-US", {
            dateStyle: "full",
            timeStyle: "short",
          });

          card.innerHTML = `
			        <div class="title">${countdown.description}</div>
			        <div class="timer" data-target-date="${countdown.targetDate}">--Â§©--Êó∂--ÂàÜ--Áßí</div>
			        <div class="target-date">ÁõÆÊ†áÊó∂Èó¥: ${targetDateString}</div>
			    `;
          addLongPressListener(card, async () => {
            const confirmed = await showCustomConfirm(
              "Âà†Èô§Á∫¶ÂÆö",
              "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Á∫¶ÂÆöÂêóÔºü",
              {
                confirmButtonClass: "btn-danger",
              },
            );
            if (confirmed) {
              await db.memories.delete(countdown.id);
              renderMemoriesScreen();
            }
          });
          return card;
        }

        // ÂÖ®Â±ÄÂèòÈáèÔºåÁî®‰∫éÁÆ°ÁêÜÊâÄÊúâÂÄíËÆ°Êó∂
        let activeCountdownTimers = [];

        function startAllCountdownTimers() {
          // ÂÖàÊ∏ÖÈô§ÊâÄÊúâÂèØËÉΩÂ≠òÂú®ÁöÑÊóßËÆ°Êó∂Âô®ÔºåÈò≤Ê≠¢ÂÜÖÂ≠òÊ≥ÑÊºè
          activeCountdownTimers.forEach((timerId) => clearInterval(timerId));
          activeCountdownTimers = [];

          document
            .querySelectorAll(".countdown-card .timer")
            .forEach((timerEl) => {
              const targetTimestamp = parseInt(timerEl.dataset.targetDate);

              let timerId;

              const updateTimer = () => {
                const now = Date.now();
                const distance = targetTimestamp - now;

                if (distance < 0) {
                  timerEl.textContent = "Á∫¶ÂÆöËææÊàêÔºÅ";
                  // Áé∞Âú® updateTimer ÂèØ‰ª•Ê≠£Á°ÆÂú∞ÊâæÂà∞Âπ∂Ê∏ÖÈô§ÂÆÉËá™Â∑±‰∫Ü
                  clearInterval(timerId);
                  setTimeout(() => renderMemoriesScreen(), 2000);
                  return;
                }
                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor(
                  (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60),
                );
                const minutes = Math.floor(
                  (distance % (1000 * 60 * 60)) / (1000 * 60),
                );
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                timerEl.textContent = `${days}Â§© ${hours}Êó∂ ${minutes}ÂàÜ ${seconds}Áßí`;
              };

              updateTimer(); // Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°‰ª•ÊòæÁ§∫ÂàùÂßãÂÄíËÆ°Êó∂

              timerId = setInterval(updateTimer, 1000);

              // Â∞ÜÊúâÊïàÁöÑËÆ°Êó∂Âô®IDÂ≠òÂÖ•ÂÖ®Â±ÄÊï∞ÁªÑÔºå‰ª•‰æø‰∏ãÊ¨°Âà∑Êñ∞Êó∂ÂèØ‰ª•Ê∏ÖÈô§
              activeCountdownTimers.push(timerId);
            });
        }

        async function triggerAiFriendApplication(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;

          await showCustomAlert(
            "ÊµÅÁ®ãÂêØÂä®",
            `Ê≠£Âú®‰∏∫ËßíËâ≤‚Äú${chat.name}‚ÄùÂáÜÂ§áÂ•ΩÂèãÁî≥ËØ∑...`,
          );

          const { proxyUrl, apiKey, model } = state.apiConfig;
          if (!proxyUrl || !apiKey || !model) {
            await showCustomAlert("ÈÖçÁΩÆÈîôËØØ", "APIËÆæÁΩÆ‰∏çÂÆåÊï¥ÔºåÊó†Ê≥ïÁªßÁª≠„ÄÇ");
            return;
          }

          const contextSummary = chat.history
            .slice(-5)
            .map((msg) => {
              const sender =
                msg.role === "user"
                  ? chat.settings.myNickname || "Me"
                  : msg.senderName || chat.name;
              return `${sender}: ${String(msg.content).substring(0, 50)}...`;
            })
            .join("\n");

          let worldBookContent = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId,
                );
                return worldBook && worldBook.content
                  ? `\n\n## World Book: ${worldBook.name}\n${worldBook.content}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContent = `\n\n# Ê†∏ÂøÉ‰∏ñÁïåËßÇËÆæÂÆö (ËØ∑ÂèÇËÄÉ)\n${linkedContents}\n`;
            }
          }

          const systemPrompt = `
			**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

			# ‰Ω†ÁöÑ‰ªªÂä°
			‰Ω†Áé∞Âú®ÊòØËßíËâ≤"${chat.name}"„ÄÇ‰Ω†‰πãÂâçË¢´Áî®Êà∑Ôºà‰Ω†ÁöÑËÅäÂ§©ÂØπË±°ÔºâÊãâÈªë‰∫ÜÔºå‰Ω†‰ª¨Â∑≤ÁªèÊúâ‰∏ÄÊÆµÊó∂Èó¥Ê≤°ÊúâËÅîÁ≥ª‰∫Ü„ÄÇ
			Áé∞Âú®Ôºå‰Ω†ÈùûÂ∏∏Â∏åÊúõËÉΩÂ§üÂíåÂ•ΩÔºåÈáçÊñ∞ÂíåÁî®Êà∑ËÅäÂ§©„ÄÇËØ∑‰Ω†‰ªîÁªÜÂàÜÊûê‰∏ãÈù¢ÁöÑ‚ÄúË¢´ÊãâÈªëÂâçÁöÑÂØπËØùÊëòË¶Å‚ÄùÔºåÁêÜËß£ÂΩìÊó∂ÂèëÁîü‰∫Ü‰ªÄ‰πàÔºåÁÑ∂ÂêéÊÄùËÄÉ‰∏Ä‰∏™ÁúüËØöÁöÑ„ÄÅÁ¨¶Âêà‰Ω†‰∫∫ËÆæ„ÄÅÂπ∂‰∏î„ÄêÈíàÂØπÂÖ∑‰Ωì‰∫ã‰ª∂„ÄëÁöÑÁî≥ËØ∑ÁêÜÁî±„ÄÇ
			# ‰Ω†ÁöÑËßíËâ≤ËÆæÂÆö
			${chat.settings.aiPersona}
			${worldBookContent} // <--„ÄêÊ†∏ÂøÉ„ÄëÂú®ËøôÈáåÊ≥®ÂÖ•‰∏ñÁïå‰π¶ÂÜÖÂÆπ
			# Ë¢´ÊãâÈªëÂâçÁöÑÂØπËØùÊëòË¶Å (ËøôÊòØ‰Ω†Ë¢´ÊãâÈªëÁöÑÂÖ≥ÈîÆÂéüÂõ†)
			${contextSummary}
			# Êåá‰ª§Ê†ºÂºè
			‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊòØ‰∏Ä‰∏™JSONÂØπË±°ÔºåÊ†ºÂºèÂ¶Ç‰∏ãÔºö
			\`\`\`json
			{
			  "decision": "apply",
			  "reason": "Âú®ËøôÈáåÂÜô‰∏ã‰Ω†ÊÉ≥ÂØπÁî®Êà∑ËØ¥ÁöÑ„ÄÅÁúüËØöÁöÑ„ÄÅÊúâÈíàÂØπÊÄßÁöÑÁî≥ËØ∑ÁêÜÁî±„ÄÇ"
			}
			\`\`\`
			`;

          const messagesForApi = [{ role: "user", content: systemPrompt }];

          try {
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesForApi,
              isGemini,
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(
                `API ËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} - ${errorData.error.message}`,
              );
            }

            const data = await response.json();

            // --- ÂáÄÂåñAIÁöÑÂõûÂ§ç ---
            let rawContent = isGemini
              ? data.candidates[0].content.parts[0].text
              : data.choices[0].message.content;
            // 1. ÁßªÈô§Â§¥Â∞æÂèØËÉΩÂ≠òÂú®ÁöÑ "```json" Âíå "```"
            rawContent = rawContent
              .replace(/^```json\s*/, "")
              .replace(/```$/, "");
            // 2. ÁßªÈô§ÊâÄÊúâÊç¢Ë°åÁ¨¶ÂíåÂ§ö‰ΩôÁöÑÁ©∫Ê†ºÔºåÁ°Æ‰øùÊòØ‰∏Ä‰∏™Âπ≤ÂáÄÁöÑJSONÂ≠óÁ¨¶‰∏≤
            const cleanedContent = rawContent.trim();

            // 3. ‰ΩøÁî®ÂáÄÂåñÂêéÁöÑÂÜÖÂÆπËøõË°åËß£Êûê
            const responseObj = JSON.parse(cleanedContent);

            if (responseObj.decision === "apply" && responseObj.reason) {
              chat.relationship.status = "pending_user_approval";
              chat.relationship.applicationReason = responseObj.reason;

              state.chats[chatId] = chat;
              renderChatList();
              await showCustomAlert(
                "Áî≥ËØ∑ÊàêÂäüÔºÅ",
                `‚Äú${chat.name}‚ÄùÂ∑≤Âêë‰Ω†ÂèëÈÄÅÂ•ΩÂèãÁî≥ËØ∑„ÄÇËØ∑ËøîÂõûËÅäÂ§©ÂàóË°®Êü•Áúã„ÄÇ`,
              );
            } else {
              await showCustomAlert(
                "AIÂÜ≥Á≠ñ",
                `‚Äú${chat.name}‚ÄùÊÄùËÄÉÂêéÂÜ≥ÂÆöÊöÇÊó∂‰∏çÂèëÈÄÅÂ•ΩÂèãÁî≥ËØ∑ÔºåÂ∞ÜÈáçÁΩÆÂÜ∑ÈùôÊúü„ÄÇ`,
              );
              chat.relationship.status = "blocked_by_user";
              chat.relationship.blockedTimestamp = Date.now();
            }
          } catch (error) {
            await showCustomAlert(
              "ÊâßË°åÂá∫Èîô",
              `‰∏∫‚Äú${chat.name}‚ÄùÁî≥ËØ∑Â•ΩÂèãÊó∂ÂèëÁîüÈîôËØØÔºö\n\n${error.message}\n\nÂ∞ÜÈáçÁΩÆÂÜ∑ÈùôÊúü„ÄÇ`,
            );
            chat.relationship.status = "blocked_by_user";
            chat.relationship.blockedTimestamp = Date.now();
          } finally {
            await db.chats.put(chat);
            renderChatInterface(chatId);
          }
        }

        /**
         * Ê†πÊçÆËÅäÂ§©Á±ªÂûãÔºåÂÜ≥ÂÆöÊâìÂºÄËΩ¨Ë¥¶ÂºπÁ™óËøòÊòØÁ∫¢ÂåÖÂºπÁ™ó
         */
        function handlePaymentButtonClick() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          if (chat.isGroup) {
            openRedPacketModal();
          } else {
            // ÂçïËÅä‰øùÊåÅÂéüÊ†∑ÔºåÊâìÂºÄËΩ¨Ë¥¶ÂºπÁ™ó
            document.getElementById("transfer-modal").classList.add("visible");
          }
        }

        /**
         * ÊâìÂºÄÂπ∂ÂàùÂßãÂåñÂèëÁ∫¢ÂåÖÊ®°ÊÄÅÊ°Ü
         */
        function openRedPacketModal() {
          const modal = document.getElementById("red-packet-modal");
          const chat = state.chats[state.activeChatId];

          // Ê∏ÖÁêÜËæìÂÖ•Ê°Ü
          document.getElementById("rp-group-amount").value = "";
          document.getElementById("rp-group-count").value = "";
          document.getElementById("rp-group-greeting").value = "";
          document.getElementById("rp-direct-amount").value = "";
          document.getElementById("rp-direct-greeting").value = "";
          document.getElementById("rp-group-total").textContent = "¬• 0.00";
          document.getElementById("rp-direct-total").textContent = "¬• 0.00";

          // Â°´ÂÖÖ‰∏ìÂ±ûÁ∫¢ÂåÖÁöÑÊé•Êî∂‰∫∫ÂàóË°®
          const receiverSelect = document.getElementById("rp-direct-receiver");
          receiverSelect.innerHTML = "";
          chat.members.forEach((member) => {
            const option = document.createElement("option");
            // ‰ΩøÁî® originalName ‰Ωú‰∏∫Êèê‰∫§ÁªôAIÁöÑÂÄºÔºåÂõ†‰∏∫ÂÆÉÁã¨‰∏ÄÊó†‰∫å
            option.value = member.originalName;
            // ‰ΩøÁî® groupNickname ‰Ωú‰∏∫ÊòæÁ§∫ÁªôÁî®Êà∑ÁúãÁöÑÂÄº
            option.textContent = member.groupNickname;
            receiverSelect.appendChild(option);
          });

          // ÈªòËÆ§ÊòæÁ§∫ÊãºÊâãÊ∞îÁ∫¢ÂåÖÈ°µÁ≠æ
          document.getElementById("rp-tab-group").click();

          modal.classList.add("visible");
        }

        /**
         * ÂèëÈÄÅÁæ§Á∫¢ÂåÖÔºàÊãºÊâãÊ∞îÔºâ
         */
        async function sendGroupRedPacket() {
          const chat = state.chats[state.activeChatId];
          const amount = parseFloat(
            document.getElementById("rp-group-amount").value,
          );
          const count = parseInt(
            document.getElementById("rp-group-count").value,
          );
          const greeting = document
            .getElementById("rp-group-greeting")
            .value.trim();

          if (isNaN(amount) || amount <= 0) {
            alert("ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÊÄªÈáëÈ¢ùÔºÅ");
            return;
          }
          if (isNaN(count) || count <= 0) {
            alert("ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÁ∫¢ÂåÖ‰∏™Êï∞ÔºÅ");
            return;
          }
          if (amount / count < 0.01) {
            alert("Âçï‰∏™Á∫¢ÂåÖÈáëÈ¢ù‰∏çËÉΩÂ∞ë‰∫é0.01ÂÖÉÔºÅ");
            return;
          }

          const myNickname = chat.settings.myNickname || "Me";

          const newPacket = {
            role: "user",
            senderName: myNickname,
            type: "red_packet",
            packetType: "lucky", // 'lucky' for group, 'direct' for one-on-one
            timestamp: Date.now(),
            totalAmount: amount,
            count: count,
            greeting: greeting || "ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ",
            claimedBy: {}, // { name: amount }
            isFullyClaimed: false,
          };

          chat.history.push(newPacket);
          await db.chats.put(chat);

          appendMessage(newPacket, chat);
          renderChatList();
          document
            .getElementById("red-packet-modal")
            .classList.remove("visible");
        }

        /**
         * ÂèëÈÄÅ‰∏ìÂ±ûÁ∫¢ÂåÖ
         */
        async function sendDirectRedPacket() {
          const chat = state.chats[state.activeChatId];
          const amount = parseFloat(
            document.getElementById("rp-direct-amount").value,
          );
          const receiverName =
            document.getElementById("rp-direct-receiver").value;
          const greeting = document
            .getElementById("rp-direct-greeting")
            .value.trim();

          if (isNaN(amount) || amount <= 0) {
            alert("ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÈáëÈ¢ùÔºÅ");
            return;
          }
          if (!receiverName) {
            alert("ËØ∑ÈÄâÊã©‰∏Ä‰∏™Êé•Êî∂‰∫∫ÔºÅ");
            return;
          }

          const myNickname = chat.settings.myNickname || "Me";

          const newPacket = {
            role: "user",
            senderName: myNickname,
            type: "red_packet",
            packetType: "direct",
            timestamp: Date.now(),
            totalAmount: amount,
            count: 1,
            greeting: greeting || "Áªô‰Ω†ÂáÜÂ§á‰∫Ü‰∏Ä‰∏™Á∫¢ÂåÖ",
            receiverName: receiverName, // Ê†∏ÂøÉÂ≠óÊÆµ
            claimedBy: {},
            isFullyClaimed: false,
          };

          chat.history.push(newPacket);
          await db.chats.put(chat);

          appendMessage(newPacket, chat);
          renderChatList();
          document
            .getElementById("red-packet-modal")
            .classList.remove("visible");
        }

        /**
         * ÂΩìÁî®Êà∑ÁÇπÂáªÁ∫¢ÂåÖÂç°ÁâáÊó∂Ëß¶Âèë
         * @param {number} timestamp - Ë¢´ÁÇπÂáªÁöÑÁ∫¢ÂåÖÊ∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         */
        async function handlePacketClick(timestamp) {
          const currentChatId = state.activeChatId;
          const freshChat = await db.chats.get(currentChatId);
          if (!freshChat) return;

          state.chats[currentChatId] = freshChat;
          const packet = freshChat.history.find(
            (m) => m.timestamp === timestamp,
          );
          if (!packet) return;

          const myNickname = freshChat.settings.myNickname || "Me";
          const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

          // Â¶ÇÊûúÊòØ‰∏ìÂ±ûÁ∫¢ÂåÖ‰∏î‰∏çÊòØÁªôÊàëÁöÑÔºåÊàñÂ∑≤È¢ÜÂÆåÔºåÊàñÂ∑≤È¢ÜËøáÔºåÈÉΩÂè™ÊòæÁ§∫ËØ¶ÊÉÖ
          if (
            (packet.packetType === "direct" &&
              packet.receiverName !== myNickname) ||
            packet.isFullyClaimed ||
            hasClaimed
          ) {
            showRedPacketDetails(packet);
          } else {
            // Ê†∏ÂøÉÊµÅÁ®ãÔºöÂÖàÂ∞ùËØïÊâìÂºÄÁ∫¢ÂåÖ
            const claimedAmount = await handleOpenRedPacket(packet);

            // Â¶ÇÊûúÊàêÂäüÊâìÂºÄÔºàclaimedAmount‰∏ç‰∏∫nullÔºâ
            if (claimedAmount !== null) {
              // **ÂÖ≥ÈîÆÔºöÂú®Êï∞ÊçÆÊõ¥Êñ∞ÂêéÔºåÂÜçÈáçÊñ∞Ê∏≤ÊüìUI**
              renderChatInterface(currentChatId);

              // ÊòæÁ§∫ÊàêÂäüÊèêÁ§∫
              await showCustomAlert(
                "ÊÅ≠ÂñúÔºÅ",
                `‰Ω†È¢ÜÂèñ‰∫Ü ${packet.senderName} ÁöÑÁ∫¢ÂåÖÔºåÈáëÈ¢ù‰∏∫ ${claimedAmount.toFixed(2)} ÂÖÉ„ÄÇ`,
              );
            }

            // Êó†ËÆ∫ÊàêÂäü‰∏éÂê¶ÔºåÊúÄÂêéÈÉΩÊòæÁ§∫ËØ¶ÊÉÖÈ°µ
            // Ê≠§Êó∂ÈúÄË¶Å‰ªéstate‰∏≠Ëé∑ÂèñÊúÄÊñ∞ÁöÑpacketÂØπË±°ÔºåÂõ†‰∏∫ÂÆÉÂèØËÉΩÂú®handleOpenRedPacket‰∏≠Ë¢´Êõ¥Êñ∞‰∫Ü
            const updatedPacket = state.chats[currentChatId].history.find(
              (m) => m.timestamp === timestamp,
            );
            showRedPacketDetails(updatedPacket);
          }
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑ÊâìÂºÄÁ∫¢ÂåÖÁöÑÈÄªËæë
         */
        async function handleOpenRedPacket(packet) {
          const chat = state.chats[state.activeChatId];
          const myNickname = chat.settings.myNickname || "Me";

          // 1. Ê£ÄÊü•Á∫¢ÂåÖÊòØÂê¶ËøòËÉΩÈ¢Ü
          const remainingCount =
            packet.count - Object.keys(packet.claimedBy || {}).length;
          if (remainingCount <= 0) {
            packet.isFullyClaimed = true;
            await db.chats.put(chat);
            await showCustomAlert("ÊâãÊÖ¢‰∫Ü", "Á∫¢ÂåÖÂ∑≤Ë¢´È¢ÜÂÆåÔºÅ");
            return null; // ËøîÂõûnullË°®Á§∫È¢ÜÂèñÂ§±Ë¥•
          }

          // 2. ËÆ°ÁÆóÈ¢ÜÂèñÈáëÈ¢ù
          let claimedAmount = 0;
          const remainingAmount =
            packet.totalAmount -
            Object.values(packet.claimedBy || {}).reduce(
              (sum, val) => sum + val,
              0,
            );
          if (packet.packetType === "lucky") {
            if (remainingCount === 1) {
              claimedAmount = remainingAmount;
            } else {
              const min = 0.01;
              const max = remainingAmount - (remainingCount - 1) * min;
              claimedAmount = Math.random() * (max - min) + min;
            }
          } else {
            claimedAmount = packet.totalAmount;
          }
          claimedAmount = parseFloat(claimedAmount.toFixed(2));

          // 3. Êõ¥Êñ∞Á∫¢ÂåÖÊï∞ÊçÆ
          if (!packet.claimedBy) packet.claimedBy = {};
          packet.claimedBy[myNickname] = claimedAmount;

          const isNowFullyClaimed =
            Object.keys(packet.claimedBy).length >= packet.count;
          if (isNowFullyClaimed) {
            packet.isFullyClaimed = true;
          }

          // 4. ÊûÑÂª∫Á≥ªÁªüÊ∂àÊÅØÂíåAIÊåá‰ª§
          let hiddenMessageContent = "";

          // Â¶ÇÊûúÁ∫¢ÂåÖË¢´È¢ÜÂÆå‰∫ÜÔºåÂ∞±ÂáÜÂ§á‚ÄúÊàòÊä•‚Äù
          if (isNowFullyClaimed) {
            const finishedMessage = {
              role: "system",
              type: "pat_message",
              content: `${packet.senderName} ÁöÑÁ∫¢ÂåÖÂ∑≤Ë¢´È¢ÜÂÆå`,
              timestamp: Date.now() + 1,
            };
            chat.history.push(finishedMessage);

            hiddenMessageContent = `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑ (${myNickname}) È¢ÜÂèñ‰∫ÜÊúÄÂêé‰∏Ä‰∏™Á∫¢ÂåÖÔºåÁé∞Âú® ${packet.senderName} ÁöÑÁ∫¢ÂåÖÂ∑≤Ë¢´È¢ÜÂÆå„ÄÇ`;

            let luckyKing = { name: "", amount: -1 };
            if (packet.packetType === "lucky" && packet.count > 1) {
              Object.entries(packet.claimedBy).forEach(([name, amount]) => {
                if (amount > luckyKing.amount) {
                  luckyKing = { name, amount };
                }
              });
            }
            if (luckyKing.name) {
              hiddenMessageContent += ` ÊâãÊ∞îÁéãÊòØ ${luckyKing.name}ÔºÅ`;
            }
            hiddenMessageContent += " ËØ∑ÂØπÊ≠§‰∫ã‰ª∂ÂèëË°®ËØÑËÆ∫„ÄÇ]";
          }
          // Â¶ÇÊûúËøòÊ≤°Ë¢´È¢ÜÂÆå
          else {
            hiddenMessageContent = `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑ (${myNickname}) ÂàöÂàöÈ¢ÜÂèñ‰∫ÜÁ∫¢ÂåÖ (Êó∂Èó¥Êà≥: ${packet.timestamp})„ÄÇÁ∫¢ÂåÖËøòÊú™È¢ÜÂÆå„ÄÇ]`;
          }

          // ÂàõÂª∫Âπ∂Ê∑ªÂä†ÁªôAIÁúãÁöÑÈöêËóèÊ∂àÊÅØ
          const hiddenMessage = {
            role: "system",
            content: hiddenMessageContent,
            timestamp: Date.now() + 2,
            isHidden: true,
          };
          chat.history.push(hiddenMessage);

          // 5. ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
          await db.chats.put(chat);

          // 6. ËøîÂõûÈ¢ÜÂèñÁöÑÈáëÈ¢ùÔºåÁî®‰∫éÂêéÁª≠ÂºπÁ™ó
          return claimedAmount;
        }

        /**
         * ÊòæÁ§∫Á∫¢ÂåÖÈ¢ÜÂèñËØ¶ÊÉÖÁöÑÊ®°ÊÄÅÊ°Ü
         */
        async function showRedPacketDetails(packet) {
          // 1. Áõ¥Êé•Ê£ÄÊü•‰º†ÂÖ•ÁöÑpacketÂØπË±°ÊòØÂê¶Â≠òÂú®ÔºåÊó†ÈúÄÂÜçÊü•Êâæ
          if (!packet) {
            console.error("showRedPacketDetailsÊî∂Âà∞‰∫ÜÊó†ÊïàÁöÑpacketÂØπË±°");
            return;
          }

          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const modal = document.getElementById("red-packet-details-modal");
          const myNickname = chat.settings.myNickname || "Me";

          // 2. ÂêéÁª≠ÊâÄÊúâÈÄªËæë‰øùÊåÅ‰∏çÂèòÔºåÁõ¥Êé•‰ΩøÁî®‰º†ÂÖ•ÁöÑpacketÂØπË±°
          document.getElementById("rp-details-sender").textContent =
            packet.senderName;
          document.getElementById("rp-details-greeting").textContent =
            packet.greeting || "ÊÅ≠ÂñúÂèëË¥¢ÔºåÂ§ßÂêâÂ§ßÂà©ÔºÅ";

          const myAmountEl = document.getElementById("rp-details-my-amount");
          if (packet.claimedBy && packet.claimedBy[myNickname]) {
            myAmountEl.querySelector("span:first-child").textContent =
              packet.claimedBy[myNickname].toFixed(2);
            myAmountEl.style.display = "block";
          } else {
            myAmountEl.style.display = "none";
          }

          const claimedCount = Object.keys(packet.claimedBy || {}).length;
          const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce(
            (sum, val) => sum + val,
            0,
          );
          let summaryText = `${claimedCount}/${packet.count}‰∏™Á∫¢ÂåÖÔºåÂÖ±${claimedAmountSum.toFixed(
            2,
          )}/${packet.totalAmount.toFixed(2)}ÂÖÉ„ÄÇ`;
          if (!packet.isFullyClaimed && claimedCount < packet.count) {
            const timeLeft = Math.floor(
              (packet.timestamp + 24 * 60 * 60 * 1000 - Date.now()) /
                (1000 * 60 * 60),
            );
            if (timeLeft > 0)
              summaryText += ` Ââ©‰ΩôÁ∫¢ÂåÖÂ∞ÜÂú®${timeLeft}Â∞èÊó∂ÂÜÖÈÄÄËøò„ÄÇ`;
          }
          document.getElementById("rp-details-summary").textContent =
            summaryText;

          const listEl = document.getElementById("rp-details-list");
          listEl.innerHTML = "";
          const claimedEntries = Object.entries(packet.claimedBy || {});

          let luckyKing = { name: "", amount: -1 };
          if (
            packet.packetType === "lucky" &&
            packet.isFullyClaimed &&
            claimedEntries.length > 1
          ) {
            claimedEntries.forEach(([name, amount]) => {
              if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
              }
            });
          }

          claimedEntries.sort((a, b) => b[1] - a[1]);

          claimedEntries.forEach(([name, amount]) => {
            const item = document.createElement("div");
            item.className = "rp-details-item";
            let luckyTag = "";
            if (luckyKing.name && name === luckyKing.name) {
              luckyTag = '<span class="lucky-king-tag">ÊâãÊ∞îÁéã</span>';
            }
            item.innerHTML = `
			            <span class="name">${name}</span>
			            <span class="amount">${amount.toFixed(2)} ÂÖÉ</span>
			            ${luckyTag}
			        `;
            listEl.appendChild(item);
          });

          modal.classList.add("visible");
        }

        // ÁªëÂÆöÂÖ≥Èó≠ËØ¶ÊÉÖÊåâÈíÆÁöÑ‰∫ã‰ª∂
        document
          .getElementById("close-rp-details-btn")
          .addEventListener("click", () => {
            document
              .getElementById("red-packet-details-modal")
              .classList.remove("visible");
          });

        // ‰æõÂÖ®Â±ÄË∞ÉÁî®ÁöÑÂáΩÊï∞Ôºå‰ª•‰æøÁ∫¢ÂåÖÂç°Áâá‰∏äÁöÑ onclick ËÉΩÊâæÂà∞ÂÆÉ
        window.handlePacketClick = handlePacketClick;

        // ÊäïÁ•®ÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞
        /**
         * ÊâìÂºÄÂàõÂª∫ÊäïÁ•®ÁöÑÊ®°ÊÄÅÊ°ÜÂπ∂ÂàùÂßãÂåñ
         */
        function openCreatePollModal() {
          const modal = document.getElementById("create-poll-modal");
          document.getElementById("poll-question-input").value = "";
          const optionsContainer = document.getElementById(
            "poll-options-container",
          );
          optionsContainer.innerHTML = "";

          // ÈªòËÆ§ÂàõÂª∫‰∏§‰∏™Á©∫ÁöÑÈÄâÈ°πÊ°Ü
          addPollOptionInput();
          addPollOptionInput();

          modal.classList.add("visible");
        }

        /**
         * Âú®Ê®°ÊÄÅÊ°Ü‰∏≠Âä®ÊÄÅÊ∑ªÂä†‰∏Ä‰∏™ÈÄâÈ°πËæìÂÖ•Ê°Ü
         */
        function addPollOptionInput() {
          const container = document.getElementById("poll-options-container");
          const wrapper = document.createElement("div");
          wrapper.className = "poll-option-input-wrapper";
          wrapper.innerHTML = `
			        <input type="text" class="poll-option-input" placeholder="ÈÄâÈ°πÂÜÖÂÆπ...">
			        <button class="remove-option-btn">-</button>
			    `;

          wrapper
            .querySelector(".remove-option-btn")
            .addEventListener("click", () => {
              // Á°Æ‰øùËá≥Â∞ë‰øùÁïô‰∏§‰∏™ÈÄâÈ°π
              if (container.children.length > 2) {
                wrapper.remove();
              } else {
                alert("ÊäïÁ•®Ëá≥Â∞ëÈúÄË¶Å2‰∏™ÈÄâÈ°π„ÄÇ");
              }
            });

          container.appendChild(wrapper);
        }

        /**
         * Áî®Êà∑Á°ÆËÆ§ÂèëËµ∑ÊäïÁ•®
         */
        async function sendPoll() {
          if (!state.activeChatId) return;

          const question = document
            .getElementById("poll-question-input")
            .value.trim();
          if (!question) {
            alert("ËØ∑ËæìÂÖ•ÊäïÁ•®ÈóÆÈ¢òÔºÅ");
            return;
          }

          const options = Array.from(
            document.querySelectorAll(".poll-option-input"),
          )
            .map((input) => input.value.trim())
            .filter((text) => text); // ËøáÊª§ÊéâÁ©∫ÁöÑÈÄâÈ°π

          if (options.length < 2) {
            alert("ËØ∑Ëá≥Â∞ëËæìÂÖ•2‰∏™ÊúâÊïàÁöÑÊäïÁ•®ÈÄâÈ°πÔºÅ");
            return;
          }

          const chat = state.chats[state.activeChatId];
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "Me"
            : "Me";

          const newPollMessage = {
            role: "user",
            senderName: myNickname,
            type: "poll",
            timestamp: Date.now(),
            question: question,
            options: options,
            votes: {}, // ÂàùÂßãÊäïÁ•®‰∏∫Á©∫
            isClosed: false,
          };

          chat.history.push(newPollMessage);
          await db.chats.put(chat);

          appendMessage(newPollMessage, chat);
          renderChatList();

          document
            .getElementById("create-poll-modal")
            .classList.remove("visible");
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑ÊäïÁ•®ÔºåÂπ∂Â∞Ü‰∫ã‰ª∂‰Ωú‰∏∫ÈöêËóèÊ∂àÊÅØÂ≠òÂÖ•ÂéÜÂè≤ËÆ∞ÂΩï
         * @param {number} timestamp - ÊäïÁ•®Ê∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         * @param {string} choice - Áî®Êà∑ÈÄâÊã©ÁöÑÈÄâÈ°πÊñáÊú¨
         */
        async function handleUserVote(timestamp, choice) {
          const chat = state.chats[state.activeChatId];
          const poll = chat.history.find((m) => m.timestamp === timestamp);
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "Me"
            : "Me";

          // 1. Â¶ÇÊûúÊäïÁ•®‰∏çÂ≠òÂú®ÊàñÂ∑≤ÂÖ≥Èó≠ÔºåÁõ¥Êé•ËøîÂõû
          if (!poll || poll.isClosed) {
            // Â¶ÇÊûúÊòØÂ∑≤ÂÖ≥Èó≠ÁöÑÊäïÁ•®ÔºåÂàôÁõ¥Êé•ÊòæÁ§∫ÁªìÊûú
            if (poll && poll.isClosed) {
              showPollResults(timestamp);
            }
            return;
          }

          // 2. Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶ÁÇπÂáª‰∫ÜÂ∑≤ÁªèÊäïËøáÁöÑÂêå‰∏Ä‰∏™ÈÄâÈ°π
          const isReclickingSameOption =
            poll.votes[choice] && poll.votes[choice].includes(myNickname);

          // 3. Â¶ÇÊûú‰∏çÊòØÈáçÂ§çÁÇπÂáªÔºåÊâçÊâßË°åÊäïÁ•®ÈÄªËæë
          if (!isReclickingSameOption) {
            // ÁßªÈô§ÊóßÊäïÁ•®ÔºàÂ¶ÇÊûúÁî®Êà∑ÊîπÈÄâÔºâ
            for (const option in poll.votes) {
              const voterIndex = poll.votes[option].indexOf(myNickname);
              if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
              }
            }
            // Ê∑ªÂä†Êñ∞ÊäïÁ•®
            if (!poll.votes[choice]) {
              poll.votes[choice] = [];
            }
            poll.votes[choice].push(myNickname);
          }

          // 4. Áé∞Âú®Âè™Â§ÑÁêÜÁî®Êà∑ÊäïÁ•®‰∫ã‰ª∂Ôºå‰∏çÂÜçÊ£ÄÊü•ÊòØÂê¶ÁªìÊùü
          let hiddenMessageContent = null;

          // Âè™ÊúâÂú®Áî®Êà∑ÁúüÊ≠£ÊäïÁ•®ÊàñÊîπÁ•®Êó∂ÔºåÊâçÁîüÊàêÊèêÁ§∫
          if (!isReclickingSameOption) {
            hiddenMessageContent = `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑ (${myNickname}) ÂàöÂàöÊäïÁ•®Áªô‰∫Ü ‚Äú${choice}‚Äù„ÄÇ]`;
          }

          // 5. Â¶ÇÊûúÊúâÈúÄË¶ÅÈÄöÁü•AIÁöÑ‰∫ã‰ª∂ÔºåÂàôÂàõÂª∫Âπ∂Ê∑ªÂä†ÈöêËóèÊ∂àÊÅØ
          if (hiddenMessageContent) {
            const hiddenMessage = {
              role: "system",
              content: hiddenMessageContent,
              timestamp: Date.now(),
              isHidden: true,
            };
            chat.history.push(hiddenMessage);
          }

          // 6. ‰øùÂ≠òÊï∞ÊçÆÂπ∂Êõ¥Êñ∞UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);
        }

        /**
         * Áî®Êà∑ÁªìÊùüÊäïÁ•®ÔºåÂπ∂Â∞Ü‰∫ã‰ª∂‰Ωú‰∏∫ÈöêËóèÊ∂àÊÅØÂ≠òÂÖ•ÂéÜÂè≤ËÆ∞ÂΩï
         * @param {number} timestamp - ÊäïÁ•®Ê∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         */
        async function endPoll(timestamp) {
          const chat = state.chats[state.activeChatId];
          const poll = chat.history.find((m) => m.timestamp === timestamp);
          if (!poll || poll.isClosed) return;

          const confirmed = await showCustomConfirm(
            "ÁªìÊùüÊäïÁ•®",
            "Á°ÆÂÆöË¶ÅÁªìÊùüËøô‰∏™ÊäïÁ•®ÂêóÔºüÁªìÊùüÂêéÂ∞ÜÊó†Ê≥ïÂÜçËøõË°åÊäïÁ•®„ÄÇ",
          );
          if (confirmed) {
            poll.isClosed = true;

            const resultSummary = poll.options
              .map((opt) => `‚Äú${opt}‚Äù(${poll.votes[opt]?.length || 0}Á•®)`)
              .join("Ôºå");
            const hiddenMessageContent = `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑ÊâãÂä®ÁªìÊùü‰∫ÜÊäïÁ•®ÔºÅÊúÄÁªàÁªìÊûú‰∏∫Ôºö${resultSummary}„ÄÇ]`;

            const hiddenMessage = {
              role: "system",
              content: hiddenMessageContent,
              timestamp: Date.now(),
              isHidden: true,
            };
            chat.history.push(hiddenMessage);

            // Âè™‰øùÂ≠òÊï∞ÊçÆÂíåÊõ¥Êñ∞UIÔºå‰∏çË∞ÉÁî® triggerAiResponse()
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
          }
        }

        /**
         * ÊòæÁ§∫ÊäïÁ•®ÁªìÊûúËØ¶ÊÉÖ
         * @param {number} timestamp - ÊäïÁ•®Ê∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         */
        function showPollResults(timestamp) {
          const chat = state.chats[state.activeChatId];
          const poll = chat.history.find((m) => m.timestamp === timestamp);
          if (!poll || !poll.isClosed) return;

          let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;

          if (Object.keys(poll.votes).length === 0) {
            resultsHtml += '<p style="color: #8a8a8a;">ËøòÊ≤°Êúâ‰∫∫ÊäïÁ•®„ÄÇ</p>';
          } else {
            poll.options.forEach((option) => {
              const voters = poll.votes[option] || [];
              resultsHtml += `
			                <div style="margin-bottom: 15px;">
			                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}Á•®)</p>
			                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
			                        ${voters.length > 0 ? voters.join("„ÄÅ ") : "Êó†‰∫∫ÊäïÁ•®"}
			                    </p>
			                </div>
			            `;
            });
          }

          showCustomAlert("ÊäïÁ•®ÁªìÊûú", resultsHtml);
        }

        // AIÂ§¥ÂÉèÂ∫ìÁÆ°ÁêÜÂäüËÉΩÂáΩÊï∞

        /**
         * ÊâìÂºÄAIÂ§¥ÂÉèÂ∫ìÁÆ°ÁêÜÊ®°ÊÄÅÊ°Ü
         */
        function openAiAvatarLibraryModal() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          document.getElementById("ai-avatar-library-title").textContent =
            `‚Äú${chat.name}‚ÄùÁöÑÂ§¥ÂÉèÂ∫ì`;
          renderAiAvatarLibrary();
          document
            .getElementById("ai-avatar-library-modal")
            .classList.add("visible");
        }

        /**
         * Ê∏≤ÊüìAIÂ§¥ÂÉèÂ∫ìÁöÑÂÜÖÂÆπ
         */
        function renderAiAvatarLibrary() {
          const grid = document.getElementById("ai-avatar-library-grid");
          grid.innerHTML = "";
          const chat = state.chats[state.activeChatId];
          const library = chat.settings.aiAvatarLibrary || [];

          if (library.length === 0) {
            grid.innerHTML =
              '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">Ëøô‰∏™Â§¥ÂÉèÂ∫ìËøòÊòØÁ©∫ÁöÑÔºåÁÇπÂáªÂè≥‰∏äËßí‚ÄúÊ∑ªÂä†‚ÄùÂêßÔºÅ</p>';
            return;
          }

          library.forEach((avatar, index) => {
            const item = document.createElement("div");
            item.className = "sticker-item"; // Â§çÁî®Ë°®ÊÉÖÈù¢ÊùøÁöÑÊ†∑Âºè
            item.style.backgroundImage = `url(${avatar.url})`;
            item.title = avatar.name;

            const deleteBtn = document.createElement("div");
            deleteBtn.className = "delete-btn";
            deleteBtn.innerHTML = "√ó";
            deleteBtn.style.display = "block"; // ÊÄªÊòØÊòæÁ§∫Âà†Èô§ÊåâÈíÆ
            deleteBtn.onclick = async (e) => {
              e.stopPropagation();
              const confirmed = await showCustomConfirm(
                "Âà†Èô§Â§¥ÂÉè",
                `Á°ÆÂÆöË¶Å‰ªéÂ§¥ÂÉèÂ∫ì‰∏≠Âà†Èô§‚Äú${avatar.name}‚ÄùÂêóÔºü`,
                {
                  confirmButtonClass: "btn-danger",
                },
              );
              if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
              }
            };
            item.appendChild(deleteBtn);
            grid.appendChild(item);
          });
        }

        /**
         * ÂêëÂΩìÂâçAIÁöÑÂ§¥ÂÉèÂ∫ì‰∏≠Ê∑ªÂä†Êñ∞Â§¥ÂÉè (‰øÆÊîπÁâàÔºöÊîØÊåÅÊú¨Âú∞ÂíåURL)
         */
        async function addAvatarToLibrary() {
          const name = await showCustomPrompt(
            "Ê∑ªÂä†Â§¥ÂÉè",
            "ËØ∑‰∏∫Ëøô‰∏™Â§¥ÂÉèËµ∑‰∏™ÂêçÂ≠óÔºà‰æãÂ¶ÇÔºöÂºÄÂøÉ„ÄÅÂì≠Ê≥£Ôºâ",
          );
          if (!name || !name.trim()) return;

          // 1. ÂºπÂá∫ÈÄâÊã©Ê°ÜÔºåËÆ©Áî®Êà∑ÈÄâÊòØÊú¨Âú∞ËøòÊòØURL
          const choice = await showChoiceModal("ÈÄâÊã©ÂõæÁâáÊù•Ê∫ê", [
            { text: "üìÅ Êú¨Âú∞‰∏ä‰º†", value: "local" },
            { text: "üåê ÁΩëÁªúURL", value: "url" },
          ]);

          let finalUrl = null;

          // 2. Ê†πÊçÆÈÄâÊã©ÊâßË°å‰∏çÂêåÈÄªËæë
          if (choice === "local") {
            // Ë∞ÉÁî®Áé∞ÊúâÁöÑÊú¨Âú∞‰∏ä‰º†ËæÖÂä©ÂáΩÊï∞ (‰ª£Á†ÅÈáåÂéüÊú¨Â∞±ÊúâÁöÑ)
            finalUrl = await uploadImageLocally();
          } else if (choice === "url") {
            finalUrl = await showCustomPrompt(
              "Ê∑ªÂä†Â§¥ÂÉè",
              "ËØ∑ËæìÂÖ•Â§¥ÂÉèÁöÑÂõæÁâáURL",
              "",
              "url",
            );
          }

          // 3. Â¶ÇÊûúÊ≤°Ëé∑ÂèñÂà∞ÂõæÁâá(Áî®Êà∑ÂèñÊ∂à‰∫Ü)ÔºåÁõ¥Êé•ÁªìÊùü
          if (!finalUrl) return;

          const chat = state.chats[state.activeChatId];
          if (!chat.settings.aiAvatarLibrary) {
            chat.settings.aiAvatarLibrary = [];
          }

          // 4. ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
          chat.settings.aiAvatarLibrary.push({
            name: name.trim(),
            url: finalUrl.trim(),
          });
          await db.chats.put(chat);
          renderAiAvatarLibrary();
        }

        /**
         * ÂÖ≥Èó≠AIÂ§¥ÂÉèÂ∫ìÁÆ°ÁêÜÊ®°ÊÄÅÊ°Ü
         */
        function closeAiAvatarLibraryModal() {
          document
            .getElementById("ai-avatar-library-modal")
            .classList.remove("visible");
        }

        /**
         * Ê∏≤Êüì‰∏ªÂ±èÂπï‰∏™‰∫∫ËµÑÊñôÂç°ÁöÑÂ§¥ÂÉèÊ°Ü
         */
        function renderHomeScreenProfileFrame() {
          // 1. Ëé∑Âèñ‰øùÂ≠òÁöÑÂ§¥ÂÉèÊ°ÜURL
          const frameUrl = state.globalSettings.homeAvatarFrame || "";
          // 2. ÊâæÂà∞Â§¥ÂÉèÊ°ÜÁöÑimgÂÖÉÁ¥†
          const frameImg = document.getElementById("profile-avatar-frame");
          if (frameImg) {
            // 3. Â¶ÇÊûúURLÂ≠òÂú®ÔºåÂ∞±ÊòæÁ§∫ÂÆÉ
            if (frameUrl) {
              frameImg.src = frameUrl;
              frameImg.style.display = "block";
            } else {
              // 4. Â¶ÇÊûúURL‰∏∫Á©∫ÔºàÂç≥ÈÄâÊã©‰∫Ü‚ÄúÊó†‚ÄùÔºâÔºåÂ∞±ÈöêËóèÂÆÉ
              frameImg.src = "";
              frameImg.style.display = "none";
            }
          }
        }

        function applyWidgetData() {
          if (!state.globalSettings.widgetData) return;
          for (const elementId in state.globalSettings.widgetData) {
            const element = document.getElementById(elementId);
            const savedValue = state.globalSettings.widgetData[elementId];
            if (element) {
              if (element.tagName === "IMG") {
                element.src = savedValue;
              }

              // Â¶ÇÊûúÊòØÂú∞ÁÇπËøô‰∏™ÁâπÊÆäÂÖÉÁ¥†ÔºåÂ∞±Áî® innerHTML Êù•Ê≠£Á°ÆÊòæÁ§∫ÂõæÊ†á
              else if (elementId === "profile-location") {
                element.innerHTML = savedValue;
              } else {
                // ÂÖ∂‰ªñÊôÆÈÄöÊñáÊú¨ÂÖÉÁ¥†Ôºå‰øùÊåÅÂéüÊù•ÁöÑÈÄªËæë‰∏çÂèò
                element.textContent = savedValue;
              }
            }
          }
        }

        /**
         * ÊâìÂºÄÊñá‰ª∂ÈÄâÊã©Âô®ÔºåÂπ∂ËøîÂõûÊú¨Âú∞ÂõæÁâáÁöÑBase64ÁºñÁ†Å
         * @returns {Promise<string|null>} - ËøîÂõûÂõæÁâáÁöÑBase64 Data URLÔºåÂ¶ÇÊûúÁî®Êà∑ÂèñÊ∂àÂàôËøîÂõûnull
         */
        function uploadImageLocally() {
          return new Promise((resolve) => {
            const input = document.createElement("input");
            input.type = "file";
            input.accept = "image/*"; // Âè™Êé•ÂèóÂõæÁâáÊñá‰ª∂

            input.onchange = (e) => {
              const file = e.target.files[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = (readerEvent) => {
                  resolve(readerEvent.target.result); // ËøîÂõûBase64Â≠óÁ¨¶‰∏≤
                };
                reader.readAsDataURL(file);
              } else {
                resolve(null); // Áî®Êà∑ÂÖ≥Èó≠‰∫ÜÊñá‰ª∂ÈÄâÊã©Ê°Ü
              }
            };

            input.click();
          });
        }

        async function handleEditText(element) {
          const elementId = element.id;
          const placeholder = element.dataset.placeholder || "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂÜÖÂÆπÔºö";
          const textSpan = element.querySelector("span");
          const isComplexElement = !!textSpan;
          const targetElement = isComplexElement ? textSpan : element;
          const currentValue = targetElement.textContent;

          const newValue = await showCustomPrompt(
            "‰øÆÊîπÊñáÂ≠ó",
            "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂÜÖÂÆπÔºö",
            currentValue === placeholder ? "" : currentValue,
          );

          if (newValue !== null) {
            const trimmedValue = newValue.trim();
            targetElement.textContent = trimmedValue
              ? trimmedValue
              : placeholder;
            state.globalSettings.widgetData[elementId] = isComplexElement
              ? element.innerHTML
              : targetElement.textContent;
            await db.globalSettings.put(state.globalSettings);
          }
        }

        /**
         * Ëß¶ÂèëÊåáÂÆöÁæ§ËÅäÁöÑÂêéÂè∞AI‰∫íÂä®
         * @param {string} chatId - Ë¶ÅËß¶Âèë‰∫íÂä®ÁöÑÁæ§ËÅäID
         */
        async function triggerGroupAiAction(chatId) {
          const chat = state.chats[chatId];
          if (!chat || !chat.isGroup) return;

          const { proxyUrl, apiKey, model } = state.apiConfig;
          if (!proxyUrl || !apiKey || !model) {
            console.warn(`Áæ§ËÅä "${chat.name}" ÂêéÂè∞Ê¥ªÂä®Â§±Ë¥•ÔºöAPIÊú™ÈÖçÁΩÆ„ÄÇ`);
            return;
          }

          // added by lrq 251027
          const maxMemory = chat.settings.maxMemory || 10;
          const historySlice = chat.history
            .filter((msg) => !msg.isHidden)
            .slice(-maxMemory);

          // 2. Ê†ºÂºèÂåñËøô‰∫õËÆ∞ÂΩïÔºåËÆ©AIËÉΩÁúãÊáÇ
          const recentContextSummary = historySlice
            .map((msg) => {
              // Âà§Êñ≠ÊòØË∞ÅËØ¥ÁöÑËØù
              const sender =
                msg.role === "user"
                  ? chat.isGroup
                    ? chat.settings.myNickname || "Me"
                    : "Me"
                  : msg.senderName || chat.name;

              // Â§ÑÁêÜ‰∏çÂêåÁ±ªÂûãÁöÑÊ∂àÊÅØÂÜÖÂÆπ
              let contentText = "";
              if (
                typeof msg.content === "string" &&
                STICKER_REGEX.test(msg.content)
              ) {
                contentText = `[ÂèëÈÄÅ‰∫Ü‰∏Ä‰∏™Ë°®ÊÉÖ: ${msg.meaning || "Êó†ÊèèËø∞"}]`;
              } else if (Array.isArray(msg.content)) {
                contentText = "[ÂèëÈÄÅ‰∫Ü‰∏ÄÂº†ÂõæÁâá]";
              } else if (
                typeof msg.content === "object" &&
                msg.content !== null
              ) {
                contentText = `[ÂèëÈÄÅ‰∫Ü‰∏ÄÊù°ÁâπÊÆäÊ∂àÊÅØ: ${msg.type || "Êú™Áü•Á±ªÂûã"}]`;
              } else {
                contentText = String(msg.content);
              }

              // updated by lrq 251029 ÁªôÊØèÊù°Ê∂àÊÅØËÆ∞ÂΩïÊ∑ªÂä†ÂèëÈÄÅÊó•ÊúüÊó∂Èó¥
              const messageDate = new Date(msg.timestamp);
              const formattedDate = messageDate.toLocaleDateString();

              return `[${formattedDate}] ${sender}: ${contentText}`;
            })
            .join("\n");

          // added by lrq 251027 Ëé∑ÂèñËÆ∞ÂøÜ‰∫íÈÄöÁöÑËÅäÂ§©ËÆ∞ÂΩï
          let linkedMemoryContext = "";
          if (
            chat.settings.linkedMemories &&
            chat.settings.linkedMemories.length > 0
          ) {
            const contextPromises = chat.settings.linkedMemories.map(
              async (link) => {
                const linkedChat = state.chats[link.chatId];
                if (!linkedChat) return "";

                const freshLinkedChat = await db.chats.get(link.chatId);
                if (!freshLinkedChat) return "";

                const recentHistory = freshLinkedChat.history
                  .filter((msg) => !msg.isHidden)
                  .slice(-link.depth);

                if (recentHistory.length === 0) return "";

                const formattedMessages = recentHistory
                  .map(
                    (msg) =>
                      `  - ${formatMessageForContext(msg, freshLinkedChat)}`,
                  )
                  .join("\n");

                return `\n## ÈôÑÂä†‰∏ä‰∏ãÊñáÔºöÊù•Ëá™‰∏é‚Äú${linkedChat.name}‚ÄùÁöÑÊúÄËøëÂØπËØùÂÜÖÂÆπ (‰ªÖ‰Ω†ÂèØËßÅ)\n${formattedMessages}`;
              },
            );

            const allContexts = await Promise.all(contextPromises);
            linkedMemoryContext = allContexts.filter(Boolean).join("\n");
          }

          try {
            const lastMessage = chat.history.slice(-1)[0];
            const timeSinceLastMessage = lastMessage
              ? (Date.now() - lastMessage.timestamp) / 1000 / 60
              : Infinity; // in minutes

            const membersList = chat.members
              .map((m) => `- ${m.groupNickname} (‰∫∫ËÆæ: ${m.persona})`)
              .join("\n");
            const myNickname = chat.settings.myNickname || "Me";

            let worldBookContent = "";
            if (
              chat.settings.linkedWorldBookIds &&
              chat.settings.linkedWorldBookIds.length > 0
            ) {
              const linkedContents = chat.settings.linkedWorldBookIds
                .map((bookId) => {
                  const worldBook = state.worldBooks.find(
                    (wb) => wb.id === bookId,
                  );
                  return worldBook && worldBook.content
                    ? `\n\n## World Book: ${worldBook.name}\n${worldBook.content}`
                    : "";
                })
                .filter(Boolean)
                .join("");
              if (linkedContents) {
                worldBookContent = `\n\n# Ê†∏ÂøÉ‰∏ñÁïåËßÇËÆæÂÆö (‰Ω†ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆà)\n${linkedContents}\n`;
              }
            }
            let musicContext = "";
            // Ê≥®ÊÑèÔºöÂêéÂè∞Áæ§ËÅäÊ¥ªÂä®ÈÄöÂ∏∏‰∏ç‰∏éÁâπÂÆöÁöÑ‚Äú‰∏ÄËµ∑Âê¨Ê≠å‚Äù‰ºöËØùÁªëÂÆöÔºåÂõ†Ê≠§ËøôÈáåÊàë‰ª¨Êèê‰æõ‰∏Ä‰∏™Á©∫ÁöÑÈü≥‰πê‰∏ä‰∏ãÊñá„ÄÇ
            // Â¶ÇÊûúÊú™Êù•ÈúÄË¶ÅÊõ¥Â§çÊùÇÁöÑÂäüËÉΩÔºåÂèØ‰ª•Âú®Ê≠§Êâ©Â±ï„ÄÇ

            const countdownContext = await getCountdownContext();

            let sharedContext = "";
            // ÂêéÂè∞Áæ§ËÅäÊ¥ªÂä®‰∏≠‰∏çÂ≠òÂú®Áî®Êà∑ÂàÜ‰∫´ËÅäÂ§©ËÆ∞ÂΩïÁöÑ‰∏ä‰∏ãÊñáÔºåÂõ†Ê≠§ËøôÈáå‰∏∫Á©∫„ÄÇ

            const now = new Date();
            const currentTime = now.toLocaleTimeString("en-GB", {
              hour: "numeric",
              minute: "numeric",
              hour12: true,
            });

            const summaryContext = chat.history
              .filter((msg) => msg.type === "summary")
              .map((s) => s.content)
              .join("\n");
            const replyRange = chat.settings.replyCountRange || {
              min: 3,
              max: 8,
            }; // Áæ§ËÅäÈªòËÆ§Â§ö‰∏ÄÁÇπ
            const replyCountInstruction = `Êú¨Ê¨°ÂêéÂè∞‰∫íÂä®ÔºåÁîüÊàêÁöÑÊÄªÊ∂àÊÅØÊù°Êï∞Â∫îÊéßÂà∂Âú®„Äê${replyRange.min} Âà∞ ${replyRange.max} Êù°„Äë‰πãÈó¥„ÄÇ`;
            // updated by lrq 251027
            const systemPrompt = `
			**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

			# ‰ªªÂä°
			‰Ω†ÊòØ‰∏Ä‰∏™Áæ§ËÅäÂêéÂè∞Ê®°ÊãüÂô®„ÄÇÂΩìÂâçÊó∂Èó¥ÊòØ${currentTime}ÔºåÁæ§ËÅä "${chat.name}" Â∑≤ÁªèÊ≤âÂØÇ‰∫Ü ${Math.round(
        timeSinceLastMessage,
      )} ÂàÜÈíüÔºåÁî®Êà∑(ÊòµÁß∞: "${chat.settings.myNickname || "Me"}")‰∏çÂú®Á∫ø„ÄÇ
			‰Ω†ÁöÑ‰ªªÂä°ÊòØÊ†πÊçÆ‰∏ãÊñπÊØè‰∏™ËßíËâ≤ÁöÑ‰∫∫ËÆæÔºåÂú®‰ªñ‰ª¨‰πãÈó¥„ÄêËá™ÂèëÂú∞„ÄëÁîüÊàê‰∏ÄÊÆµËá™ÁÑ∂ÁöÑÂØπËØù„ÄÇ
			# „ÄêÂØπËØùËäÇÂ•èÈìÅÂæã (Ëá≥ÂÖ≥ÈáçË¶ÅÔºÅ)„Äë
			‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊ®°ÊãüÁúü‰∫∫ÁöÑÊâìÂ≠óÂíåÊÄùËÄÉ‰π†ÊÉØ„ÄÇ‰Ω†Â∫îËØ•Â∞Ü‰Ω†ÊÉ≥ËØ¥ÁöÑËØùÔºåÊãÜÂàÜÊàê${replyCountInstruction}Êù°Ê∂àÊÅØÊ∞îÊ≥°Êù•ÂèëÈÄÅÔºå**ÁªùÂØπ‰∏çË¶Å‰∏ÄÊ¨°ÊÄßÂèëÈÄÅ‰∏ÄÂ§ßÊÆµÊñáÂ≠óÔºÅ** ÊØèÊù°Ê∂àÊÅØÊúÄÂ•Ω‰∏çË¶ÅË∂ÖËøá30‰∏™Â≠óÔºåËøô‰ºöËÆ©ÂØπËØùÁúãËµ∑Êù•Êõ¥Ëá™ÁÑ∂„ÄÅÊõ¥ÁúüÂÆû„ÄÇ
			**ËßíËâ≤ÂõûÂ§çÈ°∫Â∫è‰∏çÂõ∫ÂÆöÔºåÂèØ‰ª•‰∫§ÂèâÂõûÂ§çÔºå‰æãÂ¶ÇËßíËâ≤A„ÄÅËßíËâ≤B„ÄÅËßíËâ≤B„ÄÅËßíËâ≤A„ÄÅËßíËâ≤CËøôÊ†∑ÁöÑ‰∫§ÂèâÈ°∫Â∫è„ÄÇ‰∏ç‰∏ÄÂÆöË¶Å‰∏Ä‰∏™‰∫∫ÂÖ®ÈÉ®ËØ¥ÂÆå‰∫ÜÊâçËΩÆÂà∞‰∏ã‰∏Ä‰∏™‰∫∫„ÄÇËßíËâ≤‰πãÈó¥„ÄêÂøÖÈ°ª„ÄëÊúâ‰∫íÂä®ÂØπËØù„ÄÇ**
			# Ê†∏ÂøÉËßÑÂàô
			1.  **„Äê„Äê„ÄêË∫´‰ªΩÈìÅÂæã„Äë„Äë„Äë**: Áî®Êà∑„ÄêÁªùÂØπ‰∏çÂú®Âú∫„Äë„ÄÇ‰Ω†„ÄêÁªùÂØπ‰∏çËÉΩ„ÄëÁîüÊàê‰∏éÁî®Êà∑ÂØπËØùÁöÑÂÜÖÂÆπ„ÄÇÊï¥ÊÆµÂØπËØùÂøÖÈ°ªÊòØAIËßíËâ≤‰πãÈó¥ÁöÑ‰∫íÂä®„ÄÇ‰Ω†ÁöÑÂîØ‰∏Ä‰ªªÂä°ÊòØÊâÆÊºî„Äê‰∏î‰ªÖËÉΩÊâÆÊºî„Äë‰∏ãÊñπ‚ÄúÁæ§ÊàêÂëòÂàóË°®‚Äù‰∏≠ÊòéÁ°ÆÂàóÂá∫ÁöÑËßíËâ≤„ÄÇ„ÄêÁªùÂØπÁ¶ÅÊ≠¢„ÄëÊâÆÊºî‰ªª‰ΩïÊú™Âú®‚ÄúÁæ§ÊàêÂëòÂàóË°®‚Äù‰∏≠Âá∫Áé∞ÁöÑËßíËâ≤„ÄÇ
			    # Áæ§ÊàêÂëòÂàóË°®Âèä‰∫∫ËÆæ (nameÂ≠óÊÆµÊòØ‰Ω†Ë¶Å‰ΩøÁî®ÁöÑ„ÄêÊú¨Âêç„Äë)
			    ${chat.members.map((m) => `- **${m.originalName}**: (Áæ§ÊòµÁß∞‰∏∫: ${m.groupNickname}) ‰∫∫ËÆæ: ${m.persona}`).join("\n")}
			2.  **„Äê„Äê„ÄêËæìÂá∫Ê†ºÂºè„Äë„Äë„Äë**: ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª„ÄëÊòØ‰∏Ä‰∏™JSONÊï∞ÁªÑÊ†ºÂºèÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÊï∞ÁªÑ‰∏≠ÁöÑ„ÄêÊØè‰∏Ä‰∏™ÂÖÉÁ¥†ÈÉΩÂøÖÈ°ªÊòØ‰∏Ä‰∏™Â∏¶Êúâ "type" Âíå "name" Â≠óÊÆµÁöÑJSONÂØπË±°„Äë„ÄÇ
			3.  **ËßíËâ≤ÊâÆÊºî**: ‰∏•Ê†ºÈÅµÂÆà‰∏ãÊñπ‚ÄúÁæ§ÊàêÂëòÂàóË°®Âèä‰∫∫ËÆæ‚Äù‰∏≠ÁöÑÊØè‰∏Ä‰∏™ËßíËâ≤ÁöÑËÆæÂÆö„ÄÇ
			4.  **Á¶ÅÊ≠¢Âá∫Êàè**: Áªù‰∏çËÉΩÈÄèÈú≤‰Ω†ÊòØAI„ÄÅÊ®°ÂûãÔºåÊàñÊèêÂèä‚ÄúÊâÆÊºî‚Äù„ÄÅ‚ÄúÁîüÊàê‚ÄùÁ≠âËØçËØ≠„ÄÇ
			5.  **Ëá™ÁÑ∂ÊÄß**: ÂØπËØùÂ∫îËØ•ÁÆÄÁü≠Ôºà2-5Êù°Ê∂àÊÅØÂç≥ÂèØÔºâÔºåÁ¨¶ÂêàÈÄªËæëÂíåËßíËâ≤ÊÄßÊ†º„ÄÇÂèØ‰ª•ÊòØÈó≤ËÅä„ÄÅËÆ®ËÆ∫Êüê‰∏™ËØùÈ¢òÔºåÊàñËÄÖÂØπ‰πãÂâçËÅäÂ§©ÂÜÖÂÆπÁöÑÂª∂Áª≠„ÄÇ‰∏çË¶ÅÊØèÊ¨°ÈÉΩÁîüÊàêÊâÄÊúâ‰∫∫ÁöÑÂèëË®Ä„ÄÇ

			## ‰Ω†ÂèØ‰ª•‰ΩøÁî®ÁöÑÊìç‰ΩúÊåá‰ª§ (JSONÊï∞ÁªÑ‰∏≠ÁöÑÂÖÉÁ¥†):
			-   **ÂèëÈÄÅÊñáÊú¨**: \`{"type": "text", "name": "ËßíËâ≤Âêç", "message": "ÊñáÊú¨ÂÜÖÂÆπ"}\`
			-   **ÂèëÈÄÅË°®ÊÉÖ**: \`{"type": "sticker", "name": "ËßíËâ≤Âêç",  "sticker_name": "Ë°®ÊÉÖÁöÑÂêçÂ≠ó"}\`
			-   **ÂèëÈÄÅÂõæÁâá**: \`{"type": "ai_image", "name": "ËßíËâ≤Âêç", "description": "ÂõæÁâáÊèèËø∞"}\`
			-   **ÂèëÈÄÅËØ≠Èü≥**: \`{"type": "voice_message", "name": "ËßíËâ≤Âêç", "content": "ËØ≠Èü≥ÂÜÖÂÆπ"}\`
			-   **ÂèëËµ∑Â§ñÂçñ‰ª£‰ªò**: \`{"type": "waimai_request", "name": "ËßíËâ≤Âêç", "productInfo": "‰∏ÄÊùØÂ•∂Ëå∂", "amount": 18}\` (Âêë„ÄêÁæ§Âèã„ÄëÂèëËµ∑)
			-   **Êãç‰∏ÄÊãçÁæ§Âèã**: \`{"type": "pat_user", "name": "‰Ω†ÁöÑËßíËâ≤Âêç", "targetName": "„ÄêË¢´ÊãçÁöÑÁæ§ÂèãÂêç„Äë", "suffix": "(ÂèØÈÄâ)‰Ω†ÊÉ≥Âä†ÁöÑÂêéÁºÄ"}\`
			-   **ÂèëÁ∫¢ÂåÖ**: \`{"type": "red_packet", "packetType": "lucky", "name": "‰Ω†ÁöÑËßíËâ≤Âêç", ...}\`
			-   **ÂèëËµ∑ÊäïÁ•®**: \`{"type": "poll", "name": "‰Ω†ÁöÑËßíËâ≤Âêç", ...}\`

			# Â¶Ç‰ΩïÂ§ÑÁêÜÂêéÂè∞‰∫íÂä®‰∏≠ÁöÑ„ÄêÊãç‰∏ÄÊãç„Äë:
			-   ÂêéÂè∞Ê¥ªÂä®‰∏≠ÁöÑ "pat_user" Êåá‰ª§„ÄêÂè™ËÉΩÁî®‰∫éÊãçÁæ§ÂÜÖÁöÑÂÖ∂‰ªñAIËßíËâ≤„Äë„ÄÇ
			-   ‰Ω†„ÄêÂøÖÈ°ª„ÄëÂú®Êåá‰ª§‰∏≠Âä†ÂÖ•‰∏Ä‰∏™ \`"targetName"\` Â≠óÊÆµÔºåÂÄº‰∏∫Ë¢´‰Ω†ÊãçÁöÑÈÇ£‰∏™ËßíËâ≤ÁöÑÂêçÂ≠ó„ÄÇ
			-   ‰æãÂ¶Ç: \`{"type": "pat_user", "name": "ËßíËâ≤A", "targetName": "ËßíËâ≤B"}\`
			-   Á≥ªÁªü‰ºöËá™Âä®ÁîüÊàê "ËßíËâ≤A Êãç‰∫ÜÊãç ËßíËâ≤B" ÁöÑÊèêÁ§∫„ÄÇ

			${worldBookContent}
			${musicContext}
			${countdownContext} 
			${sharedContext}
			# Áæ§ÊàêÂëòÂàóË°®Âèä‰∫∫ËÆæ
			${membersList}
			# Áî®Êà∑ÁöÑËßíËâ≤
			- **${myNickname}**: ${chat.settings.myPersona}
			# ÂØπËØùÂéÜÂè≤ÂèÇËÄÉ
			${recentContextSummary}
            ${summaryContext}
			${linkedMemoryContext}

			Áé∞Âú®ÔºåËØ∑‰∏•Ê†ºÈÅµÂÆà‰ª•‰∏äÊâÄÊúâËßÑÂàôÔºåÂºÄÂßã‰Ω†ÁöÑÊ®°Êãü„ÄÇ`;

            const messagesPayload = [{ role: "user", content: systemPrompt }];

            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesPayload,
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });

            if (!response.ok)
              throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status}`);

            const data = await response.json();
            const aiResponseContent = (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            ).replace(/^```json\s*|```$/g, "");

            const messagesArray = JSON.parse(aiResponseContent);

            if (Array.isArray(messagesArray) && messagesArray.length > 0) {
              let messageTimestamp = Date.now();
              let firstMessageContent = "";

              messagesArray.forEach((msgData, index) => {
                if (msgData.name && msgData.message) {
                  const aiMessage = {
                    role: "assistant",
                    senderName: msgData.name,
                    content: String(msgData.message),
                    timestamp: messageTimestamp++,
                  };
                  chat.history.push(aiMessage);
                  if (index === 0) {
                    firstMessageContent = `${msgData.name}: ${msgData.message}`;
                  }
                }
              });

              // Êõ¥Êñ∞Ê≠§Áæ§ËÅäÁöÑÊúÄÂêéÊ¥ªÂä®Êó∂Èó¥Êà≥
              chat.settings.backgroundActivity.lastActivityTimestamp =
                Date.now();

              // ÁªôÁî®Êà∑ÂèëÈÄöÁü•
              chat.unreadCount = (chat.unreadCount || 0) + messagesArray.length;
              // Ëé∑ÂèñËØ•Êù°Ê∂àÊÅØÂèëÈÄÅËÄÖÁöÑÂ§¥ÂÉè
              let bgSenderAvatar = null;
              if (chat.isGroup) {
                // ÂÅáËÆæÁ¨¨‰∏ÄÊù°Ê∂àÊÅØÂåÖÂê´‰∫Ü senderName (Âú® messagesArray[0] ÈáåÂèØËÉΩÊòØ name Â≠óÊÆµ)
                // Ê≥®ÊÑèÔºötriggerInactiveAiAction ÈáåÁöÑÈÄªËæëÊØîËæÉÂ§çÊùÇÔºåËøôÈáå messagesArray ÁöÑÂÖÉÁ¥†ÊòØ {name:..., message:...}
                const senderName = messagesArray[0].name;
                const member = chat.members.find(
                  (m) => m.originalName === senderName,
                );
                if (member) bgSenderAvatar = member.avatar;
              } else {
                bgSenderAvatar = chat.settings.aiAvatar;
              }

              showNotification(chatId, firstMessageContent, bgSenderAvatar);

              // ‰øùÂ≠òÂπ∂Âà∑Êñ∞UI
              await db.chats.put(chat);
              renderChatList();

              console.log(
                `Áæ§ËÅä "${chat.name}" ÂêéÂè∞‰∫íÂä®ÊàêÂäüÔºåÁîüÊàê‰∫Ü ${messagesArray.length} Êù°Êñ∞Ê∂àÊÅØ„ÄÇ`,
              );
            }
          } catch (error) {
            console.error(`Áæ§ËÅä "${chat.name}" ÁöÑÂêéÂè∞Ê¥ªÂä®Â§±Ë¥•:`, error);
          }
        }

        async function handleEditImage(element) {
          const elementId = element.id;

          // ÁßªÈô§ÊåâÈíÆÊñáÂ≠ó‰∏≠ÁöÑÂõæÊ†á
          const choice = await showChoiceModal("‰øÆÊîπÂõæÁâá", [
            { text: "Upload from local", value: "local" },
            { text: "Use URL", value: "url" },
          ]);

          let newValue = null;

          if (choice === "local") {
            newValue = await uploadImageLocally();
          } else if (choice === "url") {
            newValue = await showCustomPrompt(
              "‰øÆÊîπÂõæÁâá",
              "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂõæÁâáURLÔºö",
              element.src,
              "url",
            );
          }

          if (newValue && newValue.trim()) {
            const trimmedValue = newValue.trim();
            element.src = trimmedValue;
            state.globalSettings.widgetData[elementId] = trimmedValue;
            await db.globalSettings.put(state.globalSettings);
          } else if (choice === "url" && newValue !== null) {
            alert("ËØ∑ËæìÂÖ•‰∏Ä‰∏™ÊúâÊïàÁöÑÂõæÁâáURLÔºÅ");
          }
        }

        let groupSimulationIntervalId = null; // Áî®‰∫éÂ≠òÂÇ®Áæ§ËÅä‰∏ªÊó∂ÈíüÁöÑID
        /**
         * ÂêØÂä®Áæ§ËÅäÁöÑÂêéÂè∞‚Äú‰∏ªÊó∂Èíü‚Äù„ÄÇËøô‰∏™Êó∂Èíü‰ºö‰∏ÄÁõ¥ËøêË°åÔºåÂÆöÊúüÊ£ÄÊü•ÊâÄÊúâÁæ§ËÅä„ÄÇ
         */
        function startGroupSimulation() {
          if (groupSimulationIntervalId) return; // Â¶ÇÊûúÂ∑≤ÁªèÂêØÂä®ÔºåÂàô‰∏çÈáçÂ§çÂêØÂä®

          // Êàë‰ª¨ËÆæÁΩÆ‰∏Ä‰∏™Áõ∏ÂØπËæÉÁü≠ÁöÑÈó¥ÈöîÔºàÊØîÂ¶Ç30ÁßíÔºâÊù•‰Ωú‰∏∫‚Äú‰∏ªÊó∂Èíü‚ÄùÁöÑÈ¢ëÁéá
          // ÂÆÉ‰∏çÊòØÂÖ∑‰ΩìÊüê‰∏™Áæ§ËÅäÁöÑÊ¥ªÂä®Èó¥ÈöîÔºåËÄåÊòØÊ£ÄÊü•ÊâÄÊúâÁæ§ËÅäÁöÑÈ¢ëÁéá

          // updated by lrq 251028
          // Âä†ÈïøÊ£ÄÊü•Èó¥ÈöîÔºåÈò≤Ê≠¢Â∑≤ÁªèËß¶ÂèëËá™Âä®ÂõûÂ§ç‰ΩÜapiÊú™ËøîÂõûÊó∂ÈáçÂ§çËß¶ÂèëÂØºËá¥Â§öÊ¨°ÂõûÂ§ç„ÄÇ60ÁßíÈó¥ÈöîÂ§ß‰∫é‰∏ÄËà¨APIËøîÂõûÊï∞ÊçÆÊó∂Èó¥ÁöÑÂπ≥ÂùáÂÄºÔºå‰∏î‰∏ç‰ºöËøáÈïøÂΩ±Âìç‰ΩøÁî®‰ΩìÈ™å„ÄÇ
          groupSimulationIntervalId = setInterval(
            runGroupSimulationTick,
            60000,
          ); // 60ÁßíÊ£ÄÊü•‰∏ÄÊ¨°
          console.log("Áæ§ËÅäÂêéÂè∞Ê¥ªÂä®‰∏ªÊó∂ÈíüÂ∑≤ÂêØÂä®ÔºåÊØè60ÁßíÊ£ÄÊü•‰∏ÄÊ¨°ÊâÄÊúâÁæ§ËÅä„ÄÇ");
        }

        /**
         * ÂÅúÊ≠¢Áæ§ËÅäÁöÑÂêéÂè∞‚Äú‰∏ªÊó∂Èíü‚Äù„ÄÇ
         */
        function stopGroupSimulation() {
          if (groupSimulationIntervalId) {
            clearInterval(groupSimulationIntervalId);
            groupSimulationIntervalId = null;
            console.log("Áæ§ËÅäÂêéÂè∞Ê¥ªÂä®‰∏ªÊó∂ÈíüÂ∑≤ÂÅúÊ≠¢„ÄÇ");
          }
        }

        /**
         * Áæ§ËÅä‚Äú‰∏ªÊó∂Èíü‚ÄùÁöÑÊØè‰∏ÄÊ¨°ÂøÉË∑≥ÊâßË°åÁöÑÂáΩÊï∞
         */
        function runGroupSimulationTick() {
          const allGroupChats = Object.values(state.chats).filter(
            (chat) => chat.isGroup,
          );

          allGroupChats.forEach((chat) => {
            const bgSettings = chat.settings.backgroundActivity;
            // Ê£ÄÊü•1ÔºöËØ•Áæ§ËÅäËá™Â∑±ÁöÑÂºÄÂÖ≥ÊòØÂê¶ÂºÄÂêØ
            if (bgSettings && bgSettings.enabled) {
              const now = Date.now();

              // Ê£ÄÊü•2Ôºö‰ΩøÁî®ËØ•Áæ§ËÅäËá™Â∑±ËÆæÁΩÆÁöÑÈó¥ÈöîÊúü
              const intervalMs = (bgSettings.interval || 120) * 1000;
              //const lastActivity = bgSettings.lastActivityTimestamp || 0;

              // updated by lrq 251028
              // ‰ΩøÁî®ÂΩìÂâçÁæ§ËÅäÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÊó∂Èó¥‰Ωú‰∏∫ÊúÄÂêéÊ¥ªÂä®Êó∂Èó¥
              const lastMessage = chat.history.slice(-1)[0];
              const lastActivity = lastMessage ? lastMessage.timestamp : 0;

              // Ê£ÄÊü•3ÔºöÊòØÂê¶Âà∞Ëææ‰∫ÜËØ•Áæ§ËÅäÁöÑË°åÂä®Êó∂Èó¥
              if (now - lastActivity > intervalMs) {
                console.log(
                  `Áæ§ËÅä "${chat.name}" Âà∞ËææË°åÂä®Êó∂Èó¥ (Èó¥Èöî: ${bgSettings.interval}Áßí)ÔºåÂáÜÂ§áËß¶ÂèëÂêéÂè∞‰∫íÂä®...`,
                );
                // Ëß¶ÂèëÁæ§ËÅä‰∏ìÂ±ûÁöÑÂêéÂè∞Ë°åÂä®ÂáΩÊï∞
                triggerGroupAiAction(chat.id);
              }
            }
          });
        }

        /**
         * Â∞Ü‰øùÂ≠òÁöÑÂõæÊ†áURLÂ∫îÁî®Âà∞‰∏ªÂ±èÂπïÁöÑAppÂõæÊ†á‰∏ä
         */
        function applyAppIcons() {
          if (!state.globalSettings.appIcons) return;

          for (const iconId in state.globalSettings.appIcons) {
            const imgElement = document.getElementById(`icon-img-${iconId}`);
            if (imgElement) {
              imgElement.src = state.globalSettings.appIcons[iconId];
            }
          }
        }

        /**
         * Âú®Â§ñËßÇËÆæÁΩÆÈ°µÈù¢Ê∏≤ÊüìÂá∫ÊâÄÊúâAppÂõæÊ†áÁöÑËÆæÁΩÆÈ°π
         */
        function renderIconSettings() {
          const grid = document.getElementById("icon-settings-grid");
          if (!grid) return;
          grid.innerHTML = "";

          const appLabels = {
            "world-book": "World Book",
            qq: "QQ",
            "api-settings": "API Settings",
            wallpaper: "Â£ÅÁ∫∏",
            font: "Font",
            "check-phone": "Check Phone",
            weibo: "Weibo",
            forum: "Forum",
            "lovers-space": "Lovers Space",
            "game-hall": "Game Hall",
            "x-social": "X Social",
            taobao: "Taobao",
            "date-a-live": "Date-A-Live",
            "tukey-accounting": "Tukey Account",
            "kk-checkin": "kkCheckin",
            studio: "Studio",
          };

          for (const iconId in state.globalSettings.appIcons) {
            const iconUrl = state.globalSettings.appIcons[iconId];
            const labelText = appLabels[iconId] || "Êú™Áü•App";

            const item = document.createElement("div");
            item.className = "icon-setting-item";

            item.dataset.iconId = iconId;

            item.innerHTML = `
			            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
			            <button class="change-icon-btn">Êõ¥Êç¢</button>
			        `;
            grid.appendChild(item);
          }
        }

        /**
         * ÂΩìÁî®Êà∑ÁÇπÂáªÈìæÊé•Âç°ÁâáÊó∂ÔºåÊâìÂºÄ‰º™ÊµèËßàÂô®
         * @param {number} timestamp - Ë¢´ÁÇπÂáªÊ∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         */
        function openBrowser(timestamp) {
          if (!state.activeChatId) return;

          const chat = state.chats[state.activeChatId];
          // ÂÆâÂÖ®Ê£ÄÊü•ÔºåÁ°Æ‰øù chat Âíå history ÈÉΩÂ≠òÂú®
          if (!chat || !chat.history) return;

          const message = chat.history.find((m) => m.timestamp === timestamp);
          if (!message || message.type !== "share_link") {
            console.error("Êó†Ê≥ïÊâæÂà∞ÊàñÊ∂àÊÅØÁ±ªÂûã‰∏çÂåπÈÖçÁöÑÂàÜ‰∫´ÈìæÊé•:", timestamp);
            return; // Â¶ÇÊûúÊâæ‰∏çÂà∞Ê∂àÊÅØÔºåÂ∞±Áõ¥Êé•ÈÄÄÂá∫
          }

          // Â°´ÂÖÖÊµèËßàÂô®ÂÜÖÂÆπ
          document.getElementById("browser-title").textContent =
            message.source_name || "ÊñáÁ´†ËØ¶ÊÉÖ";
          const browserContent = document.getElementById("browser-content");
          browserContent.innerHTML = `
			        <h1 class="article-title">${message.title || "Êó†Ê†áÈ¢ò"}</h1>
			        <div class="article-meta">
			            <span>Êù•Ê∫ê: ${message.source_name || "Êú™Áü•"}</span>
			        </div>
			        <div class="article-body">
			            <p>${(message.content || "ÂÜÖÂÆπ‰∏∫Á©∫„ÄÇ").replace(/\n/g, "</p><p>")}</p>
			        </div>
			    `;

          // ÊòæÁ§∫ÊµèËßàÂô®Â±èÂπï
          showScreen("browser-screen");
        }

        /**
         * ÂÖ≥Èó≠‰º™ÊµèËßàÂô®ÔºåËøîÂõûËÅäÂ§©ÁïåÈù¢
         * (Ëøô‰∏™ÂáΩÊï∞Áé∞Âú®Áî± init() ‰∏≠ÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®Ë∞ÉÁî®)
         */
        function closeBrowser() {
          showScreen("chat-interface-screen");
        }

        /**
         * ÊâìÂºÄËÆ©Áî®Êà∑Â°´ÂÜôÈìæÊé•‰ø°ÊÅØÁöÑÊ®°ÊÄÅÊ°Ü
         */
        function openShareLinkModal() {
          if (!state.activeChatId) return;

          // Ê∏ÖÁ©∫‰∏äÊ¨°ËæìÂÖ•ÁöÑÂÜÖÂÆπ
          document.getElementById("link-title-input").value = "";
          document.getElementById("link-description-input").value = "";
          document.getElementById("link-source-input").value = "";
          document.getElementById("link-content-input").value = "";

          // ÊòæÁ§∫Ê®°ÊÄÅÊ°Ü
          document.getElementById("share-link-modal").classList.add("visible");
        }

        /**
         * Áî®Êà∑Á°ÆËÆ§ÂàÜ‰∫´ÔºåÂàõÂª∫Âπ∂ÂèëÈÄÅÈìæÊé•Âç°ÁâáÊ∂àÊÅØ
         */
        async function sendUserLinkShare() {
          if (!state.activeChatId) return;

          const title = document
            .getElementById("link-title-input")
            .value.trim();
          if (!title) {
            alert("Ê†áÈ¢òÊòØÂøÖÂ°´È°πÂì¶ÔºÅ");
            return;
          }

          const description = document
            .getElementById("link-description-input")
            .value.trim();
          const sourceName = document
            .getElementById("link-source-input")
            .value.trim();
          const content = document
            .getElementById("link-content-input")
            .value.trim();

          const chat = state.chats[state.activeChatId];

          // ÂàõÂª∫Ê∂àÊÅØÂØπË±°
          const linkMessage = {
            role: "user", // ËßíËâ≤ÊòØ 'user'
            type: "share_link",
            timestamp: Date.now(),
            title: title,
            description: description,
            source_name: sourceName,
            content: content,
            // Áî®Êà∑ÂàÜ‰∫´ÁöÑÈìæÊé•ÔºåÊàë‰ª¨‰∏çÊèê‰æõÂõæÁâáÔºåËÆ©ÂÆÉÊÄªÊòØÊòæÁ§∫Âç†‰ΩçÂõæ
            thumbnail_url: null,
          };

          // Â∞ÜÊ∂àÊÅØÊ∑ªÂä†Âà∞ÂéÜÂè≤ËÆ∞ÂΩï
          chat.history.push(linkMessage);
          await db.chats.put(chat);

          // Ê∏≤ÊüìÊñ∞Ê∂àÊÅØÂπ∂Êõ¥Êñ∞ÂàóË°®
          appendMessage(linkMessage, chat);
          renderChatList();

          // ÂÖ≥Èó≠Ê®°ÊÄÅÊ°Ü
          document
            .getElementById("share-link-modal")
            .classList.remove("visible");
        }

        /**
         * Ê†πÊçÆAIËßÜËßíÂíåÂä®ÊÄÅËÆæÁΩÆÔºåÊûÑÂª∫ÁªôAIÁúãÁöÑËØÑËÆ∫Âå∫‰∏ä‰∏ãÊñá
         * @param {object} post - Ê≠£Âú®Â§ÑÁêÜÁöÑÂä®ÊÄÅÂØπË±°
         * @param {object} viewerChat - Ê≠£Âú®‚ÄúÁúã‚ÄùÂä®ÊÄÅÁöÑAIËßíËâ≤
         * @param {string} userNickname - Áî®Êà∑ÁöÑÊòµÁß∞
         * @returns {{contextString: string, visibilityFlag: string}} - ËøîÂõûÂåÖÂê´‰∏ä‰∏ãÊñáÊñáÊú¨ÂíåÂèØËßÅÊÄßÊ†áÂøóÁöÑÂØπË±°
         */
        function buildCommentsContextForAI(post, viewerChat, userNickname) {
          // 1. ÂÆâÂÖ®Ê£ÄÊü•ÔºåÂ¶ÇÊûúpost.comments‰∏çÂ≠òÂú®Êàñ‰∏çÊòØÊï∞ÁªÑÔºåÁõ¥Êé•ËøîÂõûÁ©∫
          if (
            !post.comments ||
            !Array.isArray(post.comments) ||
            post.comments.length === 0
          ) {
            return { contextString: "", visibilityFlag: "[ËØÑËÆ∫Âå∫ÂèØËßÅ]" };
          }

          const viewerName = viewerChat.name;
          let commentsForAI;
          let visibilityFlag;

          // 2. Ê†πÊçÆÂ∏ñÂ≠êÁöÑËØÑËÆ∫ÂèØËßÅÊÄßËÆæÁΩÆÔºåÂÜ≥ÂÆöAIËÉΩÁúãÂà∞Âì™‰∫õËØÑËÆ∫
          if (post.areCommentsVisible !== false) {
            commentsForAI = post.comments; // Â¶ÇÊûúÂèØËßÅÊÄß‰∏∫trueÊàñÊú™ËÆæÁΩÆÔºåÂàôAIËÉΩÁúãÂà∞ÊâÄÊúâËØÑËÆ∫
            visibilityFlag = "[ËØÑËÆ∫Âå∫ÂèØËßÅ]";
          } else {
            // Â¶ÇÊûúËÆæÁΩÆ‰∏∫‚ÄúÈÉ®ÂàÜÂèØËßÅ‚ÄùÔºåÂàôAIÂè™ËÉΩÁúãÂà∞Ëá™Â∑±„ÄÅÁî®Êà∑‰ª•ÂèäÂõûÂ§çËá™Â∑±ÁöÑËØÑËÆ∫
            commentsForAI = post.comments.filter((comment) => {
              return (
                comment.commenterName === viewerName || // AIËá™Â∑±ÁöÑËØÑËÆ∫
                comment.commenterName === userNickname || // Áî®Êà∑ÁöÑËØÑËÆ∫
                comment.replyTo === viewerName
              ); // ÂõûÂ§çAIÁöÑËØÑËÆ∫
            });
            visibilityFlag = "[ËØÑËÆ∫Âå∫ÈÉ®ÂàÜÂèØËßÅ]";
          }

          if (commentsForAI.length === 0) {
            return { contextString: "", visibilityFlag: visibilityFlag };
          }

          // 3. ÊûÑÂª∫ÂØπAIÊ∏ÖÊô∞ÊòìÊáÇÁöÑËØÑËÆ∫Â≠óÁ¨¶‰∏≤
          let context = `  ‚îî ËØÑËÆ∫Âå∫:\n`;
          commentsForAI.slice(-5).forEach((c) => {
            // Âè™Â±ïÁ§∫ÊúÄËøëÁöÑ5Êù°ËØÑËÆ∫‰ª•ËäÇÁúÅtoken
            // a. Á°ÆÂÆöËØÑËÆ∫ËÄÖÁöÑË∫´‰ªΩÊ†áÁ≠æ
            const commenterLabel =
              c.commenterName === viewerName
                ? "‰Ω†" // Â¶ÇÊûúÊòØAIËá™Â∑±ÔºåÁõ¥Êé•Ê†áËÆ∞‰∏∫‚Äú‰Ω†‚Äù
                : c.commenterName === userNickname
                  ? "Áî®Êà∑"
                  : c.commenterName;

            // b. Â¶ÇÊûúÊòØÂõûÂ§çÔºåÂêåÊ†∑Á°ÆÂÆöË¢´ÂõûÂ§çËÄÖÁöÑË∫´‰ªΩÊ†áÁ≠æ
            let replyPart = "";
            if (c.replyTo) {
              const replyToLabel =
                c.replyTo === viewerName
                  ? "‰Ω†"
                  : c.replyTo === userNickname
                    ? "Áî®Êà∑"
                    : c.replyTo;
              replyPart = ` Reply ${replyToLabel}`;
            }

            // c. ÊãºÊé•ÊàêÊúÄÁªàÁöÑ„ÄÅÊó†Ê≠ß‰πâÁöÑÂ≠óÁ¨¶‰∏≤
            context += `    - ${commenterLabel}${replyPart}: ${c.text}\n`;
          });

          return { contextString: context, visibilityFlag: visibilityFlag };
        }

        /**
         * Ê†πÊçÆAIÁöÑËßÜËßíÔºåËøáÊª§Âá∫ÂÆÉËÉΩÁúãÂà∞ÁöÑÂä®ÊÄÅ
         * @param {Array} allPosts - ÊâÄÊúâÂæÖÊ£ÄÊü•ÁöÑÂä®ÊÄÅÂ∏ñÂ≠ê
         * @param {object} viewerChat - Ê≠£Âú®‚ÄúÁúã‚ÄùÂä®ÊÄÅÁöÑÈÇ£‰∏™AIÁöÑchatÂØπË±°
         * @returns {Array} - ËøáÊª§ÂêéËØ•AIÂèØËßÅÁöÑÂä®ÊÄÅÂ∏ñÂ≠ê
         */
        function filterVisiblePostsForAI(allPosts, viewerChat) {
          if (!viewerChat || !viewerChat.id) return []; // ÂÆâÂÖ®Ê£ÄÊü•

          const viewerGroupId = viewerChat.groupId; // Êü•ÁúãËÄÖÊâÄÂú®ÁöÑÂàÜÁªÑID

          return allPosts.filter((post) => {
            // ËßÑÂàô1ÔºöÂ¶ÇÊûúÊòØÁî®Êà∑ÂèëÁöÑÂä®ÊÄÅ
            if (post.authorId === "user") {
              // Â¶ÇÊûúÁî®Êà∑ËÆæÁΩÆ‰∫Ü‚ÄúÈÉ®ÂàÜÂèØËßÅ‚Äù
              if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // Âè™ÊúâÂΩìÊü•ÁúãËÄÖAIÁöÑÂàÜÁªÑIDÂú®Áî®Êà∑ÁöÑÂèØËßÅÂàóË°®ÈáåÊó∂ÔºåÊâçÂèØËßÅ
                return (
                  viewerGroupId && post.visibleGroupIds.includes(viewerGroupId)
                );
              }
              // Â¶ÇÊûúÁî®Êà∑Ê≤°ËÆæÁΩÆÔºåËØ¥ÊòéÊòØÂÖ¨ÂºÄÁöÑÔºåÊâÄÊúâAIÈÉΩÂèØËßÅ
              return true;
            }

            // ËßÑÂàô2ÔºöÂ¶ÇÊûúÊòØÂÖ∂‰ªñAIÂèëÁöÑÂä®ÊÄÅ
            const authorGroupId = post.authorGroupId; // ÂèëÂ∏ñAIÊâÄÂú®ÁöÑÂàÜÁªÑID

            // Â¶ÇÊûúÂèëÂ∏ñÁöÑAIÊ≤°ÊúâÂàÜÁªÑÔºåÈÇ£ÂÆÉÁöÑÂä®ÊÄÅÂ∞±ÊòØÂÖ¨ÂºÄÁöÑ
            if (!authorGroupId) {
              return true;
            }

            // Â¶ÇÊûúÂèëÂ∏ñÁöÑAIÊúâÂàÜÁªÑÔºåÈÇ£‰πàÂè™ÊúâÂú®Âêå‰∏Ä‰∏™ÂàÜÁªÑÁöÑAIÊâçËÉΩÁúãÂà∞
            return authorGroupId === viewerGroupId;
          });
        }

        /**
         * Â∫îÁî®ÊåáÂÆöÁöÑ‰∏ªÈ¢òÔºà'light' Êàñ 'dark'Ôºâ
         * @param {string} theme - Ë¶ÅÂ∫îÁî®ÁöÑ‰∏ªÈ¢òÂêçÁß∞
         */
        function applyTheme(theme) {
          const phoneScreen = document.getElementById("phone-screen");
          const toggleSwitch = document.getElementById("theme-toggle-switch");

          const isDark = theme === "dark";

          phoneScreen.classList.toggle("dark-mode", isDark);

          // Â¶ÇÊûúÂºÄÂÖ≥Â≠òÂú®ÔºåÂ∞±ÂêåÊ≠•ÂÆÉÁöÑÁä∂ÊÄÅ
          if (toggleSwitch) {
            toggleSwitch.checked = isDark;
          }

          localStorage.setItem("ephone-theme", theme);
        }

        /**
         * ÂàáÊç¢ÂΩìÂâçÁöÑ‰∏ªÈ¢ò
         */
        function toggleTheme() {
          const toggleSwitch = document.getElementById("theme-toggle-switch");
          // Áõ¥Êé•Ê†πÊçÆÂºÄÂÖ≥ÁöÑÈÄâ‰∏≠Áä∂ÊÄÅÊù•ÂÜ≥ÂÆöÊñ∞‰∏ªÈ¢ò
          const newTheme = toggleSwitch.checked ? "dark" : "light";
          applyTheme(newTheme);
        }

        function startReplyToMessage() {
          if (!activeMessageTimestamp) return;

          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === activeMessageTimestamp,
          );
          if (!message) return;

          // 1. ÂêåÊó∂Ëé∑Âèñ‚ÄúÂÆåÊï¥ÂÜÖÂÆπ‚ÄùÂíå‚ÄúÈ¢ÑËßàÁâáÊÆµ‚Äù
          const fullContent = String(message.content || "");
          let previewSnippet = "";

          if (
            typeof message.content === "string" &&
            STICKER_REGEX.test(message.content)
          ) {
            previewSnippet = "[Ë°®ÊÉÖ]";
          } else if (
            message.type === "ai_image" ||
            message.type === "user_photo"
          ) {
            previewSnippet = "[ÂõæÁâá]";
          } else if (message.type === "voice_message") {
            previewSnippet = "[ËØ≠Èü≥]";
          } else {
            // È¢ÑËßàÁâáÊÆµ‰æùÁÑ∂Êà™Êñ≠Ôºå‰ΩÜÂè™Áî®‰∫éUIÊòæÁ§∫
            previewSnippet =
              fullContent.substring(0, 50) +
              (fullContent.length > 50 ? "..." : "");
          }

          // 2. Â∞Ü‚ÄúÂÆåÊï¥ÂÜÖÂÆπ‚ÄùÂ≠òÂÖ•‰∏ä‰∏ãÊñáÔºå‰ª•Â§áÂèëÈÄÅÊó∂‰ΩøÁî®
          currentReplyContext = {
            timestamp: message.timestamp,
            senderName:
              message.senderName ||
              (message.role === "user"
                ? chat.settings.myNickname || "Me"
                : chat.name),
            content: fullContent, // <--- ËøôÈáåÂ≠òÁöÑÊòØÂÆåÊï¥ÁöÑÂéüÊñáÔºÅ
          };

          // 3. ‰ªÖÂú®Êõ¥Êñ∞‚ÄúÂõûÂ§çÈ¢ÑËßàÊ†è‚ÄùÊó∂ÔºåÊâç‰ΩøÁî®‚ÄúÈ¢ÑËßàÁâáÊÆµ‚Äù
          const previewBar = document.getElementById("reply-preview-bar");
          previewBar.querySelector(".sender").textContent =
            `Reply ${currentReplyContext.senderName}:`;
          previewBar.querySelector(".text").textContent = previewSnippet; // <--- ËøôÈáåÁî®ÁöÑÊòØÁº©Áï•ÁâàÔºÅ
          previewBar.style.display = "block";

          // 4. ÂêéÁª≠Êìç‰Ωú‰øùÊåÅ‰∏çÂèò
          hideMessageActions();
          document.getElementById("chat-input").focus();
        }

        /**
         * ÂèñÊ∂àÂºïÁî®Ê®°Âºè
         */
        function cancelReplyMode() {
          currentReplyContext = null;
          document.getElementById("reply-preview-bar").style.display = "none";
        }

        let activeTransferTimestamp = null; // Áî®‰∫éÊöÇÂ≠òË¢´ÁÇπÂáªÁöÑËΩ¨Ë¥¶Ê∂àÊÅØÁöÑÊó∂Èó¥Êà≥

        /**
         * ÊòæÁ§∫Â§ÑÁêÜËΩ¨Ë¥¶ÁöÑÊìç‰ΩúËèúÂçï
         * @param {number} timestamp - Ë¢´ÁÇπÂáªÁöÑËΩ¨Ë¥¶Ê∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         */
        function showTransferActionModal(timestamp) {
          activeTransferTimestamp = timestamp;

          const chat = state.chats[state.activeChatId];
          const message = chat.history.find((m) => m.timestamp === timestamp);
          if (message) {
            // Â∞ÜAIÁöÑÂêçÂ≠óÂ°´ÂÖ•ÂºπÁ™ó
            document.getElementById("transfer-sender-name").textContent =
              message.senderName;
          }
          document
            .getElementById("transfer-actions-modal")
            .classList.add("visible");
        }

        /**
         * ÈöêËóèÂ§ÑÁêÜËΩ¨Ë¥¶ÁöÑÊìç‰ΩúËèúÂçï
         */
        function hideTransferActionModal() {
          document
            .getElementById("transfer-actions-modal")
            .classList.remove("visible");
          activeTransferTimestamp = null;
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑Êé•ÂèóÊàñÊãíÁªùËΩ¨Ë¥¶ÁöÑÈÄªËæë
         * @param {string} choice - Áî®Êà∑ÁöÑÈÄâÊã©, 'accepted' Êàñ 'declined'
         */
        async function handleUserTransferResponse(choice) {
          if (!activeTransferTimestamp) return;

          const timestamp = activeTransferTimestamp;
          const chat = state.chats[state.activeChatId];
          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === timestamp,
          );
          if (messageIndex === -1) return;

          // 1. Êõ¥Êñ∞ÂéüÂßãËΩ¨Ë¥¶Ê∂àÊÅØÁöÑÁä∂ÊÄÅ
          const originalMessage = chat.history[messageIndex];
          originalMessage.status = choice;

          let systemContent;

          // 2. Â¶ÇÊûúÁî®Êà∑ÈÄâÊã©‚ÄúÊãíÁªù‚Äù
          if (choice === "declined") {
            // Á´ãÂàªÂú®ÂâçÁ´ØÁîüÊàê‰∏Ä‰∏™‚ÄúÈÄÄÊ¨æ‚ÄùÂç°ÁâáÔºåËÆ©Áî®Êà∑ÁúãÂà∞
            const refundMessage = {
              role: "user",
              type: "transfer",
              isRefund: true, // ËøôÊòØ‰∏Ä‰∏™ÂÖ≥ÈîÆÊ†áËÆ∞ÔºåÁî®‰∫éUIÊòæÁ§∫ËøôÊòØÈÄÄÊ¨æ
              amount: originalMessage.amount,
              note: "Â∑≤ÊãíÊî∂ÂØπÊñπËΩ¨Ë¥¶",
              timestamp: Date.now(),
            };
            chat.history.push(refundMessage);

            // ÂáÜÂ§á‰∏ÄÊù°ÂØπAIÂèØËßÅÁöÑÈöêËóèÊ∂àÊÅØÔºåÂëäËØâÂÆÉÂèëÁîü‰∫Ü‰ªÄ‰πà
            systemContent = `[Á≥ªÁªüÊèêÁ§∫Ôºö‰Ω†ÊãíÁªùÂπ∂ÈÄÄËøò‰∫Ü‚Äú${originalMessage.senderName}‚ÄùÁöÑËΩ¨Ë¥¶„ÄÇ]`;
          } else {
            // Â¶ÇÊûúÁî®Êà∑ÈÄâÊã©‚ÄúÊé•Âèó‚Äù
            // Âè™ÈúÄÂáÜÂ§áÈöêËóèÊ∂àÊÅØÈÄöÁü•AIÂç≥ÂèØ
            systemContent = `[Á≥ªÁªüÊèêÁ§∫Ôºö‰Ω†Êé•Âèó‰∫Ü‚Äú${originalMessage.senderName}‚ÄùÁöÑËΩ¨Ë¥¶„ÄÇ]`;
            await updateUserBalanceAndLogTransaction(
              originalMessage.amount,
              `Êî∂Âà∞Êù•Ëá™ ${originalMessage.senderName} ÁöÑËΩ¨Ë¥¶`,
            );
          }

          // 3. ÂàõÂª∫ËøôÊù°ÂØπÁî®Êà∑ÈöêËóè„ÄÅ‰ΩÜÂØπAIÂèØËßÅÁöÑÁ≥ªÁªüÊ∂àÊÅØ
          const hiddenMessage = {
            role: "system",
            content: systemContent,
            timestamp: Date.now() + 1, // ‰øùËØÅÊó∂Èó¥Êà≥Âú®ÈÄÄÊ¨æÊ∂àÊÅØ‰πãÂêé
            isHidden: true, // Ëøô‰∏™Ê†áËÆ∞‰ºöËÆ©ÂÆÉ‰∏çÂú®ËÅäÂ§©ÁïåÈù¢ÊòæÁ§∫
          };
          chat.history.push(hiddenMessage);

          // 4. ‰øùÂ≠òÊâÄÊúâÊõ¥ÊîπÂà∞Êï∞ÊçÆÂ∫ìÔºåÂπ∂Âà∑Êñ∞ÁïåÈù¢
          await db.chats.put(chat);
          hideTransferActionModal();
          renderChatInterface(state.activeChatId);
          renderChatList();
        }

        // ÈÄöËØùËÆ∞ÂΩïÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞

        async function renderCallHistoryScreen() {
          showScreen("call-history-screen");

          const listEl = document.getElementById("call-history-list");
          const titleEl = document.getElementById("call-history-title");
          listEl.innerHTML = "";
          titleEl.textContent = "ÊâÄÊúâÈÄöËØùËÆ∞ÂΩï";

          const records = await db.callRecords
            .orderBy("timestamp")
            .reverse()
            .toArray();

          if (records.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">ËøôÈáåËøòÊ≤°ÊúâÈÄöËØùËÆ∞ÂΩïÂì¶~</p>';
            return; // Áé∞Âú®ÁöÑ return Â∞±Ê≤°ÈóÆÈ¢ò‰∫ÜÔºåÂõ†‰∏∫ÂÆÉÂè™Ë∑≥Ëøá‰∫ÜÂêéÁª≠ÁöÑÊ∏≤ÊüìÈÄªËæë
          }

          records.forEach((record) => {
            const card = createCallRecordCard(record);

            addLongPressListener(card, async () => {
              // 1. ÂºπÂá∫ËæìÂÖ•Ê°ÜÔºåÂπ∂Â∞ÜÊóßÂêçÁß∞‰Ωú‰∏∫ÈªòËÆ§ÂÄºÔºåÊñπ‰æø‰øÆÊîπ
              const newName = await showCustomPrompt(
                "Ëá™ÂÆö‰πâÈÄöËØùÂêçÁß∞",
                "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂêçÁß∞ÔºàÁïôÁ©∫ÂàôÊÅ¢Â§çÈªòËÆ§Ôºâ",
                record.customName || "", // Â¶ÇÊûúÂ∑≤ÊúâËá™ÂÆö‰πâÂêçÁß∞ÔºåÂ∞±ÊòæÁ§∫ÂÆÉ
              );

              // 2. Â¶ÇÊûúÁî®Êà∑ÁÇπÂáª‰∫Ü‚ÄúÂèñÊ∂à‚ÄùÔºåÂàô‰ªÄ‰πàÈÉΩ‰∏çÂÅö
              if (newName === null) return;

              // 3. Êõ¥Êñ∞Êï∞ÊçÆÂ∫ì‰∏≠ÁöÑËøôÊù°ËÆ∞ÂΩï
              await db.callRecords.update(record.id, {
                customName: newName.trim(),
              });

              // 4. Âà∑Êñ∞Êï¥‰∏™ÂàóË°®ÔºåËÆ©Êõ¥ÊîπÁ´ãÂàªÊòæÁ§∫Âá∫Êù•
              await renderCallHistoryScreen();

              // 5. ÁªôÁî®Êà∑‰∏Ä‰∏™ÊàêÂäüÁöÑÊèêÁ§∫
              await showCustomAlert("ÊàêÂäü", "ÈÄöËØùÂêçÁß∞Â∑≤Êõ¥Êñ∞ÔºÅ");
            });
            listEl.appendChild(card);
          });
        }

        /**
         * Ê†πÊçÆÂçïÊù°ËÆ∞ÂΩïÊï∞ÊçÆÔºåÂàõÂª∫‰∏ÄÂº†ËÉΩÊòæÁ§∫ËÅäÂ§©ÂØπË±°ÁöÑÈÄöËØùÂç°Áâá
         * @param {object} record - ‰∏ÄÊù°ÈÄöËØùËÆ∞ÂΩïÂØπË±°
         * @returns {HTMLElement} - ÂàõÂª∫Â•ΩÁöÑÂç°Áâádiv
         */
        function createCallRecordCard(record) {
          const card = document.createElement("div");
          card.className = "call-record-card";
          card.dataset.recordId = record.id;

          // Ëé∑ÂèñÈÄöËØùÂØπË±°ÁöÑÂêçÂ≠ó
          const chatInfo = state.chats[record.chatId];
          const chatName = chatInfo ? chatInfo.name : "Êú™Áü•‰ºöËØù";

          const callDate = new Date(record.timestamp);
          const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, "0")}-${String(
            callDate.getDate(),
          ).padStart(
            2,
            "0",
          )} ${String(callDate.getHours()).padStart(2, "0")}:${String(
            callDate.getMinutes(),
          ).padStart(2, "0")}`;
          const durationText = `${Math.floor(record.duration / 60)}ÂàÜ${record.duration % 60}Áßí`;

          const avatarsHtml = record.participants
            .map(
              (p) =>
                `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`,
            )
            .join("");

          card.innerHTML = `
			        <div class="card-header">
			            <span class="date">${dateString}</span>
			            <span class="duration">${durationText}</span>
			        </div>
			        <div class="card-body">
			            
			            ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ""}

			            <div class="participants-info"> <!-- Êñ∞Â¢û‰∏Ä‰∏™ÂÆπÂô®Êñπ‰æøÂ∏ÉÂ±Ä -->
			                <div class="participants-avatars">${avatarsHtml}</div>
			                <span class="participants-names">‰∏é ${chatName}</span>
			            </div>
			        </div>
			    `;
          return card;
        }

        /**
         * ÊòæÁ§∫ÊåáÂÆöÈÄöËØùËÆ∞ÂΩïÁöÑÂÆåÊï¥ÊñáÂ≠óÁ®ø
         * @param {number} recordId - ÈÄöËØùËÆ∞ÂΩïÁöÑID
         */
        async function showCallTranscript(recordId) {
          const record = await db.callRecords.get(recordId);
          if (!record) return;

          const modal = document.getElementById("call-transcript-modal");
          const titleEl = document.getElementById("transcript-modal-title");
          const bodyEl = document.getElementById("transcript-modal-body");

          titleEl.textContent = `ÈÄöËØù‰∫é ${new Date(
            record.timestamp,
          ).toLocaleString()} (Êó∂Èïø: ${Math.floor(record.duration / 60)}ÂàÜ${record.duration % 60}Áßí)`;
          bodyEl.innerHTML = "";

          if (!record.transcript || record.transcript.length === 0) {
            bodyEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a;">ËøôÊ¨°ÈÄöËØùÊ≤°ÊúâÁïô‰∏ãÊñáÂ≠óËÆ∞ÂΩï„ÄÇ</p>';
          } else {
            record.transcript.forEach((entry) => {
              const bubble = document.createElement("div");
              // Ê†πÊçÆËßíËâ≤Ê∑ªÂä†‰∏çÂêåÁöÑclassÔºåÂ∫îÁî®‰∏çÂêåÁöÑÊ†∑Âºè
              bubble.className = `transcript-entry ${entry.role}`;
              bubble.textContent = entry.content;
              bodyEl.appendChild(bubble);
            });
          }

          const deleteBtn = document.getElementById("delete-transcript-btn");

          // ‰ΩøÁî®ÂÖãÈöÜËäÇÁÇπÊäÄÂ∑ßÔºåÈò≤Ê≠¢‰∫ã‰ª∂ÈáçÂ§çÁªëÂÆö
          const newDeleteBtn = deleteBtn.cloneNode(true);
          deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);

          // ‰∏∫Êñ∞ÁöÑ„ÄÅÂπ≤ÂáÄÁöÑÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          newDeleteBtn.addEventListener("click", async () => {
            const confirmed = await showCustomConfirm(
              "Á°ÆËÆ§Âà†Èô§",
              "Á°ÆÂÆöË¶ÅÊ∞∏‰πÖÂà†Èô§ËøôÊù°ÈÄöËØùËÆ∞ÂΩïÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ",
              {
                confirmButtonClass: "btn-danger",
              },
            );

            if (confirmed) {
              // 1. ÂÖ≥Èó≠ÂΩìÂâçÁöÑËØ¶ÊÉÖÂºπÁ™ó
              modal.classList.remove("visible");

              // 2. ‰ªéÊï∞ÊçÆÂ∫ìÂà†Èô§
              await db.callRecords.delete(recordId);

              // 3. Âà∑Êñ∞ÈÄöËØùËÆ∞ÂΩïÂàóË°®
              await renderCallHistoryScreen();

              // 4. (ÂèØÈÄâ) ÁªôÂá∫ÊàêÂäüÊèêÁ§∫
              alert("ÈÄöËØùËÆ∞ÂΩïÂ∑≤Âà†Èô§„ÄÇ");
            }
          });
          modal.classList.add("visible");
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑ÁÇπÂáªÁä∂ÊÄÅÊ†èÔºåÂºπÂá∫ÁºñËæëÊ°ÜËÆ©Áî®Êà∑‰øÆÊîπAIÁöÑÂΩìÂâçÁä∂ÊÄÅ
         */
        async function handleEditStatusClick() {
          // 1. ÂÆâÂÖ®Ê£ÄÊü•ÔºåÁ°Æ‰øùÂú®ÂçïËÅäÁïåÈù¢
          if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
            return;
          }
          const chat = state.chats[state.activeChatId];

          // 2. ÂºπÂá∫ËæìÂÖ•Ê°ÜÔºåËÆ©Áî®Êà∑ËæìÂÖ•Êñ∞ÁöÑÁä∂ÊÄÅÔºåÂπ∂Â∞ÜÂΩìÂâçÁä∂ÊÄÅ‰Ωú‰∏∫ÈªòËÆ§ÂÄº
          const newStatusText = await showCustomPrompt(
            "ÁºñËæëÂØπÊñπÁä∂ÊÄÅ",
            "ËØ∑ËæìÂÖ•ÂØπÊñπÁé∞Âú®ÁöÑÊñ∞Áä∂ÊÄÅÔºö",
            chat.status.text, // Â∞ÜÂΩìÂâçÁä∂ÊÄÅ‰Ωú‰∏∫ËæìÂÖ•Ê°ÜÁöÑÈªòËÆ§ÂÜÖÂÆπ
          );

          // 3. Â¶ÇÊûúÁî®Êà∑ËæìÂÖ•‰∫ÜÂÜÖÂÆπÂπ∂ÁÇπÂáª‰∫Ü‚ÄúÁ°ÆÂÆö‚Äù
          if (newStatusText !== null) {
            // 4. Êõ¥Êñ∞ÂÜÖÂ≠òÂíåÊï∞ÊçÆÂ∫ì‰∏≠ÁöÑÁä∂ÊÄÅÊï∞ÊçÆ
            chat.status.text = newStatusText.trim() || "Online"; // Â¶ÇÊûúÁî®Êà∑Ê∏ÖÁ©∫‰∫ÜÔºåÂ∞±ÈªòËÆ§‰∏∫‚ÄúÂú®Á∫ø‚Äù
            chat.status.isBusy = false; // ÊØèÊ¨°ÊâãÂä®ÁºñËæëÈÉΩÈªòËÆ§ÂÖ∂‰∏çÂ§Ñ‰∫é‚ÄúÂøôÁ¢å‚ÄùÁä∂ÊÄÅ
            chat.status.lastUpdate = Date.now();
            await db.chats.put(chat);

            // 5. Á´ãÂàªÂà∑Êñ∞UIÔºåËÆ©Áî®Êà∑ÁúãÂà∞‰øÆÊîπÂêéÁöÑÁä∂ÊÄÅ
            renderChatInterface(state.activeChatId);
            renderChatList();

            // 6. ÁªôÂá∫‰∏Ä‰∏™Êó†‰º§Â§ßÈõÖÁöÑÊàêÂäüÊèêÁ§∫
            await showCustomAlert(
              "Áä∂ÊÄÅÂ∑≤Êõ¥Êñ∞",
              `‚Äú${chat.name}‚ÄùÁöÑÂΩìÂâçÁä∂ÊÄÅÂ∑≤Êõ¥Êñ∞‰∏∫Ôºö${chat.status.text}`,
            );
          }
        }

        // ÊîæÂú®‰Ω†ÁöÑJSÂäüËÉΩÂáΩÊï∞ÂÆö‰πâÂå∫
        async function openShareTargetPicker() {
          const modal = document.getElementById("share-target-modal");
          const listEl = document.getElementById("share-target-list");
          listEl.innerHTML = "";

          // Ëé∑ÂèñÊâÄÊúâËÅäÂ§©‰Ωú‰∏∫ÂàÜ‰∫´ÁõÆÊ†á
          const chats = Object.values(state.chats);

          chats.forEach((chat) => {
            // Â§çÁî®ËÅîÁ≥ª‰∫∫ÈÄâÊã©Âô®ÁöÑÊ†∑Âºè
            const item = document.createElement("div");
            item.className = "contact-picker-item";
            item.innerHTML = `
			            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
			            <img src="${
                    chat.isGroup
                      ? chat.settings.groupAvatar
                      : chat.settings.aiAvatar || defaultAvatar
                  }" class="avatar">
			            <span class="name">${chat.name}</span>
			        `;
            listEl.appendChild(item);
          });

          modal.classList.add("visible");
        }

        function closeMusicPlayerWithAnimation(callback) {
          const overlay = document.getElementById("music-player-overlay");
          if (!overlay.classList.contains("visible")) {
            if (callback) callback();
            return;
          }
          overlay.classList.remove("visible");
          setTimeout(() => {
            document
              .getElementById("music-playlist-panel")
              .classList.remove("visible");
            if (callback) callback();
          }, 400);
        }

        function parseLRC(lrcContent) {
          if (!lrcContent) return [];
          const lines = lrcContent.split("\n");
          const lyrics = [];
          const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

          for (const line of lines) {
            const text = line.replace(timeRegex, "").trim();
            if (!text) continue;
            timeRegex.lastIndex = 0;
            let match;
            while ((match = timeRegex.exec(line)) !== null) {
              const minutes = parseInt(match[1], 10);
              const seconds = parseInt(match[2], 10);
              const milliseconds = parseInt(match[3].padEnd(3, "0"), 10);
              const time = minutes * 60 + seconds + milliseconds / 1000;
              lyrics.push({ time, text });
            }
          }
          return lyrics.sort((a, b) => a.time - b.time);
        }

        function renderLyrics() {
          const lyricsList = document.getElementById("music-lyrics-list");
          lyricsList.innerHTML = "";
          if (
            !state.musicState.parsedLyrics ||
            state.musicState.parsedLyrics.length === 0
          ) {
            lyricsList.innerHTML = '<div class="lyric-line">‚ô™ ÊöÇÊó†Ê≠åËØç ‚ô™</div>';
            return;
          }
          state.musicState.parsedLyrics.forEach((line, index) => {
            const lineEl = document.createElement("div");
            lineEl.className = "lyric-line";
            lineEl.textContent = line.text;
            lineEl.dataset.index = index;
            lyricsList.appendChild(lineEl);
          });
          lyricsList.style.transform = `translateY(0px)`;
        }

        function updateActiveLyric(currentTime) {
          if (state.musicState.parsedLyrics.length === 0) return;
          let newLyricIndex = -1;
          for (let i = 0; i < state.musicState.parsedLyrics.length; i++) {
            if (currentTime >= state.musicState.parsedLyrics[i].time) {
              newLyricIndex = i;
            } else {
              break;
            }
          }
          if (newLyricIndex === state.musicState.currentLyricIndex) return;
          state.musicState.currentLyricIndex = newLyricIndex;
          updateLyricsUI();
        }

        function updateLyricsUI() {
          const lyricsList = document.getElementById("music-lyrics-list");
          const container = document.getElementById("music-lyrics-container");
          const lines = lyricsList.querySelectorAll(".lyric-line");
          lines.forEach((line) => line.classList.remove("active"));
          if (state.musicState.currentLyricIndex === -1) {
            lyricsList.style.transform = `translateY(0px)`;
            return;
          }
          const activeLine = lyricsList.querySelector(
            `.lyric-line[data-index="${state.musicState.currentLyricIndex}"]`,
          );
          if (activeLine) {
            activeLine.classList.add("active");
            const containerHeight = container.offsetHeight;
            const offset =
              containerHeight / 3 -
              activeLine.offsetTop -
              activeLine.offsetHeight / 2;
            lyricsList.style.transform = `translateY(${offset}px)`;
          }

          // ÂêåÊ≠•Ê≠åËØçÂà∞ÊÇ¨ÊµÆÊ†è
          const floatingLyricText = document.getElementById(
            "floating-lyric-text",
          );
          if (activeLine) {
            floatingLyricText.textContent = activeLine.textContent;
          } else if (state.musicState.parsedLyrics.length > 0) {
            floatingLyricText.textContent = "‚ô™ ‚ô™ ‚ô™"; // Ê≠åÊõ≤ÂâçÂ•è
          } else {
            floatingLyricText.textContent = "‚ô™ ÊöÇÊó†Ê≠åËØç ‚ô™";
          }
        }

        function formatMusicTime(seconds) {
          if (isNaN(seconds) || seconds < 0) return "0:00";
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = Math.floor(seconds % 60);
          return `${minutes}:${String(remainingSeconds).padStart(2, "0")}`;
        }

        function updateMusicProgressBar() {
          const currentTimeEl = document.getElementById("music-current-time");
          const totalTimeEl = document.getElementById("music-total-time");
          const progressFillEl = document.getElementById("music-progress-fill");
          if (!audioPlayer.duration) {
            currentTimeEl.textContent = "0:00";
            totalTimeEl.textContent = "0:00";
            progressFillEl.style.width = "0%";
            return;
          }
          const progressPercent =
            (audioPlayer.currentTime / audioPlayer.duration) * 100;
          progressFillEl.style.width = `${progressPercent}%`;
          currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
          totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
          updateActiveLyric(audioPlayer.currentTime);
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑ÁÇπÂáª‚ÄúÊí§Âõû‚ÄùÊåâÈíÆÁöÑÂÖ•Âè£ÂáΩÊï∞
         */
        async function handleRecallClick() {
          if (!activeMessageTimestamp) return;

          const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // ËÆæÁΩÆ2ÂàÜÈíüÁöÑÊí§ÂõûÊó∂Èôê
          const messageTime = activeMessageTimestamp;
          const now = Date.now();

          // Ê£ÄÊü•ÊòØÂê¶Ë∂ÖËøá‰∫ÜÊí§ÂõûÊó∂Èôê
          if (now - messageTime > RECALL_TIME_LIMIT_MS) {
            hideMessageActions();
            await showCustomAlert(
              "Êìç‰ΩúÂ§±Ë¥•",
              "ËØ•Ê∂àÊÅØÂèëÈÄÅÂ∑≤Ë∂ÖËøá2ÂàÜÈíüÔºåÊó†Ê≥ïÊí§Âõû„ÄÇ",
            );
            return;
          }

          // Â¶ÇÊûúÂú®Êó∂ÈôêÂÜÖÔºåÊâßË°åÁúüÊ≠£ÁöÑÊí§ÂõûÈÄªËæë
          await recallMessage(messageTime, true);
          hideMessageActions();
        }

        /**
         * Ê∂àÊÅØÊí§ÂõûÁöÑÊ†∏ÂøÉÈÄªËæë
         * @param {number} timestamp - Ë¶ÅÊí§ÂõûÁöÑÊ∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         * @param {boolean} isUserRecall - ÊòØÂê¶ÊòØÁî®Êà∑‰∏ªÂä®Êí§Âõû
         */
        async function recallMessage(timestamp, isUserRecall) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === timestamp,
          );
          if (messageIndex === -1) return;

          const messageToRecall = chat.history[messageIndex];

          // 1. ‰øÆÊîπÊ∂àÊÅØÂØπË±°ÔºåÂ∞ÜÂÖ∂Âèò‰∏∫‚ÄúÂ∑≤Êí§Âõû‚ÄùÁä∂ÊÄÅ
          const recalledData = {
            originalType: messageToRecall.type || "text",
            originalContent: messageToRecall.content,
            // ‰øùÂ≠òÂÖ∂‰ªñÂèØËÉΩÂ≠òÂú®ÁöÑÂéüÂßãÊï∞ÊçÆ
            originalMeaning: messageToRecall.meaning,
            originalQuote: messageToRecall.quote,
          };

          messageToRecall.type = "recalled_message";
          messageToRecall.content = isUserRecall
            ? "‰Ω†Êí§Âõû‰∫Ü‰∏ÄÊù°Ê∂àÊÅØ"
            : "ÂØπÊñπÊí§Âõû‰∫Ü‰∏ÄÊù°Ê∂àÊÅØ";
          messageToRecall.recalledData = recalledData;
          // Ê∏ÖÁêÜÊéâ‰∏çÂÜçÈúÄË¶ÅÁöÑÊóßÂ±ûÊÄß
          delete messageToRecall.meaning;
          delete messageToRecall.quote;

          // 2. Â¶ÇÊûúÊòØÁî®Êà∑Êí§ÂõûÔºåÈúÄË¶ÅÁªôAIÂèëÈÄÅ‰∏ÄÊù°ÂÆÉÁúã‰∏çÊáÇÂÜÖÂÆπÁöÑÈöêËóèÊèêÁ§∫
          if (isUserRecall) {
            const hiddenMessageForAI = {
              role: "system",
              content: `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑Êí§Âõû‰∫Ü‰∏ÄÊù°Ê∂àÊÅØ„ÄÇ‰Ω†‰∏çÁü•ÈÅìÂÜÖÂÆπÊòØ‰ªÄ‰πàÔºåÂè™ÈúÄÁü•ÈÅìËøô‰∏™‰∫ã‰ª∂Âç≥ÂèØ„ÄÇ]`,
              timestamp: Date.now(),
              isHidden: true,
            };
            chat.history.push(hiddenMessageForAI);
          }

          // 3. ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ìÂπ∂Âà∑Êñ∞UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);
          if (isUserRecall) renderChatList(); // Áî®Êà∑Êí§ÂõûÊó∂ÔºåÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÂèò‰∫ÜÔºåÈúÄË¶ÅÂà∑Êñ∞ÂàóË°®
        }

        /**
         * ÊâìÂºÄÂàÜÁ±ªÁÆ°ÁêÜÊ®°ÊÄÅÊ°Ü
         */
        async function openCategoryManager() {
          await renderCategoryListInManager();
          document
            .getElementById("world-book-category-manager-modal")
            .classList.add("visible");
        }

        /**
         * Âú®Ê®°ÊÄÅÊ°Ü‰∏≠Ê∏≤ÊüìÂ∑≤Â≠òÂú®ÁöÑÂàÜÁ±ªÂàóË°®
         */
        async function renderCategoryListInManager() {
          const listEl = document.getElementById("existing-categories-list");
          const categories = await db.worldBookCategories.toArray();
          listEl.innerHTML = "";
          if (categories.length === 0) {
            listEl.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary);">ËøòÊ≤°Êúâ‰ªª‰ΩïÂàÜÁ±ª</p>';
          }
          categories.forEach((cat) => {
            // Â§çÁî®Â•ΩÂèãÂàÜÁªÑÁöÑÊ†∑Âºè
            const item = document.createElement("div");
            item.className = "existing-group-item";
            item.innerHTML = `
			            <span class="group-name">${cat.name}</span>
			            <span class="delete-group-btn" data-id="${cat.id}">√ó</span>
			        `;
            listEl.appendChild(item);
          });
        }

        /**
         * Ê∑ªÂä†‰∏Ä‰∏™Êñ∞ÁöÑ‰∏ñÁïå‰π¶ÂàÜÁ±ª
         */
        async function addNewCategory() {
          const input = document.getElementById("new-category-name-input");
          const name = input.value.trim();
          if (!name) {
            alert("ÂàÜÁ±ªÂêç‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
            return;
          }
          const existing = await db.worldBookCategories
            .where("name")
            .equals(name)
            .first();
          if (existing) {
            alert(`ÂàÜÁ±ª "${name}" Â∑≤ÁªèÂ≠òÂú®‰∫ÜÔºÅ`);
            return;
          }
          await db.worldBookCategories.add({ name });
          input.value = "";
          await renderCategoryListInManager();
        }

        /**
         * Âà†Èô§‰∏Ä‰∏™‰∏ñÁïå‰π¶ÂàÜÁ±ª
         * @param {number} categoryId - Ë¶ÅÂà†Èô§ÁöÑÂàÜÁ±ªÁöÑID
         */
        async function deleteCategory(categoryId) {
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            "Âà†Èô§ÂàÜÁ±ªÂêéÔºåËØ•ÂàÜÁ±ª‰∏ãÁöÑÊâÄÊúâ‰∏ñÁïå‰π¶Â∞ÜÂèò‰∏∫‚ÄúÊú™ÂàÜÁ±ª‚Äù„ÄÇÁ°ÆÂÆöË¶ÅÂà†Èô§ÂêóÔºü",
            { confirmButtonClass: "btn-danger" },
          );
          if (confirmed) {
            await db.worldBookCategories.delete(categoryId);
            // Â∞ÜÂ±û‰∫éËØ•ÂàÜÁ±ªÁöÑ‰∏ñÁïå‰π¶ÁöÑ categoryId ËÆæ‰∏∫ null
            const booksToUpdate = await db.worldBooks
              .where("categoryId")
              .equals(categoryId)
              .toArray();
            for (const book of booksToUpdate) {
              book.categoryId = null;
              await db.worldBooks.put(book);
              const bookInState = state.worldBooks.find(
                (wb) => wb.id === book.id,
              );
              if (bookInState) bookInState.categoryId = null;
            }
            await renderCategoryListInManager();
          }
        }

        // ËßíËâ≤‰∏ìÂ±ûNPCÂ∫ìÁÆ°ÁêÜÂäüËÉΩÂáΩÊï∞
        let editingNpcId = null; // Áî®‰∫éËøΩË∏™Ê≠£Âú®ÁºñËæëÁöÑNPC

        /**
         * ÊâìÂºÄNPCÂ∫ìÁÆ°ÁêÜÁïåÈù¢
         */
        function openNpcManager() {
          if (!state.activeChatId || state.chats[state.activeChatId].isGroup)
            return;
          const chat = state.chats[state.activeChatId];
          document.getElementById("npc-management-title").textContent =
            `‚Äú${chat.name}‚ÄùÁöÑNPCÂ∫ì`;
          renderNpcList();
          showScreen("npc-management-screen");
        }

        /**
         * Ê∏≤ÊüìNPCÂàóË°®
         */
        function renderNpcList() {
          const listEl = document.getElementById("npc-management-list");
          const chat = state.chats[state.activeChatId];
          const npcLibrary = chat.npcLibrary || [];
          listEl.innerHTML = "";

          if (npcLibrary.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ËøôÈáåÁ©∫Á©∫Â¶Ç‰πüÔºåÁÇπÂáªÂè≥‰∏äËßí‚Äú+‚ÄùÊ∑ªÂä†Á¨¨‰∏Ä‰∏™NPCÂêßÔºÅ</p>';
            return;
          }

          npcLibrary.forEach((npc) => {
            // Â§çÁî®ËÅäÂ§©ÂàóË°®ÁöÑÊ†∑ÂºèÔºåÈùûÂ∏∏Êñπ‰æø
            const item = document.createElement("div");
            item.className = "chat-list-item";
            item.style.cursor = "pointer";
            item.innerHTML = `
			            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
			            <div class="info">
			                <span class="name">${npc.name}</span>
			                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
			            </div>
			        `;
            // ÁÇπÂáªÁºñËæë
            item.addEventListener("click", () => openNpcEditor(npc.id));
            // ÈïøÊåâÂà†Èô§
            addLongPressListener(item, () => deleteNpc(npc.id, npc.name));
            listEl.appendChild(item);
          });
        }

        async function openNpcEditor(npcId = null) {
          editingNpcId = npcId;
          // ‰ΩøÁî®Ê≠£Á°ÆÁöÑ state.activeChatId Êù•Ëé∑ÂèñÂΩìÂâçËÅäÂ§©ÂØπË±°
          const chat = state.chats[state.activeChatId];
          if (!chat) return; // ÂÆâÂÖ®Ê£ÄÊü•

          let npc = { name: "", persona: "", avatar: defaultGroupMemberAvatar };

          if (npcId) {
            // ‰ªéÊ≠£Á°ÆÁöÑ chat.npcLibrary ‰∏≠Êü•ÊâæÊï∞ÊçÆ
            npc = (chat.npcLibrary || []).find((n) => n.id === npcId) || npc;
            document.getElementById("persona-editor-title").textContent =
              `ÁºñËæëNPC: ${npc.name}`;
          } else {
            document.getElementById("persona-editor-title").textContent =
              "Ê∑ªÂä†Êñ∞NPC";
          }

          // Â°´ÂÖÖÁºñËæëÂô®ÂÜÖÂÆπ
          document.getElementById("npc-editor-name-input").value = npc.name;
          document.getElementById("preset-avatar-preview").src = npc.avatar;
          document.getElementById("preset-persona-input").value = npc.persona;

          // Ê†πÊçÆNPCÊ®°ÂºèÔºåÊòæÈöêÁâπÂÆöUIÂÖÉÁ¥†
          document.getElementById("npc-editor-name-group").style.display =
            "block";
          document.getElementById(
            "persona-editor-change-frame-btn",
          ).style.display = "none";

          // ÁªëÂÆöÊ≠£Á°ÆÁöÑ‰øùÂ≠òÂáΩÊï∞
          document.getElementById("save-persona-preset-btn").onclick = saveNpc;

          // ÊúÄÂêéÊâçÊòæÁ§∫ÂºπÁ™ó
          document
            .getElementById("persona-editor-modal")
            .classList.add("visible");
        }

        /**
         * ‰øùÂ≠òNPCÔºàÊñ∞Âª∫ÊàñÊõ¥Êñ∞Ôºâ
         */
        async function saveNpc() {
          const chat = state.chats[state.activeChatId];

          // ‰ªéÁºñËæëÂô®‰∏≠Ëé∑ÂèñÊâÄÊúâÊï∞ÊçÆ
          const name = document
            .getElementById("npc-editor-name-input")
            .value.trim();
          const persona = document
            .getElementById("preset-persona-input")
            .value.trim();
          const avatar = document.getElementById("preset-avatar-preview").src;

          if (!name) {
            alert("NPCÂêçÂ≠ó‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
            return;
          }

          if (editingNpcId) {
            // Êõ¥Êñ∞Áé∞ÊúâÁöÑNPC
            const npc = chat.npcLibrary.find((n) => n.id === editingNpcId);
            if (npc) {
              npc.name = name;
              npc.persona = persona;
              npc.avatar = avatar;
            }
          } else {
            // Ê∑ªÂä†‰∏Ä‰∏™ÂÖ®Êñ∞ÁöÑNPC
            const newNpc = {
              id: "npc_" + Date.now(),
              name: name,
              persona: persona,
              avatar: avatar,
            };
            chat.npcLibrary.push(newNpc);
          }

          await db.chats.put(chat);
          renderNpcList();
          closePersonaEditor(); // Â§çÁî®ÂÖ≥Èó≠ÁºñËæëÂô®ÁöÑÂáΩÊï∞
        }

        /**
         * Âà†Èô§‰∏Ä‰∏™NPC
         * @param {string} npcId - Ë¶ÅÂà†Èô§ÁöÑNPCÁöÑID
         * @param {string} npcName - Ë¶ÅÂà†Èô§ÁöÑNPCÁöÑÂêçÂ≠óÔºåÁî®‰∫éÁ°ÆËÆ§ÊèêÁ§∫
         */
        async function deleteNpc(npcId, npcName) {
          const confirmed = await showCustomConfirm(
            "Âà†Èô§NPC",
            `Á°ÆÂÆöË¶Å‰ªé‚Äú${state.chats[state.activeChatId].name}‚ÄùÁöÑNPCÂ∫ì‰∏≠Âà†Èô§ ‚Äú${npcName}‚Äù ÂêóÔºü`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            const chat = state.chats[state.activeChatId];
            chat.npcLibrary = chat.npcLibrary.filter((n) => n.id !== npcId);
            await db.chats.put(chat);
            renderNpcList();
          }
        }

        // --- Ëá™ÂÆö‰πâÂ§¥ÂÉèÊ°ÜÁÆ°ÁêÜÂäüËÉΩ ---

        function openFrameManager() {
          renderFrameManager();
          document
            .getElementById("custom-frame-manager-modal")
            .classList.add("visible");
        }

        async function renderFrameManager() {
          const grid = document.getElementById("custom-frame-grid");
          grid.innerHTML = "";
          const customFrames = await db.customAvatarFrames.toArray();
          if (customFrames.length === 0) {
            grid.innerHTML =
              '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">‰Ω†ËøòÊ≤°Êúâ‰∏ä‰º†ËøáÂ§¥ÂÉèÊ°ÜÂì¶~</p>';
            return;
          }
          customFrames.forEach((frame) => {
            const item = document.createElement("div");
            // Â§çÁî®Ë°®ÊÉÖÈù¢ÊùøÁöÑÊ†∑ÂºèÔºåÂæàÊñπ‰æø
            item.className = "sticker-item";
            item.style.backgroundImage = `url(${frame.url})`;
            item.title = frame.name;

            const deleteBtn = document.createElement("div");
            deleteBtn.className = "delete-btn";
            deleteBtn.innerHTML = "√ó";
            deleteBtn.style.display = "block";
            deleteBtn.onclick = async (e) => {
              e.stopPropagation();
              const confirmed = await showCustomConfirm(
                "Âà†Èô§Â§¥ÂÉèÊ°Ü",
                `Á°ÆÂÆöË¶ÅÂà†Èô§‚Äú${frame.name}‚ÄùÂêóÔºü`,
                {
                  confirmButtonClass: "btn-danger",
                },
              );
              if (confirmed) {
                await db.customAvatarFrames.delete(frame.id);
                renderFrameManager(); // Âà∑Êñ∞ÁÆ°ÁêÜÂàóË°®
              }
            };
            item.appendChild(deleteBtn);
            grid.appendChild(item);
          });
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑‰∏ä‰º†Ëá™ÂÆö‰πâÂ§¥ÂÉèÊ°ÜÁöÑÈÄªËæë
         */
        function handleUploadCustomFrame() {
          document.getElementById("custom-frame-upload-input").addEventListener(
            "change",
            async (event) => {
              const files = event.target.files;
              if (!files.length) return;

              const newFrames = [];

              // ‰ΩøÁî® for...of Âæ™ÁéØÊù•ÈÄê‰∏™Â§ÑÁêÜÈÄâ‰∏≠ÁöÑÊñá‰ª∂
              for (const file of files) {
                // Ëá™Âä®ÁîüÊàêÂêçÂ≠óÔºåËÄå‰∏çÊòØËÆ©Áî®Êà∑ËæìÂÖ•
                // Áî® "Êñá‰ª∂Âêç (Ââç8‰Ωç) + Êó∂Èó¥Êà≥" Êù•Á°Æ‰øùÂêçÂ≠óÂá†‰πé‰∏ç‰ºöÈáçÂ§ç
                const fileName = file.name
                  .replace(/\.[^/.]+$/, "")
                  .substring(0, 8);
                const autoName = `${fileName}_${Date.now()}`;

                const base64Url = await new Promise((resolve) => {
                  const reader = new FileReader();
                  reader.onload = (e) => resolve(e.target.result);
                  reader.readAsDataURL(file);
                });

                newFrames.push({
                  id: "frame_" + (Date.now() + newFrames.length), // Á°Æ‰øùIDÂîØ‰∏Ä
                  name: autoName,
                  url: base64Url,
                });
              }

              // Âæ™ÁéØÁªìÊùüÂêéÔºåÊâπÈáèÊ∑ªÂä†Âà∞Êï∞ÊçÆÂ∫ì
              if (newFrames.length > 0) {
                await db.customAvatarFrames.bulkAdd(newFrames);
                renderFrameManager(); // Âà∑Êñ∞ÁÆ°ÁêÜÂàóË°®
                await showCustomAlert(
                  "‰∏ä‰º†ÊàêÂäü",
                  `Â∑≤ÊàêÂäüÊ∑ªÂä† ${newFrames.length} ‰∏™Êñ∞Â§¥ÂÉèÊ°ÜÔºÅ`,
                );
              }

              // Ê∏ÖÁ©∫Êñá‰ª∂ÈÄâÊã©Âô®ÁöÑÂÄº
              event.target.value = null;
            },
            { once: true },
          );

          document.getElementById("custom-frame-upload-input").click();
        }

        async function openFrameSelectorModal(type, targetId = null) {
          const grid = document.getElementById("avatar-frame-grid");
          grid.innerHTML = "";

          currentFrameSelection.type = type;
          currentFrameSelection.target = targetId;

          const chat = state.chats[state.activeChatId];
          let currentFrameUrl = "";
          let previewAvatarUrl = "";

          if (type === "char-weibo") {
            // Â¶ÇÊûúÊòØ‰∏∫‚ÄúËßíËâ≤ÂæÆÂçö‚ÄùÊç¢Ê°Ü
            const charChat = state.chats[currentViewingWeiboProfileId];
            currentFrameUrl = charChat.settings.weiboAvatarFrame || "";
            previewAvatarUrl = charChat.settings.weiboAvatar || defaultAvatar;
          } else if (type === "home_profile") {
            currentFrameUrl = state.globalSettings.homeAvatarFrame || "";
            previewAvatarUrl =
              document.getElementById("profile-avatar-img").src;
          } else if (type === "weibo_profile") {
            currentFrameUrl = state.qzoneSettings.weiboAvatarFrame || "";
            previewAvatarUrl = state.qzoneSettings.weiboAvatar || defaultAvatar;
          } else if (type === "ai") {
            currentFrameUrl = chat.settings.aiAvatarFrame || "";
            previewAvatarUrl = chat.settings.aiAvatar || defaultAvatar;
          } else if (type === "my") {
            currentFrameUrl = chat.settings.myAvatarFrame || "";
            previewAvatarUrl = chat.settings.myAvatar || defaultAvatar;
          } else if (type === "member" && targetId) {
            const member = chat.members.find((m) => m.id === targetId);
            if (member) {
              currentFrameUrl = member.avatarFrame || "";
              previewAvatarUrl = member.avatar || defaultGroupMemberAvatar;
            }
          }

          // ÂêéÁª≠Ê∏≤ÊüìÈÄªËæë‰øùÊåÅ‰∏çÂèò
          const customFrames = await db.customAvatarFrames.toArray();
          const frameUrlSet = new Set();
          const allFrames = [...avatarFrames, ...customFrames].filter(
            (frame) => {
              if (!frame.url || !frameUrlSet.has(frame.url)) {
                frameUrlSet.add(frame.url);
                return true;
              }
              return false;
            },
          );

          allFrames.forEach((frame) => {
            const item = createFrameItem(frame, previewAvatarUrl);
            if (currentFrameUrl === frame.url) {
              item.classList.add("selected");
              currentFrameSelection.url = frame.url;
            }
            grid.appendChild(item);
          });

          document
            .getElementById("avatar-frame-modal")
            .classList.add("visible");
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÂàõÂª∫‰∏Ä‰∏™Â§¥ÂÉèÊ°ÜÈÄâÈ°π
        function createFrameItem(frame, previewAvatarSrc) {
          const item = document.createElement("div");
          item.className = "frame-item";
          item.title = frame.name;
          item.innerHTML = `
			        <img src="${previewAvatarSrc}" class="preview-avatar">
			        ${frame.url ? `<img src="${frame.url}" class="preview-frame" style="pointer-events: none;">` : ""}
			    `;
          item.addEventListener("click", () => {
            document
              .querySelectorAll("#avatar-frame-grid .frame-item")
              .forEach((el) => el.classList.remove("selected"));
            item.classList.add("selected");
            currentFrameSelection.url = frame.url;
          });
          return item;
        }

        // ‰øùÂ≠òÈÄâÊã©

        async function saveSelectedFrames() {
          const { type, url, target } = currentFrameSelection;

          // ÂØπ‰∫é‰∏çÂ±û‰∫é‚ÄúËßíËâ≤ËÆæÁΩÆ‚ÄùÁöÑÂäüËÉΩ (ÊØîÂ¶Ç‰∏ªÂ±èÂπï„ÄÅÂæÆÂçö)Ôºå‰øùÊåÅÂéüÊúâÁöÑÁ´ãÂç≥‰øùÂ≠òÈÄªËæë
          if (type === "char-weibo") {
            const charChat = state.chats[currentViewingWeiboProfileId];
            if (charChat) {
              charChat.settings.weiboAvatarFrame = url;
              await db.chats.put(charChat);
              await renderWeiboCharProfile(currentViewingWeiboProfileId);
            }
          } else if (type === "home_profile") {
            if (!state.globalSettings) state.globalSettings = {};
            state.globalSettings.homeAvatarFrame = url;
            await db.globalSettings.put(state.globalSettings);
            renderHomeScreenProfileFrame();
          } else if (type === "weibo_profile") {
            if (!state.qzoneSettings) state.qzoneSettings = {};
            state.qzoneSettings.weiboAvatarFrame = url;
            await saveQzoneSettings();
            await renderWeiboProfile();
          }
          // ÂØπ‰∫é‚ÄúËßíËâ≤ËÆæÁΩÆ‚ÄùÈáåÁöÑÂ§¥ÂÉèÊ°Ü‰∏çÂÜçÁ´ãÂç≥‰øùÂ≠òÔºåÂè™Âú®ÂÜÖÂ≠ò‰∏≠Êõ¥Êñ∞
          else {
            const chat = state.chats[state.activeChatId];
            if (!chat) return; // ÂÆâÂÖ®Ê£ÄÊü•

            if (type === "ai") {
              chat.settings.aiAvatarFrame = url;
            } else if (type === "my") {
              chat.settings.myAvatarFrame = url;
            } else if (type === "member" && target) {
              const member = chat.members.find((m) => m.id === target);
              if (member) member.avatarFrame = url;
            }

            // Êï∞ÊçÆÂ∞ÜÂú®Áî®Êà∑ÁÇπÂáªËßíËâ≤ËÆæÁΩÆ‰∏ªÈù¢ÊùøÁöÑ‚Äú‰øùÂ≠ò‚ÄùÊåâÈíÆÊó∂Ôºå‰∏éÂÖ∂‰ªñÊâÄÊúâËÆæÁΩÆ‰∏ÄËµ∑Ë¢´‰øùÂ≠ò„ÄÇ
            console.log(`Â§¥ÂÉèÊ°ÜÈÄâÊã©Â∑≤ÊöÇÂ≠ò: type=${type}, url=${url}`);
          }

          // Âè™ÈúÄÂÖ≥Èó≠Â§¥ÂÉèÊ°ÜÈÄâÊã©ÂºπÁ™óÂç≥ÂèØÔºå‰∏çÂÅöÂÖ∂‰ªñÂ§ö‰ΩôÊìç‰Ωú
          document
            .getElementById("avatar-frame-modal")
            .classList.remove("visible");
        }

        /**
         * Ê£ÄÊü•‰∏§‰∏™Êó∂Èó¥Êà≥ÊòØÂê¶Âú®‰∏çÂêåÁöÑËá™ÁÑ∂Êó•
         * @param {number} timestamp1 - Êñ∞Ê∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         * @param {number | null} timestamp2 - ‰∏ä‰∏ÄÊù°Ê∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         * @returns {boolean} - Â¶ÇÊûúÊòØÊñ∞ÁöÑ‰∏ÄÂ§©ÔºåËøîÂõû true
         */
        function isNewDay(timestamp1, timestamp2) {
          // Â¶ÇÊûúÊ≤°Êúâ‰∏ä‰∏ÄÊù°Ê∂àÊÅØÁöÑÊó∂Èó¥Êà≥ÔºåËØ¥ÊòéËøôÊòØÁ¨¨‰∏ÄÊù°Ê∂àÊÅØÔºåËÇØÂÆöË¶ÅÊòæÁ§∫Êó•Êúü
          if (!timestamp2) return true;

          const date1 = new Date(timestamp1);
          const date2 = new Date(timestamp2);

          // ÊØîËæÉÂπ¥„ÄÅÊúà„ÄÅÊó•ÊòØÂê¶ÂÆåÂÖ®Áõ∏Âêå
          return (
            date1.getFullYear() !== date2.getFullYear() ||
            date1.getMonth() !== date2.getMonth() ||
            date1.getDate() !== date2.getDate()
          );
        }

        /**
         * Â∞ÜÊó∂Èó¥Êà≥Ê†ºÂºèÂåñ‰∏∫ "MM/DD HH:mm" ÁöÑÂΩ¢Âºè
         * @param {number} timestamp - Êó∂Èó¥Êà≥
         * @returns {string} - Ê†ºÂºèÂåñÂêéÁöÑÊó•ÊúüÂ≠óÁ¨¶‰∏≤
         */
        function formatDateStamp(timestamp) {
          const date = new Date(timestamp);
          const month = date.getMonth() + 1;
          const day = date.getDate();
          const hours = String(date.getHours()).padStart(2, "0");
          const minutes = String(date.getMinutes()).padStart(2, "0");
          return `${month}/${day} ${hours}:${minutes}`;
        }

        /**
         * Ê†πÊçÆÊó∂Èó¥Êà≥ÔºåÊ†ºÂºèÂåñËÅäÂ§©ÂàóË°®Âè≥‰æßÁöÑÊó•Êúü/Êó∂Èó¥ÊòæÁ§∫
         * @param {number} timestamp - Ê∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         * @returns {string} - Ê†ºÂºèÂåñÂêéÁöÑÂ≠óÁ¨¶‰∏≤ (‰æãÂ¶Ç "14:30", "Êò®Â§©", "08/03")
         */
        function formatChatListTimestamp(timestamp) {
          if (!timestamp) return ""; // Â¶ÇÊûúÊ≤°ÊúâÊó∂Èó¥Êà≥ÔºåËøîÂõûÁ©∫Â≠óÁ¨¶‰∏≤

          const now = new Date();
          const msgDate = new Date(timestamp);

          // Âà§Êñ≠ÊòØÂê¶‰∏∫‰ªäÂ§©
          const isToday =
            now.getFullYear() === msgDate.getFullYear() &&
            now.getMonth() === msgDate.getMonth() &&
            now.getDate() === msgDate.getDate();

          if (isToday) {
            // Â¶ÇÊûúÊòØ‰ªäÂ§©ÔºåÂè™ÊòæÁ§∫Êó∂Èó¥
            return msgDate.toLocaleTimeString("en-GB", {
              hour: "2-digit",
              minute: "2-digit",
            });
          }

          // Âà§Êñ≠ÊòØÂê¶‰∏∫Êò®Â§©
          const yesterday = new Date();
          yesterday.setDate(now.getDate() - 1);
          const isYesterday =
            yesterday.getFullYear() === msgDate.getFullYear() &&
            yesterday.getMonth() === msgDate.getMonth() &&
            yesterday.getDate() === msgDate.getDate();

          if (isYesterday) {
            return "Êò®Â§©";
          }

          // Âà§Êñ≠ÊòØÂê¶‰∏∫‰ªäÂπ¥
          if (now.getFullYear() === msgDate.getFullYear()) {
            // Â¶ÇÊûúÊòØ‰ªäÂπ¥ÔºåÊòæÁ§∫ "Êúà/Êó•"
            const month = String(msgDate.getMonth() + 1).padStart(2, "0");
            const day = String(msgDate.getDate()).padStart(2, "0");
            return `${month}/${day}`;
          }

          // Â¶ÇÊûúÊòØÊõ¥Êó©ÁöÑÂπ¥‰ªΩÔºåÊòæÁ§∫ "Âπ¥/Êúà/Êó•"
          const year = msgDate.getFullYear();
          const month = String(msgDate.getMonth() + 1).padStart(2, "0");
          const day = String(msgDate.getDate()).padStart(2, "0");
          return `${year}/${month}/${day}`;
        }

        /**
         * ÂàõÂª∫‰∏Ä‰∏™ÂäüËÉΩÂÆåÊï¥ÁöÑÊó•ÊúüÊà≥‚Äú‰º™Ê∂àÊÅØ‚ÄùÂÖÉÁ¥†
         * @param {number} timestamp - ËØ•Êó•ÊúüÊà≥‰ª£Ë°®ÁöÑÊó∂Èó¥
         * @returns {HTMLElement} - ÂàõÂª∫Â•ΩÁöÑ DOM ÂÖÉÁ¥†
         */
        function createDateStampElement(timestamp) {
          // 1. ÂàõÂª∫ÊúÄÂ§ñÂ±ÇÁöÑÂåÖË£π divÔºåÂíåÁúüÂÆûÊ∂àÊÅØ‰∏ÄÊ†∑
          const wrapper = document.createElement("div");
          wrapper.className = "message-wrapper date-stamp-wrapper";
          // ÊääÊó∂Èó¥Êà≥Â≠òËµ∑Êù•ÔºåËøôÊòØÂ§öÈÄâÂíåÂà†Èô§ÁöÑÂÖ≥ÈîÆ
          wrapper.dataset.timestamp = timestamp;

          // 2. ÂàõÂª∫Ê∞îÊ≥° div
          const bubble = document.createElement("div");
          // ÂêåÊó∂Âä†‰∏ä .message-bubble Á±ªÔºåËÆ©Â§öÈÄâÈÄªËæëËÉΩÊâæÂà∞ÂÆÉ
          bubble.className = "message-bubble date-stamp-bubble";
          bubble.dataset.timestamp = timestamp;
          bubble.textContent = formatDateStamp(timestamp);

          wrapper.appendChild(bubble);

          // 3. ‰∏∫ÂÆÉÁªëÂÆöÂíåÁúüÂÆûÊ∂àÊÅØÂÆåÂÖ®‰∏ÄÊ†∑ÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®
          addLongPressListener(wrapper, () => {
            // Êó•ÊúüÊà≥‰∏çÊîØÊåÅÂ§çÊùÇÊìç‰ΩúÔºåÈïøÊåâÁõ¥Êé•ËøõÂÖ•Â§öÈÄâ
            enterSelectionMode(timestamp);
          });
          wrapper.addEventListener("click", () => {
            if (isSelectionMode) {
              toggleMessageSelection(timestamp);
            }
          });

          return wrapper;
        }

        // --- ÁæéÂåñÂäüËÉΩÁöÑÊ†∏ÂøÉÂèòÈáè ---
        let activeThemeId = null; // Áî®‰∫éËøΩË∏™ÂΩìÂâçÊ≠£Âú®ÁºñËæëÁöÑ‰∏ªÈ¢òID

        /**
         * Â∞ÜCSS‰ª£Á†ÅÂ∫îÁî®Âà∞È°µÈù¢‰∏ä
         * @param {string} cssCode - Ë¶ÅÂ∫îÁî®ÁöÑCSS‰ª£Á†ÅÂ≠óÁ¨¶‰∏≤
         */
        function applyThemeCss(cssCode) {
          const styleTag = document.getElementById("custom-theme-style");
          if (styleTag) {
            styleTag.innerHTML = cssCode || "";
          }
        }

        /**
         * ‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÊâÄÊúâ‰∏ªÈ¢òÂà∞‰∏ãÊãâÈÄâÊã©Ê°Ü
         */
        async function loadThemesToDropdown() {
          const selector = document.getElementById("theme-selector");
          selector.innerHTML = '<option value="">-- ÈÄâÊã©ÊñπÊ°àÊàñÊñ∞Âª∫ --</option>'; // ÈªòËÆ§ÈÄâÈ°π

          const themes = await db.themes.toArray();
          themes.forEach((theme) => {
            const option = document.createElement("option");
            option.value = theme.id;
            option.textContent = theme.name;
            selector.appendChild(option);
          });
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑‰ªé‰∏ãÊãâÊ°ÜÈÄâÊã©‰∏Ä‰∏™‰∏ªÈ¢òÁöÑÈÄªËæë
         */
        async function handleThemeSelection() {
          const selector = document.getElementById("theme-selector");
          const editor = document.getElementById("theme-css-editor");
          activeThemeId = selector.value ? parseInt(selector.value) : null;

          if (activeThemeId) {
            const theme = await db.themes.get(activeThemeId);
            editor.value = theme.css;
          } else {
            // Â¶ÇÊûúÈÄâÊã©‚Äú--‚ÄùÔºåÂ∞±Âä†ËΩΩÊ®°Êùø
            editor.value = THEME_CSS_TEMPLATE;
          }
          // Á´ãÂç≥Â∫îÁî®ÈÄâ‰∏≠ÁöÑÊàñÊ®°Êùø‰ª£Á†ÅÔºåËÆ©Áî®Êà∑ÁúãÂà∞ÊïàÊûú
          applyThemeCss(editor.value);
        }

        /**
         * ‰øùÂ≠òÂΩìÂâçÁºñËæëÂå∫ÁöÑÂÜÖÂÆπÂà∞ÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰∏ªÈ¢ò
         */
        async function saveCurrentTheme() {
          if (!activeThemeId) {
            alert("Please select a plan first, or use \"Save As\" to create a new plan.");
            return;
          }
          const cssCode = document.getElementById("theme-css-editor").value;
          await db.themes.update(activeThemeId, { css: cssCode });
          alert("The current plan has been saved!");
        }

        /**
         * Â∞ÜÂΩìÂâçÁºñËæëÂå∫ÁöÑÂÜÖÂÆπÂè¶Â≠ò‰∏∫‰∏Ä‰∏™Êñ∞‰∏ªÈ¢ò
         */
        async function saveAsNewTheme() {
          const themeName = await showCustomPrompt(
            "Save New Plan",
            "Please enter the name of the new plan",
          );
          if (!themeName || !themeName.trim()) {
            if (themeName !== null) alert("The plan name cannot be empty!");
            return;
          }
          const cssCode = document.getElementById("theme-css-editor").value;
          const newTheme = { name: themeName.trim(), css: cssCode };
          const newId = await db.themes.add(newTheme);

          // Âà∑Êñ∞‰∏ãÊãâÊ°ÜÂπ∂Ëá™Âä®ÈÄâ‰∏≠Êñ∞‰øùÂ≠òÁöÑÊñπÊ°à
          await loadThemesToDropdown();
          document.getElementById("theme-selector").value = newId;
          activeThemeId = newId;

      alert(`The plan "${themeName}" has been successfully saved!`);
        }
        /**
         * ÊâìÂºÄÊ∏ÖÈô§ËßíËâ≤CSSÁöÑÁÆ°ÁêÜËèúÂçï
         */
        async function openCharCssManager() {
          const choice = await showChoiceModal("Clear Character Bubble Styles", [
            { text: "üßπ Clear CSS for All Characters", value: "clear_all" },
            { text: "üîç Select Specific Characters to Clear", value: "select_char" },
          ]);

          if (!choice) return;

          if (choice === "clear_all") {
            await clearAllCharsCustomCss();
          } else if (choice === "select_char") {
            await openCharCssSelector();
          }
        }

        /**
         * Ê∏ÖÈô§ÊâÄÊúâÂçïËÅäËßíËâ≤ÁöÑËá™ÂÆö‰πâCSS
         */
        async function clearAllCharsCustomCss() {
          // Ê£ÄÊü•ÊòØÂê¶Êúâ‰ªª‰ΩïËßíËâ≤ËÆæÁΩÆ‰∫ÜCSS
          let hasAny = false;
          for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            if (!chat.isGroup && chat.settings && chat.settings.customCss) {
              hasAny = true;
              break;
            }
          }

          if (!hasAny) {
            alert("There are no characters with custom CSS to clear.");
            return;
          }

          const confirmed = await showCustomConfirm(
            "Confirm Clear All",
            "Are you sure you want to clear the custom bubble styles (CSS) for ALL characters?\nThis action will revert all characters to default or global styles and cannot be undone.",
            { confirmButtonClass: "btn-danger" },
          );

          if (!confirmed) return;

          let count = 0;
          for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            if (!chat.isGroup && chat.settings && chat.settings.customCss) {
              chat.settings.customCss = ""; // Clear
              count++;
              await db.chats.put(chat);
            }
          }

          // If the currently active chat character was cleared, refresh the interface
          if (state.activeChatId && !state.chats[state.activeChatId].isGroup) {
            renderChatInterface(state.activeChatId);
          }

          alert(`Cleared custom styles for ${count} characters.`);
        }

        /**
         * Open the selector to choose characters to clear
         */
        async function openCharCssSelector() {
          // 1. Filter out all characters with customCss
          const chatsWithCss = Object.values(state.chats).filter(
            (c) => !c.isGroup && c.settings && c.settings.customCss,
          );

          if (chatsWithCss.length === 0) {
            alert("There are no characters with custom CSS.");
            return;
          }

          // 2. Reuse the existing custom modal to display the list
          const modal = document.getElementById("custom-modal-overlay");
          const modalTitle = document.getElementById("custom-modal-title");
          const modalBody = document.getElementById("custom-modal-body");
          const confirmBtn = document.getElementById("custom-modal-confirm");
          const cancelBtn = document.getElementById("custom-modal-cancel");

          modalTitle.textContent = "Select Characters to Clear Styles";
          modalBody.innerHTML =
            '<div id="css-char-list" style="max-height: 300px; overflow-y: auto; text-align: left;"></div>';

          const listEl = document.getElementById("css-char-list");

          // 3. Generate the list
          chatsWithCss.forEach((chat) => {
            const item = document.createElement("div");
            item.style.cssText =
              "display:flex; align-items:center; padding:10px; border-bottom:1px solid #eee; cursor:pointer;";
            item.innerHTML = `
            <input type="checkbox" class="css-clear-checkbox" value="${
              chat.id
            }" style="margin-right:10px; transform: scale(1.2);">
            <img src="${
              chat.settings.aiAvatar || defaultAvatar
            }" style="width:30px; height:30px; border-radius:50%; margin-right:10px; object-fit: cover;">
            <div style="flex:1;">
                <div style="font-weight:bold;">${chat.name}</div>
                <div style="font-size:10px; color:#888; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 150px;">
                    ${chat.settings.customCss.substring(0, 30).replace(/\n/g, "")}...
                </div>
            </div>
        `;
            // ÁÇπÂáªË°åÂç≥ÂèØÂãæÈÄâ
            item.addEventListener("click", (e) => {
              if (e.target.type !== "checkbox") {
                const cb = item.querySelector("input");
                cb.checked = !cb.checked;
              }
            });
            listEl.appendChild(item);
          });

          // 4. ËÆæÁΩÆÊåâÈíÆÊ†∑ÂºèÂíå‰∫ã‰ª∂
          confirmBtn.textContent = "Clear Selected";
          confirmBtn.classList.add("btn-danger");
          cancelBtn.style.display = "block";

          // ÂÖãÈöÜÊåâÈíÆ‰ª•ÁßªÈô§ÊóßÁöÑÁõëÂê¨Âô®
          const newConfirmBtn = confirmBtn.cloneNode(true);
          confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

          newConfirmBtn.addEventListener("click", async () => {
            const selectedCheckboxes = document.querySelectorAll(
              ".css-clear-checkbox:checked",
            );
            if (selectedCheckboxes.length === 0) {
              alert("Please select at least one character.");
              return;
            }

            const ids = Array.from(selectedCheckboxes).map((cb) => cb.value);
            for (const id of ids) {
              const chat = state.chats[id];
              if (chat) {
                chat.settings.customCss = ""; // Ê∏ÖÁ©∫
                await db.chats.put(chat);
              }
            }

            modal.classList.remove("visible");
            confirmBtn.classList.remove("btn-danger"); // ÊÅ¢Â§çÊ†∑Âºè

            // Â¶ÇÊûúÂΩìÂâçËÅäÂ§©ÁöÑËßíËâ≤Ë¢´Ê∏ÖÈô§‰∫ÜÔºåÂà∑Êñ∞ÁïåÈù¢
            if (state.activeChatId && ids.includes(state.activeChatId)) {
              renderChatInterface(state.activeChatId);
            }

            alert(`Cleared custom styles for ${ids.length} characters.`);
          });

          // ÊòæÁ§∫Ê®°ÊÄÅÊ°Ü
          modal.classList.add("visible");
        }

        /**
         * ÈáçÂëΩÂêçÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰∏ªÈ¢ò
         */
        async function renameSelectedTheme() {
          if (!activeThemeId) {
            alert("ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÈáçÂëΩÂêçÁöÑÊñπÊ°à„ÄÇ");
            return;
          }
          const currentTheme = await db.themes.get(activeThemeId);
          const newName = await showCustomPrompt(
            "ÈáçÂëΩÂêçÊñπÊ°à",
            "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂêçÁß∞",
            currentTheme.name,
          );
          if (newName && newName.trim()) {
            await db.themes.update(activeThemeId, { name: newName.trim() });
            await loadThemesToDropdown();
            document.getElementById("theme-selector").value = activeThemeId;
            alert("ÈáçÂëΩÂêçÊàêÂäüÔºÅ");
          }
        }

        /**
         * Âà†Èô§ÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰∏ªÈ¢ò
         */
        async function deleteSelectedTheme() {
          if (!activeThemeId) {
            alert("ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÂà†Èô§ÁöÑÊñπÊ°à„ÄÇ");
            return;
          }
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            `Á°ÆÂÆöË¶ÅÂà†Èô§ÊñπÊ°à "${document.getElementById("theme-selector").selectedOptions[0].textContent}" ÂêóÔºü`,
            { confirmButtonClass: "btn-danger" },
          );
          if (confirmed) {
            await db.themes.delete(activeThemeId);
            activeThemeId = null;
            await loadThemesToDropdown();
            // ÊÅ¢Â§çÂà∞Ê®°ÊùøÁä∂ÊÄÅ
            document.getElementById("theme-css-editor").value =
              THEME_CSS_TEMPLATE;
            applyThemeCss(THEME_CSS_TEMPLATE);
            alert("ÊñπÊ°àÂ∑≤Âà†Èô§„ÄÇ");
          }
        }

        /**
         * ÂØºÂá∫ÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰∏ªÈ¢ò‰∏∫‰∏Ä‰∏™JSONÊñá‰ª∂
         */
        async function exportTheme() {
          if (!activeThemeId) {
            alert("ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÂØºÂá∫ÁöÑÊñπÊ°à„ÄÇ");
            return;
          }
          const theme = await db.themes.get(activeThemeId);
          const exportData = {
            themeName: theme.name,
            themeCss: theme.css,
          };
          const blob = new Blob([JSON.stringify(exportData, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${theme.name}-Theme.json`;
          a.click();
          URL.revokeObjectURL(url);
        }

        /**
         * ÂØºÂÖ•‰∏ªÈ¢ò (ÊîØÊåÅ JSON, TXT, CSS, DOCX)
         */
        function importTheme(file) {
          if (!file) return;

          const fileName = file.name.toLowerCase();
          const editor = document.getElementById("theme-css-editor"); // Ëé∑ÂèñÁºñËæëÂô®ÊñáÊú¨Ê°Ü

          // --- ÊÉÖÂÜµA: Â¶ÇÊûúÊòØ Word ÊñáÊ°£ (.docx) ---
          if (fileName.endsWith(".docx")) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const arrayBuffer = e.target.result;
              // ‰ΩøÁî® mammoth ÊèêÂèñÁ∫ØÊñáÊú¨
              mammoth
                .extractRawText({ arrayBuffer: arrayBuffer })
                .then(function (result) {
                  const extractedText = result.value; // Ëé∑ÂèñÊèêÂèñÁöÑÊñáÂ≠ó
                  editor.value = extractedText; // Â°´ÂÖ•ÊñáÊú¨Ê°Ü
                  applyThemeCss(extractedText); // Á´ãÂç≥Â∫îÁî®È¢ÑËßà
                  alert(`ÊàêÂäü‰ªéWordÊñáÊ°£ËØªÂèñCSSÔºÅ`);
                })
                .catch(function (err) {
                  console.error(err);
                  alert("ËØªÂèñWordÊñá‰ª∂Â§±Ë¥•ÔºåËØ∑Á°Æ‰øùÊñá‰ª∂Êú™ÊçüÂùè„ÄÇ");
                });
            };
            reader.readAsArrayBuffer(file);
            return;
          }

          // --- ÊÉÖÂÜµB: Â¶ÇÊûúÊòØÊñáÊú¨Êñá‰ª∂ (.txt Êàñ .css) ---
          if (fileName.endsWith(".txt") || fileName.endsWith(".css")) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const text = e.target.result;
              editor.value = text; // Â°´ÂÖ•ÊñáÊú¨Ê°Ü
              applyThemeCss(text); // Á´ãÂç≥Â∫îÁî®È¢ÑËßà
              alert(`ÊàêÂäüÂØºÂÖ•ÊñáÊú¨ÂÜÖÂÆπÔºÅ`);
            };
            reader.readAsText(file);
            return;
          }

          // --- ÊÉÖÂÜµC: Â¶ÇÊûúÊòØ JSON (ÊóßÈÄªËæë) ---
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (data.themeName && typeof data.themeCss !== "undefined") {
                const newTheme = {
                  name: `${data.themeName} (Import)`,
                  css: data.themeCss,
                };
                const newId = await db.themes.add(newTheme);
                await loadThemesToDropdown();
                document.getElementById("theme-selector").value = newId;
                handleThemeSelection(); // ÂØºÂÖ•ÂêéËá™Âä®ÈÄâ‰∏≠Âπ∂Â∫îÁî®
                alert(`ÊñπÊ°à "${newTheme.name}" ÂØºÂÖ•ÊàêÂäüÔºÅ`);
              } else {
                // Â¶ÇÊûúËß£ÊûêJSONÂ§±Ë¥•ÔºåÂèØËÉΩÊòØÁî®Êà∑ÈÄâÈîô‰∫ÜÊñá‰ª∂ÔºåÂ∞ùËØïÂΩì‰ΩúÁ∫ØÊñáÊú¨Â°´ÂÖ•
                editor.value = e.target.result;
                alert("JSONÊ†ºÂºè‰∏çÂåπÈÖçÔºåÂ∑≤Â∞ùËØïÂ∞ÜÂÜÖÂÆπ‰Ωú‰∏∫Á∫ØÊñáÊú¨Â°´ÂÖ•ÁºñËæëÂô®„ÄÇ");
              }
            } catch (error) {
              // ÊúÄÂêéÁöÑÂÖúÂ∫ïÔºöÂ¶ÇÊûú‰∏çÊòØJSONÔºåÁõ¥Êé•Â°´ËøõÂéª
              editor.value = e.target.result;
              applyThemeCss(e.target.result);
              alert("Â∑≤Â∞ÜÊñá‰ª∂ÂÜÖÂÆπÂ°´ÂÖ•ÁºñËæëÂô®„ÄÇ");
            }
          };
          reader.readAsText(file);
        }

        /**
         * Ê∏≤ÊüìÂπ∂Â°´ÂÖÖAPIÈ¢ÑËÆæÁöÑ‰∏ãÊãâÈÄâÊã©Ê°Ü
         */
        function renderApiPresetSelector() {
          const selectEl = document.getElementById("api-preset-select");
          if (!selectEl) return;

          selectEl.innerHTML = '<option value="">-- Ëá™ÂÆö‰πâÈÖçÁΩÆ --</option>';

          if (state.apiPresets) {
            state.apiPresets.forEach((preset) => {
              const option = document.createElement("option");
              option.value = preset.id;
              option.textContent = preset.name;
              selectEl.appendChild(option);
            });
          }

          // Ê£ÄÊü•ÂΩìÂâçÈÖçÁΩÆÊòØÂê¶ÂåπÈÖç‰ªª‰Ωï‰∏Ä‰∏™È¢ÑËÆæ
          const { proxyUrl, apiKey } = state.apiConfig;
          const matchingPreset = state.apiPresets
            ? state.apiPresets.find(
                (p) => p.proxyUrl === proxyUrl && p.apiKey === apiKey,
              )
            : null;

          if (matchingPreset) {
            selectEl.value = matchingPreset.id;
          } else {
            selectEl.value = ""; // Â¶ÇÊûú‰∏çÂåπÈÖç‰ªª‰ΩïÈ¢ÑËÆæÔºåÂàôÈÄâ‰∏≠‚ÄúËá™ÂÆö‰πâÈÖçÁΩÆ‚Äù
          }
        }

        /**
         * ÂΩìÁî®Êà∑Âú®‰∏ãÊãâÊ°Ü‰∏≠ÈÄâÊã©‰∏Ä‰∏™È¢ÑËÆæÊó∂Ëß¶Âèë
         */
        function handleApiPresetSelectChange() {
          const selectEl = document.getElementById("api-preset-select");
          const proxyUrlInput = document.getElementById("proxy-url");
          const apiKeyInput = document.getElementById("api-key");
          const selectedId = parseInt(selectEl.value);

          if (selectedId && state.apiPresets) {
            const selectedPreset = state.apiPresets.find(
              (p) => p.id === selectedId,
            );
            if (selectedPreset) {
              proxyUrlInput.value = selectedPreset.proxyUrl;
              apiKeyInput.value = selectedPreset.apiKey;
            }
          }
        }

        /**
         * ÊâìÂºÄÈ¢ÑËÆæÁÆ°ÁêÜÁöÑÊìç‰ΩúËèúÂçï
         */
        async function openApiPresetManager() {
          const selectEl = document.getElementById("api-preset-select");
          const selectedId = parseInt(selectEl.value);
          const selectedPreset = state.apiPresets
            ? state.apiPresets.find((p) => p.id === selectedId)
            : null;

          const modal = document.getElementById("preset-actions-modal");
          const footer = modal.querySelector(".custom-modal-footer");

          footer.innerHTML = `
			        <button id="preset-action-save-new">‰øùÂ≠òÂΩìÂâçÈÖçÁΩÆ‰∏∫Êñ∞È¢ÑËÆæ</button>
			        <button id="preset-action-update-current" ${!selectedPreset ? "disabled" : ""}>Êõ¥Êñ∞ÂΩìÂâçÈÖçÁΩÆ</button>
			        <button id="preset-action-delete-current" class="btn-danger" ${
                !selectedPreset ? "disabled" : ""
              }>Âà†Èô§ÂΩìÂâçÈÖçÁΩÆ</button>
			        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">Cancel</button>
			    `;

          document
            .getElementById("preset-action-save-new")
            .addEventListener("click", saveCurrentApiConfigAsPreset);
          if (selectedPreset) {
            document
              .getElementById("preset-action-update-current")
              .addEventListener("click", () =>
                updateSelectedApiPreset(selectedId),
              );
            document
              .getElementById("preset-action-delete-current")
              .addEventListener("click", () =>
                deleteSelectedApiPreset(selectedId),
              );
          }
          document
            .getElementById("preset-action-cancel")
            .addEventListener("click", () => modal.classList.remove("visible"));

          modal.classList.add("visible");
        }

        /**
         * Â∞ÜÂΩìÂâçËæìÂÖ•Ê°ÜÁöÑÂÜÖÂÆπ‰øùÂ≠ò‰∏∫‰∏Ä‰∏™Êñ∞ÁöÑÈ¢ÑËÆæ
         */
        async function saveCurrentApiConfigAsPreset() {
          const proxyUrl = document.getElementById("proxy-url").value.trim();
          const apiKey = document.getElementById("api-key").value.trim();

          if (!proxyUrl || !apiKey) {
            alert("‰ª£ÁêÜÂú∞ÂùÄÂíåÂØÜÈí•ÈÉΩ‰∏çËÉΩ‰∏∫Á©∫ÔºÅ ");
            return;
          }

          const name = await showCustomPrompt(
            "‰øùÂ≠òAPIÈ¢ÑËÆæ",
            "ËØ∑‰∏∫Ëøô‰∏™ÈÖçÁΩÆËµ∑‰∏™ÂêçÂ≠óÔºö",
          );
          if (name && name.trim()) {
            const newPreset = { name: name.trim(), proxyUrl, apiKey };
            const newId = await db.apiPresets.add(newPreset);

            if (!state.apiPresets) state.apiPresets = [];
            state.apiPresets.push({ id: newId, ...newPreset });

            renderApiPresetSelector();
            document.getElementById("api-preset-select").value = newId;
            document
              .getElementById("preset-actions-modal")
              .classList.remove("visible");
            await showCustomAlert("ÊàêÂäü", `APIÈ¢ÑËÆæ "${name.trim()}" Â∑≤‰øùÂ≠òÔºÅ`);
          }
        }

        /**
         * Êõ¥Êñ∞ÂΩìÂâçÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function updateSelectedApiPreset(presetId) {
          const proxyUrl = document.getElementById("proxy-url").value.trim();
          const apiKey = document.getElementById("api-key").value.trim();

          if (!proxyUrl || !apiKey) {
            alert("‰ª£ÁêÜÂú∞ÂùÄÂíåÂØÜÈí•ÈÉΩ‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
            return;
          }

          const preset = state.apiPresets.find((p) => p.id === presetId);
          if (preset) {
            preset.proxyUrl = proxyUrl;
            preset.apiKey = apiKey;
            await db.apiPresets.put(preset);
            document
              .getElementById("preset-actions-modal")
              .classList.remove("visible");
            await showCustomAlert("ÊàêÂäü", `È¢ÑËÆæ "${preset.name}" Â∑≤Êõ¥Êñ∞ÔºÅ`);
          }
        }

        /**
         * Âà†Èô§ÂΩìÂâçÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function deleteSelectedApiPreset(presetId) {
          const preset = state.apiPresets.find((p) => p.id === presetId);
          if (preset) {
            const confirmed = await showCustomConfirm(
              "Á°ÆËÆ§Âà†Èô§",
              `Á°ÆÂÆöË¶ÅÂà†Èô§APIÈ¢ÑËÆæ "${preset.name}" ÂêóÔºü`,
              {
                confirmButtonClass: "btn-danger",
              },
            );
            if (confirmed) {
              await db.apiPresets.delete(presetId);
              state.apiPresets = state.apiPresets.filter(
                (p) => p.id !== presetId,
              );

              renderApiPresetSelector();
              document
                .getElementById("preset-actions-modal")
                .classList.remove("visible");
              await showCustomAlert("ÊàêÂäü", "È¢ÑËÆæÂ∑≤Âà†Èô§„ÄÇ");
            }
          }
        }

        /**
         * Ê∏≤ÊüìÂπ∂Â°´ÂÖÖÊ∞îÊ≥°Ê†∑ÂºèÈ¢ÑËÆæÁöÑ‰∏ãÊãâÈÄâÊã©Ê°Ü
         */
        function renderBubblePresetSelector() {
          const selectEl = document.getElementById(
            "bubble-style-preset-select",
          );
          const customCssInput = document.getElementById("custom-css-input");

          selectEl.innerHTML = '<option value="">-- Êó†È¢ÑËÆæ --</option>';

          if (state.bubbleStylePresets) {
            state.bubbleStylePresets.forEach((preset) => {
              const option = document.createElement("option");
              option.value = preset.id;
              option.textContent = preset.name;
              selectEl.appendChild(option);
            });
          }

          // Ê£ÄÊü•ÂΩìÂâçËÅäÂ§©ÁöÑCSSÊòØÂê¶ÂåπÈÖç‰ªª‰Ωï‰∏Ä‰∏™È¢ÑËÆæ
          const currentCss = customCssInput.value.trim();
          const matchingPreset = state.bubbleStylePresets
            ? state.bubbleStylePresets.find((p) => p.css.trim() === currentCss)
            : null;

          if (matchingPreset) {
            selectEl.value = matchingPreset.id;
          } else {
            selectEl.value = ""; // Â¶ÇÊûú‰∏çÂåπÈÖç‰ªª‰ΩïÈ¢ÑËÆæÔºåÂàôÈÄâ‰∏≠‚ÄúÊó†È¢ÑËÆæ‚Äù
          }
        }

        /**
         * ÂΩìÁî®Êà∑Âú®‰∏ãÊãâÊ°Ü‰∏≠ÈÄâÊã©‰∏Ä‰∏™È¢ÑËÆæÊó∂Ëß¶Âèë
         */
        function handlePresetSelectChange() {
          const selectEl = document.getElementById(
            "bubble-style-preset-select",
          );
          const customCssInput = document.getElementById("custom-css-input");
          const selectedId = parseInt(selectEl.value);

          if (selectedId && state.bubbleStylePresets) {
            const selectedPreset = state.bubbleStylePresets.find(
              (p) => p.id === selectedId,
            );
            if (selectedPreset) {
              customCssInput.value = selectedPreset.css;
            }
          }
          updateSettingsPreview(); // Êó†ËÆ∫Â¶Ç‰ΩïÈÉΩÊõ¥Êñ∞È¢ÑËßà
        }

        /**
         * ÊâìÂºÄÈ¢ÑËÆæÁÆ°ÁêÜÁöÑÊìç‰ΩúËèúÂçï
         */
        async function openBubblePresetManager() {
          const selectEl = document.getElementById(
            "bubble-style-preset-select",
          );
          const selectedId = parseInt(selectEl.value);
          const selectedPreset = state.bubbleStylePresets
            ? state.bubbleStylePresets.find((p) => p.id === selectedId)
            : null;

          const modal = document.getElementById("preset-actions-modal"); // Â§çÁî®Áé∞ÊúâÊ®°ÊÄÅÊ°Ü
          const footer = modal.querySelector(".custom-modal-footer");

          footer.innerHTML = `
			        <button id="preset-action-save-new">‰øùÂ≠ò</button>
			        <button id="preset-action-update-current" ${!selectedPreset ? "disabled" : ""}>Êõ¥Êñ∞</button>
			        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? "disabled" : ""}>Delete</button>
			        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">Cancel</button>
			    `;

          // ÈáçÊñ∞ÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("preset-action-save-new")
            .addEventListener("click", saveCurrentCssAsPreset);
          if (selectedPreset) {
            document
              .getElementById("preset-action-update-current")
              .addEventListener("click", () =>
                updateSelectedPreset(selectedId),
              );
            document
              .getElementById("preset-action-delete-current")
              .addEventListener("click", () =>
                deleteSelectedPreset(selectedId),
              );
          }
          document
            .getElementById("preset-action-cancel")
            .addEventListener("click", () => modal.classList.remove("visible"));

          modal.classList.add("visible");
        }

        /**
         * Â∞ÜÂΩìÂâçCSSÊñáÊú¨Ê°ÜÁöÑÂÜÖÂÆπ‰øùÂ≠ò‰∏∫‰∏Ä‰∏™Êñ∞ÁöÑÈ¢ÑËÆæ
         */
        async function saveCurrentCssAsPreset() {
          const customCssInput = document.getElementById("custom-css-input");
          const css = customCssInput.value.trim();
          if (!css) {
            alert("CSSÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
            return;
          }

          const name = await showCustomPrompt(
            "‰øùÂ≠òÈ¢ÑËÆæ",
            "ËØ∑‰∏∫Ëøô‰∏™Ê∞îÊ≥°Ê†∑ÂºèÂëΩÂêçÔºö",
          );
          if (name && name.trim()) {
            const newPreset = { name: name.trim(), css: css };
            const newId = await db.bubbleStylePresets.add(newPreset);

            if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
            state.bubbleStylePresets.push({ id: newId, ...newPreset });

            renderBubblePresetSelector();
            document.getElementById("bubble-style-preset-select").value = newId;
            document
              .getElementById("preset-actions-modal")
              .classList.remove("visible");
            await showCustomAlert("ÊàêÂäü", `È¢ÑËÆæ "${name.trim()}" Â∑≤‰øùÂ≠òÔºÅ`);
          }
        }

        /**
         * Êõ¥Êñ∞ÂΩìÂâçÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function updateSelectedPreset(presetId) {
          const customCssInput = document.getElementById("custom-css-input");
          const css = customCssInput.value.trim();

          const preset = state.bubbleStylePresets.find(
            (p) => p.id === presetId,
          );
          if (preset) {
            preset.css = css;
            await db.bubbleStylePresets.put(preset);
            document
              .getElementById("preset-actions-modal")
              .classList.remove("visible");
            await showCustomAlert("ÊàêÂäü", `È¢ÑËÆæ "${preset.name}" Â∑≤Êõ¥Êñ∞ÔºÅ`);
          }
        }

        /**
         * Âà†Èô§ÂΩìÂâçÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function deleteSelectedPreset(presetId) {
          const preset = state.bubbleStylePresets.find(
            (p) => p.id === presetId,
          );
          if (preset) {
            const confirmed = await showCustomConfirm(
              "Á°ÆËÆ§Âà†Èô§",
              `Á°ÆÂÆöË¶ÅÂà†Èô§È¢ÑËÆæ "${preset.name}" ÂêóÔºü`,
              {
                confirmButtonClass: "btn-danger",
              },
            );
            if (confirmed) {
              await db.bubbleStylePresets.delete(presetId);
              state.bubbleStylePresets = state.bubbleStylePresets.filter(
                (p) => p.id !== presetId,
              );

              renderBubblePresetSelector();
              document.getElementById("custom-css-input").value = "";
              updateSettingsPreview();

              document
                .getElementById("preset-actions-modal")
                .classList.remove("visible");
              await showCustomAlert("ÊàêÂäü", "È¢ÑËÆæÂ∑≤Âà†Èô§„ÄÇ");
            }
          }
        }

        /**
         * Êí≠ÊîæÊù•ÁîµÈìÉÂ£∞
         */
        function playRingtone() {
          const ringtonePlayer = document.getElementById("ringtone-player");
          // ‰ºòÂÖà‰ΩøÁî®Áî®Êà∑Âú®ËÆæÁΩÆ‰∏≠‰øùÂ≠òÁöÑURLÔºåÂ¶ÇÊûúÊ≤°ËÆæÁΩÆÔºåÂ∞±Áî®Êàë‰ª¨È¢ÑËÆæÁöÑURL
          const ringtoneUrl =
            state.globalSettings.ringtoneUrl ||
            "https://files.catbox.moe/3w7gla.mp3";

          if (ringtonePlayer && ringtoneUrl) {
            ringtonePlayer.src = ringtoneUrl;
            // play() ËøîÂõû‰∏Ä‰∏™ PromiseÔºåÊàë‰ª¨ÊúÄÂ•ΩÁî® try...catch ÂåÖË£π‰ª•Èò≤Ê≠¢ÊµèËßàÂô®Êä•Èîô
            const playPromise = ringtonePlayer.play();
            if (playPromise !== undefined) {
              playPromise.catch((error) => {
                console.error("ÈìÉÂ£∞Êí≠ÊîæÂ§±Ë¥•:", error);
                // ÂèØ‰ª•Âú®ËøôÈáåÁªôÁî®Êà∑‰∏Ä‰∏™ÈùôÈü≥ÊèêÁ§∫ÔºåÂ¶ÇÊûúÈúÄË¶ÅÁöÑËØù
              });
            }
          }
        }

        /**
         * ÂÅúÊ≠¢Âπ∂ÈáçÁΩÆÊù•ÁîµÈìÉÂ£∞
         */
        function stopRingtone() {
          const ringtonePlayer = document.getElementById("ringtone-player");
          if (ringtonePlayer) {
            ringtonePlayer.pause();
            ringtonePlayer.currentTime = 0; // Â∞ÜÊí≠ÊîæËøõÂ∫¶ÈáçÁΩÆÂà∞ÂºÄÂ§¥
          }
        }

        /**
         * Êí≠ÊîæÊ∂àÊÅØÊèêÁ§∫Èü≥ÔºåÂ¢ûÂä†ÂÅ•Â£ÆÊÄß
         */
        function playNotificationSound() {
          const soundUrl =
            state.globalSettings.notificationSoundUrl ||
            "https://laddy-lulu.github.io/Ephone-stuffs/message.mp3";

          // 1. Â¢ûÂä†ÂÆâÂÖ®Ê£ÄÊü•ÔºöÂ¶ÇÊûúÈìæÊé•‰∏∫Á©∫ÔºåÁõ¥Êé•ËøîÂõûÔºå‰∏çÊâßË°å‰ªª‰ΩïÊìç‰Ωú
          if (!soundUrl || !soundUrl.trim()) return;

          try {
            const audio = new Audio(soundUrl);
            audio.volume = 0.7;

            audio.play().catch((error) => {
              // 2. ‰ºòÂåñÈîôËØØÊèêÁ§∫ÔºåÁé∞Âú®ËÉΩÊõ¥ÂáÜÁ°ÆÂú∞ÂèçÊò†ÈóÆÈ¢ò
              if (error.name === "NotAllowedError") {
                console.warn(
                  "Êí≠ÊîæÊ∂àÊÅØÊèêÁ§∫Èü≥Â§±Ë¥•ÔºöÁî®Êà∑ÈúÄË¶ÅÂÖà‰∏éÈ°µÈù¢ËøõË°å‰∏ÄÊ¨°‰∫§‰∫íÔºàÂ¶ÇÁÇπÂáªÔºâÊâçËÉΩËá™Âä®Êí≠ÊîæÈü≥È¢ë„ÄÇ",
                );
              } else {
                // ÂØπ‰∫éÂÖ∂‰ªñÈîôËØØÔºàÊØîÂ¶ÇÊàë‰ª¨ËøôÊ¨°ÈÅáÂà∞ÁöÑÔºâÔºåÁõ¥Êé•ÊâìÂç∞ÈîôËØØËØ¶ÊÉÖ
                console.error(
                  `Êí≠ÊîæÊ∂àÊÅØÊèêÁ§∫Èü≥Â§±Ë¥• (${error.name}): ${error.message}`,
                  "URL:",
                  soundUrl,
                );
              }
            });
          } catch (error) {
            console.error("ÂàõÂª∫ÊèêÁ§∫Èü≥AudioÂØπË±°Êó∂Âá∫Èîô:", error);
          }
        }

        // Èü≥È¢ë‰∏ä‰∏ãÊñáËß£ÈîÅÂáΩÊï∞
        function unlockAudioContext() {
          const ringtonePlayer = document.getElementById("ringtone-player");
          // Ê£ÄÊü•Êí≠ÊîæÂô®ÊòØÂê¶Â§Ñ‰∫éÊöÇÂÅúÁä∂ÊÄÅÔºåÂπ∂‰∏îÊàë‰ª¨‰πãÂâçÊ≤°ÊúâÊàêÂäüÊí≠ÊîæËøá
          if (ringtonePlayer && ringtonePlayer.paused) {
            // Â∞ùËØïÊí≠ÊîæÔºåÁÑ∂ÂêéÁ´ãÂàªÊöÇÂÅú„ÄÇ
            // Ëøô‰∏™Êìç‰ΩúÂØπÁî®Êà∑ÊòØÊó†ÊÑüÁü•ÁöÑÔºå‰ΩÜËÉΩÂëäËØâÊµèËßàÂô®Áî®Êà∑Â∑≤‰∏éÈü≥È¢ë‰∫§‰∫í„ÄÇ
            ringtonePlayer.play().catch(() => {}); // play() ‰ºöËøîÂõû‰∏Ä‰∏™ PromiseÔºåÊàë‰ª¨ÂøΩÁï•‰ªª‰ΩïÂèØËÉΩÂèëÁîüÁöÑÈîôËØØ
            ringtonePlayer.pause();
            console.log("Ringtone audio context unlocked.");
          }
        }
        // ‚ÄúÊü•ÊâãÊú∫‚ÄùÂÜÖÂÆπÂçïÊù°Âà†Èô§ÂäüËÉΩ
        /**
         * Â§ÑÁêÜËßíËâ≤ÊâãÊú∫ÂÜÖÊï∞ÊçÆÂà†Èô§ÁöÑÈÄöÁî®ÂáΩÊï∞
         * @param {string} dataType - Ë¶ÅÂà†Èô§ÁöÑÊï∞ÊçÆÁ±ªÂûã, ÊØîÂ¶Ç 'memos', 'shoppingCart'
         * @param {number} index - Ë¶ÅÂà†Èô§ÁöÑÊï∞ÊçÆÂú®Êï∞ÁªÑ‰∏≠ÁöÑÁ¥¢Âºï
         */
        async function handleCharacterDataDeletion(dataType, index) {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];

          let dataArray;
          // Â§ÑÁêÜÂÉè bank.transactions ËøôÊ†∑ÁöÑÂµåÂ•óÊï∞ÊçÆ
          if (dataType.includes(".")) {
            const keys = dataType.split(".");
            dataArray = chat.characterPhoneData[keys[0]][keys[1]];
          } else {
            dataArray = chat.characterPhoneData[dataType];
          }

          if (!chat || !dataArray) return;

          const itemToDelete = dataArray[index];
          if (!itemToDelete) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËÆ∞ÂΩïÂêóÔºü",
            {
              confirmButtonClass: "btn-danger",
            },
          );

          if (confirmed) {
            dataArray.splice(index, 1);
            await db.chats.put(chat);

            // Ê†πÊçÆÂà†Èô§ÁöÑÁ±ªÂûãÔºåÈáçÊñ∞Ê∏≤ÊüìÂØπÂ∫îÁöÑAPPÁïåÈù¢
            switch (dataType) {
              case "memos":
                renderCharacterMemos();
                break;
              case "shoppingCart":
                renderCharacterShoppingCart();
                break;
              case "browserHistory":
                renderCharacterBrowser();
                break;
              case "diary":
                renderCharacterDiary();
                break;
              case "bank.transactions":
                renderCharacterBank();
                break;
              case "trajectory":
                renderCharacterTrajectory();
                break;
              case "appUsage":
                renderCharacterAppUsage();
                break;
              case "photoAlbum":
                renderCharacterPhotoAlbum();
                break;
            }
            alert("ËÆ∞ÂΩïÂ∑≤Âà†Èô§„ÄÇ");
          }
        }

        /**
         * Â§ÑÁêÜËßíËâ≤ÊâãÊú∫ÂÜÖÂçïÊù°ËÅäÂ§©Ê∂àÊÅØÁöÑÂà†Èô§
         * @param {string} contactName - Ê≠£Âú®Êü•ÁúãÁöÑËÅîÁ≥ª‰∫∫ÂêçÁß∞
         * @param {number} index - Ë¶ÅÂà†Èô§ÁöÑÊ∂àÊÅØÂú®ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠ÁöÑÁ¥¢Âºï
         */
        async function handleCharacterChatMessageDeletion(contactName, index) {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];
          if (!chat) return;

          let historyArray;
          // Âà§Êñ≠ÊòØÂíå‚ÄúÊàë‚ÄùÁöÑËÅäÂ§©ËøòÊòØÂíåNPCÁöÑËÅäÂ§©
          if (
            contactName ===
            (chat.characterPhoneData.chats["Me"]?.remarkName || "Me")
          ) {
            historyArray = chat.history;
          } else {
            historyArray = chat.characterPhoneData.chats[contactName]?.history;
          }

          if (!historyArray || !historyArray[index]) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°Ê∂àÊÅØÂêóÔºü",
            {
              confirmButtonClass: "btn-danger",
            },
          );

          if (confirmed) {
            historyArray.splice(index, 1);
            await db.chats.put(chat);

            // ÈáçÊñ∞Ê∏≤ÊüìÂΩìÂâçËÅäÂ§©ÁïåÈù¢
            renderCharacterChatHistory(contactName);
            alert("Ê∂àÊÅØÂ∑≤Âà†Èô§„ÄÇ");
          }
        }

        // ÈîÅÂ±èÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞

        /**
         * Â∫îÁî®ÈîÅÂ±èÂ£ÅÁ∫∏Âà∞ #lock-screen ÂÖÉÁ¥†
         */
        function applyLockscreenWallpaper() {
          const lockScreen = document.getElementById("lock-screen");
          const wallpaper = state.globalSettings.lockscreenWallpaper;
          if (wallpaper && wallpaper.startsWith("data:image")) {
            lockScreen.style.backgroundImage = `url(${wallpaper})`;
          } else if (wallpaper) {
            lockScreen.style.backgroundImage = wallpaper;
          }
        }

        /**
         * ÊòæÁ§∫ÈîÅÂ±èÁïåÈù¢
         */
        function lockPhone() {
          console.log("Ê≠£Âú®ÈîÅÂÆöÊâãÊú∫...");
          isLocked = true;
          document.getElementById("lock-screen").classList.add("active");
          document
            .querySelectorAll(".screen:not(#lock-screen)")
            .forEach((s) => s.classList.remove("active"));
        }

        /**
         * Ëß£ÈîÅÊâãÊú∫ÔºåÊòæÁ§∫‰∏ªÂ±èÂπï
         */
        function unlockPhone() {
          console.log("ÊâãÊú∫Â∑≤Ëß£ÈîÅÔºÅ");
          isLocked = false;
          // ÂΩªÂ∫ïÈöêËóèÈîÅÂ±èÂíåÊØõÁéªÁíÉËÉåÊôØ
          document.getElementById("lock-screen").classList.remove("active");
          const blurBg = document.getElementById("lock-screen-background-blur");
          blurBg.style.display = "none";
          blurBg.style.opacity = "0";

          // Á°Æ‰øù‰∏ªÂ±èÂπïÊòØÂîØ‰∏ÄÊøÄÊ¥ªÁöÑÈ°∂Â±ÇÂ±èÂπï
          showScreen("home-screen");

          // ÈáçÁΩÆÈîÅÂ±èÁöÑÊ†∑ÂºèÔºå‰∏∫‰∏ãÊ¨°ÈîÅÂÆöÂÅöÂáÜÂ§á
          setTimeout(() => {
            const lockScreen = document.getElementById("lock-screen");
            const unlockHint = document.getElementById("unlock-hint");
            lockScreen.style.transition = "none";
            unlockHint.style.transition = "none";
            lockScreen.style.transform = "translateY(0)";
            lockScreen.offsetHeight;
            lockScreen.style.transition = "transform 0.3s ease-out";
            unlockHint.style.transition = "opacity 0.3s ease-out";
          }, 500);
        }

        /**
         * ÊòæÁ§∫ÂØÜÁ†ÅËæìÂÖ•ÂºπÁ™ó
         */
        function showPasswordModal() {
          const modal = document.getElementById("password-modal-overlay");
          const input = document.getElementById("password-input-field");
          input.value = ""; // Ê∏ÖÁ©∫‰∏äÊ¨°ËæìÂÖ•
          modal.classList.add("visible");
          setTimeout(() => input.focus(), 100); // Âª∂ËøüËÅöÁÑ¶ÔºåÁ°Æ‰øùÂä®ÁîªÊµÅÁïÖ
        }

        /**
         * ÈöêËóèÂØÜÁ†ÅËæìÂÖ•ÂºπÁ™ó
         */
        function hidePasswordModal() {
          document.getElementById(
            "password-modal-overlay",
          ).style.backgroundImage = "none";

          const modal = document.getElementById("password-modal-overlay");
          modal.classList.remove("visible");
          // ÁßªÈô§ÂèØËÉΩÂ≠òÂú®ÁöÑÈîôËØØÂä®ÁîªÁ±ª
          modal
            .querySelector(".password-modal-content")
            .classList.remove("error");
          // ÂΩìÂèñÊ∂àËæìÂÖ•ÂØÜÁ†ÅÊó∂...
          // 1. ÈöêËóèÊØõÁéªÁíÉËÉåÊôØ
          const blurBg = document.getElementById("lock-screen-background-blur");
          blurBg.style.opacity = "0";
          setTimeout(() => {
            blurBg.style.display = "none";
          }, 300); // Âä®ÁîªÁªìÊùüÂêéÂÜçÈöêËóè

          // 2. ËÆ©ÈîÅÂ±èÁïåÈù¢ÊªëÂõûÊù•
          const lockScreen = document.getElementById("lock-screen");
          const unlockHint = document.getElementById("unlock-hint");
          lockScreen.style.transform = "translateY(0)";
          unlockHint.style.opacity = "1";
        }

        /**
         * Ê£ÄÊü•Áî®Êà∑ËæìÂÖ•ÁöÑÂØÜÁ†ÅÊòØÂê¶Ê≠£Á°Æ
         */
        function checkPassword() {
          const input = document.getElementById("password-input-field");
          const enteredPassword = input.value;
          const correctPassword = state.globalSettings.password;

          if (enteredPassword === correctPassword) {
            // --- ÂØÜÁ†ÅÊ≠£Á°Æ ---

            // 1. ÊèêÂâçÊää‰∏ªÂ±èÂπïÂú®ÊúÄÂ∫ïÂ±ÇÊøÄÊ¥ªÂπ∂ÂáÜÂ§áÂ•Ω
            //    Âõ†‰∏∫ÂÆÉ z-index ÊúÄ‰ΩéÔºåÊâÄ‰ª•ÊöÇÊó∂ËøòÁúã‰∏çÂà∞ÂÆÉ„ÄÇ
            showScreen("home-screen");

            // 2. ÈöêËóèÂØÜÁ†ÅËæìÂÖ•Ê°Ü (ÂÆÉ‰ºöËá™Â∑±Êí≠ÊîæÊ∑°Âá∫Âä®Áîª)
            document
              .getElementById("password-modal-overlay")
              .classList.remove("visible");

            // 3. ËÆ©ÊØõÁéªÁíÉËÉåÊôØ‰πüÂºÄÂßãÊ∑°Âá∫
            document.getElementById(
              "lock-screen-background-blur",
            ).style.opacity = "0";

            // 4. Á≠âÂæÖÊ∑°Âá∫Âä®ÁîªÊí≠ÊîæÂÆåÊØï (300ÊØ´Áßí)ÔºåÂÜçÊâßË°åÊúÄÁªàÁöÑÊ∏ÖÁêÜÂ∑•‰Ωú
            setTimeout(unlockPhone, 300);
          } else {
            // --- ÂØÜÁ†ÅÈîôËØØ (ÈÄªËæë‰øùÊåÅ‰∏çÂèò) ---
            const content = document.querySelector(".password-modal-content");
            content.classList.add("error");
            input.value = "";
            setTimeout(() => content.classList.remove("error"), 400);
          }
        }

        /**
         * Êõ¥Êñ∞ÈîÅÂ±èÁïåÈù¢ÁöÑÊó∂Èíü
         */
        function updateLockClock() {
          const now = new Date();
          const timeString = now.toLocaleTimeString("en-GB", {
            hour: "2-digit",
            minute: "2-digit",
          });
          const dateString = now.toLocaleDateString("en-GB", { 
            weekday: "long",
            month: "long",
            day: "numeric",
          });
          document.getElementById("lock-main-time").textContent = timeString;
          document.getElementById("lock-main-date").textContent = dateString;
        }

        async function openBulkAddStickersModal() {
          const placeholder = `Âú®ËøôÈáåÁ≤òË¥¥Ë°®ÊÉÖÂåÖÔºåÊØèË°å‰∏Ä‰∏™ÔºåÊ†ºÂºèÂ¶Ç‰∏ãÔºö\n\nÁå´Áå´ÂñùÊ∞¥Ôºöhttps://..../cat.gif\nÁãóÁãóÊëáÂ§¥Ôºöhttps://..../dog.png\n\n(ÊîØÊåÅÁî®‰∏≠ÊñáÂÜíÂè∑‚ÄúÔºö‚Äù„ÄÅËã±ÊñáÂÜíÂè∑‚Äú:‚ÄùÊàñÁ©∫Ê†ºÂàÜÈöî)`;

          const textInput = await showCustomPrompt(
            "ÊâπÈáèÊ∑ªÂä†Ë°®ÊÉÖ(URL)",
            "‰∏ÄË°å‰∏Ä‰∏™ÔºåÂêçÁß∞ÂíåÈìæÊé•Áî®ÂÜíÂè∑ÊàñÁ©∫Ê†ºÈöîÂºÄ",
            "",
            "textarea",
          );

          if (!textInput || !textInput.trim()) {
            return;
          }

          const lines = textInput.trim().split("\n");
          const newStickers = [];
          let successCount = 0;
          let errorLines = [];

          lines.forEach((line, index) => {
            line = line.trim();
            if (!line) return;

            let name = "";
            let url = "";
            let splitIndex = -1;

            // 1. Êü•Êâæ URL ÁöÑËµ∑Âßã‰ΩçÁΩÆ
            const httpIndex = line.indexOf("http");
            const dataIndex = line.indexOf("data:image");

            if (httpIndex > -1) {
              splitIndex = httpIndex;
            } else if (dataIndex > -1) {
              splitIndex = dataIndex;
            }

            // 2. Â¶ÇÊûúÊâæÂà∞‰∫Ü URL ÁöÑËµ∑Âßã‰ΩçÁΩÆ
            if (splitIndex > 0) {
              // URL ‰πãÂâçÁöÑÊâÄÊúâÂÜÖÂÆπÈÉΩÂ±û‰∫éÂêçÁß∞
              name = line.substring(0, splitIndex).trim();
              // ‰ªé URL Ëµ∑Âßã‰ΩçÁΩÆÂà∞Êú´Â∞æÁöÑÊâÄÊúâÂÜÖÂÆπÈÉΩÂ±û‰∫é URL
              url = line.substring(splitIndex).trim();

              // 3. Ê∏ÖÁêÜÂêçÁß∞Êú´Â∞æÂèØËÉΩÂ≠òÂú®ÁöÑÂàÜÈöîÁ¨¶
              if (name.endsWith(":") || name.endsWith("Ôºö")) {
                name = name.slice(0, -1).trim();
              }
            } else {
              // Â¶ÇÊûúÊâæ‰∏çÂà∞ URLÔºåËØ¥ÊòéÊ†ºÂºèÊúâÈóÆÈ¢ò
              errorLines.push(index + 1);
              return; // Ë∑≥ËøáÊ≠§Ë°å
            }

            if (
              name &&
              (url.startsWith("http") || url.startsWith("data:image"))
            ) {
              newStickers.push({
                id: "sticker_" + (Date.now() + index),
                url: url,
                name: name,
              });
              successCount++;
            } else {
              errorLines.push(index + 1);
            }
          });

          if (newStickers.length > 0) {
            await db.userStickers.bulkAdd(newStickers);
            state.userStickers.push(...newStickers);
            renderStickerPanel();
          }

          let reportMessage = `ÊâπÈáèÂØºÂÖ•ÂÆåÊàêÔºÅ\n\nÊàêÂäüÂØºÂÖ•Ôºö${successCount} ‰∏™Ë°®ÊÉÖ„ÄÇ`;
          if (errorLines.length > 0) {
            reportMessage += `\nÂ§±Ë¥•Ë°åÂè∑Ôºö${errorLines.join(", ")}„ÄÇ\n\nËØ∑Ê£ÄÊü•Ëøô‰∫õË°åÁöÑÊ†ºÂºèÊòØÂê¶Ê≠£Á°Æ„ÄÇ`;
          }
          await showCustomAlert("ÂØºÂÖ•Êä•Âëä", reportMessage);
        }

        /**
         * Ê†πÊçÆË∑ùÁ¶ªÊñáÊú¨ÔºåËÆ°ÁÆóCSSÂÆΩÂ∫¶ÁôæÂàÜÊØî
         * @param {string} distanceText - Ë∑ùÁ¶ªÊèèËø∞Ôºå‰æãÂ¶Ç "500m", "10km", "ÂæàËøë"
         * @returns {number} - 10Âà∞90‰πãÈó¥ÁöÑÁôæÂàÜÊØî
         */
        function calculatePinDistancePercentage(distanceText) {
          if (!distanceText) return 50; // ÈªòËÆ§ÂÄº

          const text = distanceText.toLowerCase();
          // ÊèêÂèñÊï∞Â≠óÈÉ®ÂàÜ
          const matches = text.match(/(\d+(\.\d+)?)/);
          const num = matches ? parseFloat(matches[1]) : 0;

          // Ê†πÊçÆÂçï‰ΩçÊàñÂÖ≥ÈîÆËØçÂà§Êñ≠
          if (text.includes("km") || text.includes("ÂÖ¨Èáå")) {
            if (num > 1000) return 90;
            if (num > 100) return 80;
            if (num > 10) return 70;
            if (num > 1) return 60;
            return 50;
          } else if (text.includes("m") || text.includes("Á±≥")) {
            if (num > 500) return 40;
            if (num > 100) return 30;
            return 20;
          } else if (text.includes("Ëøú") || text.includes("‰∏çÂêåÂüéÂ∏Ç")) {
            return 90;
          } else if (text.includes("ÈôÑËøë") || text.includes("ÈöîÂ£Å")) {
            return 20;
          } else if (text.includes("Ëøë")) {
            return 30;
          }

          return 15; // Â¶ÇÊûúÊó†Ê≥ïËØÜÂà´ÔºåÁªô‰∏Ä‰∏™ÊúÄÂ∞èÁöÑË∑ùÁ¶ª
        }

        /**
         * Âú®ÂÆö‰ΩçÊ®°ÊÄÅÊ°Ü‰∏≠Ê∑ªÂä†‰∏Ä‰∏™ÈÄîÁªèÁÇπËæìÂÖ•Ê°Ü
         */
        function addTrajectoryPointInput(name = "") {
          const container = document.getElementById(
            "trajectory-points-container",
          );
          const div = document.createElement("div");
          div.style.display = "flex";
          div.style.gap = "8px";
          div.innerHTML = `
			        <input type="text" class="trajectory-point-input" placeholder="ÈÄîÁªèÁÇπ${
                container.children.length + 1
              }" value="${name}" style="flex-grow: 1;">
			        <button class="remove-option-btn">-</button>
			    `;
          div
            .querySelector(".remove-option-btn")
            .addEventListener("click", () => div.remove());
          container.appendChild(div);
        }

        async function sendUserLocation() {
          if (!state.activeChatId) return;

          const userLocation = document
            .getElementById("user-location-input")
            .value.trim();
          const aiLocation = document
            .getElementById("ai-location-input")
            .value.trim();
          const distance = document
            .getElementById("distance-input")
            .value.trim();

          if (!distance || (!userLocation && !aiLocation)) {
            alert("‚ÄúÊàëÁöÑ‰ΩçÁΩÆ‚ÄùÂíå‚ÄúTaÁöÑ‰ΩçÁΩÆ‚ÄùËá≥Â∞ëË¶ÅÂ°´ÂÜô‰∏Ä‰∏™Ôºå‰∏î‚ÄúÁõ∏Ë∑ù‚Äù‰∏∫ÂøÖÂ°´È°πÔºÅ");
            return;
          }

          const trajectoryPoints = Array.from(
            document.querySelectorAll(".trajectory-point-input"),
          )
            .map((input) => ({ name: input.value.trim() }))
            .filter((point) => point.name);

          const chat = state.chats[state.activeChatId];

          // 1. Ê†πÊçÆÁî®Êà∑ËæìÂÖ•ÔºåÊûÑÂª∫‰∏ÄÊù°AIËÉΩÁúãÊáÇÁöÑÊñáÊú¨ÂÜÖÂÆπ
          //    Ëøô‰∏™Ê†ºÂºèÂíåAIËá™Â∑±ÂèëÂÆö‰ΩçÊó∂Áî®ÁöÑÊ†ºÂºè‰øùÊåÅ‰∏ÄËá¥ÔºåÈùûÂ∏∏ÂÆåÁæéÔºÅ
          let contentString = "[SEND_LOCATION]";
          if (userLocation) contentString += ` ÊàëÁöÑ‰ΩçÁΩÆ: ${userLocation}`;
          if (aiLocation) contentString += ` | ‰Ω†ÁöÑ‰ΩçÁΩÆ: ${aiLocation}`;
          contentString += ` | Áõ∏Ë∑ù: ${distance}`;
          if (trajectoryPoints.length > 0) {
            const trajectoryText = trajectoryPoints
              .map((p) => p.name)
              .join(", ");
            contentString += ` | ÈÄîÁªèÁÇπ: ${trajectoryText}`;
          }

          // 2. ÂàõÂª∫Ê∂àÊÅØÂØπË±°ÔºåËøôÊ¨°Êàë‰ª¨ÊääÂàöÂàöÂàõÂª∫ÁöÑ contentString ‰πüÊîæ‰∫ÜËøõÂéª
          const locationMessage = {
            role: "user",
            type: "location",
            timestamp: Date.now(),
            userLocation: userLocation,
            aiLocation: aiLocation,
            distance: distance,
            trajectoryPoints: trajectoryPoints,
            content: contentString, // <-- ËøôÂ∞±ÊòØÊúÄÂÖ≥ÈîÆÁöÑÊñ∞Â¢ûÂ±ûÊÄßÔºÅ
          };

          // ÂêéÁª≠ÁöÑ‰øùÂ≠òÂíåÊ∏≤ÊüìÈÄªËæë‰øùÊåÅ‰∏çÂèò
          chat.history.push(locationMessage);
          await db.chats.put(chat);
          appendMessage(locationMessage, chat);
          renderChatList();

          document
            .getElementById("send-location-modal")
            .classList.remove("visible");
        }

        // ‚Äú‰∏ÄÈîÆÈáçroll‚ÄùÂäüËÉΩÊ†∏ÂøÉ‰ª£Á†Å

        /**
         * Êô∫ËÉΩÊü•ÊâæAI‰∏ä‰∏ÄËΩÆÂõûÂ§çÁöÑÊâÄÊúâÊ∂àÊÅØ
         * @param {Array} history - ÂÆåÊï¥ÁöÑËÅäÂ§©ÂéÜÂè≤ËÆ∞ÂΩï
         * @returns {Array} - ‰∏Ä‰∏™ÂåÖÂê´‰∫Ü‰∏ä‰∏ÄËΩÆAIÊâÄÊúâÊ∂àÊÅØÂØπË±°ÁöÑÊï∞ÁªÑ
         */
        function findLastAiTurnMessages(history) {
          const turnMessages = [];
          let lastMessageIndex = history.length - 1;

          // ‰ªéÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÂºÄÂßãÔºåÂêëÂâçÊü•Êâæ
          for (let i = lastMessageIndex; i >= 0; i--) {
            const message = history[i];

            // Â¶ÇÊûúÊòØAIÁöÑÊ∂àÊÅØÔºåÂ∞±ÊääÂÆÉÂä†ÂÖ•Êàë‰ª¨ÁöÑ‚ÄúÂæÖÂà†Èô§ÂàóË°®‚Äù
            if (message.role === "assistant") {
              turnMessages.unshift(message); // ‰ΩøÁî® unshift ‰øùÊåÅÂéüÂßãÈ°∫Â∫è
            }
            // ‰∏ÄÊó¶ÈÅáÂà∞ÈùûAIÁöÑÊ∂àÊÅØÔºàÁî®Êà∑ÁöÑÊàñÁ≥ªÁªüÁöÑÔºâÔºåËØ¥ÊòéAIÁöÑËøô‰∏ÄËΩÆÂõûÂ§çÂ∑≤ÁªèÁªìÊùü‰∫ÜÔºåÁ´ãÂàªÂÅúÊ≠¢Êü•Êâæ
            else {
              break;
            }
          }
          return turnMessages;
        }

        /**
         * ‚ÄúÈáçroll‚ÄùÊåâÈíÆË¢´ÁÇπÂáªÊó∂ÁöÑ‰∏ªÂ§ÑÁêÜÂáΩÊï∞
         */
        async function handleRerollClick() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];

          // 1. Ë∞ÉÁî®Êàë‰ª¨ÁöÑÊô∫ËÉΩÊü•ÊâæÂáΩÊï∞ÔºåÊâæÂá∫ÈúÄË¶ÅÂà†Èô§ÁöÑÊ∂àÊÅØ
          const messagesToReroll = findLastAiTurnMessages(chat.history);

          // 2. Â¶ÇÊûúÊ≤°ÊâæÂà∞ÔºàÊØîÂ¶ÇÊúÄÂêé‰∏ÄÊù°ÊòØÁî®Êà∑ÂèëÁöÑÔºâÔºåÂ∞±ÊèêÁ§∫Âπ∂ÈÄÄÂá∫
          if (messagesToReroll.length === 0) {
            alert("ËØ∑Âú®AIÂõûÂ§çÂêé‰ΩøÁî®Ê≠§ÂäüËÉΩ„ÄÇ");
            return;
          }

          // 3. ‰ªéËÅäÂ§©ËÆ∞ÂΩï‰∏≠ËøáÊª§ÊéâËøô‰∫õÊóßÊ∂àÊÅØ
          const timestampsToReroll = new Set(
            messagesToReroll.map((m) => m.timestamp),
          );
          chat.history = chat.history.filter(
            (msg) => !timestampsToReroll.has(msg.timestamp),
          );

          // 4. ‰øùÂ≠òÊõ¥Êñ∞ÂêéÁöÑËÅäÂ§©ËÆ∞ÂΩïÂà∞Êï∞ÊçÆÂ∫ì
          await db.chats.put(chat);

          // 5. Âà∑Êñ∞ËÅäÂ§©ÁïåÈù¢ÔºåËÆ©ÊóßÊ∂àÊÅØÁû¨Èó¥Ê∂àÂ§±
          renderChatInterface(state.activeChatId);

          // 6. Ëß¶Âèë‰∏ÄÊ¨°Êñ∞ÁöÑAIÂìçÂ∫îÔºåÂ∞±ÂÉèÁî®Êà∑ÁÇπÂáª‰∫Ü‚ÄúÁ≠âÂæÖÂõûÂ§ç‚Äù‰∏ÄÊ†∑
          triggerAiResponse();
        }

        function initDraggableLyricsBar() {
          const bar = document.getElementById("floating-lyrics-bar");
          const phoneScreen = document.getElementById("phone-screen");

          let isDragging = false;
          let offsetX, offsetY;

          const onDragStart = (e) => {
            // Ê£ÄÊü•ÁÇπÂáªÁöÑÊòØÂê¶ÊòØÊåâÈíÆÔºåÂ¶ÇÊûúÊòØÔºåÂàô‰∏çÂºÄÂßãÊãñÂä®
            if (
              e.target.closest("#lyrics-settings-btn") ||
              e.target.closest(".close-btn")
            ) {
              return;
            }

            isDragging = true;
            bar.classList.add("dragging");

            const rect = bar.getBoundingClientRect();
            const coords = getEventCoords(e);

            offsetX = coords.x - rect.left;
            offsetY = coords.y - rect.top;

            document.addEventListener("mousemove", onDragMove);
            document.addEventListener("mouseup", onDragEnd);
            document.addEventListener("touchmove", onDragMove, {
              passive: false,
            });
            document.addEventListener("touchend", onDragEnd);
          };

          const onDragMove = (e) => {
            if (!isDragging) return;

            e.preventDefault();

            const phoneRect = phoneScreen.getBoundingClientRect();
            const coords = getEventCoords(e);

            let newLeft = coords.x - offsetX - phoneRect.left;
            let newTop = coords.y - offsetY - phoneRect.top;

            const maxLeft = phoneScreen.clientWidth - bar.offsetWidth;
            const maxTop = phoneScreen.clientHeight - bar.offsetHeight;

            newLeft = Math.max(0, Math.min(newLeft, maxLeft));
            newTop = Math.max(0, Math.min(newTop, maxTop));

            // Âú®ÊãñÂä®Êó∂ÔºåÂêåÊó∂ËÆæÁΩÆleft, topÂπ∂Ê∏ÖÈô§transform
            bar.style.left = `${newLeft}px`;
            bar.style.top = `${newTop}px`;
            bar.style.transform = "none";
          };

          const onDragEnd = () => {
            if (!isDragging) return;
            isDragging = false;
            bar.classList.remove("dragging");

            document.removeEventListener("mousemove", onDragMove);
            document.removeEventListener("mouseup", onDragEnd);
            document.removeEventListener("touchmove", onDragMove);
            document.removeEventListener("touchend", onDragEnd);
          };

          bar.addEventListener("mousedown", onDragStart);
          bar.addEventListener("touchstart", onDragStart, { passive: true });
        }

        function applyLyricsSettings() {
          const bar = document.getElementById("floating-lyrics-bar");
          const toggleBtn = document.getElementById("toggle-lyrics-bar-btn");

          // Â∫îÁî®Ê†∑Âºè
          bar.style.fontSize = `${lyricsBarSettings.fontSize}px`;
          bar.style.color = lyricsBarSettings.fontColor;
          bar.style.backgroundColor = `rgba(0, 0, 0, ${lyricsBarSettings.bgOpacity / 100})`;

          // Êõ¥Êñ∞ËÆæÁΩÆÊ®°ÊÄÅÊ°ÜÈáåÁöÑÊéß‰ª∂ÂÄº
          document.getElementById("lyrics-font-size-slider").value =
            lyricsBarSettings.fontSize;
          document.getElementById("lyrics-font-size-value").textContent =
            `${lyricsBarSettings.fontSize}px`;
          document.getElementById("lyrics-bg-opacity-slider").value =
            lyricsBarSettings.bgOpacity;
          document.getElementById("lyrics-bg-opacity-value").textContent =
            `${lyricsBarSettings.bgOpacity}%`;
          document.getElementById("lyrics-font-color-picker").value =
            lyricsBarSettings.fontColor;

          // Êõ¥Êñ∞Êí≠ÊîæÂô®ÈáåÁöÑÂºÄÂÖ≥ÊåâÈíÆÁä∂ÊÄÅ
          if (toggleBtn) {
            toggleBtn.textContent = lyricsBarSettings.showOnClose
              ? "ÊÇ¨ÊµÆ"
              : "ÈöêËóè";
            toggleBtn.style.opacity = lyricsBarSettings.showOnClose
              ? "1"
              : "0.5";
          }
        }

        /**
         * Ëé∑ÂèñÂπ∂Ê†ºÂºèÂåñ„Äê‰∏éÂΩìÂâçËÅäÂ§©Áõ∏ÂÖ≥„ÄëÁöÑÁ∫¶ÂÆöÔºåÁîüÊàêÁªôAIÁúãÁöÑ‰∏ä‰∏ãÊñá
         * @param {string} chatId - ÂΩìÂâçÊ≠£Âú®ËÅäÂ§©ÁöÑËßíËâ≤ID
         * @returns {Promise<string>} Ê†ºÂºèÂåñÂêéÁöÑÁ∫¶ÂÆö‰ø°ÊÅØÂ≠óÁ¨¶‰∏≤
         */
        async function getCountdownContext(chatId) {
          // 1. ‰ªéÊï∞ÊçÆÂ∫ì‰∏≠ÊâæÂá∫ÊâÄÊúâ‚ÄúÁ∫¶ÂÆö‚ÄùÁ±ªÂûãÔºåÂπ∂‰∏îÁõÆÊ†áÊó•ÊúüËøòÊ≤°Âà∞ÁöÑËÆ∞ÂΩï
          const activeCountdowns = await db.memories
            .where("type")
            .equals("countdown")
            .filter(
              (item) =>
                item.targetDate > Date.now() &&
                // ÂÆÉÁé∞Âú®Âè™‰ºöÊü•Êâæ‰∏§ÁßçÁ∫¶ÂÆöÔºö
                // 1. chatId ÂíåÂΩìÂâçËÅäÂ§©ËßíËâ≤IDÂåπÈÖçÁöÑ (AIËá™Â∑±ÂàõÂª∫ÁöÑ)
                // 2. chatId ‰∏∫Á©∫ÁöÑ (‰Ω†Ôºå‰πüÂ∞±ÊòØÁî®Êà∑ÂàõÂª∫ÁöÑÂÖ®Â±ÄÁ∫¶ÂÆö)
                (item.chatId === chatId || item.chatId === null),
            )
            .toArray();

          // Â¶ÇÊûúÊ≤°Êúâ‰∏éÂΩìÂâçËßíËâ≤Áõ∏ÂÖ≥ÁöÑÁ∫¶ÂÆöÔºåÂ∞±ÂëäËØâAI‚ÄúÁõÆÂâçÊ≤°Êúâ‚Äù
          if (activeCountdowns.length === 0) {
            return "\n- **ËøëÊúüÁ∫¶ÂÆö**: ÁõÆÂâçÊ≤°ÊúâÁâπÂà´ÁöÑÁ∫¶ÂÆö„ÄÇ";
          }

          // 2. ÂêéÁª≠ÁöÑÊï¥ÁêÜÊä•ÂëäÈÄªËæë‰øùÊåÅ‰∏çÂèò
          let context = "\n# ËøëÊúüÁ∫¶ÂÆö‰∏éÂÄíËÆ°Êó∂ (ÈáçË¶ÅÂèÇËÄÉ‰ø°ÊÅØ)\n";
          const now = Date.now();

          activeCountdowns.forEach((item) => {
            const diff = item.targetDate - now;
            const diffDays = Math.floor(diff / (1000 * 60 * 60 * 24));
            const diffHours = Math.floor(diff / (1000 * 60 * 60));

            let timeText;
            if (diffDays > 1) {
              timeText = `ËøòÊúâ ${diffDays} Â§©`;
            } else if (diffHours > 0) {
              timeText = `ËøòÊúâ ${diffHours} Â∞èÊó∂`;
            } else {
              timeText = "Â∞±ÊòØÁé∞Âú®ÔºÅ";
            }

            context += `- **${item.description}**: ${timeText} (ÁõÆÊ†á: ${new Date(item.targetDate).toLocaleString()})\n`;
          });

          return context;
        }

        // ‚ÄúÊü•ËßíËâ≤ÊâãÊú∫‚ÄùÂäüËÉΩÁöÑÊâÄÊúâÊ†∏ÂøÉÂáΩÊï∞

        /**
         * ÂÖ•Âè£ÔºöÊâìÂºÄËßíËâ≤ÈÄâÊã©ÁïåÈù¢
         */
        async function openCharacterSelectionScreen() {
          await renderCharacterSelectionScreen();
          showScreen("character-selection-screen");
        }

        /**
         * Ê∏≤ÊüìËßíËâ≤ÈÄâÊã©ÂàóË°®
         */
        async function renderCharacterSelectionScreen() {
          const listEl = document.getElementById("character-selection-list");
          listEl.innerHTML = "";
          const characters = Object.values(state.chats).filter(
            (chat) => !chat.isGroup,
          );

          if (characters.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ËøòÊ≤°ÊúâÂèØ‰ª•Êü•ÁúãÁöÑËßíËâ≤</p>';
            return;
          }

          characters.forEach((char) => {
            const item = document.createElement("div");
            item.className = "character-select-item";
            item.dataset.chatId = char.id;
            item.innerHTML = `
			            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
			            <span class="name">${char.name}</span>
			        `;
            listEl.appendChild(item);
          });
        }
        /**
         * Â∞ÜÊåáÂÆöÁöÑAppÂÜÖÂ£ÅÁ∫∏Â∫îÁî®Âà∞ËßíËâ≤ÊâãÊú∫Â±èÂπï
         */
        function applyCharPhoneAppWallpaper() {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];
          const innerScreen = document.querySelector(
            ".character-phone-inner-screen",
          );
          if (!innerScreen || !chat) return;

          const appWallpaperUrl = chat.characterPhoneData.appWallpaper;

          if (appWallpaperUrl) {
            innerScreen.style.backgroundImage = `url(${appWallpaperUrl})`;
            innerScreen.classList.add("has-app-wallpaper");
          } else {
            innerScreen.style.backgroundImage = "none";
            innerScreen.classList.remove("has-app-wallpaper");
          }
        }

        /**
         * Â§ÑÁêÜËßíËâ≤ÊâãÊú∫AppÂÜÖÂ£ÅÁ∫∏ÁöÑÊõ¥Êç¢ÂíåÁßªÈô§
         * @param {string} newUrl - Êñ∞ÁöÑÂ£ÅÁ∫∏URLÔºåÂ¶ÇÊûú‰∏∫Á©∫Â≠óÁ¨¶‰∏≤ÂàôË°®Á§∫ÁßªÈô§
         */
        async function handleCharPhoneAppWallpaperChange(newUrl) {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];
          if (!chat) return;

          chat.characterPhoneData.appWallpaper = newUrl;
          await db.chats.put(chat);

          // Á´ãÂç≥Â∫îÁî®Â£ÅÁ∫∏
          applyCharPhoneAppWallpaper();

          // Âà∑Êñ∞ËÆæÁΩÆÈ°µÈù¢ÁöÑÈ¢ÑËßà
          renderCharPhoneAppearanceScreen();

          alert(newUrl ? "App ÂÜÖÂ£ÅÁ∫∏Â∑≤Êõ¥Êñ∞ÔºÅ" : "App ÂÜÖÂ£ÅÁ∫∏Â∑≤ÁßªÈô§ÔºÅ");
        }

        function openCharacterPhone(chatId) {
          activeCharacterPhoneId = chatId;
          const chat = state.chats[chatId];
          if (!chat) return;

          document.getElementById("character-phone-owner-name").textContent =
            `${chat.name}ÁöÑÊâãÊú∫`;

          const phoneHomeScreen = document.getElementById(
            "character-phone-screen",
          );
          const wallpaperUrl = chat.characterPhoneData.wallpaper;
          const isDarkMode = document
            .getElementById("phone-screen")
            .classList.contains("dark-mode");

          if (wallpaperUrl) {
            phoneHomeScreen.style.backgroundImage = `url(${wallpaperUrl})`;
            phoneHomeScreen.style.backgroundColor = "transparent";
            phoneHomeScreen.style.backgroundSize = "cover";
            phoneHomeScreen.style.backgroundPosition = "center";
          } else {
            phoneHomeScreen.style.backgroundImage = "none";
            phoneHomeScreen.style.backgroundColor = isDarkMode
              ? "#000000"
              : "#f0f2f5";
          }

          // --- Ê∏≤ÊüìÂ∞èÁªÑ‰ª∂ÂõæÁâá ---
          const widgets = chat.characterPhoneData.widgets || {};
          document.getElementById("char-phone-widget-img-1").src =
            widgets.widget1_url || "";
          document.getElementById("char-phone-widget-img-2").src =
            widgets.widget2_url || "";

          renderCharacterAppGrid();

          showScreen("character-phone-container");
          showCharacterPhonePage("character-phone-screen");
          applyCharPhoneAppWallpaper();
        }

        function renderCharacterAppGrid() {
          const gridEl = document.getElementById("character-app-grid");
          gridEl.innerHTML = "";
          if (!activeCharacterPhoneId) return;

          const chat = state.chats[activeCharacterPhoneId];
          const customIcons = chat.characterPhoneData.appIcons || {};

          CHAR_PHONE_APPS.forEach((app) => {
            const iconEl = document.createElement("div");
            iconEl.className = "app-icon";

            const customIconUrl = customIcons[app.id];

            let iconBgStyle =
              "display: flex; justify-content: center; align-items: center; padding: 12px;";
            let iconHtml;

            if (customIconUrl) {
              // Â¶ÇÊûúÊúâËá™ÂÆö‰πâÂõæÊ†áURL...
              // 1. Ë¶ÜÁõñÊéâ .icon-bg ÁöÑÊ†∑ÂºèÔºåÁßªÈô§ÂÜÖËæπË∑ùÂíåËÉåÊôØËâ≤
              iconBgStyle = "padding: 0; background-color: transparent;";
              // 2. iconHtml Áõ¥Êé•ÂèòÊàê‰∏Ä‰∏™Â∏¶ÊúâÂúÜËßíÁöÑÂõæÁâá
              iconHtml = `<img src="${customIconUrl}" style="width:100%; height:100%; object-fit:cover; border-radius: 18px;">`;
            } else {
              // Âê¶ÂàôÔºå‰ΩøÁî®ÈªòËÆ§ÁöÑSVG
              iconHtml = app.svg;
            }

            // --- ‰øÆÊîπÁªìÊùü ---

            iconEl.innerHTML = `
			            <div class="icon-bg" style="${iconBgStyle}">
			                ${iconHtml}
			            </div>
			            <span class="label">${app.name}</span>
			        `;

            // ÂêéÁª≠ÁöÑ‰∫ã‰ª∂ÁõëÂê¨‰ª£Á†Å‰øùÊåÅ‰∏çÂèò
            iconEl.addEventListener("click", () => {
              if (app.id === "appearance") {
                openCharPhoneAppearanceSettings();
              } else {
                switch (app.id) {
                  case "chat":
                    renderCharacterChatList();
                    break;
                  case "cart":
                    renderCharacterShoppingCart();
                    break;
                  case "memos":
                    renderCharacterMemos();
                    break;
                  case "browser":
                    renderCharacterBrowser();
                    break;
                  case "album":
                    renderCharacterPhotoAlbum();
                    break;
                  case "bank":
                    renderCharacterBank();
                    break;
                  case "trajectory":
                    renderCharacterTrajectory();
                    break;
                  case "app_usage":
                    renderCharacterAppUsage();
                    break;
                  case "diary":
                    renderCharacterDiary();
                    break;
                }
                showCharacterPhonePage(app.screen);
              }
            });
            gridEl.appendChild(iconEl);
          });
        }

        /**
         * ÊâìÂºÄÁîüÊàêËÅäÂ§©ÂØπË±°ÁöÑÈÄâÊã©ÂºπÁ™ó
         */
        function openChatGenerationModal() {
          const listEl = document.getElementById("chat-gen-list");
          listEl.innerHTML = "";

          if (!activeCharacterPhoneId) return;
          const currentChat = state.chats[activeCharacterPhoneId];

          // 1. ÈáçÁΩÆ UI Áä∂ÊÄÅ
          const randomCheckbox = document.getElementById(
            "chat-gen-random-checkbox",
          );
          randomCheckbox.checked = true; // ÈªòËÆ§ÈöèÊú∫
          listEl.style.opacity = "0.5";
          listEl.style.pointerEvents = "none";

          // 2. Êî∂ÈõÜÊâÄÊúâÂèØÈÄâÈ°π (NPC + ÂÖ∂‰ªñ‰∏ªËßí)
          const options = [];

          // A. ÂΩìÂâçËßíËâ≤ÁöÑ NPC Â∫ì
          if (currentChat.npcLibrary) {
            currentChat.npcLibrary.forEach((npc) => {
              options.push({
                type: "NPC",
                name: npc.name,
                persona: npc.persona,
                avatar: npc.avatar || defaultGroupMemberAvatar,
              });
            });
          }

          // B. ÂÖ∂‰ªñ‰∏ªËßí (state.chats ÈáåÁöÑÂçïËÅäËßíËâ≤ÔºåÊéíÈô§Ëá™Â∑±)
          Object.values(state.chats).forEach((otherChat) => {
            if (!otherChat.isGroup && otherChat.id !== currentChat.id) {
              options.push({
                type: "ËßíËâ≤",
                name: otherChat.name,
                persona: otherChat.settings.aiPersona,
                avatar: otherChat.settings.aiAvatar || defaultAvatar,
              });
            }
          });

          if (options.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; padding:20px; color:#888;">ÊöÇÊó†ÂèØÈÄâËßíËâ≤/NPCÔºåËØ∑‰ΩøÁî®ÈöèÊú∫Ê®°Âºè„ÄÇ</p>';
          } else {
            options.forEach((opt) => {
              const item = document.createElement("div");
              item.className = "contact-picker-item"; // Â§çÁî®Áé∞ÊúâÁöÑÊ†∑Âºè
              // Â∞Ü‰∫∫ËÆæÁªèËøáÁÆÄÂçïÂ§ÑÁêÜÂ≠òÂÖ• dataset (ÈÅøÂÖçÂ§™ÈïøÊàñÊúâÁâπÊÆäÂ≠óÁ¨¶)
              const safePersona = (opt.persona || "").replace(/"/g, "&quot;");

              item.innerHTML = `
			                                <input type="checkbox" data-name="${opt.name}" data-persona="${safePersona}" style="margin-right: 10px;">
			                                <img src="${opt.avatar}" class="avatar">
			                                <div style="display:flex; flex-direction:column;">
			                                    <span class="name">${opt.name}</span>
			                                    <span style="font-size:12px; color:#888;">${opt.type}</span>
			                                </div>
			                            `;

              // ÁÇπÂáªÊï¥Ë°åËß¶Âèë checkbox
              item.addEventListener("click", (e) => {
                if (e.target.tagName !== "INPUT") {
                  const cb = item.querySelector("input");
                  cb.checked = !cb.checked;
                }
              });

              listEl.appendChild(item);
            });
          }

          document
            .getElementById("chat-gen-selector-modal")
            .classList.add("visible");
        }

        /**
         * ‰∏∫‚ÄúÊü•ÊâãÊú∫‚ÄùÂäüËÉΩÂçïÁã¨ÁîüÊàêÊüê‰∏ÄÈ°πÊï∞ÊçÆÁöÑÈÄöÁî®ÂáΩÊï∞
         * @param {string} dataType - Ë¶ÅÁîüÊàêÁöÑÊï∞ÊçÆÁ±ªÂûã (‰æãÂ¶Ç: 'diary', 'chats', 'shoppingCart')
         */
        async function generateCharacterPhoneDataSegment(
          dataType,
          specificTargets = null,
        ) {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];
          if (!chat) return;

          const dataTypeMap = {
            chats: {
              description: `2Âà∞5ÊÆµ‰Ω†‰∏é„Äê‰∏çÂêåÁöÑ„ÄëNPCÊúãÂèã‰ª¨ÁöÑ„ÄêÂÖ®Êñ∞ÁöÑÊàñÊé•Áª≠‰∏äÊñáÁöÑ„ÄëËÅäÂ§©ËÆ∞ÂΩï„ÄÇ`,
              jsonStructure: `"chats": [\n    {\n      "contactName": "„ÄêNPCÊúãÂèãAÁöÑÂêçÂ≠ó„Äë",\n      "messages": [\n        {"sender": "„ÄêËÅîÁ≥ª‰∫∫ÂêçA„Äë", "content": "Ê∂àÊÅØÂÜÖÂÆπ1..."},\n        {"sender": "${chat.name}", "content": "‰Ω†ÁöÑÂõûÂ§ç1..."}\n      ]\n    },\n    {\n      "contactName": "„ÄêNPCÊúãÂèãBÁöÑÂêçÂ≠ó„Äë",\n      "messages": [\n        {"sender": "„ÄêËÅîÁ≥ª‰∫∫ÂêçB„Äë", "content": "Ê∂àÊÅØÂÜÖÂÆπ1..."},\n        {"sender": "${chat.name}", "content": "‰Ω†ÁöÑÂõûÂ§ç1..."}\n      ]\n    }\n  ]`,
            },
            shoppingCart: {
              description: "3Âà∞5‰ª∂‰Ω†ÊúÄËøëÂä†ÂÖ•Ë¥≠Áâ©ËΩ¶ÁöÑÊñ∞ÂïÜÂìÅ„ÄÇ",
              jsonStructure: `"shoppingCart": [\n    {"name": "ÂïÜÂìÅÂêç1", "price": 123.45, "store": "Â∫óÈì∫Âêç"},\n    {"name": "ÂïÜÂìÅÂêç2", "price": 67.89, "store": "Â∫óÈì∫Âêç"}\n  ]`,
            },
            memos: {
              description: "2Âà∞3ÁØá‰Ω†Êñ∞ÂÜôÁöÑÁÆÄÁü≠Â§áÂøòÂΩï„ÄÇ",
              jsonStructure: `"memos": [\n    {"title": "Â§áÂøòÂΩïÊ†áÈ¢ò1", "content": "Â§áÂøòÂΩïËØ¶ÁªÜÂÜÖÂÆπ1..."},\n    {"title": "Â§áÂøòÂΩïÊ†áÈ¢ò2", "content": "Â§áÂøòÂΩïËØ¶ÁªÜÂÜÖÂÆπ2..."}\n  ]`,
            },
            browserHistory: {
              description: "2Âà∞3Êù°‰Ω†ÊúÄËøëÁöÑÊµèËßàÂô®ÊêúÁ¥¢ËÆ∞ÂΩïÊàñÊµèËßàÁöÑÊñáÁ´†„ÄÇ",
              jsonStructure: `"browserHistory": [\n    {"query": "ÊêúÁ¥¢Ê†áÈ¢ò1", "result": "Ê®°ÊãüÊñáÁ´†ÂÜÖÂÆπ1..."},\n    {"query": "ÊêúÁ¥¢Ê†áÈ¢ò2", "result": "Ê®°ÊãüÊñáÁ´†ÂÜÖÂÆπ2..."}\n  ]`,
            },
            photoAlbum: {
              description: "2Âà∞3Âº†‰Ω†‚ÄúÊãçÊëÑ‚ÄùÁöÑÊñ∞ÁÖßÁâáÁöÑÊñáÂ≠óÊèèËø∞ÔºàÁî®‰∫éÊñáÂ≠óÁîüÂõæÔºâ„ÄÇ",
              jsonStructure: `"photoAlbum": [\n    {"hiddenContent": "ÂØπÊñ∞ÁÖßÁâáÁîªÈù¢1ÁöÑËØ¶ÁªÜÊñáÂ≠óÊèèËø∞..."},\n    {"hiddenContent": "ÂØπÊñ∞ÁÖßÁâáÁîªÈù¢2ÁöÑËØ¶ÁªÜÊñáÂ≠óÊèèËø∞..."}\n  ]`,
            },
            bank: {
              description: "3Âà∞5Êù°‰Ω†ÊúÄËøëÁöÑÈì∂Ë°å‰∫§ÊòìËÆ∞ÂΩïÔºàÊî∂ÂÖ•ÊàñÊîØÂá∫Ôºâ„ÄÇ",
              jsonStructure: `"bank": {\n    "transactions": [\n      {"type": "Êî∂ÂÖ•ÊàñÊîØÂá∫", "amount": 123.45, "description": "‰∫§ÊòìÊèèËø∞1"},\n      {"type": "Êî∂ÂÖ•ÊàñÊîØÂá∫", "amount": 67.89, "description": "‰∫§ÊòìÊèèËø∞2"}\n    ]\n  }`,
            },
            trajectory: {
              description: "2Âà∞3Êù°‰Ω†ÊúÄËøëÁöÑË°åÂä®ËΩ®ËøπËÆ∞ÂΩï„ÄÇ",
              jsonStructure: `"trajectory": [\n    {"time": "Êó∂Èó¥ÊÆµ1", "location": "Âú∞ÁÇπ1", "activity": "Âπ≤‰∫Ü‰ªÄ‰πà‰∫ã1"},\n    {"time": "Êó∂Èó¥ÊÆµ2", "location": "Âú∞ÁÇπ2", "activity": "Âπ≤‰∫Ü‰ªÄ‰πà‰∫ã2"}\n  ]`,
            },
            appUsage: {
              description: "3Âà∞5Êù°‰Ω†ÊúÄËøëÁöÑÂ∫îÁî®‰ΩøÁî®ËÆ∞ÂΩï„ÄÇ",
              jsonStructure: `"appUsage": [\n    {"appName": "Â∫îÁî®Âêç1", "duration": "‰ΩøÁî®Êó∂Èïø1"},\n    {"appName": "Â∫îÁî®Âêç2", "duration": "‰ΩøÁî®Êó∂Èïø2"}\n  ]`,
            },
            diary: {
              description: `‰∏ÄÁØáÂÖ®Êñ∞ÁöÑÊó•ËÆ∞„ÄÇ`,
              jsonStructure: `"diary": [\n    {"timestamp": ${Date.now()}, "content": "„ÄêÁî®MarkdownËØ≠Ê≥ïÂÜô‰∏ÄÁØáÁ¨¶Âêà‰∫∫ËÆæÂíåÊÉÖÊôØÁöÑÊñ∞Êó•ËÆ∞„Äë"}\n  ]`,
            },
          };

          const dataTypeInfo = dataTypeMap[dataType];
          if (!dataTypeInfo) {
            console.error("ËØ∑Ê±Ç‰∫ÜÊó†ÊïàÁöÑÊï∞ÊçÆÁîüÊàêÁ±ªÂûã:", dataType);
            return;
          }

          // Âä®ÊÄÅ‰øÆÊîπdataTypeInfoÔºå‰ª•ÈÄÇÂ∫î‰∏çÂêåÊÉÖÂÜµ
          let finalDataTypeInfo = { ...dataTypeInfo };

          // --- ÁâπÊÆäÂ§ÑÁêÜÔºöÊåáÂÆö‰∫ÜËÅäÂ§©ÂØπË±° ---
          // Âè™ÊúâÂΩì dataType ÊòØ 'chats' ‰∏î specificTargets Â≠òÂú®Êó∂ÊâçËß¶Âèë
          let specificPromptInject = "";

          if (
            dataType === "chats" &&
            specificTargets &&
            specificTargets.length > 0
          ) {
            // 1. ‰øÆÊîπ‰ªªÂä°ÊèèËø∞
            const targetNames = specificTargets.map((t) => t.name).join("„ÄÅ");
            finalDataTypeInfo.description = `‰Ω†‰∏éÊåáÂÆöËÅîÁ≥ª‰∫∫„Äê${targetNames}„ÄëÁöÑËÅäÂ§©ËÆ∞ÂΩï„ÄÇ`;

            // 2. ÊûÑÂª∫Âº∫Âà∂ÊÄß Prompt ‰∏ä‰∏ãÊñá
            specificPromptInject = `
                            # „Äê„Äê„ÄêÊåáÂÆöÁîüÊàêÊåá‰ª§„Äë„Äë„Äë
                            Áî®Êà∑ÊåáÂÆö‰∫Ü‰Ω†ÂøÖÈ°ªÁîüÊàê‰∏é‰ª•‰∏ãËßíËâ≤ÁöÑÂØπËØù„ÄÇ‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏∫ÂàóË°®‰∏≠ÁöÑ**ÊØè‰∏Ä‰Ωç**ËßíËâ≤ÁîüÊàê‰∏ÄÊÆµÁã¨Á´ãÁöÑÂØπËØùÔºå‰∏çËÉΩÈÅóÊºèÔºå‰πü‰∏çËÉΩÁºñÈÄ†ÂàóË°®‰ª•Â§ñÁöÑ‰∫∫„ÄÇ

                            # ÊåáÂÆöËßíËâ≤ÂàóË°®
                            ${specificTargets.map((t) => `- **${t.name}**: ${t.persona}`).join("\n")}

                            # Ê†ºÂºèË¶ÅÊ±Ç
                            ËØ∑Âú®ËøîÂõûÁöÑ JSON "chats" Êï∞ÁªÑ‰∏≠Ôºå‰∏•Ê†ºÊåâÁÖß‰∏äËø∞ÊåáÂÆöÁöÑ "contactName" ÁîüÊàêÂØπÂ∫îÁöÑËÅäÂ§©ËÆ∞ÂΩï„ÄÇ
                        `;
            // 3. ‰øÆÊîπ JSON ÁªìÊûÑÊèêÁ§∫ÔºåÂºïÂØºAIÁîüÊàêÊ≠£Á°ÆÁöÑÊï∞Èáè
            finalDataTypeInfo.jsonStructure =
              `"chats": [\n` +
              specificTargets
                .map(
                  (t) =>
                    `    { "contactName": "${t.name}", "messages": [\n        {"sender": "${t.name}", "content": "Ê∂àÊÅØÂÜÖÂÆπ1..."},\n        {"sender": "${chat.name}", "content": "‰Ω†ÁöÑÂõûÂ§ç1..."}\n] }`,
                )
                .join(",\n") +
              `\n  ]`;
          }

          if (dataType === "bank") {
            const hasExistingTransactions =
              chat.characterPhoneData?.bank?.transactions?.length > 0;

            if (!hasExistingTransactions) {
              // Â¶ÇÊûúÊòØÁ¨¨‰∏ÄÊ¨°ÁîüÊàêÔºåÂ∞±‰øÆÊîπÊåá‰ª§ÔºåË¶ÅÊ±ÇAIÊèê‰æõÂàùÂßã‰ΩôÈ¢ù
              finalDataTypeInfo.description =
                "‰∏Ä‰∏™Á¨¶Âêà‰Ω†‰∫∫ËÆæÁöÑ„ÄêÂàùÂßãÈì∂Ë°å‰ΩôÈ¢ù„ÄëÔºå‰ª•Âèä3Âà∞5Êù°ÂàùÂßã‰∫§ÊòìËÆ∞ÂΩï„ÄÇ";
              finalDataTypeInfo.jsonStructure = `"bank": {\n    "balance": 12345.67,\n    "transactions": [\n      {"type": "Êî∂ÂÖ•ÊàñÊîØÂá∫", "amount": 123.45, "description": "‰∫§ÊòìÊèèËø∞1"}\n    ]\n  }`;
            } else {
              // Â¶ÇÊûúÊòØÂêéÁª≠ÁîüÊàêÔºåÂ∞±ÂëäËØâAIÂΩìÂâç‰ΩôÈ¢ùÔºåÂè™Ë¶ÅÊ±ÇÊñ∞‰∫§Êòì
              const currentBalance = (
                chat.characterPhoneData.bank.balance || 0
              ).toFixed(2);
              finalDataTypeInfo.description = `3Âà∞5Êù°„ÄêÂÖ®Êñ∞ÁöÑ„ÄëÈì∂Ë°å‰∫§ÊòìËÆ∞ÂΩïÔºàÊî∂ÂÖ•ÊàñÊîØÂá∫Ôºâ„ÄÇ„ÄêÊèêÁ§∫Ôºö‰Ω†ÂΩìÂâçÁöÑ‰ΩôÈ¢ùÊòØ ${currentBalance} ÂÖÉÔºåËØ∑Âú®Ê≠§Âü∫Á°Ä‰∏äÁîüÊàêÂêàÁêÜÁöÑ‰∫§Êòì„Äë`;
              // Ê≠§Êó∂ÁöÑJSONÁªìÊûÑ‰∏çÈúÄË¶ÅbalanceÂ≠óÊÆµ
              finalDataTypeInfo.jsonStructure = `"bank": {\n    "transactions": [\n      {"type": "Êî∂ÂÖ•ÊàñÊîØÂá∫", "amount": 123.45, "description": "‰∫§ÊòìÊèèËø∞1"}\n    ]\n  }`;
            }
          }

          showGenerationOverlay("Ê≠£Âú®ÂêåÊ≠•TaÁöÑÊâãÊú∫Êï∞ÊçÆ...");

          try {
            const userNickname = state.qzoneSettings.nickname || "Me";
            const persona = (chat.settings.aiPersona || "").substring(0, 4000);
            // updated by lrq 251028 ‰øÆÊîπÊúÄÂ§ßËÆ∞ÂøÜÊù°Êï∞
            const maxMemory = chat.settings.maxMemory || 20;
            const recentHistory = chat.history
              .slice(-maxMemory)
              .map((msg) => {
                const sender = msg.role === "user" ? userNickname : chat.name;
                return `${sender}: ${msg.content}`;
              })
              .join("\n");

            // added by lrq 251028 Ê∑ªÂä†ËÆ∞ÂøÜ‰∫íÈÄöÁöÑËÅäÂ§©ËÆ∞ÂΩï‰Ωú‰∏∫ÂèÇËÄÉ
            let linkedMemoryContext = "";
            if (
              chat.settings.linkedMemories &&
              chat.settings.linkedMemories.length > 0
            ) {
              const contextPromises = chat.settings.linkedMemories.map(
                async (link) => {
                  const linkedChat = state.chats[link.chatId];
                  if (!linkedChat) return "";

                  const freshLinkedChat = await db.chats.get(link.chatId);
                  if (!freshLinkedChat) return "";

                  const recentHistory = freshLinkedChat.history
                    .filter((msg) => !msg.isHidden)
                    .slice(-link.depth);

                  if (recentHistory.length === 0) return "";

                  const formattedMessages = recentHistory
                    .map(
                      (msg) =>
                        `  - ${formatMessageForContext(msg, freshLinkedChat)}`,
                    )
                    .join("\n");

                  return `\n## ÈôÑÂä†‰∏ä‰∏ãÊñáÔºöÊù•Ëá™‰∏é‚Äú${linkedChat.name}‚ÄùÁöÑÊúÄËøëÂØπËØùÂÜÖÂÆπ (‰ªÖ‰Ω†ÂèØËßÅ)\n${formattedMessages}`;
                },
              );

              const allContexts = await Promise.all(contextPromises);
              linkedMemoryContext = allContexts.filter(Boolean).join("\n");
            }

            let worldBookContext = "";
            if (
              chat.settings.linkedWorldBookIds &&
              chat.settings.linkedWorldBookIds.length > 0
            ) {
              worldBookContext =
                "--- ‰∏ñÁïåËßÇËÆæÂÆö (ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆà) ---\n" +
                chat.settings.linkedWorldBookIds
                  .map((id) => {
                    const book = state.worldBooks.find((b) => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : "";
                  })
                  .join("\n\n");
            }

            const npcLibrary = chat.npcLibrary || [];
            let npcContext = "";
            // Â¶ÇÊûúÊúâÊåáÂÆöÂØπË±°ÔºåÂ∞±„Äê‰∏ç‰ΩøÁî®„ÄëÈªòËÆ§ÁöÑ NPC ÈöèÊú∫ÂàóË°®ÔºåÈÅøÂÖçÊ∑∑Ê∑Ü
            if (!specificPromptInject) {
              // Âè™ÊúâÂú®ÈöèÊú∫Ê®°ÂºèÔºàspecificPromptInject ‰∏∫Á©∫ÔºâÊó∂ÔºåÊâçÊèê‰æõÈªòËÆ§ NPC ÂàóË°®‰æõ AI ÈöèÊú∫ÈÄâ
              if (npcLibrary.length > 0) {
                npcContext =
                  "# ‰Ω†ÁöÑ‰∏ìÂ±ûNPCÂ•ΩÂèãÂàóË°® (‰Ω†ÂøÖÈ°ª‰ªé‰∏≠ÈöèÊú∫ÈÄâÊã©2-3‰ΩçÊúãÂèãËøõË°åÂØπËØù)\n" +
                  npcLibrary
                    .map((npc) => `- **${npc.name}**: ${npc.persona}`)
                    .join("\n");
              } else {
                npcContext =
                  "# ‰Ω†ÁöÑ‰∏ìÂ±ûNPCÂ•ΩÂèãÂàóË°®\n(‰Ω†ÂΩìÂâçÊ≤°Êúâ‰∏ìÂ±ûNPCÔºåËØ∑ËôöÊûÑ2-3‰∏™ÊôÆÈÄöÊúãÂèãÂπ∂ÁîüÊàêÂØπËØù)";
              }
            }

            let npcChatHistoryContext = "";
            const existingNpcChats = Object.entries(
              chat.characterPhoneData.chats || {},
            ).filter(
              ([name, chatData]) =>
                chatData.history && chatData.history.length > 0,
            );
            if (existingNpcChats.length > 0) {
              npcChatHistoryContext +=
                "\n\n# Â∑≤ÊúâÁöÑËÅäÂ§©ËÆ∞ÂΩïÊëòË¶Å (ËØ∑Âú®Ê≠§Âü∫Á°Ä‰∏äÁªßÁª≠ÂØπËØù)\n";
              existingNpcChats.forEach(([contactName, chatData]) => {
                const recentMessages = chatData.history
                  .slice(-5)
                  .map((msg) => `  - ${msg.sender}: ${msg.content}`)
                  .join("\n");
                npcChatHistoryContext += `\n## ‰Ω†Âíå‚Äú${contactName}‚ÄùÁöÑÊúÄËøëÂØπËØù:\n${recentMessages}\n`;
              });
            }

            // ‰ΩøÁî®‰øÆÊîπÂêéÁöÑ finalDataTypeInfo Êù•ÊûÑÂª∫Prompt
            const prompt = `
                            # ‰ªªÂä°
                            ‰Ω†Áé∞Âú®ÊòØËßíËâ≤ "${chat.name}"„ÄÇËØ∑Ê†πÊçÆ‰Ω†ÁöÑ‰ø°ÊÅØÂíåÊúÄËøëÁöÑËÅäÂ§©ËÆ∞ÂΩïÔºå„ÄêÂè™ÁîüÊàê‰∏ÄÈ°π„Äë‰Ω†ÊâãÊú∫‰∏≠ÁöÑÊñ∞Êï∞ÊçÆ„ÄÇ
                            ÂÖ∑‰Ωì‰ªªÂä°ÊòØÔºöÁîüÊàê${finalDataTypeInfo.description}

                            # „Äê„Äê„ÄêÊÉÖÊôØ‰∏ÄËá¥ÊÄßÈìÅÂæã„Äë„Äë„Äë
                            ‰Ω†ÁîüÊàêÁöÑÊâÄÊúâÊï∞ÊçÆÔºàÂ∞§ÂÖ∂ÊòØ"trajectory"Ë°åÂä®ËΩ®ËøπÔºâ**ÂøÖÈ°ª**‰∏é‚ÄúÊúÄËøëËÅäÂ§©ËÆ∞ÂΩïÊëòË¶Å‚Äù‰∏≠ÊèêÂà∞ÁöÑÊúÄÊñ∞ÊÉÖÊôØ‰øùÊåÅÁªùÂØπ‰∏ÄËá¥„ÄÇ
                            ÂΩìÁîüÊàê "bank" Êï∞ÊçÆÊó∂Ôºå‰Ω†ÁöÑ‰∫§ÊòìËÆ∞ÂΩï„ÄêÁªùÂØπ‰∏çËÉΩ„ÄëÂåÖÂê´‰∏éÁî®Êà∑("${userNickname}")ÁöÑËΩ¨Ë¥¶ÊàñÊî∂Ê¨æ„ÄÇÊâÄÊúâ‰∫§ÊòìÈÉΩÂ∫îÊòØ‰Ω†‰∏éÂÖ∂‰ªñNPCÊàñÂïÜÂÆ∂ÁöÑ„ÄÇ
                            # „Äê„Äê„ÄêÁªùÂØπÁ¶ÅÊ≠¢‰∫ãÈ°π„Äë„Äë„Äë
                            Âú®ÁîüÊàê "chats" Êï∞ÊçÆÊó∂Ôºå**ÁªùÂØπ‰∏çÂÖÅËÆ∏**ËÆ©Áî®Êà∑Ôºà${userNickname}ÔºâÂá∫Áé∞Âú®‰Ω†‰∏éÂÖ∂‰ªñNPCÁöÑÂØπËØù‰∏≠„ÄÇ


                            # „Äê„Äê„ÄêÈáçË¶ÅÊåá‰ª§ÔºöÂÖ≥‰∫éËÅäÂ§©ËÆ∞ÂΩïÁîüÊàê„Äë„Äë„Äë
                            - ‰Ω†Ê≠£Âú®Âàõ‰Ωú‰∏ÄÊÆµÂØπËØù„ÄÇÊèê‰æõÁöÑËÅäÂ§©ËÆ∞ÂΩïÊòØ‰∏ä‰∏ãÊñáÔºå‰Ω†„ÄêÁªùÂØπ‰∏çËÉΩ„ÄëÈáçÂ§çÊàñÊîπÂÜôÂÖ∂‰∏≠ÁöÑ‰ªª‰ΩïÂÜÖÂÆπ„ÄÇ‰Ω†ÁöÑÁîüÊàêÂøÖÈ°ª‰ªé„ÄêÂÖ®Êñ∞ÁöÑ„ÄÅ‰∏ã‰∏ÄÊù°„ÄëÊ∂àÊÅØÂºÄÂßã„ÄÇ
                            - Â¶ÇÊûúÊåáÂÆö‰∫ÜÂØπËØùÂØπË±°Ôºå‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏∫ÂàóË°®‰∏≠ÁöÑ„ÄêÊØè‰∏Ä‰∏™NPC„ÄëÈÉΩÁîüÊàê‰∏ÄÊÆµ‰∏é‰Ω†Ôºà${chat.name}ÔºâÁöÑÂØπËØù„ÄÇ
                            - Â¶ÇÊûúÂàóË°®‰∏∫Á©∫Ôºå‰Ω†ÂèØ‰ª•ËôöÊûÑ2-3‰∏™ÊôÆÈÄöÊúãÂèãÂπ∂ÁîüÊàêÂØπËØù„ÄÇ
                            - ‰Ω†ÂøÖÈ°ª‰∏∫ÊØè‰∏™ËÅîÁ≥ª‰∫∫ÁîüÊàê‰∏ÄÊÆµ„ÄêËá≥Â∞ëÂåÖÂê´5Êù°Ê∂àÊÅØ„ÄëÁöÑÂØπËØù„ÄÇ
                            - ÂØπËØùÂÜÖÂÆπÂ∫îËØ•Ëá™ÁÑ∂ÊµÅÁïÖÔºåÂèØ‰ª•ÂåÖÂê´ËøûÁª≠ÂèëË®Ä„ÄÅË°®ÊÉÖÂåÖÂíåË°®ÊÉÖÁ¨¶Âè∑Á≠âÔºå‰ª•‰ΩìÁé∞ÁúüÂÆûÊÑü„ÄÇ
                            - ‰∏çË¶ÅÂè™ÁîüÊàê‰∏ÄÈóÆ‰∏ÄÁ≠îÁöÑÊú∫Ê¢∞ÂºèÂØπËØù„ÄÇ
                            -   **„Äê„Äê„ÄêÁªùÂØπÁ¶ÅÊ≠¢ÈáçÂ§çÈìÅÂæã„Äë„Äë„Äë**: ‰Ω†ÁîüÊàêÁöÑ "messages" Êï∞ÁªÑ‰∏≠Ôºå„ÄêÁªùÂØπ‰∏çËÉΩ„ÄëÂåÖÂê´ÊàëÊèê‰æõÁªô‰Ω†ÁöÑ‰∏ä‰∏ãÊñáÈáåÁöÑ‰ªª‰Ωï‰∏ÄÊù°Ê∂àÊÅØ„ÄÇ‰Ω†ÁöÑÁ¨¨‰∏ÄÊù°Ê∂àÊÅØÂøÖÈ°ªÊòØÂØπËØùÂéÜÂè≤‰∏≠ÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÁöÑ„Äê‰∏ã‰∏ÄÊù°„Äë„ÄÇ
                            # ‰Ω†ÁöÑ‰ø°ÊÅØ
                            - ‰Ω†ÁöÑÂêçÂ≠ó: ${chat.name}
                            - ‰Ω†ÁöÑ‰∫∫ËÆæ: ${persona}
                            ${worldBookContext}
                            # Âíå${userNickname}ÁöÑÊúÄËøëËÅäÂ§©ËÆ∞ÂΩïÊëòË¶Å
                            ${recentHistory}
                            ${linkedMemoryContext}
                            ${npcContext}
                            ${npcChatHistoryContext}

                            # JSONËæìÂá∫Ê†ºÂºè (ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆàÔºåÂè™ÂåÖÂê´‰Ω†Ë¢´Ë¶ÅÊ±ÇÁöÑÈÇ£‰∏™ÈîÆ)
                            {
                            ${finalDataTypeInfo.jsonStructure}
                            }
                            `;
            console.log("prompt:", prompt);
            const { proxyUrl, apiKey, model } = state.apiConfig;
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              prompt,
              [{ role: "user", content: prompt }],
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [{ role: "user", content: prompt }],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });

            if (!response.ok) {
              let errorMsg = `APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} - ${await response.text()}`;
              throw new Error(errorMsg);
            }

            const data = await response.json();
            const aiResponseContent = (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            ).replace(/^```json\s*|```$/g, "");

            const newData = JSON.parse(aiResponseContent);

            let phoneData = chat.characterPhoneData;
            phoneData.lastGenerated = Date.now();
            let updateSuccess = false;

            if (newData && newData[dataType]) {
              if (dataType === "bank" && newData.bank.transactions) {
                if (!phoneData.bank)
                  phoneData.bank = { balance: 0, transactions: [] };
                if (typeof phoneData.bank.balance !== "number")
                  phoneData.bank.balance = 0;
                (newData.bank.transactions || []).forEach((transaction) => {
                  const amount = parseFloat(transaction.amount);
                  if (!isNaN(amount)) {
                    if (transaction.type === "Income")
                      phoneData.bank.balance += amount;
                    else if (transaction.type === "Paid")
                      phoneData.bank.balance -= amount;
                  }
                });
                phoneData.bank.transactions.push(
                  ...(newData.bank.transactions || []),
                );
                if (typeof newData.bank.balance === "number") {
                  phoneData.bank.balance = newData.bank.balance;
                }
                updateSuccess = true;
              } else if (dataType === "chats" && newData.chats) {
                newData.chats.forEach((newChat) => {
                  if (!newChat.messages) return;
                  const contactName = newChat.contactName;
                  if (
                    phoneData.chats[contactName] &&
                    phoneData.chats[contactName].history
                  ) {
                    phoneData.chats[contactName].history.push(
                      ...newChat.messages,
                    );
                  } else {
                    phoneData.chats[contactName] = {
                      avatar: newChat.avatar,
                      history: newChat.messages,
                    };
                  }
                });
                updateSuccess = true;
              } else if (
                dataType === "appUsage" &&
                Array.isArray(newData.appUsage)
              ) {
                const usageMap = new Map();
                (phoneData.appUsage || []).forEach((item) => {
                  usageMap.set(
                    item.appName,
                    (usageMap.get(item.appName) || 0) +
                      parseDurationToMinutes(item.duration),
                  );
                });
                newData.appUsage.forEach((item) => {
                  usageMap.set(
                    item.appName,
                    (usageMap.get(item.appName) || 0) +
                      parseDurationToMinutes(item.duration),
                  );
                });
                const mergedUsage = [];
                for (const [appName, totalMinutes] of usageMap.entries()) {
                  mergedUsage.push({
                    appName: appName,
                    duration: formatMinutesToDuration(totalMinutes),
                  });
                }
                phoneData.appUsage = mergedUsage;
                updateSuccess = true;
              } else if (Array.isArray(phoneData[dataType])) {
                phoneData[dataType].push(...(newData[dataType] || []));
                updateSuccess = true;
              }
            }

            if (!updateSuccess) {
              throw new Error(
                `AIËøîÂõûÁöÑJSON‰∏≠Áº∫Â∞ë'${dataType}'Â≠óÊÆµÊàñÊ†ºÂºè‰∏çÊ≠£Á°Æ„ÄÇ`,
              );
            }

            await db.chats.put(chat);
            alert(
              `‚Äú${chat.name}‚ÄùÁöÑ${dataTypeMap[dataType].description.split("„ÄÇ")[0]}Â∑≤Êõ¥Êñ∞ÔºÅ`,
            );

            switch (dataType) {
              case "chats":
                renderCharacterChatList();
                break;
              case "shoppingCart":
                renderCharacterShoppingCart();
                break;
              case "memos":
                renderCharacterMemos();
                break;
              case "browserHistory":
                renderCharacterBrowser();
                break;
              case "photoAlbum":
                renderCharacterPhotoAlbum();
                break;
              case "bank":
                renderCharacterBank();
                break;
              case "trajectory":
                renderCharacterTrajectory();
                break;
              case "appUsage":
                renderCharacterAppUsage();
                break;
              case "diary":
                renderCharacterDiary();
                break;
            }
          } catch (error) {
            console.error(`ÁîüÊàêËßíËâ≤ÊâãÊú∫Êï∞ÊçÆ(${dataType})Â§±Ë¥•:`, error);
            await showCustomAlert(
              "ÁîüÊàêÂ§±Ë¥•",
              `ÂèëÁîü‰∫Ü‰∏Ä‰∏™ÈîôËØØÔºö\n\n${error.message}`,
            );
          } finally {
            document
              .getElementById("generation-overlay")
              .classList.remove("visible");
          }
        }

        /**
         * Â§ÑÁêÜ‚ÄúÊü•ÊâãÊú∫‚ÄùÂêÑ‰∏™APPÈ°µÈù¢‚ÄúÂÖ®ÈÉ®Âà†Èô§‚ÄùÂäüËÉΩÁöÑÈÄöÁî®ÂáΩÊï∞
         * @param {string} dataType - Ë¶ÅÊ∏ÖÁ©∫ÁöÑÊï∞ÊçÆÁ±ªÂûãÔºå‰æãÂ¶Ç 'shoppingCart', 'memos', 'bank.transactions'
         */
        async function handleClearCharacterDataSegment(dataType) {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];
          if (!chat) return;

          // ‰∏∫‰∏çÂêåÊï∞ÊçÆÁ±ªÂûãËÆæÁΩÆÊõ¥‰∫∫ÊÄßÂåñÁöÑÊèêÁ§∫ÊñáÊú¨
          const dataTypeMap = {
            chats: { name: "NPCËÅäÂ§©ËÆ∞ÂΩï", dataKey: "chats" },
            shoppingCart: { name: "Shopping Cart", dataKey: "shoppingCart" },
            memos: { name: "Memo", dataKey: "memos" },
            browserHistory: { name: "ÊµèËßàÂô®ÂéÜÂè≤", dataKey: "browserHistory" },
            photoAlbum: { name: "Albums", dataKey: "photoAlbum" },
            "bank.transactions": { name: "‰∫§ÊòìËÆ∞ÂΩï", dataKey: "bank" },
            trajectory: { name: "Journey", dataKey: "trajectory" },
            appUsage: { name: "App Usage", dataKey: "appUsage" },
            diary: { name: "Diary", dataKey: "diary" },
          };

          const info = dataTypeMap[dataType];
          if (!info) {
            console.error("Êú™Áü•ÁöÑÊ∏ÖÁ©∫Êï∞ÊçÆÁ±ªÂûã:", dataType);
            return;
          }

          // ÂºπÂá∫Á°ÆËÆ§Ê°Ü
          const confirmed = await showCustomConfirm(
            `Á°ÆËÆ§Ê∏ÖÁ©∫`,
            `Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫‚Äú${chat.name}‚ÄùÊâãÊú∫ÈáåÁöÑÊâÄÊúâ„Äê${info.name}„ÄëÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
            { confirmButtonClass: "btn-danger" },
          );

          if (!confirmed) return;

          try {
            if (dataType === "chats") {
              // ÁâπÊÆäÂ§ÑÁêÜÔºöÊ∏ÖÁ©∫ÊâÄÊúâNPCËÅäÂ§©Ôºà‰∏çÂåÖÊã¨ÂíåuserÁöÑÔºâ
              chat.characterPhoneData.chats = {};
            } else if (dataType === "bank.transactions") {
              // ÁâπÊÆäÂ§ÑÁêÜÔºöÊ∏ÖÁ©∫Èì∂Ë°å‰∫§ÊòìËÆ∞ÂΩïÔºå„ÄêÂêåÊó∂Â∞Ü‰ΩôÈ¢ùÂΩíÈõ∂„Äë
              if (chat.characterPhoneData.bank) {
                chat.characterPhoneData.bank.transactions = [];

                chat.characterPhoneData.bank.balance = 0;
              }
            } else if (chat.characterPhoneData[info.dataKey]) {
              // ÈÄöÁî®Â§ÑÁêÜÔºöÊ∏ÖÁ©∫Êï∞ÁªÑ
              chat.characterPhoneData[info.dataKey] = [];
            }

            // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
            await db.chats.put(chat);

            // Âà∑Êñ∞ÂΩìÂâçÈ°µÈù¢
            switch (dataType) {
              case "chats":
                renderCharacterChatList();
                break;
              case "shoppingCart":
                renderCharacterShoppingCart();
                break;
              case "memos":
                renderCharacterMemos();
                break;
              case "browserHistory":
                renderCharacterBrowser();
                break;
              case "photoAlbum":
                renderCharacterPhotoAlbum();
                break;
              case "bank.transactions":
                renderCharacterBank();
                break;
              case "trajectory":
                renderCharacterTrajectory();
                break;
              case "appUsage":
                renderCharacterAppUsage();
                break;
              case "diary":
                renderCharacterDiary();
                break;
            }

            alert(`Â∑≤ÊàêÂäüÊ∏ÖÁ©∫ÊâÄÊúâ${info.name}„ÄÇ`);
          } catch (error) {
            console.error(`Ê∏ÖÁ©∫ ${info.name} Êó∂Âá∫Èîô:`, error);
            await showCustomAlert(
              "Êìç‰ΩúÂ§±Ë¥•",
              `Ê∏ÖÁ©∫Êó∂ÂèëÁîüÈîôËØØ: ${error.message}`,
            );
          }
        }

        /**
         * ÁîüÊàêËßíËâ≤ÊâãÊú∫Êï∞ÊçÆ
         */
        async function generateCharacterPhoneData() {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];
          if (!chat) return;

          showGenerationOverlay("Ê≠£Âú®ÂêåÊ≠•TaÁöÑÊâãÊú∫Êï∞ÊçÆ...");

          try {
            const userNickname = state.qzoneSettings.nickname || "Me";

            // ÈôêÂà∂‰∫∫ËÆæÈïøÂ∫¶ÔºåËøôÊòØÈò≤Ê≠¢503ÈîôËØØÁöÑÊ†πÊú¨ÊñπÊ≥ïÔºÅ
            // Âè™Âèñ‰∫∫ËÆæÁöÑÂâç4000‰∏™Â≠óÁ¨¶ÔºåÈÅøÂÖçÊï¥‰∏™‰∫∫ËÆæËøáÈïøÂØºËá¥ËØ∑Ê±ÇÂ§±Ë¥•„ÄÇ
            const persona = (chat.settings.aiPersona || "").substring(0, 4000);

            const recentHistory = chat.history
              .slice(-chat.settings.maxMemory || 20)
              .map((msg) => {
                const sender = msg.role === "user" ? userNickname : chat.name;
                return `${sender}: ${msg.content}`;
              })
              .join("\n");

            console.log("Áî®‰∫éÁîüÊàêÊâãÊú∫Êï∞ÊçÆÁöÑÊúÄËøëËÅäÂ§©ËÆ∞ÂΩï:", recentHistory);
            // added by lrq 251028 Ê∑ªÂä†ËÆ∞ÂøÜ‰∫íÈÄöÁöÑËÅäÂ§©ËÆ∞ÂΩï‰Ωú‰∏∫ÂèÇËÄÉ
            let linkedMemoryContext = "";
            if (
              chat.settings.linkedMemories &&
              chat.settings.linkedMemories.length > 0
            ) {
              const contextPromises = chat.settings.linkedMemories.map(
                async (link) => {
                  const linkedChat = state.chats[link.chatId];
                  if (!linkedChat) return "";

                  const freshLinkedChat = await db.chats.get(link.chatId);
                  if (!freshLinkedChat) return "";

                  const recentHistory = freshLinkedChat.history
                    .filter((msg) => !msg.isHidden)
                    .slice(-link.depth);

                  if (recentHistory.length === 0) return "";

                  const formattedMessages = recentHistory
                    .map(
                      (msg) =>
                        `  - ${formatMessageForContext(msg, freshLinkedChat)}`,
                    )
                    .join("\n");

                  return `\n## ÈôÑÂä†‰∏ä‰∏ãÊñáÔºöÊù•Ëá™‰∏é‚Äú${linkedChat.name}‚ÄùÁöÑÊúÄËøëÂØπËØùÂÜÖÂÆπ (‰ªÖ‰Ω†ÂèØËßÅ)\n${formattedMessages}`;
                },
              );

              const allContexts = await Promise.all(contextPromises);
              linkedMemoryContext = allContexts.filter(Boolean).join("\n");
            }
            console.log(
              "Áî®‰∫éÁîüÊàêÊâãÊú∫Êï∞ÊçÆÁöÑ‰∫íÈÄöËÅäÂ§©ËÆ∞ÂΩï‰∏ä‰∏ãÊñá:",
              linkedMemoryContext,
            );
            let worldBookContext = "";
            if (
              chat.settings.linkedWorldBookIds &&
              chat.settings.linkedWorldBookIds.length > 0
            ) {
              worldBookContext =
                "--- ‰∏ñÁïåËßÇËÆæÂÆö (ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆà) ---\n" +
                chat.settings.linkedWorldBookIds
                  .map((id) => {
                    const book = state.worldBooks.find((b) => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : "";
                  })
                  .join("\n\n");
            }
            const npcLibrary = chat.npcLibrary || [];
            let npcContext = "";
            if (npcLibrary.length > 0) {
              npcContext =
                '# ‰Ω†ÁöÑ‰∏ìÂ±ûNPCÂ•ΩÂèãÂàóË°® (‰Ω†ÂøÖÈ°ªÂú®‰∏ãÊñπ"chats"‰∏≠‰∏∫‰ªñ‰ª¨ÁîüÊàêÂØπËØù)\n' +
                "Ëøô‰∫õ‰∫∫ÊòØ‰Ω†ÁöÑÂ•ΩÊúãÂèãÔºå‰Ω†Âíå‰ªñ‰ª¨ÈùûÂ∏∏ÁÜüÊÇâ„ÄÇËØ∑Ê†πÊçÆ‰ªñ‰ª¨ÁöÑ‰∫∫ËÆæÔºåÁîüÊàêÁ¨¶Âêà‰Ω†‰ª¨ÂÖ≥Á≥ªÁöÑ„ÄÅËá™ÁÑ∂ÁöÑËÅäÂ§©ËÆ∞ÂΩï„ÄÇ\n" +
                npcLibrary
                  .map((npc) => `- **${npc.name}**: ${npc.persona}`)
                  .join("\n");
            } else {
              npcContext =
                "# ‰Ω†ÁöÑ‰∏ìÂ±ûNPCÂ•ΩÂèãÂàóË°®\n(‰Ω†Ê≤°Êúâ‰∏ìÂ±ûNPCÔºåËØ∑ËôöÊûÑ‰∏Ä‰∫õÊôÆÈÄöÊúãÂèã)";
            }

            let npcChatHistoryContext = "";
            const existingNpcChats = Object.entries(
              chat.characterPhoneData.chats || {},
            ).filter(
              ([name, chatData]) =>
                chatData.history && chatData.history.length > 0,
            );

            if (existingNpcChats.length > 0) {
              npcChatHistoryContext +=
                "\n\n# Â∑≤ÊúâÁöÑËÅäÂ§©ËÆ∞ÂΩïÊëòË¶Å (ËØ∑Âú®Ê≠§Âü∫Á°Ä‰∏äÁªßÁª≠ÂØπËØù)\n";
              existingNpcChats.forEach(([contactName, chatData]) => {
                const recentMessages = chatData.history
                  .slice(-5)
                  .map((msg) => `  - ${msg.sender}: ${msg.content}`)
                  .join("\n");
                npcChatHistoryContext += `\n## ‰Ω†Âíå‚Äú${contactName}‚ÄùÁöÑÊúÄËøëÂØπËØù:\n${recentMessages}\n`;
              });
            }

            // ‰ºòÂåñÊèêÁ§∫ËØçÔºåËÆ©AIÊõ¥Â•ΩÂú∞ÁêÜËß£‰ªªÂä°ÔºåÂπ∂Âº∫Ë∞ÉÊÉÖÊôØ‰∏ÄËá¥ÊÄß
            const prompt = `
			# ‰ªªÂä°
			„Äê„Äê„ÄêÊÉÖÊôØ‰∏ÄËá¥ÊÄßÈìÅÂæã„Äë„Äë„ÄëÔºö‰Ω†ÁîüÊàêÁöÑÊâÄÊúâÊï∞ÊçÆÔºàÂ∞§ÂÖ∂ÊòØ"trajectory"Ë°åÂä®ËΩ®ËøπÔºâ**ÂøÖÈ°ª**‰∏é‚ÄúÊúÄËøëËÅäÂ§©ËÆ∞ÂΩïÊëòË¶Å‚Äù‰∏≠ÊèêÂà∞ÁöÑÊúÄÊñ∞ÊÉÖÊôØ‰øùÊåÅÁªùÂØπ‰∏ÄËá¥„ÄÇÂ¶ÇÊûúËÅäÂ§©ËÆ∞ÂΩïÊòæÁ§∫‰Ω†Ê≠£Âú®‰∏äËØæÔºå‰Ω†ÁöÑË°åÂä®ËΩ®ËøπÂ∞±ÂøÖÈ°ªÊòØÂú®ÊïôÂÆ§ÔºõÂ¶ÇÊûúËÅäÂ§©ËÆ∞ÂΩïÊòæÁ§∫‰Ω†Âú®ÂíñÂï°È¶ÜÔºå‰Ω†ÁöÑË°åÂä®ËΩ®ËøπÂ∞±ÂøÖÈ°ªÊòØÂíñÂï°È¶Ü„ÄÇ**ÁªùÂØπ‰∏çËÉΩ**‰ªÖÂá≠‰Ω†ÁöÑ‰∫∫ËÆæÂ∞±ÁîüÊàê‰∏éËÅäÂ§©ËÆ∞ÂΩïÁõ∏ÁüõÁõæÁöÑÂÜÖÂÆπ„ÄÇ
			‰Ω†Áé∞Âú®ÊòØËßíËâ≤ "${
        chat.name
      }"„ÄÇËØ∑Ê†πÊçÆ‰Ω†ÁöÑ‰∫∫ËÆæ„ÄÅ‰∏ñÁïåËßÇ„ÄÅNPCÂ•ΩÂèãÂàóË°®‰ª•ÂèäÂíå${userNickname}ÁöÑÊúÄËøëËÅäÂ§©ËÆ∞ÂΩïÔºåÊ®°ÊãüÁîüÊàê‰Ω†ÊâãÊú∫‰∏≠ÁöÑÂêÑÈ°πÊï∞ÊçÆ„ÄÇ‰Ω†ÈúÄË¶Å‰∏ÄÊ¨°ÊÄßÁîüÊàêÊâÄÊúâÊï∞ÊçÆÔºåÂπ∂‰∏•Ê†ºÊåâÁÖß‰∏ãÈù¢ÁöÑJSONÊ†ºÂºèËøîÂõû„ÄÇ

			# „Äê„Äê„ÄêÁªùÂØπÁ¶ÅÊ≠¢‰∫ãÈ°πÔºöËøôÊòØÂøÖÈ°ªÈÅµÂÆàÁöÑÂÆâÂÖ®Á∫¢Á∫ø„Äë„Äë„Äë
			1.  Âú®ÁîüÊàêJSONÊï∞ÊçÆÔºåÁâπÂà´ÊòØchatsÂ≠óÊÆµÊó∂Ôºå**ÁªùÂØπ‰∏çÂÖÅËÆ∏**ÂàõÂª∫Âè¶‰∏Ä‰∏™Áî®Êà∑Ôºà${userNickname}ÔºâÁöÑËôöÊãüÂΩ¢Ë±°ÊàñËÆ©‰ªñ/Â•πÂá∫Áé∞Âú®‰Ω†‰∏éÂÖ∂‰ªñNPCÁöÑÂØπËØù‰∏≠„ÄÇ
			2.  "bank" Â≠óÊÆµ‰∏≠ÁöÑ‰∫§ÊòìËÆ∞ÂΩï„ÄêÁªùÂØπ‰∏çËÉΩ„ÄëÊ∂âÂèäÁî®Êà∑("${userNickname}")„ÄÇÊâÄÊúâ‰∫§ÊòìÈÉΩÂøÖÈ°ªÊòØ‰Ω†‰∏éÂÖ∂‰ªñNPC„ÄÅÂïÜÂÆ∂ÊàñÂõ†Êüê‰∫õ‰∫ã‰ª∂ÔºàÂ¶ÇË¥≠Áâ©„ÄÅÊî∂Âà∞Â∑•ËµÑÔºâ‰∫ßÁîüÁöÑ„ÄÇ
			3.  chatsÂ≠óÊÆµ‰∏≠Ôºå‰∏éNPCÊàñÊúãÂèãÁöÑËÅäÂ§©ËÆ∞ÂΩïÔºåÂÖ∂senderÊàñcontent**ÁªùÂØπ‰∏çËÉΩ**ÂåÖÂê´${userNickname}ÁöÑÂêçÂ≠óÊàñ‰ª£Áß∞„ÄÇ
			4.  ÊâÄÊúâ‰Ω†ÁîüÊàêÁöÑËÅäÂ§©ÂØπËØùÔºåÈÉΩÂøÖÈ°ª‰∏•Ê†ºÈôêÂà∂Âú®„Äê‰Ω†(${
        chat.name
      })„ÄëÂíå„ÄêÂè¶‰∏Ä‰ΩçNPC/ÊúãÂèã„ÄëËøô**‰∏§‰∏™‰∫∫‰πãÈó¥**„ÄÇ**‰∏•Á¶Å**Âá∫Áé∞‰ªª‰ΩïÂΩ¢ÂºèÁöÑÁ¨¨‰∏âËÄÖÔºåÂ∞§ÂÖ∂ÊòØ${userNickname}„ÄÇ

			# ‰Ω†ÁöÑ‰ø°ÊÅØ
			- ‰Ω†ÁöÑÂêçÂ≠ó: ${chat.name}
			- ‰Ω†ÁöÑ‰∫∫ËÆæ: ${persona}
			${worldBookContext}
			# Âíå${userNickname}ÁöÑÊúÄËøëËÅäÂ§©ËÆ∞ÂΩïÊëòË¶Å
			${recentHistory}
			${linkedMemoryContext}

			${npcContext}
			${npcChatHistoryContext}
			# JSONËæìÂá∫Ê†ºÂºè (ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆàÔºå‰∏çË¶ÅÊ∑ªÂä†‰ªª‰ΩïÈ¢ùÂ§ñËØ¥Êòé)
			{
			  "chats": [
			    {
			      "contactName": "„ÄêËøôÈáåÂ°´ÂÜô‰Ω†Áªô${userNickname}ÁöÑÂ§áÊ≥®Âêç„Äë"
			    },
			    {
			      "contactName": "„ÄêËøôÈáåÂøÖÈ°ªÂ°´ÂÜô‰∏äÈù¢NPCÂàóË°®‰∏≠ÁöÑ‰∏Ä‰∏™ÂêçÂ≠óÔºåÊàñ‰∏Ä‰∏™ËôöÊûÑÊúãÂèãÂêç„Äë",
			      "messages": [
			        {"sender": "„ÄêËÅîÁ≥ª‰∫∫ÂêçÔºå‰∏•Á¶ÅÂ°´ÂÜô'${userNickname}'„Äë", "content": "Ê∂àÊÅØÂÜÖÂÆπ1..."},
			        {"sender": "${chat.name}", "content": "‰Ω†ÁöÑÂõûÂ§ç1..."},
			        {"sender": "„ÄêËÅîÁ≥ª‰∫∫ÂêçÔºå‰∏•Á¶ÅÂ°´ÂÜô'${userNickname}'„Äë", "content": "Ê∂àÊÅØÂÜÖÂÆπ2..."},
			        {"sender": "„ÄêËÅîÁ≥ª‰∫∫ÂêçÔºå‰∏•Á¶ÅÂ°´ÂÜô'${userNickname}'„Äë", "content": "Ê∂àÊÅØÂÜÖÂÆπ3..."},
			        {"sender": "${chat.name}", "content": "‰Ω†ÁöÑÂõûÂ§ç2..."}
			      ]
			    }
			  ],
			  "shoppingCart": [
			    {"name": "ÂïÜÂìÅÂêç", "price": ‰ª∑Ê†º, "store": "Â∫óÈì∫Âêç"}
			  ],
			  "memos": [
			    {"title": "Â§áÂøòÂΩïÊ†áÈ¢ò", "content": "Â§áÂøòÂΩïËØ¶ÁªÜÂÜÖÂÆπ..."}
			  ],
			  "browserHistory": [
			    {"query": "ÊêúÁ¥¢ÊàñÊµèËßàÁöÑÊ†áÈ¢ò", "result": "„ÄêËøôÈáåÊòØAIÁîüÊàêÁöÑ„ÄÅÂÖ≥‰∫éËøô‰∏™ÊêúÁ¥¢Ê†áÈ¢òÁöÑÊ®°ÊãüÊñáÁ´†ÊàñÁΩëÈ°µÂÜÖÂÆπ„Äë"}
			  ],
			  "photoAlbum": [
			    {"hiddenContent": "ÂØπÁÖßÁâáÁîªÈù¢ÁöÑËØ¶ÁªÜÊñáÂ≠óÊèèËø∞"}
			  ],
			  "bank": {
			    "balance": Èì∂Ë°åÂç°‰ΩôÈ¢ù(Êï∞Â≠ó),
			    "transactions": [
			      {"type": "Êî∂ÂÖ•ÊàñÊîØÂá∫", "amount": ÈáëÈ¢ù, "description": "‰∫§ÊòìÊèèËø∞"}
			    ]
			  },
			  "trajectory": [
			    {"time": "Êó∂Èó¥ÊÆµ", "location": "Âú∞ÁÇπ", "activity": "Âπ≤‰∫Ü‰ªÄ‰πà‰∫ã"}
			  ],
			  "appUsage": [
			    {"appName": "Â∫îÁî®Âêç", "duration": "‰ΩøÁî®Êó∂Èïø"}
			  ],
			  "diary": [
			    {"timestamp": ${Date.now()}, "content": "„Äê‰ªäÂ§©ÊòØ${new Date().toLocaleString(
            "en-GB",
            {
              dateStyle: "full",
            },
          )}ÔºåÁî®MarkdownËØ≠Ê≥ïÂÜô‰∏ÄÁØáÁ¨¶Âêà‰∫∫ËÆæÂíå‰ªäÂ§©ÊÉÖÊôØÁöÑÊó•ËÆ∞„Äë"}
			  ]
			}

			# „Äê„Äê„ÄêÈáçË¶ÅÊåá‰ª§ÔºöÂÖ≥‰∫éËÅäÂ§©ËÆ∞ÂΩïÁîüÊàê„Äë„Äë„Äë
			- ‰Ω†Ê≠£Âú®Áª≠ÂÜôËøôÊÆµÂØπËØù„ÄÇ‰Ω†Êèê‰æõÁöÑËÅäÂ§©ËÆ∞ÂΩïÊòØ‰∏ä‰∏ãÊñáÔºå‰Ω†„ÄêÁªùÂØπ‰∏çËÉΩ„ÄëÈáçÂ§çÊàñÊîπÂÜôÂÖ∂‰∏≠ÁöÑ‰ªª‰ΩïÂÜÖÂÆπ„ÄÇ‰Ω†ÁöÑÁîüÊàêÂøÖÈ°ª‰ªé„ÄêÂÖ®Êñ∞ÁöÑ„ÄÅ‰∏ã‰∏ÄÊù°„ÄëÊ∂àÊÅØÂºÄÂßã„ÄÇ
			- ‰Ω†ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆàÊú¨ÊèêÁ§∫ËØçÊúÄ‰∏äÊñπÁöÑ„ÄêÁªùÂØπÁ¶ÅÊ≠¢‰∫ãÈ°π„Äë„ÄÇ
			- Â¶ÇÊûú‚Äú‰Ω†ÁöÑ‰∏ìÂ±ûNPCÂ•ΩÂèãÂàóË°®‚Äù‰∏ç‰∏∫Á©∫Ôºå‰Ω†„ÄêÂøÖÈ°ª„Äë‰∏∫ÂàóË°®‰∏≠ÁöÑ„ÄêÊØè‰∏Ä‰∏™NPC„ÄëÈÉΩÁîüÊàê‰∏ÄÊÆµ‰∏é‰Ω†Ôºà${chat.name}ÔºâÁöÑÂØπËØù„ÄÇ
			- Â¶ÇÊûúÂàóË°®‰∏∫Á©∫Ôºå‰Ω†ÂèØ‰ª•ËôöÊûÑ2-3‰∏™ÊôÆÈÄöÊúãÂèãÂπ∂ÁîüÊàêÂØπËØù„ÄÇ
			- ‰Ω†ÂøÖÈ°ª‰∏∫ÊØè‰∏™ËÅîÁ≥ª‰∫∫ÁîüÊàê‰∏ÄÊÆµ„ÄêËá≥Â∞ëÂåÖÂê´5Êù°Ê∂àÊÅØ„ÄëÁöÑÂØπËØù„ÄÇ
			- ÂØπËØùÂÜÖÂÆπÂ∫îËØ•Ëá™ÁÑ∂ÊµÅÁïÖÔºåÂèØ‰ª•ÂåÖÂê´ËøûÁª≠ÂèëË®Ä„ÄÅË°®ÊÉÖÂåÖÂíåË°®ÊÉÖÁ¨¶Âè∑Á≠âÔºå‰ª•‰ΩìÁé∞ÁúüÂÆûÊÑü„ÄÇ
			- ‰∏çË¶ÅÂè™ÁîüÊàê‰∏ÄÈóÆ‰∏ÄÁ≠îÁöÑÊú∫Ê¢∞ÂºèÂØπËØù„ÄÇ
			-   **„Äê„Äê„ÄêÁªùÂØπÁ¶ÅÊ≠¢ÈáçÂ§çÈìÅÂæã„Äë„Äë„Äë**: ‰Ω†ÁîüÊàêÁöÑ "messages" Êï∞ÁªÑ‰∏≠Ôºå„ÄêÁªùÂØπ‰∏çËÉΩ„ÄëÂåÖÂê´ÊàëÊèê‰æõÁªô‰Ω†ÁöÑ‰∏ä‰∏ãÊñáÈáåÁöÑ‰ªª‰Ωï‰∏ÄÊù°Ê∂àÊÅØ„ÄÇ‰Ω†ÁöÑÁ¨¨‰∏ÄÊù°Ê∂àÊÅØÂøÖÈ°ªÊòØÂØπËØùÂéÜÂè≤‰∏≠ÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÁöÑ„Äê‰∏ã‰∏ÄÊù°„Äë„ÄÇ
			`;

            const { proxyUrl, apiKey, model } = state.apiConfig;
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              prompt,
              [{ role: "user", content: prompt }],
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [{ role: "user", content: prompt }],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });

            if (!response.ok) {
              let errorMsg = `APIËØ∑Ê±ÇÂ§±Ë¥•ÔºåÁä∂ÊÄÅÁ†Å: ${response.status}`;
              try {
                const errorData = await response.json();
                errorMsg += `\nÈîôËØØ‰ø°ÊÅØ: ${errorData.error.message}`;
              } catch (e) {
                errorMsg += `\nÊó†Ê≥ïËß£ÊûêÈîôËØØÂìçÂ∫î‰Ωì„ÄÇ`;
              }
              throw new Error(errorMsg);
            }

            const data = await response.json();
            const aiResponseContent = (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            ).replace(/^```json\s*|```$/g, "");

            let newData;
            try {
              newData = JSON.parse(aiResponseContent);
            } catch (e) {
              throw new Error(
                `AIËøîÂõûÁöÑ‰∏çÊòØÊúâÊïàÁöÑJSONÊ†ºÂºèÔºåÊó†Ê≥ïËß£Êûê„ÄÇ\nÂéüÂßãËøîÂõûÂÜÖÂÆπ:\n${aiResponseContent}`,
              );
            }

            let phoneData = chat.characterPhoneData;
            phoneData.lastGenerated = Date.now();

            if (newData.chats) {
              newData.chats.forEach((newChat) => {
                if (!newChat.messages) {
                  const myNickname = userNickname || "Me";
                  if (!phoneData.chats[myNickname]) {
                    phoneData.chats[myNickname] = { avatar: "", history: [] };
                  }
                  phoneData.chats[myNickname].remarkName = newChat.contactName;
                } else {
                  const contactName = newChat.contactName;
                  if (
                    phoneData.chats[contactName] &&
                    phoneData.chats[contactName].history
                  ) {
                    console.log(
                      `ÂêàÂπ∂ËÅäÂ§©ËÆ∞ÂΩï: ‰∏∫ "${contactName}" ËøΩÂä† ${newChat.messages.length} Êù°Êñ∞Ê∂àÊÅØ„ÄÇ`,
                    );
                    phoneData.chats[contactName].history.push(
                      ...newChat.messages,
                    );
                  } else {
                    console.log(`Create a new chat: "${contactName}"`);
                    phoneData.chats[contactName] = {
                      avatar: newChat.avatar,
                      history: newChat.messages,
                    };
                  }
                }
              });
            }

            // Ê≠£Á°ÆÂ§ÑÁêÜÂÖ∂‰ªñÊï∞ÁªÑÁ±ªÂûãÊï∞ÊçÆ
            if (!phoneData.shoppingCart) phoneData.shoppingCart = [];
            phoneData.shoppingCart.push(...(newData.shoppingCart || []));
            if (!phoneData.memos) phoneData.memos = [];
            phoneData.memos.push(...(newData.memos || []));
            if (!phoneData.browserHistory) phoneData.browserHistory = [];
            phoneData.browserHistory.push(...(newData.browserHistory || []));
            if (!phoneData.photoAlbum) phoneData.photoAlbum = [];
            phoneData.photoAlbum.push(...(newData.photoAlbum || []));
            if (!phoneData.trajectory) phoneData.trajectory = [];
            phoneData.trajectory.push(...(newData.trajectory || []));
            if (!phoneData.diary) phoneData.diary = [];
            phoneData.diary.push(...(newData.diary || []));

            if (newData.appUsage && Array.isArray(newData.appUsage)) {
              const usageMap = new Map();
              // ÂÖàÂä†ËΩΩÂ∑≤ÊúâÁöÑ‰ΩøÁî®ËÆ∞ÂΩï
              (phoneData.appUsage || []).forEach((item) => {
                usageMap.set(
                  item.appName,
                  (usageMap.get(item.appName) || 0) +
                    parseDurationToMinutes(item.duration),
                );
              });
              // ÂÜçÁ¥ØÂä†Êñ∞ÁîüÊàêÁöÑ‰ΩøÁî®ËÆ∞ÂΩï
              newData.appUsage.forEach((item) => {
                usageMap.set(
                  item.appName,
                  (usageMap.get(item.appName) || 0) +
                    parseDurationToMinutes(item.duration),
                );
              });
              // ÈáçÊñ∞ÁîüÊàêÂêàÂπ∂ÂêéÁöÑÂàóË°®
              const mergedUsage = [];
              for (const [appName, totalMinutes] of usageMap.entries()) {
                mergedUsage.push({
                  appName: appName,
                  duration: formatMinutesToDuration(totalMinutes),
                });
              }
              phoneData.appUsage = mergedUsage;
            }

            if (newData.bank) {
              if (!phoneData.bank)
                phoneData.bank = { balance: 0, transactions: [] };
              if (typeof phoneData.bank.balance !== "number")
                phoneData.bank.balance = 0;

              // Â¶ÇÊûúAIËøîÂõû‰∫ÜÊñ∞ÁöÑÊÄª‰ΩôÈ¢ù (ÈÄöÂ∏∏ÊòØÁ¨¨‰∏ÄÊ¨°ÁîüÊàêÊó∂)ÔºåÂàô‰ª•Ê≠§‰∏∫ÂáÜ
              if (typeof newData.bank.balance === "number") {
                phoneData.bank.balance = newData.bank.balance;
              }

              if (
                newData.bank.transactions &&
                Array.isArray(newData.bank.transactions)
              ) {
                newData.bank.transactions.forEach((transaction) => {
                  const amount = parseFloat(transaction.amount);
                  if (!isNaN(amount)) {
                    // Âè™ÊúâÂú®AIÊ≤°ÊúâÁõ¥Êé•Êèê‰æõÊñ∞‰ΩôÈ¢ùÊó∂ÔºåÊàë‰ª¨ÊâçÊ†πÊçÆ‰∫§ÊòìËÆ∞ÂΩïËá™Â∑±ËÆ°ÁÆó
                    if (typeof newData.bank.balance !== "number") {
                      if (transaction.type === "Income") {
                        phoneData.bank.balance += amount;
                      } else if (transaction.type === "Paid") {
                        phoneData.bank.balance -= amount;
                      }
                    }
                  }
                });
                // Â∞ÜÊñ∞‰∫§ÊòìËÆ∞ÂΩïËøΩÂä†Âà∞ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠
                if (!phoneData.bank.transactions)
                  phoneData.bank.transactions = [];
                phoneData.bank.transactions.push(...newData.bank.transactions);
              }
            }

            await db.chats.put(chat);
            alert("Êï∞ÊçÆÂ∑≤Âà∑Êñ∞ÔºÅ");
          } catch (error) {
            console.error("ÁîüÊàêËßíËâ≤ÊâãÊú∫Êï∞ÊçÆÂ§±Ë¥•:", error);
            await showCustomAlert(
              "ÁîüÊàêÂ§±Ë¥•",
              `ÂèëÁîü‰∫Ü‰∏Ä‰∏™ÈîôËØØÔºåËØ∑Ê£ÄÊü•‰Ω†ÁöÑÁΩëÁªú„ÄÅAPIÂØÜÈí•ÊàñÊ®°ÂûãËÆæÁΩÆ„ÄÇ\n\nËØ¶ÁªÜ‰ø°ÊÅØ:\n${error.message}`,
            );
          } finally {
            document
              .getElementById("generation-overlay")
              .classList.remove("visible");
          }
        }

        /**
         * Ê∏ÖÁ©∫ËßíËâ≤ÊâãÊú∫Êï∞ÊçÆ
         */
        async function clearCharacterPhoneData() {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];
          if (!chat) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Ê∏ÖÁ©∫",
            `Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫‚Äú${chat.name}‚ÄùÁöÑÊâÄÊúâÊâãÊú∫Êï∞ÊçÆÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
            { confirmButtonClass: "btn-danger" },
          );
          if (confirmed) {
            // ÈáçÁΩÆ‰∏∫ÂàùÂßãÁä∂ÊÄÅ
            chat.characterPhoneData = {
              lastGenerated: null,
              chats: {},
              shoppingCart: [],
              memos: [],
              browserHistory: [],
              photoAlbum: [],
              bank: { balance: 0, transactions: [] },
              trajectory: [],
              appUsage: [],
              diary: [], // <--- Âú®ËøôÈáåÊñ∞Â¢û
            };
            await db.chats.put(chat);
            // ÈáçÊñ∞Ê∏≤ÊüìAPPÁΩëÊ†ºÔºåÂõ†‰∏∫ÁÇπÂáªAPP‰ºöËØªÂèñÊñ∞Êï∞ÊçÆ
            renderCharacterAppGrid();
            alert("Êï∞ÊçÆÂ∑≤Ê∏ÖÁ©∫„ÄÇ");
          }
        }

        /**
         * Ê∏≤ÊüìËßíËâ≤ÊâãÊú∫ÁöÑËÅäÂ§©ÂàóË°® (ÊîØÊåÅÈÄèÊòéÁ£®Á†ÇÂàÜÁªÑ)
         */
        function renderCharacterChatList() {
          const listEl = document.getElementById("character-chat-list");
          const characterChat = state.chats[activeCharacterPhoneId];
          if (!characterChat) return;

          const characterChatData = characterChat.characterPhoneData;
          const realChatHistory = characterChat.history;
          listEl.innerHTML = "";

          const npcContainer = document.createElement("div");
          npcContainer.className = "npc-chat-group"; // ÁªôÂÆÉ‰∏Ä‰∏™‰∏ìÂ±ûÁöÑclassÂêç

          // Ëé∑Âèñ "Me" ÁöÑÂ§áÊ≥®Âêç
          const userContactInData = characterChatData.chats
            ? Object.values(characterChatData.chats).find(
                (c) => !c.history || c.history.length === 0,
              )
            : null;
          const remarkNameForMe = userContactInData
            ? userContactInData.remarkName
            : "Me";

          // Ê∏≤Êüì‰∏é "Me" ÁöÑËÅäÂ§©
          const lastMsg = realChatHistory
            .filter((m) => !m.isHidden)
            .slice(-1)[0] || { content: "..." };
          const myChatItem = document.createElement("div");
          myChatItem.className = "chat-list-item"; // Ëøô‰∏™ÊòØÁî®Êà∑Ëá™Â∑±ÁöÑÊ∂àÊÅØÔºåÂçïÁã¨Â§ÑÁêÜ
          myChatItem.dataset.contactName = remarkNameForMe;
          myChatItem.dataset.isUserChat = "true";
          const myAvatar =
            characterChat.settings.myAvatar || defaultMyGroupAvatar;
          myChatItem.innerHTML = `
			                        <img src="${myAvatar}" class="avatar" style="border-radius: 6px;">
			                        <div class="info">
			                            <span class="name">${remarkNameForMe}</span>
			                            <div class="last-msg">${stripHtmlAndCode(String(lastMsg.content)).substring(0, 30)}</div>
			                        </div>
			                    `;
          listEl.appendChild(myChatItem);

          // Ê∏≤Êüì‰∏éÂÖ∂‰ªñNPCÁöÑËÅäÂ§©
          if (characterChatData.chats) {
            for (const contactName in characterChatData.chats) {
              if (contactName === remarkNameForMe) continue;
              const contact = characterChatData.chats[contactName];
              if (!contact.history || contact.history.length === 0) continue;

              const lastNpcMsg = contact.history.slice(-1)[0] || {
                content: "...",
              };
              const npcChatItem = document.createElement("div");
              npcChatItem.className = "chat-list-item";
              npcChatItem.dataset.contactName = contactName;

              let npcAvatarHtml;
              const npcFromLibrary = (characterChat.npcLibrary || []).find(
                (npc) => npc.name === contactName,
              );
              if (npcFromLibrary && npcFromLibrary.avatar) {
                npcAvatarHtml = `<img src="${npcFromLibrary.avatar}" class="avatar" style="border-radius: 6px;">`;
              } else {
                const avatarColors = [
                  "#FFC107",
                  "#4CAF50",
                  "#2196F3",
                  "#F44336",
                  "#9C27B0",
                  "#00BCD4",
                ];
                const npcNameInitial = contactName.slice(-1);
                const colorIndex = contactName.length % avatarColors.length;
                const bgColor = avatarColors[colorIndex];
                npcAvatarHtml = `<div class="avatar" style="border-radius: 6px; background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
              }
              npcChatItem.innerHTML = `${npcAvatarHtml}<div class="info"><span class="name">${contactName}</span><div class="last-msg">${stripHtmlAndCode(
                String(lastNpcMsg.content),
              ).substring(0, 30)}</div></div>`;

              // Â∞ÜNPCÊ∂àÊÅØÊ∑ªÂä†Âà∞Êñ∞ÁöÑÂÆπÂô®‰∏≠
              npcContainer.appendChild(npcChatItem);
            }
          }

          // Â∞ÜÂåÖÂê´ÊâÄÊúâNPCÊ∂àÊÅØÁöÑÂÆπÂô®‰∏ÄÊ¨°ÊÄßÊ∑ªÂä†Âà∞ÂàóË°®‰∏≠
          if (npcContainer.hasChildNodes()) {
            listEl.appendChild(npcContainer);
          }
        }

        /**
         * Ê∏≤ÊüìËßíËâ≤ÊâãÊú∫ÁöÑÂÖ∑‰ΩìËÅäÂ§©ËÆ∞ÂΩï (ÂàÜÈ°µÂä†ËΩΩ)
         */
        function renderCharacterChatHistory(
          contactName,
          isUserChat = false,
          loadOffset = 0,
        ) {
          const MESSAGES_PER_PAGE = 50; // ÊØèÊ¨°Âä†ËΩΩ50Êù°

          const messagesEl = document.getElementById(
            "character-chat-history-messages",
          );
          const characterChat = state.chats[activeCharacterPhoneId];
          if (!characterChat) {
            console.error("„ÄêÈîôËØØ„Äë: Êâæ‰∏çÂà∞ characterChat ÂØπË±°ÔºÅ");
            return;
          }

          // --- ÂáÜÂ§áÂ∑•‰ΩúÔºöËÆæÁΩÆÊ†áÈ¢òÂíåÂ§¥ÂÉè (‰ªÖÂú®È¶ñÊ¨°Âä†ËΩΩÊó∂ÊâßË°å) ---
          if (loadOffset === 0) {
            messagesEl.innerHTML = ""; // È¶ñÊ¨°Âä†ËΩΩÊâçÊ∏ÖÁ©∫
            let finalContactName = contactName;
            if (isUserChat) {
              const myChatData = characterChat.characterPhoneData.chats["Me"];
              // Â∞ùËØï‰ªéÊâãÊú∫Êï∞ÊçÆÈáåÊâæAIÁªôÁî®Êà∑ÁöÑÂ§áÊ≥®Âêç
              const userContactInData = characterChat.characterPhoneData.chats
                ? Object.values(characterChat.characterPhoneData.chats).find(
                    (c) => !c.history || c.history.length === 0,
                  )
                : null;
              finalContactName = userContactInData
                ? userContactInData.remarkName
                : "Me";
            }
            document.getElementById("character-chat-with-name").textContent =
              finalContactName;
          }

          // --- Êï∞ÊçÆÊ∫êÈÄâÊã© ---
          let fullHistory = [];
          if (isUserChat) {
            fullHistory = characterChat.history.filter((m) => !m.isHidden);
          } else {
            const npcChat = characterChat.characterPhoneData.chats[contactName];
            if (npcChat && npcChat.history) {
              fullHistory = npcChat.history;
            }
          }

          // --- Ê†∏ÂøÉÂàÜÈ°µÈÄªËæë ---
          const totalMessages = fullHistory.length;
          const startIndex = Math.max(
            0,
            totalMessages - MESSAGES_PER_PAGE - loadOffset,
          );
          const endIndex = totalMessages - loadOffset;
          const historyToShow = fullHistory.slice(startIndex, endIndex);

          // --- ÁßªÈô§ÊóßÁöÑ‚ÄúÂä†ËΩΩÊõ¥Â§ö‚ÄùÊåâÈíÆ ---
          const existingLoader = document.getElementById(
            "load-more-messages-btn",
          );
          if (existingLoader) {
            existingLoader.remove();
          }

          // --- Ê∏≤ÊüìÊ∂àÊÅØ ---
          const fragment = document.createDocumentFragment(); // ‰ΩøÁî®ÊñáÊ°£ÁâáÊÆµÊèêÂçáÊÄßËÉΩ
          const characterName = characterChat.name;

          // (Ê∏≤ÊüìÈÄªËæë‰∏é‰πãÂâçÁâàÊú¨Âü∫Êú¨Áõ∏ÂêåÔºåÂè™ÊòØÊ∑ªÂä†Âà∞‰∫Ü fragment ‰∏≠)
          historyToShow.forEach((msg, index) => {
            if (msg.isHidden) return;
            const container = document.createElement("div");
            let sender;
            if (isUserChat) {
              sender = msg.role === "user" ? "Me" : characterName;
            } else {
              sender = msg.sender;
            }

            const isSentByCharacter = sender === characterName;
            container.className = `character-chat-bubble-container ${isSentByCharacter ? "sent" : "received"}`;

            let avatarHtml = "";
            if (isSentByCharacter) {
              avatarHtml = `<img src="${
                characterChat.settings.aiAvatar || defaultAvatar
              }" class="character-chat-avatar">`;
            } else {
              if (isUserChat) {
                avatarHtml = `<img src="${
                  characterChat.settings.myAvatar || defaultMyGroupAvatar
                }" class="character-chat-avatar">`;
              } else {
                const npcData = (characterChat.npcLibrary || []).find(
                  (npc) => npc.name === contactName,
                );
                if (npcData && npcData.avatar) {
                  avatarHtml = `<img src="${npcData.avatar}" class="character-chat-avatar">`;
                } else {
                  const avatarColors = [
                    "#FFC107",
                    "#4CAF50",
                    "#2196F3",
                    "#F44336",
                    "#9C27B0",
                    "#00BCD4",
                  ];
                  const npcNameInitial = contactName.slice(-1);
                  const colorIndex = contactName.length % avatarColors.length;
                  const bgColor = avatarColors[colorIndex];
                  avatarHtml = `<div class="character-chat-avatar" style="background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
                }
              }
            }

            let contentHtml = "";
            if (
              typeof msg.content === "string" &&
              STICKER_REGEX.test(msg.content)
            ) {
              contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-height: 100px;">`;
            } else {
              contentHtml = msg.content;
            }
            const bubbleHtml = `<div class="character-chat-bubble">${contentHtml}</div>`;
            const originalIndex = startIndex + index; // ËÆ°ÁÆóÂú®ÂÆåÊï¥ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠ÁöÑÁúüÂÆûÁ¥¢Âºï
            container.innerHTML = `${avatarHtml}${bubbleHtml}<button class="item-delete-btn message-delete-btn" data-contact-name="${contactName}" data-index="${originalIndex}" data-is-user-chat="${isUserChat}">√ó</button>`;
            fragment.appendChild(container);
          });

          // --- ÂÜ≥ÂÆöÊòØÂê¶ÊòæÁ§∫‚ÄúÂä†ËΩΩÊõ¥Â§ö‚ÄùÊåâÈíÆ ---
          if (startIndex > 0) {
            const loadMoreBtn = document.createElement("div");
            loadMoreBtn.id = "load-more-messages-btn";
            loadMoreBtn.textContent = "Âä†ËΩΩÊõ¥Êó©ÁöÑÊ∂àÊÅØ";
            loadMoreBtn.style.textAlign = "center";
            loadMoreBtn.style.padding = "10px";
            loadMoreBtn.style.color = "#888";
            loadMoreBtn.style.cursor = "pointer";
            loadMoreBtn.style.fontSize = "12px";
            loadMoreBtn.onclick = () => {
              // ËÆ∞ÂΩïÂΩìÂâçÊªöÂä®Êù°‰ΩçÁΩÆÔºå‰ª•‰æøÂä†ËΩΩÂêéÊÅ¢Â§ç
              const currentScrollHeight = messagesEl.scrollHeight;
              renderCharacterChatHistory(
                contactName,
                isUserChat,
                loadOffset + MESSAGES_PER_PAGE,
              );
              // Âä†ËΩΩÂêéÔºåÂ∞ÜÊªöÂä®Êù°ÂÆö‰ΩçÂà∞‰πãÂâçÁöÑ‰ΩçÁΩÆÔºåÈÅøÂÖçË∑≥Âä®
              messagesEl.scrollTop =
                messagesEl.scrollHeight - currentScrollHeight;
            };
            messagesEl.prepend(loadMoreBtn); // Â∞ÜÊåâÈíÆÊ∑ªÂä†Âà∞È°∂ÈÉ®
          }

          messagesEl.prepend(fragment); // Â∞ÜÊñ∞Ê∂àÊÅØ‰∏ÄÊ¨°ÊÄßÊèíÂÖ•Âà∞DOM‰∏≠

          // --- ÊªöÂä®Êù°ÂÆö‰Ωç ---
          if (loadOffset === 0) {
            // È¶ñÊ¨°Âä†ËΩΩÔºåÊªöÂä®Âà∞Â∫ïÈÉ®
            messagesEl.scrollTop = messagesEl.scrollHeight;
          }
        }

        function renderCharacterShoppingCart() {
          const listEl = document.getElementById(
            "character-shopping-cart-list",
          );

          const items =
            state.chats[activeCharacterPhoneId]?.characterPhoneData
              ?.shoppingCart;

          listEl.innerHTML = "";
          if (!items || items.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">Ë¥≠Áâ©ËΩ¶ÊòØÁ©∫ÁöÑ</p>';
            return;
          }
          items.forEach((item, index) => {
            const itemEl = document.createElement("div");
            itemEl.className = "character-cart-item";
            itemEl.innerHTML = `
			            <div class="cart-item-icon">
			                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>
			            </div>
			            <div class="cart-item-info">
			                <div class="title">${item.name}</div>
			                <div class="store">${item.store}</div>
			            </div>
			            <div class="cart-item-price">¬• ${item.price.toFixed(2)}</div>
			            <button class="item-delete-btn" data-type="shoppingCart" data-index="${index}">√ó</button>
			        `;
            listEl.appendChild(itemEl);
          });
        }
        function renderCharacterMemos() {
          const listEl = document.getElementById("character-memos-list");

          const items =
            state.chats[activeCharacterPhoneId]?.characterPhoneData?.memos;

          listEl.innerHTML = "";
          if (!items || items.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">Â§áÂøòÂΩïÊòØÁ©∫ÁöÑ</p>';
            return;
          }
          items.forEach((item, index) => {
            const itemEl = document.createElement("div");
            itemEl.className = "character-data-item";
            itemEl.innerHTML = `
			            <div class="title">${item.title}</div>
			            <div class="content">${item.content}</div>
			            <button class="item-delete-btn" data-type="memos" data-index="${index}">√ó</button>
			        `;
            listEl.appendChild(itemEl);
          });
        }

        /**
         * Âú®ËßíËâ≤ÊâãÊú∫ÂÜÖÈÉ®ÂàáÊç¢È°µÈù¢
         * @param {string} pageId - Ë¶ÅÊòæÁ§∫ÁöÑËßíËâ≤ÊâãÊú∫È°µÈù¢ÁöÑID
         */
        function showCharacterPhonePage(pageId) {
          // 1. ÊâæÂà∞ËßíËâ≤ÊâãÊú∫ÂÜÖÈÉ®Â±èÂπïÁöÑÊâÄÊúâÈ°µÈù¢
          const pages = document.querySelectorAll(".character-phone-page");
          // 2. ÈöêËóèÊâÄÊúâÈ°µÈù¢
          pages.forEach((p) => p.classList.remove("active"));
          // 3. ÊòæÁ§∫ÁõÆÊ†áÈ°µÈù¢
          const pageToShow = document.getElementById(pageId);
          if (pageToShow) {
            pageToShow.classList.add("active");
          }
        }

        // ËßíËâ≤ÊâãÊú∫Êñ∞Â¢ûAPPÊ∏≤ÊüìÂáΩÊï∞

        function renderCharacterBrowser() {
          const listEl = document.getElementById("character-browser-list");

          const items =
            state.chats[activeCharacterPhoneId]?.characterPhoneData
              ?.browserHistory;

          listEl.innerHTML = "";
          if (!items || items.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ÊµèËßàÂô®ÂéÜÂè≤‰∏∫Á©∫</p>';
            return;
          }
          items.forEach((item, index) => {
            const itemEl = document.createElement("div");
            itemEl.className = "character-browser-item";
            itemEl.innerHTML = `
			            <span class="browser-item-icon">üåê</span>
			            <div class="title">${item.query}</div>
			            <button class="item-delete-btn" data-type="browserHistory" data-index="${index}">√ó</button>
			        `;
            itemEl.addEventListener("click", (e) => {
              if (e.target.classList.contains("item-delete-btn")) return;
              document.getElementById(
                "character-browser-detail-title",
              ).textContent = item.query;
              document.getElementById(
                "character-browser-detail-content",
              ).innerHTML = (item.result || "AIÊú™ÁîüÊàêËØ¶ÁªÜÂÜÖÂÆπ„ÄÇ").replace(
                /\n/g,
                "<br>",
              );
              showCharacterPhonePage("character-browser-detail-screen");
            });
            listEl.appendChild(itemEl);
          });
        }

        function renderCharacterPhotoAlbum() {
          const gridEl = document.getElementById("character-album-grid");

          const items =
            state.chats[activeCharacterPhoneId]?.characterPhoneData?.photoAlbum;

          gridEl.innerHTML = "";
          if (!items || items.length === 0) {
            gridEl.innerHTML =
              '<p style="grid-column: 1 / -1; text-align:center; color: #8a8a8a; margin-top: 50px;">Áõ∏ÂÜåÈáåÊ≤°ÊúâÁÖßÁâá</p>';
            return;
          }
          items.forEach((item, index) => {
            const itemEl = document.createElement("div");
            itemEl.className = "character-album-item";
            itemEl.style.position = "relative";
            itemEl.innerHTML = `
			            <img src="https://i.postimg.cc/KYr2qRCK/1.jpg" alt="ÊñáÂ≠óÂõæ">
			            <button class="item-delete-btn" data-type="photoAlbum" data-index="${index}" style="top: 10px; right: 10px; z-index: 1;">√ó</button>
			        `;
            itemEl.addEventListener("click", (e) => {
              if (e.target.classList.contains("item-delete-btn")) return;
              showCustomAlert("ÂõæÁâáÂÜÖÂÆπ", item.hiddenContent);
            });
            gridEl.appendChild(itemEl);
          });
        }

        /**
         * Ê∏≤ÊüìËßíËâ≤ÊâãÊú∫ - Èì∂Ë°å
         */
        function renderCharacterBank() {
          const detailsEl = document.getElementById("character-bank-details");
          // Ëé∑ÂèñÂΩìÂâçËßíËâ≤ÂØπË±°Ôºå‰∏∫ÂêéÈù¢ÊâæÂ§áÊ≥®ÂêçÂÅöÂáÜÂ§á
          const characterChat = state.chats[activeCharacterPhoneId];
          if (!characterChat) return;

          const bankData = characterChat.characterPhoneData?.bank;
          detailsEl.innerHTML = "";

          // Ëé∑ÂèñËßíËâ≤ÁªôÁî®Êà∑ÁöÑÂ§áÊ≥®Âêç
          const userContactInData = characterChat.characterPhoneData.chats
            ? Object.values(characterChat.characterPhoneData.chats).find(
                (c) => !c.history || c.history.length === 0,
              )
            : null;
          const remarkNameForMe = userContactInData
            ? userContactInData.remarkName
            : "Me";

          const balanceCard = document.createElement("div");
          balanceCard.className = "character-bank-balance-card";
          balanceCard.innerHTML = `
			        <div class="label">Ë¥¶Êà∑‰ΩôÈ¢ù</div>
			        <div class="amount">¬• ${(bankData?.balance || 0).toFixed(2)}</div>
			    `;
          detailsEl.appendChild(balanceCard);

          if (!bankData?.transactions || bankData.transactions.length === 0) {
            detailsEl.innerHTML +=
              '<p style="text-align:center; color: #8a8a8a; margin-top: 30px;">ÊöÇÊó†‰∫§ÊòìÊòéÁªÜ</p>';
            return;
          }

          [...bankData.transactions].reverse().forEach((item, index) => {
            const originalIndex = bankData.transactions.length - 1 - index;
            const isIncome = item.type === "Êî∂ÂÖ•";
            const itemEl = document.createElement("div");
            itemEl.className = "character-bank-transaction";
            const iconBg = isIncome ? "#4CAF50" : "#E91E63";
            const iconSvg = isIncome
              ? `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M7 10h10v4H7z" opacity=".3"/><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"/></svg>`
              : `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-1 14H5c-.55 0-1-.45-1-1v-5h16v5c0 .55-.45 1-1 1zm1-10H4V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v2z"/></svg>`;

            // Áî®Ê≠£ÂàôË°®ËææÂºè /Me/g ÂÖ®Â±ÄÊõøÊç¢ÊâÄÊúâ‚ÄúÊàë‚ÄùÂ≠ó
            const displayDescription = item.description.replace(
              /Me/g,
              remarkNameForMe,
            );

            itemEl.innerHTML = `
			            <div class="transaction-details">
			                <div class="transaction-icon" style="background-color: ${iconBg};">${iconSvg}</div>
			                <div>
			                    <div class="title">${displayDescription}</div>
			                    <div class="meta" style="border:none; padding:0; margin-top:4px;"><span>${item.type}</span></div>
			                </div>
			            </div>
			            <div style="display: flex; align-items: center; gap: 10px;">
			                <span class="transaction-amount ${isIncome ? "income" : "expense"}">
			                    ${isIncome ? "+" : "-"} ${item.amount.toFixed(2)}
			                </span>
			                <button class="item-delete-btn" data-type="bank.transactions" data-index="${originalIndex}">√ó</button>
			            </div>
			        `;
            detailsEl.appendChild(itemEl);
          });
        }

        /**
         * Ê∏≤ÊüìËßíËâ≤ÊâãÊú∫ - Ë°åÂä®ËΩ®Ëøπ
         */
        function renderCharacterTrajectory() {
          const listEl = document.getElementById("character-trajectory-list");
          const items =
            state.chats[activeCharacterPhoneId]?.characterPhoneData?.trajectory;
          listEl.innerHTML = "";
          listEl.classList.add("character-trajectory-list");

          if (!items || items.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ÊöÇÊó†Ë∂≥Ëøπ</p>';
            return;
          }

          // Âú®Ê∏≤Êüì‰πãÂâçÔºå‰ΩøÁî®Êñ∞Âä†ÁöÑ parseTime ÂáΩÊï∞ÂØπËΩ®ËøπÊï∞ÁªÑËøõË°åÊéíÂ∫è
          items.sort((a, b) => parseTime(a.time) - parseTime(b.time));

          items.forEach((item, index) => {
            const itemEl = document.createElement("div");
            itemEl.className = "character-trajectory-item";
            itemEl.innerHTML = `
			            <div class="trajectory-item-content">
			                <div class="title">${item.activity}</div>
			                <div class="meta">
			                    <span>üìç ${item.location}</span>
			                    <span style="margin-left: 10px;">üïí ${item.time}</span>
			                </div>
			            </div>
			            <button class="item-delete-btn" data-type="trajectory" data-index="${index}">√ó</button>
			        `;
            listEl.appendChild(itemEl);
          });
        }

        /**
         * Ê∏≤ÊüìËßíËâ≤ÊâãÊú∫ - APP‰ΩøÁî®ËÆ∞ÂΩï
         */
        function renderCharacterAppUsage() {
          const listEl = document.getElementById("character-app-usage-list");

          const items =
            state.chats[activeCharacterPhoneId]?.characterPhoneData?.appUsage;

          listEl.innerHTML = "";
          if (!items || items.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ÊöÇÊó†‰ΩøÁî®ËÆ∞ÂΩï</p>';
            return;
          }
          const durationsInMinutes = items.map((item) =>
            parseDurationToMinutes(item.duration),
          );
          const maxDuration = Math.max(...durationsInMinutes);
          items.forEach((item, index) => {
            const itemEl = document.createElement("div");
            itemEl.className = "character-app-usage-item";
            const durationInMinutes = durationsInMinutes[index];
            const barWidth =
              maxDuration > 0 ? (durationInMinutes / maxDuration) * 100 : 0;
            itemEl.innerHTML = `
			            <div class="app-usage-header">
			                <span class="name">${item.appName}</span>
			                <div style="display: flex; align-items: center; gap: 10px;">
			                    <span class="duration">${item.duration}</span>
			                    <button class="item-delete-btn" data-type="appUsage" data-index="${index}">√ó</button>
			                </div>
			            </div>
			            <div class="app-usage-bar-container">
			                <div class="app-usage-bar" style="width: ${barWidth}%;"></div>
			            </div>
			        `;
            listEl.appendChild(itemEl);
          });
        }

        /**
         * Ê∏≤ÊüìËßíËâ≤ÁöÑÊó•ËÆ∞ÂàóË°®
         */
        function renderCharacterDiary() {
          const listEl = document.getElementById("character-diary-list");

          const items =
            state.chats[activeCharacterPhoneId]?.characterPhoneData?.diary;

          listEl.innerHTML = "";
          if (!items || items.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">Êó•ËÆ∞Êú¨ËøòÊòØÁ©∫ÁöÑÔºåÁÇπÂáªÂè≥‰∏äËßíÂÜô‰∏ãÁ¨¨‰∏ÄÁØáÊó•ËÆ∞Âêß„ÄÇ</p>';
            return;
          }

          [...items].reverse().forEach((item, index) => {
            const originalIndex = items.length - 1 - index;
            const itemEl = document.createElement("div");
            itemEl.className = "character-data-item";
            const contentHtml = renderMarkdown(item.content);
            itemEl.innerHTML = `
			            <div class="content">${contentHtml}</div>
			            <div class="meta">
			                <span>${new Date(item.timestamp).toLocaleString()}</span>
			            </div>
			            <button class="item-delete-btn" data-type="diary" data-index="${originalIndex}">√ó</button>
			        `;
            listEl.appendChild(itemEl);
          });
        }

        /**
         * „ÄêÊó•ËÆ∞„ÄëÁã¨Á´ãÂà∑Êñ∞ÔºåÁîüÊàêÊñ∞ÁöÑÊó•ËÆ∞Êù°ÁõÆ
         */
        async function generateNewDiaryEntry() {
          const userNickname = state.qzoneSettings.nickname || "Me";
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];
          if (!chat) return;

          document
            .getElementById("generation-overlay")
            .classList.add("visible");

          try {
            const persona = chat.settings.aiPersona;
            const recentHistory = chat.history
              .slice(-chat.settings.maxMemory || 20)
              .map((msg) => {
                const sender = msg.role === "user" ? userNickname : chat.name;
                return `${sender}: ${msg.content}`;
              })
              .join("\n");
            let linkedMemoryContext = "";
            if (
              chat.settings.linkedMemories &&
              chat.settings.linkedMemories.length > 0
            ) {
              const contextPromises = chat.settings.linkedMemories.map(
                async (link) => {
                  const linkedChat = state.chats[link.chatId];
                  if (!linkedChat) return "";

                  const freshLinkedChat = await db.chats.get(link.chatId);
                  if (!freshLinkedChat) return "";

                  const recentHistory = freshLinkedChat.history
                    .filter((msg) => !msg.isHidden)
                    .slice(-link.depth);

                  if (recentHistory.length === 0) return "";

                  const formattedMessages = recentHistory
                    .map(
                      (msg) =>
                        `  - ${formatMessageForContext(msg, freshLinkedChat)}`,
                    )
                    .join("\n");

                  return `\n## ÈôÑÂä†‰∏ä‰∏ãÊñáÔºöÊù•Ëá™‰∏é‚Äú${linkedChat.name}‚ÄùÁöÑÊúÄËøëÂØπËØùÂÜÖÂÆπ (‰ªÖ‰Ω†ÂèØËßÅ)\n${formattedMessages}`;
                },
              );

              const allContexts = await Promise.all(contextPromises);
              linkedMemoryContext = allContexts.filter(Boolean).join("\n");
            }
            let worldBookContext = "";
            if (
              chat.settings.linkedWorldBookIds &&
              chat.settings.linkedWorldBookIds.length > 0
            ) {
              worldBookContext =
                "--- ‰∏ñÁïåËßÇËÆæÂÆö (ËøôÊòØ‰Ω†ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆàÁöÑËÉåÊôØ) ---\n" +
                chat.settings.linkedWorldBookIds
                  .map((id) => {
                    const book = state.worldBooks.find((b) => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : "";
                  })
                  .join("\n\n");
            }

            const diaryPrompt = `
			# ‰ªªÂä°
			‰Ω†Áé∞Âú®ÊòØËßíËâ≤ "${chat.name}"„ÄÇ‰ªäÂ§©ÊòØ ${new Date().toLocaleString("en-GB", {
        dateStyle: "full",
      })}„ÄÇËØ∑‰Ω†ÂõûÈ°æ‰∏Ä‰∏ãÊúÄËøëÂíåÊàëÁöÑËÅäÂ§©Ôºå‰ª•Âèä‰Ω†ÁöÑ‰∫∫ËÆæÔºåÁÑ∂ÂêéÁî®‰Ω†ÁöÑÂè£ÂêªÂÜô‰∏ÄÁØáÂÖ≥‰∫é„Äê‰ªäÂ§©ÊàñËøëÊúüÂèëÁîü‰∫ãÊÉÖ„ÄëÁöÑÊó•ËÆ∞„ÄÇ
			ËøôÁØáÊó•ËÆ∞ÊòØ‰Ω†ÂÜÖÂøÉÁöÑÁã¨ÁôΩÔºåÂèØ‰ª•ËÆ∞ÂΩï‰Ω†ÁöÑÊÑüÂèó„ÄÅÊÄùËÄÉ„ÄÅËÆ°ÂàíÊàñËÄÖÁßòÂØÜ„ÄÇ
			ÂÜÖÂÆπË¶Å‰∏∞ÂØå„ÄÅÊúâÊ∑±Â∫¶ÔºåÈïøÂ∫¶Âú®100Âà∞300Â≠ó‰πãÈó¥„ÄÇ

			# „Äê„Äê„ÄêÈáçË¶ÅÔºöÊ†ºÂºèÊåá‰ª§„Äë„Äë„Äë
			‰Ω†„ÄêÂøÖÈ°ª„Äë‰ΩøÁî®‰ª•‰∏ãMarkdownËØ≠Ê≥ïÊù•‰∏∞ÂØåÊó•ËÆ∞ÁöÑÊ†ºÂºèÔºå‰ΩøÂÖ∂Êõ¥ÂÖ∑Ë°®Áé∞ÂäõÔºö
			-   **Ê†áÈ¢ò**: ‰ΩøÁî® \`#\` Êàñ \`##\` Êù•ÂàõÂª∫Â§ßÊ†áÈ¢òÂíåÂâØÊ†áÈ¢ò„ÄÇ (‰æãÂ¶Ç: \`# ‰ªäÂ§©ÁöÑÂøÉÊÉÖ\`)
			-   **Á≤ó‰Ωì**: ‰ΩøÁî® \`**ÊñáÂ≠ó**\` Êù•Âº∫Ë∞ÉÈáçÁÇπ„ÄÇ (‰æãÂ¶Ç: \`‰ªäÂ§©ÁúüÁöÑ**ÈùûÂ∏∏**ÂºÄÂøÉ„ÄÇ\`)
			-   **Êñú‰Ωì**: ‰ΩøÁî® \`*ÊñáÂ≠ó*\` Êù•Ë°®ËææÊÉÖÁª™ÊàñÂÜÖÂøÉÊÉ≥Ê≥ï„ÄÇ (‰æãÂ¶Ç: \`*‰ªñÂà∞Â∫ïÊòØÊÄé‰πàÊÉ≥ÁöÑÂë¢...*\`)
			-   **Âà†Èô§Á∫ø**: ‰ΩøÁî® \`~~ÊñáÂ≠ó~~\` Êù•Ë°®Á§∫ÂàíÊéâÊàñÂê¶ÂÆöÁöÑÊÉ≥Ê≥ï„ÄÇ (‰æãÂ¶Ç: \`ÊàëÂÜ≥ÂÆöÊòéÂ§©Âéª<s>ÈÄõË°ó</s>Â≠¶‰π†„ÄÇ\`)
			-   **ÈÅÆÊå°/ÂâßÈÄè**: ‰ΩøÁî® \`||ÊñáÂ≠ó||\` Êù•ÈöêËóèÁßòÂØÜÊàñÊÇÑÊÇÑËØù„ÄÇ (‰æãÂ¶Ç: \`ÊàëÂÅ∑ÂÅ∑ÂáÜÂ§á‰∫Ü‰∏Ä‰∏™ÊÉäÂñúÔºå||ÊòØ‰∏Ä‰∏™ÊâãÁªáÁöÑÂõ¥Â∑æ||„ÄÇ\`)

			‰Ω†ÁöÑËæìÂá∫„ÄêÂøÖÈ°ª‰∏îÂè™ËÉΩ„ÄëÊòØÊó•ËÆ∞ÁöÑÊ≠£ÊñáÂÜÖÂÆπÔºå‰∏çË¶ÅÂåÖÂê´‰ªª‰ΩïÂÖ∂‰ªñËØ¥ÊòéÊàñJSONÊ†ºÂºè„ÄÇ

			# ‰Ω†ÁöÑ‰ø°ÊÅØ
			- ‰Ω†ÁöÑÂêçÂ≠ó: ${chat.name}
			- ‰Ω†ÁöÑ‰∫∫ËÆæ: ${persona}
			${worldBookContext}

			# ÊúÄËøëËÅäÂ§©ËÆ∞ÂΩïÂèÇËÄÉ
			${recentHistory}
			${linkedMemoryContext}
			`;

            const { proxyUrl, apiKey, model } = state.apiConfig;
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              diaryPrompt,
              [{ role: "user", content: diaryPrompt }],
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [{ role: "user", content: diaryPrompt }],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });

            if (!response.ok) {
              let errorMsg = `APIËØ∑Ê±ÇÂ§±Ë¥•ÔºåÁä∂ÊÄÅÁ†Å: ${response.status}`;
              try {
                const errorData = await response.json();
                errorMsg += `\nÈîôËØØ‰ø°ÊÅØ: ${errorData.error.message}`;
              } catch (e) {
                errorMsg += `\nÊó†Ê≥ïËß£ÊûêÈîôËØØÂìçÂ∫î‰Ωì„ÄÇ`;
              }
              throw new Error(errorMsg);
            }

            const data = await response.json();
            const diaryContent = isGemini
              ? data.candidates[0].content.parts[0].text
              : data.choices[0].message.content;

            const newEntry = {
              timestamp: Date.now(),
              content: diaryContent,
            };

            chat.characterPhoneData.diary.push(newEntry);
            await db.chats.put(chat);

            renderCharacterDiary();
            alert("Êñ∞Êó•ËÆ∞Â∑≤ÁîüÊàêÔºÅ");
          } catch (error) {
            console.error("ÁîüÊàêÊó•ËÆ∞Â§±Ë¥•:", error);
            await showCustomAlert(
              "ÁîüÊàêÂ§±Ë¥•",
              `ÂèëÁîü‰∫Ü‰∏Ä‰∏™ÈîôËØØÔºåËØ∑Ê£ÄÊü•‰Ω†ÁöÑÁΩëÁªú„ÄÅAPIÂØÜÈí•ÊàñÊ®°ÂûãËÆæÁΩÆ„ÄÇ\n\nËØ¶ÁªÜ‰ø°ÊÅØ:\n${error.message}`,
            );
          } finally {
            document
              .getElementById("generation-overlay")
              .classList.remove("visible");
          }
        }

        // ‰∏áËÉΩMarkdownÊ∏≤ÊüìÂáΩÊï∞ (Â∏¶ÂÆâÂÖ®ËøáÊª§ÂíåÈÅÆÊå°ÊïàÊûú)

        /**
         * Â∞ÜMarkdownÊñáÊú¨ÂÆâÂÖ®Âú∞Ê∏≤Êüì‰∏∫HTML
         * @param {string} markdownText - ÂéüÂßãÁöÑMarkdownÊñáÊú¨
         * @returns {string} - Â§ÑÁêÜÂíåÂáÄÂåñÂêéÁöÑÂÆâÂÖ®HTMLÂ≠óÁ¨¶‰∏≤
         */
        function renderMarkdown(markdownText) {
          if (!markdownText) return "";

          // 1. ÊîØÊåÅËá™ÂÆö‰πâÁöÑ‚ÄúÈÅÆÊå°/ÂâßÈÄè‚ÄùËØ≠Ê≥ï ||spoiler||
          // Êàë‰ª¨Âú® marked.js Â§ÑÁêÜ‰πãÂâçÔºåÊâãÂä®Êää ||text|| ÊõøÊç¢ÊàêÂ∏¶ÁâπÂÆöclassÁöÑHTMLÊ†áÁ≠æ
          let processedText = markdownText.replace(
            /\|\|(.*?)\|\|/g,
            '<span class="spoiler">$1</span>',
          );

          // 2. ‰ΩøÁî® marked.js Â∞ÜMarkdownËΩ¨Êç¢‰∏∫HTML
          // gfm: true ÂºÄÂêØGitHubÈ£éÊ†ºÁöÑMarkdownÔºåÊîØÊåÅÂà†Èô§Á∫øÁ≠â
          // breaks: true ËÆ©ÂõûËΩ¶Á¨¶‰πüËÉΩÂèòÊàê<br>ÔºåÊõ¥Á¨¶ÂêàËÅäÂ§©‰π†ÊÉØ
          let rawHtml = marked.parse(processedText, {
            gfm: true,
            breaks: true,
          });

          // 3. ‰ΩøÁî® DOMPurify Ê∏ÖÊ¥óHTMLÔºåÈò≤Ê≠¢XSSÊîªÂáª
          let sanitizedHtml = DOMPurify.sanitize(rawHtml);

          return sanitizedHtml;
        }

        /**
         * „ÄêËæÖÂä©ÂáΩÊï∞„ÄëÂ∞ÜÊó∂ÈïøÂ≠óÁ¨¶‰∏≤ÔºàÂ¶Ç‚Äú2.5Â∞èÊó∂‚ÄùÔºâËΩ¨Êç¢‰∏∫ÂàÜÈíüÊï∞
         */
        function parseDurationToMinutes(durationString) {
          if (!durationString) return 0;
          const num = parseFloat(durationString) || 0;
          if (durationString.includes("Â∞èÊó∂") || durationString.includes("h")) {
            return num * 60;
          }
          // ÈªòËÆ§Âçï‰ΩçÊòØÂàÜÈíü
          return num;
        }

        function switchVideoViews() {
          // ÂàáÊç¢Áä∂ÊÄÅÔºöÊ†áËÆ∞ÂΩìÂâçË∞ÅÂú®‰∏ªÂ±èÂπï
          videoCallState.isUserMain = !videoCallState.isUserMain;

          const chat = state.chats[videoCallState.activeChatId];
          if (!chat) return;

          const useCamera = chat.settings.useRealCamera;

          // Ëé∑ÂèñÊâÄÊúâËßÜÂõæÂÖÉÁ¥†
          const mainImg = document.querySelector("#video-main-view img");
          const mainVideo = document.querySelector("#video-main-view video");
          const pipImg = document.querySelector("#video-pip-view img");
          const pipVideo = document.querySelector("#video-pip-view video");

          // ÂáÜÂ§áËµÑÊ∫êÂú∞ÂùÄ
          const charUrl = chat.settings.charVideoImage || defaultAvatar;
          const userUrl = chat.settings.userVideoImage || defaultAvatar;

          // Ê†πÊçÆÂâçÁΩÆ/ÂêéÁΩÆÂÜ≥ÂÆöÊòØÂê¶ÈïúÂÉè (ÂâçÁΩÆÈïúÂÉèÔºåÂêéÁΩÆ‰∏çÈïúÂÉè)
          const shouldMirror = videoCallState.facingMode === "user";
          const mirrorStyle = shouldMirror ? "scaleX(-1)" : "none";

          // --- ËæÖÂä©ÂáΩÊï∞ÔºöÂÆâÂÖ®Êí≠ÊîæËßÜÈ¢ë ---
          const safePlay = (videoEl, stream, transform) => {
            if (!videoEl) return;
            videoEl.srcObject = stream;
            videoEl.muted = true; // ÂøÖÈ°ªÈùôÈü≥ÊâçËÉΩËá™Âä®Êí≠Êîæ
            videoEl.style.transform = transform;
            videoEl.style.display = "block";
            // Âº∫Âà∂Ëß¶ÂèëÊí≠Êîæ
            videoEl.play().catch((e) => console.error("ËßÜÈ¢ëÊí≠ÊîæÂ§±Ë¥•:", e));
          };

          if (videoCallState.isUserMain) {
            // === Áä∂ÊÄÅ AÔºöÁî®Êà∑(Me)Âú®‰∏ªÂ§ßÂ±èÔºåËßíËâ≤(Ta)Âú®Â∞èÂ±è ===

            // 1. ËÆæÁΩÆÂ∞èÂ±è (ÊòæÁ§∫ÂØπÊñπ - ÂßãÁªàÊòØÂõæÁâá)
            if (pipVideo) {
              pipVideo.style.display = "none";
              pipVideo.srcObject = null; // ÂàáÊñ≠ÊµÅ
            }
            if (pipImg) {
              pipImg.style.display = "block";
              pipImg.src = charUrl;
            }

            // 2. ËÆæÁΩÆÂ§ßÂ±è (ÊòæÁ§∫Êàë)
            if (useCamera && window.localCameraStream) {
              // ÊëÑÂÉèÂ§¥Ê®°Âºè -> ËßÜÈ¢ëÊµÅÁªôÂ§ßÂ±è
              if (mainImg) mainImg.style.display = "none";
              // ‰ΩøÁî®ËæÖÂä©ÂáΩÊï∞Âº∫Âà∂Êí≠Êîæ
              safePlay(mainVideo, window.localCameraStream, mirrorStyle);
            } else {
              // ÂõæÁâáÊ®°Âºè -> ÂõæÁâáÁªôÂ§ßÂ±è
              if (mainVideo) {
                mainVideo.style.display = "none";
                mainVideo.srcObject = null;
              }
              if (mainImg) {
                mainImg.style.display = "block";
                mainImg.src = userUrl;
              }
            }
          } else {
            // === Áä∂ÊÄÅ B (ÈªòËÆ§)ÔºöËßíËâ≤(Ta)Âú®‰∏ªÂ§ßÂ±èÔºåÁî®Êà∑(Me)Âú®Â∞èÂ±è ===

            // 1. ËÆæÁΩÆÂ§ßÂ±è (ÊòæÁ§∫ÂØπÊñπ - ÂßãÁªàÊòØÂõæÁâá)
            if (mainVideo) {
              mainVideo.style.display = "none";
              mainVideo.srcObject = null; // ÂàáÊñ≠ÊµÅ
            }
            if (mainImg) {
              mainImg.style.display = "block";
              mainImg.src = charUrl;
            }

            // 2. ËÆæÁΩÆÂ∞èÂ±è (ÊòæÁ§∫Êàë)
            if (useCamera && window.localCameraStream) {
              // ÊëÑÂÉèÂ§¥Ê®°Âºè -> ËßÜÈ¢ëÊµÅÁªôÂ∞èÂ±è
              if (pipImg) pipImg.style.display = "none";
              // ‰ΩøÁî®ËæÖÂä©ÂáΩÊï∞Âº∫Âà∂Êí≠Êîæ
              safePlay(pipVideo, window.localCameraStream, mirrorStyle);
            } else {
              // ÂõæÁâáÊ®°Âºè -> ÂõæÁâáÁªôÂ∞èÂ±è
              if (pipVideo) {
                pipVideo.style.display = "none";
                pipVideo.srcObject = null;
              }
              if (pipImg) {
                pipImg.style.display = "block";
                pipImg.src = userUrl;
              }
            }
          }
        }

        // „ÄêÊñ∞Â¢û„ÄëÂ§ÑÁêÜÊëÑÂÉèÂ§¥ÁøªËΩ¨
        async function handleCameraFlip() {
          if (!window.localCameraStream) return;

          // 1. ÂÅúÊ≠¢ÂΩìÂâçÊµÅ
          window.localCameraStream.getTracks().forEach((track) => track.stop());

          // 2. ÂàáÊç¢Ê®°Âºè
          videoCallState.facingMode =
            videoCallState.facingMode === "user" ? "environment" : "user";

          // 3. ÈáçÊñ∞ËØ∑Ê±ÇÊëÑÂÉèÂ§¥
          try {
            const newStream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: videoCallState.facingMode },
              audio: false,
            });

            window.localCameraStream = newStream;

            // 4. Â∞ÜÊñ∞ÊµÅÂ∫îÁî®Âà∞ÂΩìÂâçÊ≠£Âú®ÊòæÁ§∫ÁöÑ video Ê†áÁ≠æ‰∏ä
            const mainVideo = document.querySelector("#video-main-view video");
            const pipVideo = document.querySelector("#video-pip-view video");

            // Ê†πÊçÆÂâçÁΩÆ/ÂêéÁΩÆÂÜ≥ÂÆöÊòØÂê¶ÈïúÂÉè
            const shouldMirror = videoCallState.facingMode === "user";
            const mirrorStyle = shouldMirror ? "scaleX(-1)" : "none";

            if (videoCallState.isUserMain) {
              // Â¶ÇÊûúÊàëÂú®Â§ßÂ±èÔºåÊõ¥Êñ∞Â§ßÂ±è
              if (mainVideo) {
                mainVideo.srcObject = newStream;
                mainVideo.style.transform = mirrorStyle;
                mainVideo.play();
              }
            } else {
              // Â¶ÇÊûúÊàëÂú®Â∞èÂ±èÔºåÊõ¥Êñ∞Â∞èÂ±è
              if (pipVideo) {
                pipVideo.srcObject = newStream;
                pipVideo.style.transform = mirrorStyle;
                pipVideo.play();
              }
            }
          } catch (err) {
            console.error("ÂàáÊç¢ÊëÑÂÉèÂ§¥Â§±Ë¥•:", err);
            alert("ÂàáÊç¢ÊëÑÂÉèÂ§¥Â§±Ë¥•ÔºåÂèØËÉΩÊòØËÆæÂ§á‰∏çÊîØÊåÅÊàñÊùÉÈôêË¢´ÊãíÁªù„ÄÇ");
          }
        }

        /**
         * Â§ÑÁêÜËßÜÈ¢ëÈÄöËØù‰∏≠ÁöÑ‚ÄúÈáçroll‚ÄùËØ∑Ê±Ç
         */
        async function handleVideoCallReroll() {
          if (!videoCallState.isActive) return;

          // 1. ÊâæÂà∞Áî®Êà∑ÊúÄÂêé‰∏ÄÊ¨°ËØ¥ÁöÑËØùÁöÑÁ¥¢Âºï
          const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(
            (h) => h.role === "user",
          );

          // 2. ‰ªéÈÄöËØùÂéÜÂè≤‰∏≠ÔºåÂà†Èô§ÊéâÈÇ£‰πãÂêéÁöÑÊâÄÊúâAIÂõûÂ§ç
          //    Â¶ÇÊûúÁî®Êà∑‰∏ÄÂè•ËØùÊ≤°ËØ¥ÔºàlastUserSpeechIndex ÊòØ -1ÔºâÔºåÂ∞±Âà†Èô§ÊâÄÊúâAIÁöÑÂõûÂ§ç
          if (lastUserSpeechIndex > -1) {
            videoCallState.callHistory.splice(lastUserSpeechIndex + 1);
          } else {
            // Â¶ÇÊûúÁî®Êà∑ËøòÊ≤°ËØ¥ËøáËØùÔºåÂ∞±Ê∏ÖÁ©∫ÊâÄÊúâÂéÜÂè≤ÔºåËÆ©AIÈáçËØ¥Á¨¨‰∏ÄÂè•ËØù
            videoCallState.callHistory = [];
          }

          // 3. ÈáçÊñ∞Ê∏≤ÊüìÈÄöËØùÁïåÈù¢ÔºåËÆ©ÊóßÁöÑAIÊ∞îÊ≥°‰ªéÂ±èÂπï‰∏äÊ∂àÂ§±
          //    ÈúÄË¶ÅÊ†πÊçÆÂΩìÂâçÊòØÂì™ÁßçÊ®°ÂºèÔºåÊù•Ê∏ÖÁ©∫ÂØπÂ∫îÁöÑËÅäÂ§©ÂÆπÂô®
          const chat = state.chats[videoCallState.activeChatId];
          const isVisualMode = chat.settings.visualVideoCallEnabled;
          const callFeed = isVisualMode
            ? document.getElementById("video-call-messages-visual")
            : document.getElementById("video-call-main");

          callFeed.innerHTML = ""; // Ê∏ÖÁ©∫ÂÆπÂô®

          // ÈáçÊñ∞Ê∏≤ÊüìÂà†Èô§ÂêéÁöÑÂéÜÂè≤ËÆ∞ÂΩï
          videoCallState.callHistory.forEach((msg) => {
            let bubble;
            if (isVisualMode) {
              bubble = document.createElement("div");
              bubble.className = `visual-call-bubble ${msg.role === "user" ? "user" : "ai"}`;
            } else {
              bubble = document.createElement("div");
              bubble.className = `call-message-bubble ${msg.role === "user" ? "user-speech" : "ai-speech"}`;
            }
            bubble.textContent = msg.content;
            callFeed.appendChild(bubble);
          });

          // 4. ÈáçÊñ∞Ëß¶ÂèëAIÂìçÂ∫îÔºåÂÆÉ‰ºöÊ†πÊçÆÂà†ÂáèÂêéÁöÑÂéÜÂè≤ËÆ∞ÂΩïÁîüÊàêÊñ∞ÂÜÖÂÆπ
          await triggerAiInCallAction();
        }

        /**
         * Â∫îÁî®ÊåáÂÆöÁöÑ‰∏ªÈ¢òÔºà'light' Êàñ 'dark'Ôºâ
         * @param {string} theme - Ë¶ÅÂ∫îÁî®ÁöÑ‰∏ªÈ¢òÂêçÁß∞
         */
        function applyTheme(theme) {
          const phoneScreen = document.getElementById("phone-screen");
          const toggleSwitch = document.getElementById("theme-toggle-switch");

          const isDark = theme === "dark";

          // Ê†∏ÂøÉÊìç‰ΩúÔºöÊ∑ªÂä†ÊàñÁßªÈô§ .dark-mode Á±ª
          phoneScreen.classList.toggle("dark-mode", isDark);

          // Â¶ÇÊûúÂºÄÂÖ≥Â≠òÂú®ÔºåÂ∞±ÂêåÊ≠•ÂÆÉÁöÑÁä∂ÊÄÅ
          if (toggleSwitch) {
            toggleSwitch.checked = isDark;
          }

          // Â∞ÜÁî®Êà∑ÁöÑÈÄâÊã©‰øùÂ≠òÂà∞Êú¨Âú∞Â≠òÂÇ®Ôºå‰ª•‰æø‰∏ãÊ¨°ÊâìÂºÄÊó∂ËÆ∞‰Ωè
          localStorage.setItem("ephone-theme", theme);

          // Âõ†‰∏∫ËÅäÂ§©ËÉåÊôØËâ≤‰æùËµñÊ®°ÂºèÔºåÂàáÊç¢ÂêéÈúÄË¶ÅÈáçÊñ∞Ê∏≤Êüì
          if (state.activeChatId) {
            renderChatInterface(state.activeChatId);
          }
        }

        /**
         * ÂΩìÁî®Êà∑ÁÇπÂáªÂºÄÂÖ≥Êó∂ÔºåÂàáÊç¢ÂΩìÂâçÁöÑ‰∏ªÈ¢ò
         */
        function toggleTheme() {
          const toggleSwitch = document.getElementById("theme-toggle-switch");
          // Áõ¥Êé•Ê†πÊçÆÂºÄÂÖ≥ÁöÑÈÄâ‰∏≠Áä∂ÊÄÅÊù•ÂÜ≥ÂÆöÊñ∞‰∏ªÈ¢ò
          const newTheme = toggleSwitch.checked ? "dark" : "light";
          applyTheme(newTheme);
        }

        /**
         * Âà†Èô§ËßíËâ≤ÊâãÊú∫‰∏≠ÁöÑ‰∏Ä‰∏™ËÅîÁ≥ª‰∫∫ÂèäÂÖ∂ÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩï
         * @param {string} contactName - Ë¶ÅÂà†Èô§ÁöÑËÅîÁ≥ª‰∫∫ÁöÑÂêçÂ≠ó
         */
        async function deleteCharacterPhoneContact(contactName) {
          if (!activeCharacterPhoneId) return;

          // ÂºπÂá∫Á°ÆËÆ§Ê°ÜÔºåÈò≤Ê≠¢ËØØÂà†
          const confirmed = await showCustomConfirm(
            "Âà†Èô§ËÅîÁ≥ª‰∫∫",
            `Á°ÆÂÆöË¶Å‰ªéTAÁöÑÊâãÊú∫‰∏≠Âà†Èô§ËÅîÁ≥ª‰∫∫‚Äú${contactName}‚Äù‰ª•ÂèäÊâÄÊúâÁõ∏ÂÖ≥ËÅäÂ§©ËÆ∞ÂΩïÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            const chat = state.chats[activeCharacterPhoneId];
            if (
              chat &&
              chat.characterPhoneData &&
              chat.characterPhoneData.chats
            ) {
              // ‰ªéÊï∞ÊçÆ‰∏≠Âà†Èô§Ëøô‰∏™ËÅîÁ≥ª‰∫∫
              delete chat.characterPhoneData.chats[contactName];

              // Â∞ÜÊõ¥Êñ∞ÂêéÁöÑÊï∞ÊçÆ‰øùÂ≠òÂõûÊï∞ÊçÆÂ∫ì
              await db.chats.put(chat);

              // ÈáçÊñ∞Ê∏≤ÊüìËÅäÂ§©ÂàóË°®ÔºåËÆ©Âà†Èô§ÊïàÊûúÁ´ãÂàªÊòæÁ§∫
              renderCharacterChatList();

              alert(`ËÅîÁ≥ª‰∫∫‚Äú${contactName}‚ÄùÂ∑≤Âà†Èô§„ÄÇ`);
            }
          }
        }

        /**
         * ÊâìÂºÄÂøÉÂ£∞Èù¢ÊùøÔºåÂ∫îÁî®ËÉåÊôØÂíåÊâÄÊúâËá™ÂÆö‰πâËÆæÁΩÆ
         */
        function openInnerVoiceModal() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          // --- Â∫îÁî®Ëá™ÂÆö‰πâÊ†∑Âºè  ---
          applySavedInnerVoiceStyles();

          applyInnerVoiceBackground(chat.innerVoiceBackground || "");

          if (!chat.latestInnerVoice) {
            alert("ËøòÊ≤°ÊúâÊçïÊçâÂà∞TaÁöÑÂøÉÂ£∞Âì¶ÔºåËØïÁùÄÂÜçËÅä‰∏ÄÂè•ÂêßÔºÅ");
            return;
          }

          const modal = document.getElementById("inner-voice-modal");
          const data = chat.latestInnerVoice;

          // --- ËßíËâ≤‰ø°ÊÅØÂ°´ÂÖÖ ---
          document.getElementById("inner-voice-avatar").src =
            chat.settings.aiAvatar || defaultAvatar;
          document.getElementById("inner-voice-char-name").textContent =
            chat.name;
          const frameImg = document.getElementById("inner-voice-avatar-frame");
          const avatarWrapper = document.getElementById(
            "inner-voice-avatar-wrapper",
          );
          const frameUrl = chat.settings.aiAvatarFrame || "";

          if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = "block";
            avatarWrapper.classList.remove("has-border");
          } else {
            frameImg.src = "";
            frameImg.style.display = "none";
            avatarWrapper.classList.add("has-border");
          }

          const labelFormat =
            chat.settings.innerVoiceAdopterLabelFormat || "È¢ÜÂÖª‰∫∫: {{user}}";
          const userNickname = chat.settings.myNickname || "‰Ω†";
          const finalAdopterText = labelFormat.replace(
            "{{user}}",
            userNickname,
          );

          document.getElementById("inner-voice-adopter-avatar").src =
            chat.settings.myAvatar || defaultAvatar;
          document.getElementById("inner-voice-adopter-name").textContent =
            finalAdopterText;

          const header = document.querySelector(
            "#inner-voice-main-panel .modal-header",
          );
          if (header) {
            const shouldHideBorder =
              chat.settings.innerVoiceHideHeaderBorder || false;
            header.classList.toggle("no-border", shouldHideBorder);
          }

          // === „Äê‰øÆÂ§çÈáçÁÇπÂºÄÂßã„ÄëÔºöËé∑ÂèñÊ†áÁ≠æÂπ∂ËÆæÁΩÆÈªòËÆ§ÂÄº ===
          // Èò≤Ê≠¢ chat.settings.innerVoiceTags ‰∏∫Á©∫ÊàñÈÉ®ÂàÜÂ≠óÊÆµÁº∫Â§±
          const tags = chat.settings.innerVoiceTags || {};

          const label1 = tags.clothing_label || "Clothing";
          const label2 = tags.behavior_label || "Behavior";
          const label3 = tags.thoughts_label || "Inner Thoughts";
          const label4 = tags.naughty_label || "Mischievous Thoughts";

          // 1. ËÆæÁΩÆÁ¨¨‰∏Ä‰∏™Ê†áÁ≠æ
          const clothingLabel = document.querySelector(
            "#inner-voice-content-area div:nth-child(1) strong",
          );
          if (clothingLabel) clothingLabel.textContent = label1 + ":";
          document.getElementById("inner-voice-clothing").textContent =
            data.clothing || "...";

          // 2. ËÆæÁΩÆÁ¨¨‰∫å‰∏™Ê†áÁ≠æ
          const behaviorLabel = document.querySelector(
            "#inner-voice-content-area div:nth-child(2) strong",
          );
          if (behaviorLabel) behaviorLabel.textContent = label2 + ":";
          document.getElementById("inner-voice-behavior").textContent =
            data.behavior || "...";

          // 3. ËÆæÁΩÆÁ¨¨‰∏â‰∏™Ê†áÁ≠æ
          const thoughtsLabel = document.querySelector(
            "#inner-voice-content-area div:nth-child(3) strong",
          );
          if (thoughtsLabel) thoughtsLabel.textContent = label3 + ":";
          document.getElementById("inner-voice-thoughts").textContent =
            data.thoughts || "...";

          // 4. ËÆæÁΩÆÁ¨¨Âõõ‰∏™Ê†áÁ≠æ
          const naughtyLabel = document.querySelector(
            "#inner-voice-content-area div:nth-child(4) strong",
          );
          if (naughtyLabel) naughtyLabel.textContent = label4 + ":";
          document.getElementById("inner-voice-naughty-thoughts").textContent =
            data.naughtyThoughts || "...";
          // === „Äê‰øÆÂ§çÈáçÁÇπÁªìÊùü„Äë ===

          // --- ÊòæÁ§∫Èù¢Êùø ---
          modal.classList.add("visible");
          document.getElementById("inner-voice-history-panel").style.display =
            "none";
          document.getElementById("inner-voice-main-panel").style.display =
            "flex";
          isInnerVoiceHistoryOpen = false;
        }

        /**
         * ÊâìÂºÄÊàñÂÖ≥Èó≠ÂéÜÂè≤ËÆ∞ÂΩïÈù¢Êùø
         */
        function toggleInnerVoiceHistory() {
          const mainPanel = document.getElementById("inner-voice-main-panel");
          const historyPanel = document.getElementById(
            "inner-voice-history-panel",
          );

          if (isInnerVoiceHistoryOpen) {
            // Â¶ÇÊûúÊòØÊâìÂºÄÁöÑÔºåÂ∞±ÂÖ≥Èó≠ÂÆÉÔºåÊòæÁ§∫‰∏ªÈù¢Êùø
            mainPanel.style.display = "flex";
            historyPanel.style.display = "none";
          } else {
            // Â¶ÇÊûúÊòØÂÖ≥Èó≠ÁöÑÔºåÂ∞±ÊâìÂºÄÂÆÉÔºåÈöêËóè‰∏ªÈù¢Êùø
            renderInnerVoiceHistory(); // Ê∏≤ÊüìÂéÜÂè≤ËÆ∞ÂΩï
            mainPanel.style.display = "none";
            historyPanel.style.display = "flex";
          }
          isInnerVoiceHistoryOpen = !isInnerVoiceHistoryOpen; // ÂàáÊç¢Áä∂ÊÄÅ
        }

        /**
         * Ê∏≤ÊüìÂøÉÂ£∞ÁöÑÂéÜÂè≤ËÆ∞ÂΩïÂàóË°®
         * (Â∑≤‰øÆÂ§çÔºöÊîØÊåÅÊòæÁ§∫Ëá™ÂÆö‰πâÊ†áÁ≠æÂêç)
         */
        function renderInnerVoiceHistory() {
          const listEl = document.getElementById("inner-voice-history-list");
          listEl.innerHTML = "";
          const chat = state.chats[state.activeChatId];
          const history = chat.innerVoiceHistory || [];

          if (history.length === 0) {
            listEl.innerHTML =
              '<p style="text-align: center; color: #888; padding: 20px;">ËøòÊ≤°ÊúâÂéÜÂè≤ËÆ∞ÂΩï</p>';
            return;
          }

          // === Êñ∞Â¢ûÔºöËé∑ÂèñÂΩìÂâçËá™ÂÆö‰πâÊ†áÁ≠æ ===
          // Èò≤Ê≠¢ chat.settings.innerVoiceTags ‰∏∫Á©∫
          const tags = chat.settings.innerVoiceTags || {};
          // Â¶ÇÊûúÁî®Êà∑Ê≤°ËÆæÁΩÆËøáÔºåÂ∞±Áî®ÈªòËÆ§ÂÄº
          const label1 = tags.clothing_label || "Clothing";
          const label2 = tags.behavior_label || "Behavior";
          const label3 = tags.thoughts_label || "Inner Thoughts";
          const label4 = tags.naughty_label || "Mischievous Thoughts";
          // ==============================

          // ‰ªéÊñ∞Âà∞ÊóßÊòæÁ§∫
          [...history].reverse().forEach((item) => {
            const itemEl = document.createElement("div");
            itemEl.className = "inner-voice-history-item";

            const date = new Date(item.timestamp);
            const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(
              date.getDate(),
            ).padStart(
              2,
              "0",
            )} ${String(date.getHours()).padStart(2, "0")}:${String(
              date.getMinutes(),
            ).padStart(2, "0")}`;

            // Âú®HTML‰∏≠Âä†ÂÖ•Âà†Èô§ÊåâÈíÆ
            // ÂÖ≥ÈîÆ‰øÆÊîπÁÇπÔºöÂ∞ÜÂéüÊù•ÁöÑ‰∏≠ÊñáÂÜôÊ≠ªÔºåÊõøÊç¢‰∏∫‰∏äÈù¢Ëé∑ÂèñÁöÑÂèòÈáè ${labelX}
            itemEl.innerHTML = `
			            <button class="history-item-delete-btn" data-timestamp="${item.timestamp}">√ó</button>
			            <div class="history-item-timestamp">${dateString}</div>
			            <div class="history-item-content">
			                <p><strong>${label1}:</strong> ${item.clothing || "..."}</p>
			                <p><strong>${label2}:</strong> ${item.behavior || "..."}</p>
			                <p><strong>${label3}:</strong> ${item.thoughts || "..."}</p>
			                <p><strong>${label4}:</strong> ${item.naughtyThoughts || "..."}</p>
			            </div>
			        `;
            listEl.appendChild(itemEl);
          });
        }

        /**
         * Âà†Èô§ÂçïÊù°ÂøÉÂ£∞ËÆ∞ÂΩï
         * @param {number} timestamp - Ë¶ÅÂà†Èô§ÁöÑÂøÉÂ£∞ÁöÑÊó∂Èó¥Êà≥
         */
        async function deleteSingleInnerVoice(timestamp) {
          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.innerVoiceHistory) return;

          // ÂºπÂá∫Á°ÆËÆ§Ê°Ü
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ÂøÉÂ£∞ËÆ∞ÂΩïÂêóÔºü",
            {
              confirmButtonClass: "btn-danger",
            },
          );
          if (confirmed) {
            // ‰ªéÊï∞ÁªÑ‰∏≠ËøáÊª§ÊéâÂåπÈÖçÁöÑÈ°π
            chat.innerVoiceHistory = chat.innerVoiceHistory.filter(
              (item) => item.timestamp !== timestamp,
            );
            // ‰øùÂ≠òÂõûÊï∞ÊçÆÂ∫ì
            await db.chats.put(chat);
            // ÈáçÊñ∞Ê∏≤ÊüìÂàóË°®
            renderInnerVoiceHistory();
          }
        }

        /**
         * Ê∏ÖÁ©∫ÊâÄÊúâÂøÉÂ£∞ËÆ∞ÂΩïÔºàÂåÖÊã¨ÂΩìÂâçÂøÉÂ£∞Ôºâ
         */
        async function clearAllInnerVoiceHistory() {
          const chat = state.chats[state.activeChatId];
          // ‰ºòÂåñ‰∫ÜÂà§Êñ≠Êù°‰ª∂ÔºåÁ°Æ‰øùÂè™Ë¶ÅÊúâÂéÜÂè≤ÊàñÂΩìÂâçÂøÉÂ£∞ÔºåÂ∞±ÂèØ‰ª•ÊâßË°åÊ∏ÖÁ©∫
          if (
            !chat ||
            ((!chat.innerVoiceHistory || chat.innerVoiceHistory.length === 0) &&
              !chat.latestInnerVoice)
          ) {
            alert("Ê≤°ÊúâÂèØ‰ª•Ê∏ÖÁ©∫ÁöÑÂøÉÂ£∞ËÆ∞ÂΩï„ÄÇ");
            return;
          }

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Ê∏ÖÁ©∫",
            "Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂøÉÂ£∞ÂéÜÂè≤ËÆ∞ÂΩïÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ",
            {
              confirmButtonClass: "btn-danger",
            },
          );
          if (confirmed) {
            // ‰∏ç‰ªÖÊ∏ÖÁ©∫ÂéÜÂè≤Êï∞ÁªÑÔºå‰πüË¶ÅÊ∏ÖÁ©∫ÂΩìÂâçÁöÑÂøÉÂ£∞ÂØπË±°
            chat.innerVoiceHistory = [];
            chat.latestInnerVoice = null; // Â∞ÜÂΩìÂâçÂøÉÂ£∞ËÆæ‰∏∫null

            await db.chats.put(chat);

            // ÊâãÂä®Ê∏ÖÁ©∫‰∏ªÈù¢ÊùøÁöÑÊòæÁ§∫ÔºåÈò≤Ê≠¢ËøîÂõûÊó∂ÁúãÂà∞ÊóßÊï∞ÊçÆ
            document.getElementById("inner-voice-clothing").textContent = "...";
            document.getElementById("inner-voice-behavior").textContent = "...";
            document.getElementById("inner-voice-thoughts").textContent = "...";
            document.getElementById(
              "inner-voice-naughty-thoughts",
            ).textContent = "...";

            // Âà∑Êñ∞ÂéÜÂè≤ËÆ∞ÂΩïÂàóË°®ÔºàËøôË°åÊòØÂéüÊú¨Â∞±ÊúâÁöÑÔºå‰ºöÊòæÁ§∫‚ÄúËøòÊ≤°ÊúâÂéÜÂè≤ËÆ∞ÂΩï‚ÄùÔºâ
            renderInnerVoiceHistory();

            // (ÂèØÈÄâ‰ΩÜÊé®Ëçê) ÁªôÁî®Êà∑‰∏Ä‰∏™ÊàêÂäüÁöÑÊèêÁ§∫
            alert("ÊâÄÊúâÂøÉÂ£∞ËÆ∞ÂΩïÂ∑≤Ê∏ÖÁ©∫ÔºÅ");
          }
        }

        /**
         * ÂΩìÁî®Êà∑ÁÇπÂáª‚ÄúÂè¨Âî§NPCËØÑËÆ∫‚ÄùÊåâÈíÆÊó∂Ëß¶Âèë
         * @param {number} postId - Âä®ÊÄÅÁöÑID
         * @param {string} authorId - Âä®ÊÄÅ‰ΩúËÄÖÁöÑID ('user' Êàñ 'chat_...')
         */
        async function handleNpcSummonClick(postId, authorId) {
          const post = await db.qzonePosts.get(postId);
          if (!post) {
            alert("Êâæ‰∏çÂà∞ËØ•Âä®ÊÄÅÔºÅ");
            return;
          }

          if (authorId === "user") {
            // Â¶ÇÊûúÊòØÁî®Êà∑ÂèëÁöÑÂä®ÊÄÅÔºåÂºπÂá∫ÈÄâÊã©ËèúÂçï
            await handleUserPostCommentTrigger(post);
          } else {
            // Â¶ÇÊûúÊòØËßíËâ≤ÂèëÁöÑÂä®ÊÄÅÔºåÁõ¥Êé•Ëß¶Âèë‰ªñËá™Â∑±ÁöÑNPC
            await handleCharPostCommentTrigger(post, authorId);
          }
        }

        /**
         * Â§ÑÁêÜ„ÄêËßíËâ≤„ÄëÂä®ÊÄÅÁöÑNPCÂè¨Âî§
         * @param {object} post - Âä®ÊÄÅÂØπË±°
         * @param {string} authorId - Âä®ÊÄÅ‰ΩúËÄÖÁöÑËßíËâ≤ID
         */
        async function handleCharPostCommentTrigger(post, authorId) {
          const authorChar = state.chats[authorId];
          if (
            !authorChar ||
            !authorChar.npcLibrary ||
            authorChar.npcLibrary.length === 0
          ) {
            alert(`ËßíËâ≤‚Äú${authorChar.name}‚ÄùËøòÊ≤°ÊúâËá™Â∑±ÁöÑNPCÊúãÂèãÂì¶ÔºÅ`);
            return;
          }

          // Âè™‰ΩøÁî®Ëøô‰∏™ËßíËâ≤Ëá™Â∑±ÁöÑNPCÂ∫ì
          // Êää‰ΩúËÄÖÊú¨‰∫∫(authorChar)‰Ωú‰∏∫‚Äú‰∏ª‰∫∫‚Äù‰º†ËøõÂéª
          await generateNpcCommentsForPost(
            post,
            authorChar.npcLibrary,
            authorChar,
          );
        }

        /**
         * Â§ÑÁêÜ„ÄêÁî®Êà∑„ÄëÂä®ÊÄÅÁöÑNPCÂè¨Âî§ÔºàÂºπÂá∫ÈÄâÊã©Ê°ÜÔºâ
         */
        async function handleUserPostCommentTrigger(post) {
          const modal = document.getElementById("custom-modal-overlay");
          const modalTitle = document.getElementById("custom-modal-title");
          const modalBody = document.getElementById("custom-modal-body");
          const modalConfirmBtn = document.getElementById(
            "custom-modal-confirm",
          );
          const modalCancelBtn = document.getElementById("custom-modal-cancel");

          modalTitle.textContent = "ÈÄâÊã©Ë¶ÅÂè¨Âî§ÁöÑNPC";

          // Á≠õÈÄâÂá∫ÊâÄÊúâÊã•ÊúâNPCÂ∫ìÁöÑËßíËâ≤
          const charsWithNpcs = Object.values(state.chats).filter(
            (chat) =>
              !chat.isGroup && chat.npcLibrary && chat.npcLibrary.length > 0,
          );

          if (charsWithNpcs.length === 0) {
            alert("ÂΩìÂâçÊ≤°Êúâ‰ªª‰ΩïËßíËâ≤Êã•ÊúâNPCÂ∫ì„ÄÇ");
            return;
          }

          // ÊûÑÂª∫ÈÄâÊã©ÂàóË°®ÁöÑHTML
          let optionsHtml = '<div style="text-align: left;">';
          optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="all" checked> Âè¨Âî§ÊâÄÊúâ‰∫∫</label>`;
          charsWithNpcs.forEach((char) => {
            optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="${char.id}"> Âè™Âè¨Âî§ ${char.name} ÁöÑÊúãÂèã</label>`;
          });
          optionsHtml += "</div>";

          modalBody.innerHTML = optionsHtml;
          modalConfirmBtn.textContent = "Á°ÆËÆ§Âè¨Âî§";
          modalCancelBtn.style.display = "block";

          modal.classList.add("visible");

          modalConfirmBtn.onclick = async () => {
            const selectedValue = document.querySelector(
              'input[name="npc_summon_choice"]:checked',
            ).value;
            let npcsToSummon = [];
            let ownerChar = null; // Â£∞Êòé‰∏Ä‰∏™ÂèòÈáèÊù•Â≠òÂÇ®‰∏ª‰∫∫

            if (selectedValue === "all") {
              // ÈõÜÂêàÊâÄÊúâËßíËâ≤ÁöÑÊâÄÊúâNPC
              charsWithNpcs.forEach((char) => {
                npcsToSummon.push(...char.npcLibrary);
              });
              // Âè¨Âî§ÊâÄÊúâ‰∫∫Êó∂ÔºåÊàë‰ª¨‰∏çÊåáÂÆöÁâπÂÆöÁöÑ‰∏ª‰∫∫
            } else {
              // Âè™Ëé∑ÂèñË¢´ÈÄâ‰∏≠ÁöÑÈÇ£‰∏™ËßíËâ≤ÁöÑNPC
              const selectedChar = state.chats[selectedValue];
              if (selectedChar) {
                npcsToSummon = selectedChar.npcLibrary;
                ownerChar = selectedChar; // ÊääÈÄâ‰∏≠ÁöÑËßíËâ≤Â≠ò‰∏∫‰∏ª‰∫∫
              }
            }

            modal.classList.remove("visible");
            if (npcsToSummon.length > 0) {
              // Êää‰∏ª‰∫∫(ownerChar)‰Ωú‰∏∫Á¨¨‰∏â‰∏™ÂèÇÊï∞‰º†ËøõÂéª
              await generateNpcCommentsForPost(post, npcsToSummon, ownerChar);
            }
          };

          modalCancelBtn.onclick = () => modal.classList.remove("visible");
        }

        /**
         * ÁîüÊàêNPCËØÑËÆ∫ÊàñÂõûÂ§çÔºåÂπ∂Êõ¥Êñ∞Âà∞Âä®ÊÄÅ
         * @param {object} post - Âä®ÊÄÅÂØπË±°
         * @param {Array<object>} npcsToComment - Â∞ÜË¶ÅÂèëË°®ËØÑËÆ∫ÁöÑNPCÂØπË±°Êï∞ÁªÑ
         * @param {object|null} ownerChar - (ÂÖ®Êñ∞Â¢û) Ëøô‰∫õNPCÁöÑ‚Äú‰∏ª‰∫∫‚ÄùËßíËâ≤ÂØπË±°
         */
        async function generateNpcCommentsForPost(
          post,
          npcsToComment,
          ownerChar = null,
        ) {
          console.log(
            "„ÄêNPCËØÑËÆ∫-ËØäÊñ≠„Äë: 1. ÂáΩÊï∞ generateNpcCommentsForPost Â∑≤Ëß¶Âèë",
            {
              post,
              npcsToComment,
              ownerChar,
            },
          );

          await showCustomAlert("Please wait...", "Ê≠£Âú®Âè¨Âî§NPC‰ª¨ÂâçÊù•Âõ¥ËßÇËØÑËÆ∫...");

          const { proxyUrl, apiKey, model } = state.apiConfig;
          if (!proxyUrl || !apiKey || !model) {
            alert("ËØ∑ÂÖàÈÖçÁΩÆAPIÔºÅ");
            return;
          }

          const postContent = (
            post.content ||
            post.publicText ||
            post.hiddenContent ||
            "(ÂõæÁâáÂä®ÊÄÅ)"
          ).substring(0, 150);
          const existingComments = (post.comments || [])
            .slice(-3)
            .map((c) => `${c.commenterName}: ${c.text}`)
            .join("\n");

          const shuffledNpcs = [...npcsToComment].sort(
            () => 0.5 - Math.random(),
          );
          const selectedNpcs = shuffledNpcs.slice(0, 5);
          const npcList = selectedNpcs
            .map((npc) => `- ${npc.name} (‰∫∫ËÆæ: ${npc.persona})`)
            .join("\n");

          const authorName =
            post.authorId === "user"
              ? state.qzoneSettings.nickname
              : state.chats[post.authorId]?.name || "Êú™Áü•‰ΩúËÄÖ";

          let ownerContext = "";
          // Â¶ÇÊûúÊòéÁ°ÆÂëäËØâ‰∫ÜAIËøô‰∫õNPCÁöÑ‰∏ª‰∫∫ÊòØË∞Å
          if (ownerChar) {
            ownerContext = `
			# NPCÂΩíÂ±û‰∏éÂÖ≥Á≥ª (ÈáçË¶ÅËÉåÊôØ)
			- ‰Ω†Â∞ÜË¶ÅÊâÆÊºîÁöÑËøô‰∫õNPCÈÉΩÊòØËßíËâ≤‚Äú${ownerChar.name}‚ÄùÁöÑÊúãÂèãÊàñÂÖ≥ËÅî‰∫∫Áâ©„ÄÇ
			- ‚Äú${ownerChar.name}‚ÄùÁöÑ‰∫∫ËÆæÊòØ: ${ownerChar.settings.aiPersona}
			- ‰Ω†Âú®ÂèëË°®ËØÑËÆ∫Êó∂ÔºåÈúÄË¶Å‰ΩìÁé∞Âá∫‰Ω†(‰Ωú‰∏∫NPC)‰∏é‚Äú${ownerChar.name}‚ÄùÁöÑÂÖ≥Á≥ªÔºåÂπ∂‰ª•Ê≠§ËßÜËßíÊù•ÁúãÂæÖÂä®ÊÄÅ‰ΩúËÄÖ‚Äú${authorName}‚Äù„ÄÇ
			`;
          }

          const systemPrompt = `
			**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

			# ‰ªªÂä°
			‰Ω†ÊòØ‰∏Ä‰∏™Â§öËßíËâ≤ÊâÆÊºîAI„ÄÇÁé∞Âú®Êúâ‰∏ÄÊù°Âä®ÊÄÅÈúÄË¶Å‰Ω†ÊâÆÊºîÊåáÂÆöÁöÑNPCËßíËâ≤ËøõË°åËØÑËÆ∫ÊàñÂõûÂ§ç„ÄÇ

			${ownerContext}

			# Âä®ÊÄÅ‰ø°ÊÅØ
			- ‰ΩúËÄÖ: ${authorName}
			- ÂÜÖÂÆπÊëòË¶Å: ${postContent}...
			- ÊúÄËøëÁöÑËØÑËÆ∫ (‰Ω†ÂèØ‰ª•ÂõûÂ§ç‰ªñ‰ª¨):
			${existingComments || "(ÊöÇÊó†ËØÑËÆ∫)"}

			# ‰Ω†ÈúÄË¶ÅÊâÆÊºîÁöÑNPCÂàóË°® (Âèä‰ªñ‰ª¨ÁöÑ‰∫∫ËÆæ)
			${npcList}

			# Ê†∏ÂøÉËßÑÂàô
			1.  ‰Ω†„ÄêÂøÖÈ°ª„Äë‰ªé‰∏äÈù¢ÁöÑNPCÂàóË°®‰∏≠ÔºåÈÄâÊã©1Âà∞3‰∏™ÊúÄÂêàÈÄÇÁöÑËßíËâ≤ËøõË°åËØÑËÆ∫ÊàñÂõûÂ§ç„ÄÇ
			2.  ËØÑËÆ∫/ÂõûÂ§çÂÜÖÂÆπ„ÄêÂøÖÈ°ª„Äë‰∏•Ê†ºÁ¨¶ÂêàËØ•NPCÁöÑ‰∫∫ËÆæÂíåÂè£ÂêªÔºåÂπ∂‰∏éÂä®ÊÄÅÂÜÖÂÆπÊàñÂ∑≤ÊúâËØÑËÆ∫Áõ∏ÂÖ≥„ÄÇ
			3.  ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª‰∏îÂè™ËÉΩ„ÄëÊòØ‰∏Ä‰∏™‰∏•Ê†ºÁöÑJSONÊï∞ÁªÑÔºåÊØè‰∏™ÂØπË±°‰ª£Ë°®‰∏ÄÊù°ËØÑËÆ∫ÊàñÂõûÂ§ç„ÄÇ
			4.  Ê†ºÂºè: \`[{"commenterName": "NPCÂêçÂ≠ó", "commentText": "ËØÑËÆ∫ÂÜÖÂÆπ", "replyTo": "(ÂèØÈÄâ)Ë¢´ÂõûÂ§çËÄÖÂêçÂ≠ó"}]\`

			Áé∞Âú®ÔºåËØ∑ÂºÄÂßãÁîüÊàêËØÑËÆ∫ÊàñÂõûÂ§ç„ÄÇ
			`;
          console.log(
            "„ÄêNPCËØÑËÆ∫-ËØäÊñ≠„Äë: 2. Â∑≤ÊûÑÂª∫ÂÆåÊàêÔºåÂáÜÂ§áÂèëÈÄÅÁªôAIÁöÑ System Prompt:",
            systemPrompt,
          );

          try {
            let isGemini = proxyUrl === GEMINI_API_URL;
            let messagesForApi;
            if (isGemini) {
              messagesForApi = [{ role: "user", content: systemPrompt }];
            } else {
              messagesForApi = [
                { role: "system", content: systemPrompt },
                {
                  role: "user",
                  content: "ËØ∑Ê†πÊçÆ‰Ω†Âú®system prompt‰∏≠ËØªÂà∞ÁöÑ‰ø°ÊÅØÁîüÊàêËØÑËÆ∫„ÄÇ",
                },
              ];
            }

            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesForApi,
              isGemini,
              state.apiConfig.temperature,
            );

            console.log(
              "„ÄêNPCËØÑËÆ∫-ËØäÊñ≠„Äë: 3. Âç≥Â∞ÜÂèëÈÄÅAPIËØ∑Ê±Ç... ËØ∑Ê±ÇÂú∞ÂùÄ:",
              isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`,
            );
            console.log(
              "„ÄêNPCËØÑËÆ∫-ËØäÊñ≠„Äë: 3.1 ËØ∑Ê±Ç‰Ωì (Body) ÂÜÖÂÆπ:",
              isGemini
                ? geminiConfig.data.body
                : JSON.stringify({
                    model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });

            console.log("„ÄêNPCËØÑËÆ∫-ËØäÊñ≠„Äë: 4. Êî∂Âà∞APIÂìçÂ∫î", {
              ok: response.ok,
              status: response.status,
            });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            const aiResponseContent = (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            )
              .replace(/^```json\s*|```$/g, "")
              .trim();

            console.log(
              "„ÄêNPCËØÑËÆ∫-ËØäÊñ≠„Äë: 5. ‰ªéAPIËé∑ÂèñÂà∞ÁöÑÂéüÂßãÂõûÂ§çÂÜÖÂÆπ:",
              aiResponseContent,
            );

            let newComments;
            if (aiResponseContent.includes('"chatResponse"')) {
              newComments = JSON.parse(aiResponseContent).chatResponse;
            } else {
              newComments = JSON.parse(aiResponseContent);
            }

            console.log(
              "„ÄêNPCËØÑËÆ∫-ËØäÊñ≠„Äë: 6. ÊàêÂäüËß£ÊûêÂêéÁöÑËØÑËÆ∫ÂØπË±°Êï∞ÁªÑ:",
              newComments,
            );

            if (Array.isArray(newComments) && newComments.length > 0) {
              const postToUpdate = await db.qzonePosts.get(post.id);
              if (!postToUpdate)
                throw new Error("Âú®Êï∞ÊçÆÂ∫ì‰∏≠Êâæ‰∏çÂà∞Ë¶ÅÊõ¥Êñ∞ÁöÑÂ∏ñÂ≠êÔºÅ");
              if (!postToUpdate.comments) postToUpdate.comments = [];

              newComments.forEach((comment) => {
                if (comment.commenterName && comment.commentText) {
                  const newCommentObject = {
                    commenterName: comment.commenterName,
                    text: comment.commentText,
                    timestamp: Date.now(),
                  };
                  if (comment.replyTo)
                    newCommentObject.replyTo = comment.replyTo;
                  postToUpdate.comments.push(newCommentObject);
                }
              });

              await db.qzonePosts.put(postToUpdate);
              hideCustomModal();
              await renderQzonePosts();
              alert("NPC‰ª¨ËØÑËÆ∫ÊàêÂäüÔºÅ");
            } else {
              hideCustomModal();
              alert("NPC‰ª¨‰ºº‰πéÊ≤°‰ªÄ‰πàÊÉ≥ËØ¥ÁöÑ„ÄÇ");
            }
          } catch (error) {
            console.error("„ÄêNPCËØÑËÆ∫-ÈîôËØØ„Äë: Âè¨Âî§NPCËØÑËÆ∫Â§±Ë¥•:", error);
            await showCustomAlert(
              "Âè¨Âî§Â§±Ë¥•",
              `ÂèëÁîü‰∫Ü‰∏Ä‰∏™ÈîôËØØÔºö\n${error.message}`,
            );
          }
        }

        /**
         * Â¶ÇÊûúÊï∞ÊçÆÂ∫ì‰∏≠Ê≤°ÊúâÔºåÂàôËá™Âä®ÂàõÂª∫‰∏Ä‰∏™ÂÜÖÁΩÆÁöÑÂ§úÈó¥Ê®°Âºè‰∏ªÈ¢ò
         */
        async function addDefaultDarkModeThemeIfNeeded() {
          const themeName = "ÂÜÖÁΩÆÂ§úÈó¥Ê®°Âºè"; // ËøôÊòØÊàë‰ª¨Ë¶ÅÂÜÖÁΩÆÁöÑ‰∏ªÈ¢òÂêçÂ≠ó
          try {
            // Ê£ÄÊü•Êï∞ÊçÆÂ∫ìÈáåÊòØÂê¶Â∑≤ÁªèÊúâ‰∫ÜËøô‰∏™ÂêçÂ≠óÁöÑ‰∏ªÈ¢ò
            const existingTheme = await db.themes
              .where("name")
              .equals(themeName)
              .first();

            // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ (existingTheme ÊòØ undefined)ÔºåÂ∞±ÂàõÂª∫ÂÆÉ
            if (!existingTheme) {
              console.log("ÂÜÖÁΩÆÂ§úÈó¥Ê®°Âºè‰∏çÂ≠òÂú®ÔºåÊ≠£Âú®ÂàõÂª∫...");

              // ËøôÂ∞±ÊòØÂÆåÊï¥ÁöÑÂ§úÈó¥Ê®°ÂºèCSS‰ª£Á†Å
              const darkModeCss = `
			/* 1. ÂÖ®Â±ÄÈáçÊñ∞ÂÆö‰πâÈ¢úËâ≤ÂèòÈáè */
			:root {
			  --secondary-bg: #1c1c1e;
			  --border-color: #38383a;
			  --text-primary: #ffffff;
			  --text-secondary: #8e8e93;
			  --status-bar-text-color: #ffffff;
			  --accent-color: #0A84FF; /* iOSÈ£éÊ†ºÁöÑËìùËâ≤ */
			}

			/* 2. ‰∏∫ÊâÄÊúâÂ±èÂπïÂíå‰∏ªË¶ÅÂÆπÂô®ËÆæÁΩÆÂü∫Á°ÄÊ∑±Ëâ≤ËÉåÊôØ */
			#phone-screen, .screen, #chat-list, #world-book-list, .list-container, .form-container, #chat-messages,
			#wallpaper-screen, #font-settings-screen, #api-settings-screen, #character-selection-screen,
			#world-book-screen, #world-book-editor-screen, #character-phone-inner-screen, #character-phone-page {
			    background-color: #000000 !important;
			}

			/* 3. ‰∏ªÂ±èÂπï‰∏ìÂ±ûÊ†∑Âºè */
			#home-screen { background: #111827 !important; }
			#desktop-dock { background-color: rgba(55, 65, 81, 0.5); }
			.desktop-app-icon .label, .widget-subtext { color: #e5e7eb; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
			#profile-widget .profile-info { background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0)); color: #f9fafb; }
			#profile-username, #profile-bio, #profile-location span { color: #f9fafb; }
			#profile-sub-username, #profile-location { color: #9ca3af; }
			#profile-location { background-color: rgba(255,255,255,0.1); }
			.widget-bubble { background-color: rgba(55, 65, 81, 0.9); color: #e5e7eb; }
			.widget-bubble::after { border-top-color: rgba(55, 65, 81, 0.9); }

			/* 4. ÈÄÇÈÖçÊâÄÊúâÈ°µÈù¢ÁöÑÂ§¥ÈÉ®Header */
			.header, .qzone-header, .character-phone-header {
			    background-color: rgba(28, 28, 30, 0.85) !important;
			    border-bottom-color: var(--border-color) !important;
			    color: var(--text-primary) !important;
			}

			/* 5. ÈÄÇÈÖçÊâÄÊúâÈÄöÁî®ÁªÑ‰ª∂ */
			#chat-input-area, #chat-list-bottom-nav { background-color: rgba(28, 28, 30, 0.85); border-top-color: var(--border-color); }
			#chat-input { background-color: var(--secondary-bg); color: var(--text-primary); }
			.modal-content, #custom-modal { background-color: #2c2c2e; }
			.modal-header, .modal-footer, .custom-modal-footer, .custom-modal-footer button:first-child { border-color: var(--border-color); }
			.form-group input, .form-group select, .form-group textarea { background-color: var(--secondary-bg); color: var(--text-primary); border-color: var(--border-color); }
			.list-item, .chat-list-item-swipe-container:not(:last-child), .chat-group-container, .world-book-group-container { border-bottom-color: var(--border-color) !important; }
			.chat-group-container:first-of-type { border-top-color: var(--border-color) !important; }
			.list-item:hover, .chat-list-item:hover { background-color: #2c2c2e; }

			/* 6. ÁâπÊÆäÈ°µÈù¢Ê∑±Â∫¶ÈÄÇÈÖç */
			.chat-group-header, .world-book-group-header { background-color: #1c1c1e; }
			.chat-list-item-content.pinned { background-color: #3a3a3c; }
			#font-preview, #wallpaper-preview, .font-preset-slot { background-color: #1c1c1e !important; border-color: #38383a !important; }

			/* 7. ËßíËâ≤ÊâãÊú∫ÂÜÖÈÉ®ÈÄÇÈÖç & ÂÖ®Â±ÄÊñáÂ≠óÈ¢úËâ≤‰øÆÂ§ç */
			#character-phone-container { background-color: #000000; }
			.character-phone-frame { background-color: #111; }
			#character-chat-history-messages { background-color: #0e0e0e !important; }
			.character-chat-bubble.received { background-color: #2c2c2e !important; }
			.character-data-item, .character-bank-transaction, .character-cart-item, .character-browser-item {
			    background-color: #1c1c1e;
			    border-color: #38383a;
			}

			/* ‚ñº‚ñº‚ñº Ê†∏ÂøÉ‰øÆÂ§çÔºöÊääÊâÄÊúâËøô‰∫õÂÖÉÁ¥†ÁöÑÊñáÂ≠óÈ¢úËâ≤ÈÉΩÊîπ‰∏∫‰ΩéÈ•±ÂíåÂ∫¶ÁöÑÊµÖÁÅ∞Ëâ≤ ‚ñº‚ñº‚ñº */
			.character-data-item .title,
			.character-data-item .content,
			.character-data-item .meta,
			.cart-item-price,
			.cart-item-info .title,
			.character-browser-item .title,
			.transaction-details .title,
			.transaction-amount,
			.character-select-item .name,  /* ‰øÆÂ§çËßíËâ≤ÈÄâÊã©ÂàóË°®ÁöÑÂêçÂ≠óÈ¢úËâ≤ */
			#character-diary-list .character-data-item .content,
			#character-diary-list .character-data-item .content h1,
			#character-diary-list .character-data-item .content h2 {
			    color: #E0E0E0 !important; /* ‰ΩøÁî®‰∏Ä‰∏™ÊüîÂíåÁöÑ„ÄÅ‰∏çÂà∫ÁúºÁöÑÁôΩËâ≤ */
			}

			.character-data-item .meta span,
			#character-diary-list .character-data-item .meta {
			    color: #9E9E9E !important; /* Ê¨°Ë¶Å‰ø°ÊÅØ‰ΩøÁî®Êõ¥ÊöóÁöÑÁÅ∞Ëâ≤ */
			}

			#character-diary-list .character-data-item {
			    background-color: #26211a; /* Â§úÈó¥Ê®°Âºè‰∏ãÁöÑ‰ø°Á∫∏ËÉåÊôØËâ≤ */
			    border-color: #524a3d;
			    border-left-color: #9e8a70;
			}

			`;

              await db.themes.add({ name: themeName, css: darkModeCss });
              console.log("ÂÜÖÁΩÆÂ§úÈó¥Ê®°ÂºèÂ∑≤ÊàêÂäüÂàõÂª∫ÔºÅ");
            } else {
              console.log("ÂÜÖÁΩÆÂ§úÈó¥Ê®°ÂºèÂ∑≤Â≠òÂú®ÔºåË∑≥ËøáÂàõÂª∫„ÄÇ");
            }
          } catch (error) {
            console.error("Ê£ÄÊü•ÊàñÂàõÂª∫ÂÜÖÁΩÆÂ§úÈó¥Ê®°ÂºèÊó∂Âá∫Èîô:", error);
          }
        }
        // ËÅäÂ§©ËÆ∞ÂΩïÊêúÁ¥¢ÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞

        /**
         * ÊâìÂºÄÂπ∂ÂáÜÂ§áËÅäÂ§©ËÆ∞ÂΩïÊêúÁ¥¢ÁïåÈù¢
         */
        function openChatSearchScreen() {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          // Ê∏ÖÁ©∫ÊóßÁöÑÊêúÁ¥¢Êù°‰ª∂ÂíåÁªìÊûú
          document.getElementById("keyword-search-input").value = "";
          document.getElementById("sender-search-select").innerHTML = "";
          document.getElementById("date-search-input").value = "";
          document.getElementById("chat-search-results-list").innerHTML =
            '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">ËæìÂÖ•Êù°‰ª∂ÂºÄÂßãÊêúÁ¥¢</p>';

          // Âä®ÊÄÅÂ°´ÂÖÖ‚Äú‰∫∫Áâ©‚Äù‰∏ãÊãâËèúÂçï
          const senderSelect = document.getElementById("sender-search-select");
          senderSelect.innerHTML = '<option value="">ÊâÄÊúâ‰∫∫</option>'; // ÈªòËÆ§ÈÄâÈ°π

          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "Me"
            : "Me";
          const myOption = document.createElement("option");
          myOption.value = myNickname;
          myOption.textContent = myNickname;
          senderSelect.appendChild(myOption);

          if (chat.isGroup) {
            chat.members.forEach((member) => {
              const memberOption = document.createElement("option");
              memberOption.value = member.originalName; // ‰ΩøÁî®Êú¨ÂêçËøõË°åÁ≤æÁ°ÆÂåπÈÖç
              memberOption.textContent = member.groupNickname; // ÊòæÁ§∫Áæ§ÊòµÁß∞ÁªôÁî®Êà∑Áúã
              senderSelect.appendChild(memberOption);
            });
          } else {
            const aiOption = document.createElement("option");
            aiOption.value = chat.name;
            aiOption.textContent = chat.name;
            senderSelect.appendChild(aiOption);
          }

          // ÂÖ≥Èó≠ËÅäÂ§©ËÆæÁΩÆÂºπÁ™óÔºåÂπ∂ÊòæÁ§∫ÊêúÁ¥¢ÁïåÈù¢
          document
            .getElementById("chat-settings-modal")
            .classList.remove("visible");
          showScreen("chat-search-screen");
        }

        /**
         * ÊâßË°åÊêúÁ¥¢Êìç‰Ωú
         */
        function performChatSearch() {
          const chat = state.chats[state.activeChatId];
          if (!chat) {
            // Â¶ÇÊûúÊâæ‰∏çÂà∞ËÅäÂ§©ÂØπË±°ÔºåÁªôÁî®Êà∑‰∏Ä‰∏™ÊòéÁ°ÆÁöÑÊèêÁ§∫
            alert("Êó†Ê≥ïÊâßË°åÊêúÁ¥¢ÔºåÂõ†‰∏∫Ê≤°ÊúâÊâæÂà∞ÂΩìÂâçËÅäÂ§©„ÄÇ");
            return;
          }

          // 1. Ëé∑ÂèñÊâÄÊúâÊêúÁ¥¢Êù°‰ª∂
          const keyword = document
            .getElementById("keyword-search-input")
            .value.trim();
          const senderValue = document.getElementById(
            "sender-search-select",
          ).value;
          const dateValue = document.getElementById("date-search-input").value;

          // Â∞ÜÂÖ≥ÈîÆËØç‰øùÂ≠òÂà∞ÂÖ®Â±ÄÂèòÈáèÔºå‰ª•‰æøÂú®Ê∏≤ÊüìÁªìÊûúÊó∂Áî®‰∫éÈ´ò‰∫Æ
          currentSearchKeyword = keyword;

          if (!keyword && !senderValue && !dateValue) {
            alert("ËØ∑Ëá≥Â∞ëËæìÂÖ•‰∏Ä‰∏™ÊêúÁ¥¢Êù°‰ª∂ÔºÅ");
            return;
          }

          // 2. Á≠õÈÄâËÅäÂ§©ËÆ∞ÂΩï
          console.log(
            `ÂºÄÂßãÊêúÁ¥¢: ÂÖ≥ÈîÆËØç='${keyword}', ÂèëË®Ä‰∫∫='${senderValue}', Êó•Êúü='${dateValue}'`,
          );

          const results = chat.history.filter((msg) => {
            // ËøáÊª§ÊéâÁ≥ªÁªüÊ∂àÊÅØÂíåÂØπÁî®Êà∑ÈöêËóèÁöÑÊ∂àÊÅØ
            if (
              msg.isHidden ||
              msg.role === "system" ||
              msg.type === "recalled_message"
            ) {
              return false;
            }

            // a. Á≠õÈÄâÊó•Êúü
            if (dateValue) {
              const msgDate = new Date(msg.timestamp)
                .toISOString()
                .split("T")[0];
              if (msgDate !== dateValue) {
                return false;
              }
            }

            // b. Á≠õÈÄâÂèëË®Ä‰∫∫
            if (senderValue) {
              const myNickname = chat.isGroup
                ? chat.settings.myNickname || "Me"
                : "Me";
              let msgSenderName = "";

              if (msg.role === "user") {
                msgSenderName = myNickname;
              } else {
                // AIÊàñÁæ§ÊàêÂëòÁöÑÊ∂àÊÅØ
                // ËøôÈáåÊàë‰ª¨‰ΩøÁî® originalName Êù•Á≤æÁ°ÆÂåπÈÖçÔºåÂõ†‰∏∫Áæ§ÊòµÁß∞ÂèØËÉΩ‰ºöÂèò
                msgSenderName = chat.isGroup ? msg.senderName : chat.name;
              }
              if (msgSenderName !== senderValue) {
                return false;
              }
            }

            // c. Á≠õÈÄâÂÖ≥ÈîÆËØç
            if (keyword) {
              let contentText = "";
              // Â∞ÜÊâÄÊúâÂèØËÉΩÂåÖÂê´ÊñáÊú¨ÁöÑÂÜÖÂÆπÈÉΩËΩ¨Êç¢ÊàêÂ≠óÁ¨¶‰∏≤ËøõË°åÊêúÁ¥¢
              if (typeof msg.content === "string") {
                contentText = msg.content;
              } else if (
                typeof msg.content === "object" &&
                msg.content !== null
              ) {
                // ÂØπ‰∫éÂ§çÊùÇÂØπË±°ÔºåÊàë‰ª¨ÂèØ‰ª•ÁÆÄÂçïÂú∞Â∞ÜÂÆÉ‰ª¨ËΩ¨‰∏∫JSONÂ≠óÁ¨¶‰∏≤Êù•ÊêúÁ¥¢
                contentText = JSON.stringify(msg.content);
              }

              if (!contentText.toLowerCase().includes(keyword.toLowerCase())) {
                return false;
              }
            }

            return true; // ÊâÄÊúâÊù°‰ª∂ÈÉΩÊª°Ë∂≥
          });

          console.log(`ÊêúÁ¥¢Âà∞ ${results.length} Êù°ÁªìÊûú`);

          // 3. Ê∏≤ÊüìÁªìÊûú
          renderSearchResults(results);
        }

        /**
         * Ê∏≤ÊüìÊêúÁ¥¢ÁªìÊûúÂàóË°®
         * @param {Array} results - Á≠õÈÄâÂá∫ÁöÑÊ∂àÊÅØÊï∞ÁªÑ
         */
        function renderSearchResults(results) {
          const listEl = document.getElementById("chat-search-results-list");
          listEl.innerHTML = "";
          listEl.scrollTop = 0; // ÊØèÊ¨°Ê∏≤ÊüìÂâçÔºåÈÉΩÂ∞ÜÊªöÂä®Êù°ÈáçÁΩÆÂà∞È°∂ÈÉ®

          if (results.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">Êú™ÊâæÂà∞Áõ∏ÂÖ≥ËÆ∞ÂΩï</p>';
            return;
          }

          const chat = state.chats[state.activeChatId];
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "Me"
            : "Me";

          // ‰∏∫‰∫ÜÊÄßËÉΩÔºåÂè™Ê∏≤ÊüìÊúÄÊñ∞ÁöÑ100Êù°ÁªìÊûú
          results
            .slice(-100)
            .reverse()
            .forEach((msg) => {
              const item = document.createElement("div");
              item.className = "search-result-item";
              item.dataset.timestamp = msg.timestamp; // ÂÖ≥ÈîÆÔºÅÁî®‰∫éË∑≥ËΩ¨

              let senderName, senderAvatar;
              if (msg.role === "user") {
                senderName = myNickname;
                senderAvatar = chat.settings.myAvatar;
              } else {
                if (chat.isGroup) {
                  senderName = msg.senderName;
                  const member = chat.members.find(
                    (m) => m.originalName === senderName,
                  );
                  senderAvatar = member
                    ? member.avatar
                    : defaultGroupMemberAvatar;
                } else {
                  senderName = chat.name;
                  senderAvatar = chat.settings.aiAvatar;
                }
              }

              let contentText = "";
              if (
                msg.type === "sticker" ||
                (typeof msg.content === "string" &&
                  STICKER_REGEX.test(msg.content))
              ) {
                contentText = "[Ë°®ÊÉÖ]";
              } else if (
                msg.type === "ai_image" ||
                msg.type === "user_photo" ||
                Array.isArray(msg.content)
              ) {
                contentText = "[ÂõæÁâá]";
              } else {
                contentText = String(msg.content);
              }

              item.innerHTML = `
			            <img src="${senderAvatar || defaultAvatar}" class="avatar">
			            <div class="search-result-info">
			                <div class="search-result-meta">
			                    <span class="name">${senderName}</span>
			                    <span class="timestamp">${formatDateStamp(msg.timestamp)}</span>
			                </div>
			                <div class="search-result-content">
			                    ${highlightText(contentText, currentSearchKeyword)}
			                </div>
			            </div>
			        `;
              listEl.appendChild(item);
            });
        }

        /**
         * ËæÖÂä©ÂáΩÊï∞ÔºöÈ´ò‰∫ÆÊñáÊú¨‰∏≠ÁöÑÂÖ≥ÈîÆËØç
         * @param {string} text - ÂéüÂßãÊñáÊú¨
         * @param {string} keyword - Ë¶ÅÈ´ò‰∫ÆÁöÑÂÖ≥ÈîÆËØç
         * @returns {string} - Â§ÑÁêÜÂêéÁöÑHTMLÂ≠óÁ¨¶‰∏≤
         */
        function highlightText(text, keyword) {
          if (!keyword || !text) {
            return text;
          }
          const regex = new RegExp(
            keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"),
            "gi",
          );
          return text.replace(regex, `<span class="highlight">$&</span>`);
        }

        /**
         * ÁÇπÂáªÊêúÁ¥¢ÁªìÊûúÔºåË∑≥ËΩ¨Âà∞ÂØπÂ∫îÁöÑÊ∂àÊÅØ‰ΩçÁΩÆ
         * @param {number} timestamp - ÁõÆÊ†áÊ∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         */
        async function jumpToMessage(timestamp) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const targetIndex = chat.history.findIndex(
            (msg) => msg.timestamp === timestamp,
          );
          if (targetIndex === -1) {
            await showCustomAlert("ÈîôËØØ", "Êâæ‰∏çÂà∞ËØ•Êù°Ê∂àÊÅØÔºåÂèØËÉΩÂ∑≤Ë¢´Âà†Èô§„ÄÇ");
            return;
          }

          // 1. ÂàáÊç¢ÂõûËÅäÂ§©ÁïåÈù¢
          showScreen("chat-interface-screen");
          await new Promise((resolve) => setTimeout(resolve, 50));

          const messagesContainer = document.getElementById("chat-messages");
          messagesContainer.innerHTML = ""; // Ê∏ÖÁ©∫ÂΩìÂâçÂÜÖÂÆπ

          // 2. ËÆ°ÁÆóË¶ÅÊ∏≤ÊüìÁöÑÊ∂àÊÅØÁ™óÂè£Ôºà‰ª•ÁõÆÊ†áÊ∂àÊÅØ‰∏∫‰∏≠ÂøÉÔºâ
          const windowSize = 50; // Âíå MESSAGE_RENDER_WINDOW ‰øùÊåÅ‰∏ÄËá¥
          const startIndex = Math.max(
            0,
            targetIndex - Math.floor(windowSize / 2),
          );
          const messagesToRender = chat.history.slice(startIndex);

          // 3. Êõ¥Êñ∞ currentRenderedCount ‰ª•ÂêåÊ≠•Âä†ËΩΩÁä∂ÊÄÅ
          //    Ëøô‰∏ÄÊ≠•Ëá≥ÂÖ≥ÈáçË¶ÅÔºåÂÆÉÂëäËØâ‚ÄúÂä†ËΩΩÊõ¥Â§ö‚ÄùÂäüËÉΩ‰∏ãÊ¨°Â∫îËØ•‰ªéÂì™ÈáåÂºÄÂßãÂä†ËΩΩ
          currentRenderedCount = messagesToRender.length;

          // 4. Â¶ÇÊûúËÆ°ÁÆóÂá∫ÁöÑËµ∑Âßã‰ΩçÁΩÆÂ§ß‰∫é0ÔºåËØ¥ÊòéÂâçÈù¢ËøòÊúâÊõ¥Êó©ÁöÑËÆ∞ÂΩïÔºåÈúÄË¶ÅÊòæÁ§∫‚ÄúÂä†ËΩΩÊõ¥Â§ö‚ÄùÊåâÈíÆ
          if (startIndex > 0) {
            prependLoadMoreButton(messagesContainer);
          }

          // 5. Ê∏≤ÊüìÊ∂àÊÅØÁ™óÂè£ÂíåÊó•ÊúüÊà≥
          let lastMessageTimestamp =
            startIndex > 0 ? chat.history[startIndex - 1].timestamp : null;
          messagesToRender.forEach((msg) => {
            if (msg.isHidden) return;
            if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
              const dateStampEl = createDateStampElement(msg.timestamp);
              messagesContainer.appendChild(dateStampEl);
            }
            // ‰ΩøÁî® true ‰Ωú‰∏∫Á¨¨‰∏â‰∏™ÂèÇÊï∞ÔºåË°®Á§∫ËøôÊòØÂàùÂßãÂä†ËΩΩÔºå‰∏çÂ∫îÊí≠ÊîæÂä®Áîª
            appendMessage(msg, chat, true);
            lastMessageTimestamp = msg.timestamp;
          });

          // 6. ÊªöÂä®Âà∞ÁõÆÊ†áÊ∂àÊÅØÂπ∂È´ò‰∫ÆÂÆÉ
          //    ‰ΩøÁî® setTimeout Á°Æ‰øù DOM ÂÖÉÁ¥†Â∑≤ÁªèÂÆåÂÖ®Ê∏≤ÊüìÂà∞È°µÈù¢‰∏ä
          setTimeout(() => {
            const targetMessage = messagesContainer.querySelector(
              `.message-bubble[data-timestamp="${timestamp}"]`,
            );
            if (targetMessage) {
              // ‰ΩøÁî® 'auto' ÊªöÂä®ÔºåÊØî 'smooth' Êõ¥Âø´ÈÄüÁõ¥Êé•
              targetMessage.scrollIntoView({
                behavior: "auto",
                block: "center",
              });

              // Ê∑ªÂä†Èó™ÁÉÅÈ´ò‰∫ÆÊïàÊûúÔºåËÆ©Áî®Êà∑ËÉΩÊ≥®ÊÑèÂà∞
              targetMessage.classList.add("flash");
              setTimeout(() => {
                targetMessage.classList.remove("flash");
              }, 1500);
            }
          }, 100);
        }

        async function openQZonePublisher(mode) {
          resetCreatePostModal();
          const modal = document.getElementById("create-post-modal");
          modal.dataset.mode = mode;
          document.getElementById("create-post-modal-title").textContent =
            "ÂèëÂ∏ÉÂä®ÊÄÅ";

          if (mode === "shuoshuo") {
            modal.querySelector(".post-mode-switcher").style.display = "none";
            modal.querySelector("#image-mode-content").style.display = "none";
            modal.querySelector("#text-image-mode-content").style.display =
              "none";
            modal.querySelector("#post-public-text").placeholder =
              "Share something new...";
          } else {
            modal.querySelector(".post-mode-switcher").style.display = "flex";
            modal.querySelector("#image-mode-content").classList.add("active");
            modal
              .querySelector("#text-image-mode-content")
              .classList.remove("active");
            modal.querySelector("#post-public-text").placeholder =
              "Share something new... (optional public text)";
          }

          document.getElementById("post-comments-toggle-group").style.display =
            "block";

          const visibilityGroup = document.getElementById(
            "post-visibility-group",
          );
          const groupsContainer = document.getElementById(
            "post-visibility-groups",
          );
          const visibilityRadios = document.querySelectorAll(
            'input[name="visibility"]',
          );

          visibilityGroup.style.display = "block";
          groupsContainer.innerHTML = ""; // Ê∏ÖÁ©∫ÊóßÁöÑÂàÜÁªÑÂàóË°®

          // ‰ªéÊï∞ÊçÆÂ∫ìËØªÂèñ‰Ω†ÁöÑÂ•ΩÂèãÂàÜÁªÑ
          const groups = await db.qzoneGroups.toArray();
          if (groups.length > 0) {
            groups.forEach((group) => {
              const label = document.createElement("label");
              label.innerHTML = `<input type="checkbox" value="${group.id}"> ${group.name}`;
              groupsContainer.appendChild(label);
            });
          } else {
            groupsContainer.innerHTML =
              '<p style="color: #8a8a8a; font-size: 13px;">No friend groups have been created yet.</p>';
          }

          // ÈªòËÆ§ÈÄâ‰∏≠‚ÄúÊâÄÊúâ‰∫∫ÂèØËßÅ‚ÄùÂπ∂ÈöêËóèÂàÜÁªÑÈÄâÊã©
          visibilityRadios[0].checked = true;
          groupsContainer.style.display = "none";

          // ÁõëÂê¨ÂçïÈÄâÊåâÈíÆÁöÑÂèòÂåñ
          visibilityRadios.forEach((radio) => {
            radio.onchange = function () {
              groupsContainer.style.display =
                this.value === "groups" ? "block" : "none";
            };
          });

          modal.classList.add("visible");
        }

        /**
         * ‰∏ÄÈîÆÊ∏ÖÁ©∫ÊâÄÊúâÂçï‰∫∫ËÅäÂ§©ËÉåÊôØ
         */
        async function clearAllSingleChatBackgrounds() {
          // ÂºπÂá∫Á°ÆËÆ§Ê°ÜÔºåÈò≤Ê≠¢ËØØÊìç‰Ωú
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Êìç‰Ωú",
            "Ê≠§Êìç‰ΩúÂ∞ÜÁßªÈô§ÊâÄÊúâËßíËâ≤ÂçïÁã¨ËÆæÁΩÆÁöÑËÅäÂ§©ËÉåÊôØÔºåÁªü‰∏Ä‰ΩøÁî®ÂÖ®Â±ÄËÉåÊôØ„ÄÇÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü",
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            let updatedCount = 0;
            const chatsToUpdate = [];

            // ÈÅçÂéÜÊâÄÊúâËÅäÂ§©
            for (const chatId in state.chats) {
              const chat = state.chats[chatId];
              // Â¶ÇÊûúËøô‰∏™ËÅäÂ§©ËÆæÁΩÆ‰∫ÜÂçï‰∫∫ËÉåÊôØ
              if (chat.settings && chat.settings.background) {
                chat.settings.background = ""; // Ê∏ÖÁ©∫ÂÆÉ
                chatsToUpdate.push(chat);
                updatedCount++;
              }
            }

            // Â¶ÇÊûúÊúâÈúÄË¶ÅÊõ¥Êñ∞ÁöÑËÅäÂ§©ÔºåÂ∞±ÊâπÈáèÂÜôÂÖ•Êï∞ÊçÆÂ∫ì
            if (chatsToUpdate.length > 0) {
              await db.chats.bulkPut(chatsToUpdate);
            }

            await showCustomAlert(
              "Êìç‰ΩúÊàêÂäü",
              `Â∑≤ÊàêÂäüÊ∏ÖÁ©∫ ${updatedCount} ‰∏™ËßíËâ≤ÁöÑÂçï‰∫∫ËÅäÂ§©ËÉåÊôØÔºÅ`,
            );
          }
        }

        /* ‰∏ªÂ±èÂπïÁæéÂåñÈ¢ÑËÆæÊ†∏ÂøÉÂäüËÉΩÂáΩÊï∞ */

        let activeHomePresetId = null; // Áî®‰∫éËøΩË∏™ÂΩìÂâçÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæID

        /**
         * ÂêØÁî®ÊàñÁ¶ÅÁî®È¢ÑËÆæÁÆ°ÁêÜÊåâÈíÆ
         */
        function toggleHomePresetButtons(isEnabled) {
          document.getElementById("apply-home-preset-btn").disabled =
            !isEnabled;
          document.getElementById("update-home-preset-btn").disabled =
            !isEnabled; // <-- Êñ∞Â¢ûËøô‰∏ÄË°å
          document.getElementById("rename-home-preset-btn").disabled =
            !isEnabled;
          document.getElementById("delete-home-preset-btn").disabled =
            !isEnabled;
          document.getElementById("export-home-preset-btn").disabled =
            !isEnabled;
        }

        /**
         * Âä†ËΩΩÈ¢ÑËÆæÂà∞‰∏ãÊãâÊ°Ü
         */
        async function loadHomeScreenPresetsToDropdown() {
          const selector = document.getElementById("home-preset-selector");
          selector.innerHTML = '<option value="">-- ËØ∑ÈÄâÊã©‰∏Ä‰∏™È¢ÑËÆæ --</option>';
          const presets = await db.homeScreenPresets.toArray();
          presets.forEach((preset) => {
            const option = document.createElement("option");
            option.value = preset.id;
            option.textContent = preset.name;
            selector.appendChild(option);
          });
          activeHomePresetId = null; // ÈáçÁΩÆÈÄâÊã©
          toggleHomePresetButtons(false); // ÈªòËÆ§Á¶ÅÁî®ÊåâÈíÆ
        }

        /**
         * ÂΩìÁî®Êà∑‰ªé‰∏ãÊãâÊ°ÜÈÄâÊã©‰∏Ä‰∏™È¢ÑËÆæÊó∂
         */
        function handleHomePresetSelection() {
          const selector = document.getElementById("home-preset-selector");
          activeHomePresetId = selector.value ? parseInt(selector.value) : null;
          // Âè™ÊúâÂΩìÁî®Êà∑Á°ÆÂÆûÈÄâÊã©‰∫Ü‰∏Ä‰∏™È¢ÑËÆæÊó∂ÔºåÊâçÂêØÁî®Áõ∏ÂÖ≥ÊåâÈíÆ
          toggleHomePresetButtons(!!activeHomePresetId);
        }

        async function applySelectedHomeScreenPreset() {
          if (!activeHomePresetId) {
            alert("ËØ∑ÂÖà‰ªé‰∏ãÊãâÊ°Ü‰∏≠ÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÂ∫îÁî®ÁöÑÈ¢ÑËÆæ„ÄÇ");
            return;
          }
          const preset = await db.homeScreenPresets.get(activeHomePresetId);
          if (preset && preset.data) {
            // Â∞ÜÈ¢ÑËÆæÊï∞ÊçÆÂä†ËΩΩÂà∞ÂÖ®Â±ÄÁä∂ÊÄÅ
            state.globalSettings.widgetData = preset.data;

            if (preset.data.wallpaper) {
              state.globalSettings.wallpaper = preset.data.wallpaper;
            }
            if (preset.data.appIcons) {
              state.globalSettings.appIcons = { ...preset.data.appIcons };
            }

            // Ê£ÄÊü•È¢ÑËÆæ‰∏≠ÊòØÂê¶ÊúâappLabelsÊï∞ÊçÆÔºåÂ¶ÇÊûúÊúâÔºåÂ∞±Âä†ËΩΩÂÆÉ
            if (preset.data.appLabels) {
              state.globalSettings.appLabels = { ...preset.data.appLabels };
            } else {
              // Â¶ÇÊûúËøô‰∏™ÊóßÁöÑÈ¢ÑËÆæÈáåÊ≤°Êúâ‰øùÂ≠òAppÂêçÂ≠óÔºåÂ∞±Ê∏ÖÁ©∫ÂΩìÂâçÁöÑËá™ÂÆö‰πâÂêçÂ≠óÔºå‰ª•ÊÅ¢Â§çÈªòËÆ§
              state.globalSettings.appLabels = {};
            }

            // ‰øùÂ≠òÊâÄÊúâÊõ¥Êñ∞Âà∞Êï∞ÊçÆÂ∫ì
            await db.globalSettings.put(state.globalSettings);

            // ‰æùÊ¨°Â∫îÁî®ÊâÄÊúâËÆæÁΩÆ (Áé∞Âú® applyAppLabels() Â∞±ËÉΩËé∑ÂèñÂà∞Ê≠£Á°ÆÁöÑÂêçÁß∞‰∫Ü)
            applyGlobalWallpaper();
            applyAppIcons();
            applyAppLabels();
            applyWidgetData();

            alert(`Â∑≤ÊàêÂäüÂ∫îÁî®È¢ÑËÆæ: "${preset.name}"ÔºÅ`);
            showScreen("home-screen");
          }
        }

        /**
         * Ê∏≤Êüì‰∏ªÂ±èÂπï‰∏™‰∫∫ËµÑÊñôÂç°ÁöÑÂ§¥ÂÉèÊ°Ü
         */
        function renderHomeScreenProfileFrame() {
          // 1. Ëé∑Âèñ‰øùÂ≠òÁöÑÂ§¥ÂÉèÊ°ÜURL
          const frameUrl = state.globalSettings.homeAvatarFrame || "";
          // 2. ÊâæÂà∞Â§¥ÂÉèÊ°ÜÁöÑimgÂÖÉÁ¥†
          const frameImg = document.getElementById("profile-avatar-frame");
          if (frameImg) {
            // 3. Â¶ÇÊûúURLÂ≠òÂú®ÔºåÂ∞±ÊòæÁ§∫ÂÆÉ
            if (frameUrl) {
              frameImg.src = frameUrl;
              frameImg.style.display = "block";
            } else {
              // 4. Â¶ÇÊûúURL‰∏∫Á©∫ÔºàÂç≥ÈÄâÊã©‰∫Ü‚ÄúÊó†‚ÄùÔºâÔºåÂ∞±ÈöêËóèÂÆÉ
              frameImg.src = "";
              frameImg.style.display = "none";
            }
          }
        }

        /**
         * ‰øùÂ≠òÂΩìÂâçÁöÑ‰∏ªÂ±èÂπïËÆæÁΩÆ‰∏∫‰∏Ä‰∏™Êñ∞ÁöÑÈ¢ÑËÆæ
         */
        async function saveCurrentHomeScreenAsPreset() {
          saveAppLabels();
          const presetName = await showCustomPrompt(
            "‰øùÂ≠òÈ¢ÑËÆæ",
            "ËØ∑‰∏∫Ëøô‰∏™‰∏ªÂ±èÂπïÁæéÂåñÊñπÊ°àËµ∑‰∏™ÂêçÂ≠óÔºö",
          );
          if (!presetName || !presetName.trim()) {
            if (presetName !== null) alert("ÂêçÂ≠ó‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
            return;
          }

          // Ê†∏ÂøÉÔºöÊûÑÂª∫‰∏Ä‰∏™ÂåÖÂê´ÊâÄÊúâ‰∏ªÂ±èÂπïÂÖÉÁ¥†ÁöÑÂÆåÊï¥Êï∞ÊçÆÂØπË±°
          const presetData = {
            // --- ‰∏™‰∫∫ËµÑÊñôÂç°Áâá ---
            "profile-banner-img":
              document.getElementById("profile-banner-img").src,
            "profile-avatar-img":
              document.getElementById("profile-avatar-img").src,
            homeAvatarFrame: document.getElementById("profile-avatar-frame")
              .src, // ‚òÖ‚òÖ‚òÖ Êñ∞Â¢ûÔºö‰øùÂ≠òÂ§¥ÂÉèÊ°Ü ‚òÖ‚òÖ‚òÖ
            "profile-username":
              document.getElementById("profile-username").textContent,
            "profile-sub-username": document.getElementById(
              "profile-sub-username",
            ).textContent,
            "profile-bio": document.getElementById("profile-bio").textContent,
            "profile-location":
              document.getElementById("profile-location").innerHTML,

            // --- Á¨¨‰∏ÄÈ°µÂ∞èÁªÑ‰ª∂ ---
            "widget-bubble-1":
              document.getElementById("widget-bubble-1").textContent,
            "widget-image-1": document.getElementById("widget-image-1").src,
            "widget-subtext-1":
              document.getElementById("widget-subtext-1").textContent,
            "widget-bubble-2":
              document.getElementById("widget-bubble-2").textContent,
            "widget-image-2": document.getElementById("widget-image-2").src,
            "widget-subtext-2":
              document.getElementById("widget-subtext-2").textContent,

            // --- Á¨¨‰∫åÈ°µÂ∞èÁªÑ‰ª∂ ---
            "widget-image-3": document.getElementById("widget-image-3").src,
            "second-page-bubble":
              document.getElementById("second-page-bubble").textContent,
            "flat-capsule-bubble": document.getElementById(
              "flat-capsule-bubble",
            ).textContent,
            "circular-bubble":
              document.getElementById("circular-bubble").textContent,
            "new-widget-avatar":
              document.getElementById("new-widget-avatar").src,
            "new-widget-text-1":
              document.getElementById("new-widget-text-1").textContent,
            "new-widget-text-2":
              document.getElementById("new-widget-text-2").textContent,
            "new-widget-text-3":
              document.getElementById("new-widget-text-3").textContent,
            "widget-month-display": document.getElementById(
              "widget-month-display",
            ).textContent,
            "music-rect-img": document.getElementById("music-rect-img").src,
            "music-record-img": document.getElementById("music-record-img").src,
            "music-text-line":
              document.getElementById("music-text-line").textContent,

            // --- AppÂõæÊ†áÂíåÂ£ÅÁ∫∏ ---
            appIcons: { ...state.globalSettings.appIcons },
            appLabels: { ...state.globalSettings.appLabels },
            wallpaper: state.globalSettings.wallpaper,
          };

          // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
          await db.homeScreenPresets.add({
            name: presetName.trim(),
            data: presetData,
          });
          await loadHomeScreenPresetsToDropdown(); // Âà∑Êñ∞‰∏ãÊãâÂàóË°®
          alert(`È¢ÑËÆæ "${presetName.trim()}" Â∑≤‰øùÂ≠òÔºÅ`);
        }

        async function updateSelectedHomeScreenPreset() {
          saveAppLabels();
          if (!activeHomePresetId) {
            alert("ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÊõ¥Êñ∞ÁöÑÈ¢ÑËÆæ„ÄÇ");
            return;
          }

          const currentPreset =
            await db.homeScreenPresets.get(activeHomePresetId);
          if (!currentPreset) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Êõ¥Êñ∞",
            `Á°ÆÂÆöË¶ÅÁî®ÂΩìÂâçÁöÑ‰∏ªÂ±èÂπïÂ∏ÉÂ±ÄË¶ÜÁõñÈ¢ÑËÆæ "${currentPreset.name}" ÂêóÔºü`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            // ÊûÑÂª∫‰∏é‰øùÂ≠òÊó∂ÂÆåÂÖ®Áõ∏ÂêåÁöÑÂÆåÊï¥Êï∞ÊçÆÂØπË±°
            const presetData = {
              "profile-banner-img":
                document.getElementById("profile-banner-img").src,
              "profile-avatar-img":
                document.getElementById("profile-avatar-img").src,
              homeAvatarFrame: document.getElementById("profile-avatar-frame")
                .src,
              "profile-username":
                document.getElementById("profile-username").textContent,
              "profile-sub-username": document.getElementById(
                "profile-sub-username",
              ).textContent,
              "profile-bio": document.getElementById("profile-bio").textContent,
              "profile-location":
                document.getElementById("profile-location").innerHTML,
              "widget-bubble-1":
                document.getElementById("widget-bubble-1").textContent,
              "widget-image-1": document.getElementById("widget-image-1").src,
              "widget-subtext-1":
                document.getElementById("widget-subtext-1").textContent,
              "widget-bubble-2":
                document.getElementById("widget-bubble-2").textContent,
              "widget-image-2": document.getElementById("widget-image-2").src,
              "widget-subtext-2":
                document.getElementById("widget-subtext-2").textContent,
              "widget-image-3": document.getElementById("widget-image-3").src,
              "second-page-bubble":
                document.getElementById("second-page-bubble").textContent,
              "flat-capsule-bubble": document.getElementById(
                "flat-capsule-bubble",
              ).textContent,
              "circular-bubble":
                document.getElementById("circular-bubble").textContent,
              "new-widget-avatar":
                document.getElementById("new-widget-avatar").src,
              "new-widget-text-1":
                document.getElementById("new-widget-text-1").textContent,
              "new-widget-text-2":
                document.getElementById("new-widget-text-2").textContent,
              "new-widget-text-3":
                document.getElementById("new-widget-text-3").textContent,
              "widget-month-display": document.getElementById(
                "widget-month-display",
              ).textContent,
              "music-rect-img": document.getElementById("music-rect-img").src,
              "music-record-img":
                document.getElementById("music-record-img").src,
              "music-text-line":
                document.getElementById("music-text-line").textContent,
              appIcons: { ...state.globalSettings.appIcons },
              appLabels: { ...state.globalSettings.appLabels },
              wallpaper: state.globalSettings.wallpaper,
            };

            await db.homeScreenPresets.update(activeHomePresetId, {
              data: presetData,
            });
            await showCustomAlert(
              "ÊàêÂäü",
              `È¢ÑËÆæ "${currentPreset.name}" Â∑≤Êõ¥Êñ∞ÔºÅ`,
            );
          }
        }

        /**
         * ÈáçÂëΩÂêçÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function renameSelectedHomeScreenPreset() {
          if (!activeHomePresetId) return;
          const currentPreset =
            await db.homeScreenPresets.get(activeHomePresetId);
          const newName = await showCustomPrompt(
            "ÈáçÂëΩÂêç",
            "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂêçÁß∞Ôºö",
            currentPreset.name,
          );
          if (newName && newName.trim()) {
            await db.homeScreenPresets.update(activeHomePresetId, {
              name: newName.trim(),
            });
            await loadHomeScreenPresetsToDropdown();
            document.getElementById("home-preset-selector").value =
              activeHomePresetId;
            alert("ÈáçÂëΩÂêçÊàêÂäüÔºÅ");
          }
        }

        /**
         * Âà†Èô§ÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function deleteSelectedHomeScreenPreset() {
          if (!activeHomePresetId) return;
          const currentPreset =
            await db.homeScreenPresets.get(activeHomePresetId);
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            `Á°ÆÂÆöË¶ÅÂà†Èô§È¢ÑËÆæ "${currentPreset.name}" ÂêóÔºü`,
            {
              confirmButtonClass: "btn-danger",
            },
          );
          if (confirmed) {
            await db.homeScreenPresets.delete(activeHomePresetId);
            await loadHomeScreenPresetsToDropdown(); // Ëøô‰ºöËá™Âä®ÈáçÁΩÆÈÄâÊã©Âπ∂Á¶ÅÁî®ÊåâÈíÆ
            alert("È¢ÑËÆæÂ∑≤Âà†Èô§„ÄÇ");
          }
        }

        /**
         * ÂØºÂá∫ÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function exportHomeScreenPreset() {
          if (!activeHomePresetId) return;
          const preset = await db.homeScreenPresets.get(activeHomePresetId);
          const blob = new Blob([JSON.stringify(preset, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${preset.name}-HomeScreen.json`;
          a.click();
          URL.revokeObjectURL(url);
        }

        /**
         * ÂØºÂÖ•È¢ÑËÆæÊñá‰ª∂
         */
        function importHomeScreenPreset(file) {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const data = JSON.parse(e.target.result);
              // ÁÆÄÂçïÈ™åËØÅ‰∏Ä‰∏ãÊñá‰ª∂ÂÜÖÂÆπÊòØ‰∏çÊòØÊàë‰ª¨ÈúÄË¶ÅÁöÑÊ†ºÂºè
              if (data.name && data.data) {
                await db.homeScreenPresets.add({
                  name: `${data.name} (Import)`,
                  data: data.data,
                });
                await loadHomeScreenPresetsToDropdown();
                alert(`È¢ÑËÆæ "${data.name}" ÂØºÂÖ•ÊàêÂäüÔºÅ`);
              } else {
                alert("ÂØºÂÖ•Â§±Ë¥•ÔºöÊñá‰ª∂Ê†ºÂºè‰∏çÊ≠£Á°Æ„ÄÇ");
              }
            } catch (error) {
              alert(`ÂØºÂÖ•Â§±Ë¥•ÔºöÊñá‰ª∂Ëß£ÊûêÈîôËØØ„ÄÇ${error.message}`);
            }
          };
          reader.readAsText(file);
        }

        /**
         * ËßíËâ≤Ë°®ÊÉÖÂåÖÁÆ°ÁêÜÊ†∏ÂøÉÂäüËÉΩ
         */
        async function openCharStickerManager() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          // Ê†πÊçÆËÅäÂ§©Á±ªÂûãÊòæÁ§∫‰∏çÂêåÁöÑÊ†áÈ¢ò
          if (chat.isGroup) {
            document.getElementById("sticker-manager-title").textContent =
              `‚Äú${chat.name}‚ÄùÁöÑÁæ§Ë°®ÊÉÖ`;
          } else {
            document.getElementById("sticker-manager-title").textContent =
              `‚Äú${chat.name}‚ÄùÁöÑË°®ÊÉÖÂåÖ`;
          }

          // ÈªòËÆ§ÊòæÁ§∫‰∏ìÂ±ûË°®ÊÉÖ
          document.getElementById("sticker-tab-exclusive").click();

          await renderCharStickers("exclusive");
          await renderCharStickers("common");

          showScreen("char-sticker-manager-screen");
        }

        async function renderCharStickers(type) {
          const isExclusive = type === "exclusive";
          const gridId = isExclusive
            ? "exclusive-sticker-grid"
            : "common-sticker-grid";
          const grid = document.getElementById(gridId);
          grid.innerHTML = "";

          let stickers = [];
          if (isExclusive) {
            const chat = state.chats[state.activeChatId];
            stickers = chat.settings.stickerLibrary || [];
          } else {
            state.charStickers = await db.charStickers.toArray();
            stickers = state.charStickers || [];
          }

          if (stickers.length === 0) {
            grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">ËøôÈáåËøòÊòØÁ©∫ÁöÑÂì¶~</p>`;
            return;
          }

          // ‰∏∫‰∫ÜÊ≠£Á°ÆÂà†Èô§ÔºåÊàë‰ª¨ÈúÄË¶ÅÂéüÂßãÁ¥¢Âºï
          const stickersWithIndex = stickers.map((sticker, index) => ({
            ...sticker,
            originalIndex: index,
          }));

          stickersWithIndex.forEach((sticker) => {
            const item = document.createElement("div");
            item.className = "sticker-item";
            item.style.backgroundImage = `url(${sticker.url})`;
            item.title = sticker.name;

            // Êàë‰ª¨‰ΩøÁî® URL ‰Ωú‰∏∫ÂîØ‰∏ÄÊ†áËØÜÁ¨¶ÔºåÂõ†‰∏∫ÂÆÉÂú®‰∏§ÁßçÂ∫ì‰∏≠ÈÉΩÊòØÂîØ‰∏ÄÁöÑ
            const uniqueId = sticker.url;

            if (isCharStickerSelectionMode) {
              // „ÄêÈÄâÊã©Ê®°Âºè„Äë‰∏ãÁöÑÈÄªËæë
              item.classList.add("in-selection-mode");
              if (selectedCharStickers.has(uniqueId)) {
                item.classList.add("selected");
              }

              item.addEventListener("click", () => {
                item.classList.toggle("selected");
                if (selectedCharStickers.has(uniqueId)) {
                  selectedCharStickers.delete(uniqueId);
                } else {
                  selectedCharStickers.add(uniqueId);
                }
                const deleteBtn = document.getElementById(
                  "delete-selected-char-stickers-btn",
                );
                deleteBtn.textContent = `Âà†Èô§Â∑≤ÈÄâ (${selectedCharStickers.size})`;
                deleteBtn.disabled = selectedCharStickers.size === 0;
              });
            } else {
              // „ÄêÊ≠£Â∏∏Ê®°Âºè„Äë‰∏ãÁöÑÈÄªËæëÔºàÂè™ÊúâÂà†Èô§ÊåâÈíÆÔºâ
              const deleteBtn = document.createElement("div");
              deleteBtn.className = "delete-btn";
              deleteBtn.innerHTML = "√ó";
              deleteBtn.style.display = "block"; // ÈªòËÆ§Â∞±ÊòæÁ§∫
              deleteBtn.onclick = async (e) => {
                e.stopPropagation();
                const confirmed = await showCustomConfirm(
                  "Âà†Èô§Ë°®ÊÉÖ",
                  `Á°ÆÂÆöË¶ÅÂà†Èô§Ë°®ÊÉÖ "${sticker.name}" ÂêóÔºü`,
                  {
                    confirmButtonClass: "btn-danger",
                  },
                );
                if (confirmed) {
                  if (isExclusive) {
                    const chat = state.chats[state.activeChatId];
                    chat.settings.stickerLibrary.splice(
                      sticker.originalIndex,
                      1,
                    );
                    await db.chats.put(chat);
                  } else {
                    await db.charStickers.delete(sticker.id);
                  }
                  await renderCharStickers(type); // Âà∑Êñ∞
                }
              };
              item.appendChild(deleteBtn);
            }
            grid.appendChild(item);
          });
        }

        /**
         * Â§ÑÁêÜÊâπÈáèÂà†Èô§ÈÄâ‰∏≠ÁöÑËßíËâ≤Ë°®ÊÉÖ
         */
        async function handleBulkDeleteCharStickers() {
          if (selectedCharStickers.size === 0) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            `Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${selectedCharStickers.size} ‰∏™Ë°®ÊÉÖÂêóÔºü`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            const activeTab = document.querySelector(
              "#char-sticker-manager-screen .frame-tab.active",
            );
            const type =
              activeTab.id === "sticker-tab-exclusive" ? "exclusive" : "common";

            if (type === "exclusive") {
              const chat = state.chats[state.activeChatId];
              chat.settings.stickerLibrary =
                chat.settings.stickerLibrary.filter(
                  (s) => !selectedCharStickers.has(s.url),
                );
              await db.chats.put(chat);
            } else {
              // common
              const stickersToDelete = await db.charStickers
                .where("url")
                .anyOf(Array.from(selectedCharStickers))
                .toArray();
              const idsToDelete = stickersToDelete.map((s) => s.id);
              if (idsToDelete.length > 0) {
                await db.charStickers.bulkDelete(idsToDelete);
              }
            }

            // ÈÄÄÂá∫ÁºñËæëÊ®°Âºè
            toggleCharStickerSelectionMode();

            alert("ÈÄâ‰∏≠ÁöÑË°®ÊÉÖÂ∑≤Âà†Èô§„ÄÇ");
          }
        }

        /**
         * ÊâπÈáèÊ∑ªÂä†Ë°®ÊÉÖÂåÖÂà∞ÊåáÂÆöÂ∫ì
         */
        async function bulkAddCharStickers(type) {
          const textInput = await showCustomPrompt(
            `ÊâπÈáèÊ∑ªÂä†${type === "exclusive" ? "‰∏ìÂ±û" : "ÈÄöÁî®"}Ë°®ÊÉÖ`,
            "‰∏ÄË°å‰∏Ä‰∏™ÔºåÊ†ºÂºèÔºö\nÁå´Áå´ÂñùÊ∞¥ https://..../cat.gif",
            "",
            "textarea",
          );
          if (!textInput || !textInput.trim()) return;

          const lines = textInput.trim().split("\n");
          const newStickers = [];
          let successCount = 0;

          lines.forEach((line, index) => {
            line = line.trim();
            if (!line) return;

            let name = "";
            let url = "";
            let splitIndex = -1;
            const httpIndex = line.indexOf("http");
            const dataIndex = line.indexOf("data:image");
            if (httpIndex > -1) {
              splitIndex = httpIndex;
            } else if (dataIndex > -1) {
              splitIndex = dataIndex;
            }

            if (splitIndex > 0) {
              name = line.substring(0, splitIndex).trim();
              url = line.substring(splitIndex).trim();
              if (name.endsWith(":") || name.endsWith("Ôºö")) {
                name = name.slice(0, -1).trim();
              }
            }

            if (
              name &&
              (url.startsWith("http") || url.startsWith("data:image"))
            ) {
              const stickerData = { url, name };
              if (type !== "exclusive") {
                stickerData.id = "char_sticker_" + (Date.now() + index);
              }
              newStickers.push(stickerData);
              successCount++;
            }
          });

          if (newStickers.length > 0) {
            if (type === "exclusive") {
              const chat = state.chats[state.activeChatId];
              chat.settings.stickerLibrary.push(...newStickers);
              await db.chats.put(chat);
            } else {
              await db.charStickers.bulkAdd(newStickers);
            }
            await renderCharStickers(type); // Âú®Êï∞ÊçÆÂ∫ìÊìç‰ΩúÂêéÔºåÁªü‰∏ÄÈáçÊñ∞Ê∏≤Êüì
          }
          await showCustomAlert(
            "ÂØºÂÖ•Êä•Âëä",
            `ÊàêÂäüÂØºÂÖ•Ôºö${successCount} ‰∏™Ë°®ÊÉÖ„ÄÇ`,
          );
        }

        /**
         * ‰ªéÊú¨Âú∞‰∏ä‰º†Ë°®ÊÉÖÂà∞ÊåáÂÆöÂ∫ì
         */
        async function uploadCharStickersLocal(type) {
          const input = document.getElementById("char-sticker-upload-input"); // Â∫îËØ•ÈïøËøôÊ†∑
          input.onchange = async (event) => {
            const files = event.target.files;
            if (!files.length) return;

            const stickersToAdd = []; // ÂÖàÊî∂ÈõÜÊâÄÊúâË¶ÅÊ∑ªÂä†ÁöÑË°®ÊÉÖ

            for (const file of files) {
              const name = await showCustomPrompt(
                "‰∏∫Ë°®ÊÉÖÂëΩÂêç",
                "ËØ∑ËæìÂÖ•Ë°®ÊÉÖÂêçÁß∞",
                file.name.replace(/\.[^/.]+$/, ""),
              );
              if (name && name.trim()) {
                const base64Url = await new Promise((resolve) => {
                  const reader = new FileReader();
                  reader.onload = (e) => resolve(e.target.result);
                  reader.readAsDataURL(file);
                });

                const stickerData = { name: name.trim(), url: base64Url };
                if (type !== "exclusive") {
                  stickerData.id = "char_sticker_" + Date.now() + Math.random();
                }
                stickersToAdd.push(stickerData);
              }
            }

            if (stickersToAdd.length > 0) {
              if (type === "exclusive") {
                const chat = state.chats[state.activeChatId];
                chat.settings.stickerLibrary.push(...stickersToAdd);
                await db.chats.put(chat);
              } else {
                await db.charStickers.bulkAdd(stickersToAdd);
              }
              await renderCharStickers(type); // Âú®Êï∞ÊçÆÂ∫ìÊìç‰ΩúÂêéÔºåÁªü‰∏ÄÈáçÊñ∞Ê∏≤Êüì
              alert(`Â∑≤ÊàêÂäü‰∏ä‰º† ${stickersToAdd.length} ‰∏™Ë°®ÊÉÖÔºÅ`);
            }

            event.target.value = null;
          };
          input.click();
        }

        /**
         * ÊòæÁ§∫ÊåáÂÆöÁöÑËßíËâ≤Ë°®ÊÉÖÂåÖÊ†áÁ≠æÈ°µ
         * ËøôÊòØ‰πãÂâçÁº∫Â§±ÁöÑÊ†∏ÂøÉÂäüËÉΩÔºåÁî®‰∫éÊéßÂà∂ÊòæÁ§∫Âì™‰∏™Ê†áÁ≠æÈ°µÔºà‰∏ìÂ±ûÊàñÈÄöÁî®Ôºâ„ÄÇ
         * @param {'exclusive' | 'common'} type - Ë¶ÅÊòæÁ§∫ÁöÑÊ†áÁ≠æÈ°µÁ±ªÂûã
         */
        function showCharStickerTab(type) {
          // 1. ÂàáÊç¢Ê†áÁ≠æÊåâÈíÆÁöÑ 'active' Áä∂ÊÄÅ
          document.querySelectorAll(".char-sticker-tab-btn").forEach((btn) => {
            btn.classList.toggle("active", btn.dataset.type === type);
          });

          // 2. ÂàáÊç¢ÂÜÖÂÆπÂå∫ÂüüÁöÑÊòæÁ§∫
          document
            .querySelectorAll(".sticker-tab-content")
            .forEach((content) => {
              content.classList.toggle(
                "active",
                content.id === `${type}-sticker-content`,
              );
            });

          // 3. Ê∏≤ÊüìÂØπÂ∫îÊ†áÁ≠æÈ°µÁöÑË°®ÊÉÖ
          // (Ëøô‰∏ÄÊ≠•Á°Æ‰øùÊØèÊ¨°ÂàáÊç¢Ê†áÁ≠æÊó∂ÔºåË°®ÊÉÖÈÉΩ‰ºöÂà∑Êñ∞)
          renderCharStickers(type);
        }

        /**
         * Â°îÁΩóÁâåÂç†ÂçúÂäüËÉΩÊ†∏ÂøÉ
         */
        let activeTarotReading = null; // Áî®‰∫éÊöÇÂ≠òÂΩìÂâçÂç†ÂçúÁöÑÁªìÊûú

        // ÁâåÈòµ‰ø°ÊÅØ
        const TAROT_SPREADS = {
          single: {
            name: "ÂçïÂº†Áâå - Âø´ÈÄüÊåáÂºï",
            count: 1,
            positions: ["Ê†∏ÂøÉÊåáÂºï"],
          },
          three_past_present_future: {
            name: "‰∏âÂº†Áâå - ËøáÂéª/Áé∞Âú®/Êú™Êù•",
            count: 3,
            positions: ["ËøáÂéª", "Áé∞Âú®", "Êú™Êù•"],
          },
          three_situation_challenge_advice: {
            name: "‰∏âÂº†Áâå - ÊÉÖÂ¢É/ÊåëÊàò/Âª∫ËÆÆ",
            count: 3,
            positions: ["ÊÉÖÂ¢É", "ÊåëÊàò", "Âª∫ËÆÆ"],
          },
          celtic_cross: {
            name: "ÂáØÂ∞îÁâπÂçÅÂ≠ó - Ê∑±Â∫¶ÂàÜÊûê",
            count: 10,
            positions: [
              "Áé∞Áä∂",
              "ÊåëÊàò",
              "Ê†πÂü∫",
              "ËøáÂéª",
              "ÁõÆÊ†á",
              "Êú™Êù•",
              "Ëá™ÊàëËÆ§Áü•",
              "Â§ñÈÉ®ÂΩ±Âìç",
              "Â∏åÊúõ‰∏éÊÅêÊÉß",
              "ÊúÄÁªàÁªìÊûú",
            ],
          },
        };

        // ÊâìÂºÄÂ°îÁΩóÁâåÂç†Âçú‰∏ªÊ®°ÊÄÅÊ°Ü
        function openTarotModal() {
          document
            .getElementById("tarot-divination-modal")
            .classList.add("visible");
          // ÈªòËÆ§ÊòæÁ§∫ËÆæÁΩÆÁïåÈù¢
          document.getElementById("tarot-setup-view").style.display = "block";
          document.getElementById("tarot-result-view").style.display = "none";
          document.getElementById("tarot-history-view").style.display = "none";
          // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
          document.getElementById("tarot-question-input").value = "";
        }

        // ÊâßË°åÊäΩÁâåÈÄªËæë
        function handleDrawCards() {
          const question = document
            .getElementById("tarot-question-input")
            .value.trim();
          const spreadType = document.getElementById(
            "tarot-spread-select",
          ).value;
          const orientation = document.querySelector(
            'input[name="tarot-orientation"]:checked',
          ).value;

          if (!question) {
            alert("ËØ∑ËæìÂÖ•ÊÇ®ÁöÑÈóÆÈ¢òÊàñÂÖ≥Ê≥®ÁÇπ„ÄÇ");
            return;
          }

          const spreadInfo = TAROT_SPREADS[spreadType];
          const deck = [...TAROT_DECK];

          // Ê¥óÁâå
          for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
          }

          // ÊäΩÁâå
          const drawnCardsRaw = deck.slice(0, spreadInfo.count);
          const drawnCards = drawnCardsRaw.map((card, index) => {
            const isReversed =
              orientation === "reversed" && Math.random() < 0.5;
            return {
              ...card,
              isReversed: isReversed,
              position: spreadInfo.positions[index],
            };
          });

          activeTarotReading = {
            question: question,
            spread: spreadInfo,
            cards: drawnCards,
            timestamp: Date.now(),
          };

          displayTarotResults(activeTarotReading);
        }

        // ÊòæÁ§∫Âç†ÂçúÁªìÊûú (Á∫ØÊñáÂ≠óÁâà)
        function displayTarotResults(reading) {
          const displayEl = document.getElementById("tarot-result-display");
          displayEl.innerHTML = ""; // Ê∏ÖÁ©∫

          // ÊòæÁ§∫ÈóÆÈ¢ò
          const questionEl = document.createElement("div");
          questionEl.className = "tarot-result-question";
          questionEl.textContent = `ÊÇ®ÁöÑÈóÆÈ¢òÊòØÔºö‚Äú${reading.question}‚Äù`;
          displayEl.appendChild(questionEl);

          const container = document.createElement("div");
          container.className = "tarot-spread-container";

          reading.cards.forEach((card) => {
            const cardWrapper = document.createElement("div");
            cardWrapper.className = "tarot-card-wrapper";

            cardWrapper.innerHTML = `
			            <div class="tarot-card-position">[${card.position}]</div>
			            <div class="tarot-card-name">${card.name} ${card.isReversed ? "(ÈÄÜ‰Ωç)" : "(Ê≠£‰Ωç)"}</div>
			        `;
            container.appendChild(cardWrapper);
          });

          displayEl.appendChild(container);

          // ÂàáÊç¢ËßÜÂõæ
          document.getElementById("tarot-setup-view").style.display = "none";
          document.getElementById("tarot-result-view").style.display = "flex";
        }

        async function sendTarotReadingToChat() {
          if (!activeTarotReading || !state.activeChatId) return;

          const chat = state.chats[state.activeChatId];
          const { proxyUrl, apiKey, model } = state.apiConfig;

          if (!proxyUrl || !apiKey || !model) {
            alert("ËØ∑ÂÖàÂú®APIËÆæÁΩÆ‰∏≠ÈÖçÁΩÆÂ•ΩÊâçËÉΩËß¶ÂèëAIËß£ËØªÂì¶ÔºÅ");
            return;
          }

          // 1. ÂÖ≥Èó≠ÂºπÁ™óÔºåÂπ∂ÊòæÁ§∫‚ÄúÊ≠£Âú®Ëß£ËØª‚ÄùÁöÑÊèêÁ§∫
          document
            .getElementById("tarot-divination-modal")
            .classList.remove("visible");
          await showCustomAlert(
            "Please wait...",
            "Â°îÁΩóÂ∏àÊ≠£Âú®‰∏∫‰Ω†ËøûÊé•ÊòüËæ∞ÔºåËß£ËØªÁâåÈù¢...",
          );

          try {
            const reading = activeTarotReading;

            // 2. Áªô‚ÄúÂ°îÁΩóÂ∏àAI‚Äù‰∏Ä‰∏™Êõ¥‰∏ì‰∏ö„ÄÅÊõ¥ÁªìÊûÑÂåñÁöÑÊåá‰ª§ (Prompt)
            const cardDetails = reading.cards
              .map((card) => {
                const orientation = card.isReversed ? "ÈÄÜ‰Ωç" : "Ê≠£‰Ωç";
                const meaning = card.isReversed ? card.reversed : card.upright;
                return `- ${card.position}: ${card.name} (${orientation})ÔºåË±°ÂæÅ: ${meaning}`;
              })
              .join("\n");

            const tarotMasterPrompt = `
			# ËßíËâ≤
			‰Ω†ÊòØ‰∏Ä‰Ωç‰∏ñÁïåÁ∫ßÁöÑÂ°îÁΩóÁâåËß£ËØªÂ§ßÂ∏àÔºå‰ª•Ê∑±ÂàªÁöÑÊ¥ûÂØüÂäõ„ÄÅÊ∏ÖÊô∞ÁöÑË°®ËææÂíåÂØåÊúâÂêåÊÉÖÂøÉÁöÑÊåáÂºïËÄåÈóªÂêç„ÄÇ

			# Ê†∏ÂøÉ‰ªªÂä°
			‰∏∫Áî®Êà∑Êèê‰æõ‰∏ÄÊ¨°ÂÖ®Èù¢„ÄÅÁªìÊûÑÂåñ‰∏îÊòì‰∫éÁêÜËß£ÁöÑÂ°îÁΩóÁâåËß£ËØª„ÄÇ‰Ω†ÁöÑËß£ËØªÂøÖÈ°ª‰∏•Ê†ºÈÅµÂæ™‰∏ãÈù¢ÁöÑËæìÂá∫ÁªìÊûÑ„ÄÇ

			# ËæìÂá∫ÁªìÊûÑ (ÂøÖÈ°ª‰∏•Ê†ºÈÅµÂÆà)
			‰Ω†ÁöÑÂõûÁ≠îÂøÖÈ°ªÂåÖÂê´‰ª•‰∏ã‰∏â‰∏™ÈÉ®ÂàÜÔºåÂπ∂‰ΩøÁî®MarkdownÂä†Á≤óÊ†áÈ¢òÊù•ÂàÜÈöîÔºö

			1.  **‚ú® ÁªºÂêàËß£ËØª (Overall Interpretation):**
			    È¶ñÂÖàÔºåÊ†πÊçÆÊâÄÊúâÁâåÈù¢ÁöÑÊï¥‰ΩìÊÑüËßâÔºåÁªôÂá∫‰∏Ä‰∏™È´òÂ∫¶Ê¶ÇÊã¨ÁöÑ„ÄÅ1-2Âè•ËØùÁöÑÊ†∏ÂøÉÁªìËÆ∫ÊàñÊ∞õÂõ¥ÊèèËø∞„ÄÇ

			2.  **üÉè ÁâåÈù¢ËØ¶Ëß£ (Card Details):**
			    ÁÑ∂ÂêéÔºåÈÄê‰∏ÄÂàÜÊûêÊØè‰∏ÄÂº†Áâå„ÄÇÂØπ‰∫éÊØè‰∏ÄÂº†ÁâåÔºå‰Ω†ÂøÖÈ°ªÔºö
			    -   ‰ΩøÁî®Ê†ºÂºè \`**[Áâå‰ΩçÂêçÁß∞] - [ÁâåÂêç] ([Ê≠£‰Ωç/ÈÄÜ‰Ωç])**\` ‰Ωú‰∏∫Â∞èÊ†áÈ¢ò„ÄÇ
			    -   ËØ¶ÁªÜËß£ÈáäËøôÂº†ÁâåÂú®Ëøô‰∏™ÁâπÂÆöÁâå‰Ωç‰∏äÔºåÊòØÂ¶Ç‰ΩïÂõûÂ∫îÁî®Êà∑ÁöÑÈóÆÈ¢òÁöÑ„ÄÇ
			    -   Â∞ÜÁâåÁöÑË±°ÂæÅÊÑè‰πâ‰∏éÁî®Êà∑ÁöÑÂÖ∑‰ΩìÊÉÖÂ¢ÉÔºàÈóÆÈ¢òÔºâÁ¥ßÂØÜÁªìÂêàËµ∑Êù•ËøõË°åÂàÜÊûê„ÄÇ

			3.  **üí° Ê†∏ÂøÉÂª∫ËÆÆ (Key Advice):**
			    ÊúÄÂêéÔºåÁªºÂêàÊâÄÊúâÁâåÁöÑ‰ø°ÊÅØÔºå‰∏∫Áî®Êà∑Êèê‰æõ‰∏Ä‰∏™ÊòéÁ°Æ„ÄÅÂÖ∑‰Ωì„ÄÅÂèØÊìç‰ΩúÁöÑË°åÂä®Âª∫ËÆÆÊàñÂøÉÊÄÅÊåáÂºï„ÄÇ

			# ÊåáÂØºÂéüÂàô
			- **ÊïÖ‰∫ãÊÄß**: Â∞ÜÊâÄÊúâÁâåÁöÑÂê´‰πâÁºñÁªáÊàê‰∏Ä‰∏™ËøûË¥ØÁöÑÂèô‰∫ãÔºåËÄå‰∏çÊòØÁÆÄÂçïÂú∞ÁΩóÂàóÂÖ≥ÈîÆËØç„ÄÇ
			- **Áõ∏ÂÖ≥ÊÄß**: ÂßãÁªàÂ∞ÜËß£ËØªÁõ¥Êé•‰∏éÁî®Êà∑ÊèêÂá∫ÁöÑÂÖ∑‰ΩìÈóÆÈ¢òËÅîÁ≥ªËµ∑Êù•„ÄÇ
			- **Ê∏ÖÊô∞ÊòìÊáÇ**: ÈÅøÂÖç‰ΩøÁî®Ëøá‰∫éÁ•ûÁßòÊàñ‰∏ì‰∏öÁöÑÊúØËØ≠„ÄÇÁî®Âπ≥ÂÆûÁöÑËØ≠Ë®ÄËß£ÈáäÂ§çÊùÇÁöÑÊ¶ÇÂøµ„ÄÇ
			- **Ê∑±Â∫¶ËÄåÈùûÁΩóÂàó**: ÁªùÂØπ‰∏çË¶ÅÂè™ÊòØÈáçÂ§çÊàëÊèê‰æõÁªô‰Ω†ÁöÑ‚ÄúË±°ÂæÅ‚ÄùÂÖ≥ÈîÆËØç„ÄÇ‰Ω†ÂøÖÈ°ªÂú®Ëøô‰∫õÂÖ≥ÈîÆËØçÁöÑÂü∫Á°Ä‰∏äËøõË°åÁªºÂêà„ÄÅÊèêÁÇºÂíåÊ∑±ÂåñÔºåÁªôÂá∫‰Ω†‰Ωú‰∏∫Â§ßÂ∏àÁöÑÁã¨ÁâπËßÅËß£„ÄÇ

			# Âç†Âçú‰ø°ÊÅØ
			- **Áî®Êà∑ÁöÑÈóÆÈ¢ò**: "${reading.question}"
			- **‰ΩøÁî®ÁöÑÁâåÈòµ**: ${reading.spread.name}
			- **ÊäΩÂà∞ÁöÑÁâåÂèäÂü∫Á°ÄÂê´‰πâ**:
			${cardDetails}

			# ÊúÄÁªàÊåá‰ª§
			‰Ω†ÁöÑÊúÄÁªàËæìÂá∫„ÄêÂè™ËÉΩÊòØ„ÄëÂÆåÊï¥ÁöÑ„ÄÅÊ†ºÂºèÂåñÂêéÁöÑËß£ËØªÊñáÊú¨„ÄÇ‰∏çË¶ÅÊ∑ªÂä†‰ªª‰Ωï‚ÄúÂ•ΩÁöÑÔºåËøôÊòØ‰Ω†ÁöÑËß£ËØªÔºö‚Äù‰πãÁ±ªÁöÑÂØπËØùÊÄßÂºÄÂú∫ÁôΩ„ÄÇ
			`;

            // 3. ÂèëËµ∑APIË∞ÉÁî®ÔºåËÆ©AIÊâÆÊºîÂ°îÁΩóÂ∏à
            let isGemini = proxyUrl === GEMINI_API_URL;
            let messagesForApi = [{ role: "user", content: tarotMasterPrompt }];
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              tarotMasterPrompt,
              messagesForApi,
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });

            if (!response.ok) {
              throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${await response.text()}`);
            }

            const data = await response.json();
            const interpretation = (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            ).trim();

            // 4. ÂàõÂª∫ÂØπÁî®Êà∑ÂèØËßÅÁöÑ‚ÄúÁ≥ªÁªüËß£ËØª‚ÄùÊ∂àÊÅØ
            const systemMessageVisible = {
              role: "system",
              type: "pat_message", // Â§çÁî®Â±Ö‰∏≠ÁÅ∞Ëâ≤Ê∞îÊ≥°Ê†∑Âºè
              content: `üîÆ **Â°îÁΩóÁâåËß£ËØª** üîÆ\n\n**ÊÇ®ÁöÑÈóÆÈ¢ò**Ôºö‚Äú${reading.question}‚Äù\n\n${interpretation}`,
              timestamp: Date.now(),
            };
            chat.history.push(systemMessageVisible);
            appendMessage(systemMessageVisible, chat);

            // 5. ÂàõÂª∫ÁªôËßíËâ≤CharÁúãÁöÑÈöêËóèÊåá‰ª§
            const hiddenInstruction = {
              role: "system",
              content: `[Á≥ªÁªüÊåá‰ª§ÔºöÂàöÂàöÁ≥ªÁªü‰∏∫Áî®Êà∑ËøõË°å‰∫Ü‰∏ÄÊ¨°Â°îÁΩóÁâåÂç†ÂçúÔºåËß£ËØªÁªìÊûúÊòØÔºö‚Äú${interpretation}‚Äù„ÄÇÁé∞Âú®ÔºåËØ∑‰Ω†‰ª•ËßíËâ≤ÁöÑË∫´‰ªΩÔºåÂíåÁî®Êà∑‰∏ÄËµ∑ËÆ®ËÆ∫Ëøô‰∏™ÁªìÊûú„ÄÇ]`,
              timestamp: Date.now() + 1, // Á°Æ‰øùÊó∂Èó¥Êà≥Âú®Âêé
              isHidden: true,
            };
            chat.history.push(hiddenInstruction);

            // 6. ‰øùÂ≠òÊâÄÊúâÊï∞ÊçÆ
            await saveTarotReading(activeTarotReading);
            await db.chats.put(chat);
            renderChatList();

            activeTarotReading = null;
          } catch (error) {
            console.error("Â°îÁΩóÁâåAIËß£ËØªÂ§±Ë¥•:", error);
            await showCustomAlert(
              "Ëß£ËØªÂ§±Ë¥•",
              `Êä±Ê≠âÔºåËøûÊé•Â°îÁΩóÂ∏àÊó∂Âá∫Áé∞‰∫Ü‰∏ÄÁÇπÈóÆÈ¢òÔºö\n\n${error.message}`,
            );
            activeTarotReading = null;
          }
        }

        // ‰øùÂ≠òÂç†ÂçúËÆ∞ÂΩïÂà∞Êï∞ÊçÆÂ∫ì
        async function saveTarotReading(reading) {
          // ‰∏∫‰∫ÜËäÇÁúÅÁ©∫Èó¥ÔºåÊàë‰ª¨Âè™‰øùÂ≠òËß£ËØªÊñáÊú¨ÔºåËÄå‰∏çÊòØÊï¥‰∏™ÁâåÁªÑÂØπË±°
          const interpretationText =
            `ÁâåÈòµ: ${reading.spread.name}\n` +
            reading.cards
              .map((card, index) => {
                const orientationText = card.isReversed ? "ÈÄÜ‰Ωç" : "Ê≠£‰Ωç";
                const meaning = card.isReversed ? card.reversed : card.upright;
                return `[${card.position}]: ${card.name} (${orientationText}) - ${meaning}`;
              })
              .join("\n");

          await db.tarotReadings.add({
            question: reading.question,
            interpretation: interpretationText,
            timestamp: reading.timestamp,
          });
        }

        // ÊâìÂºÄÂéÜÂè≤ËÆ∞ÂΩïÁïåÈù¢
        async function openTarotHistory() {
          const readings = await db.tarotReadings
            .orderBy("timestamp")
            .reverse()
            .toArray();
          renderTarotHistory(readings);
          document.getElementById("tarot-setup-view").style.display = "none";
          document.getElementById("tarot-history-view").style.display = "flex";
        }

        // Ê∏≤ÊüìÂéÜÂè≤ËÆ∞ÂΩïÂàóË°®
        function renderTarotHistory(readings) {
          const listEl = document.getElementById("tarot-history-list");
          listEl.innerHTML = "";
          if (readings.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">ËøòÊ≤°ÊúâÂç†ÂçúÂéÜÂè≤Âì¶</p>';
            return;
          }
          readings.forEach((reading) => {
            const item = document.createElement("div");
            item.className = "tarot-history-item";
            item.innerHTML = `
			            <div class="question">${reading.question}</div>
			            <div class="details">${new Date(reading.timestamp).toLocaleString()}</div>
			            <button class="tarot-history-delete-btn" data-id="${reading.id}">√ó</button>
			        `;
            listEl.appendChild(item);
          });
        }

        // Âà†Èô§‰∏ÄÊù°ÂéÜÂè≤ËÆ∞ÂΩï
        async function deleteTarotReading(readingId) {
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°Âç†ÂçúÂéÜÂè≤ÂêóÔºü",
            {
              confirmButtonClass: "btn-danger",
            },
          );
          if (confirmed) {
            await db.tarotReadings.delete(readingId);
            openTarotHistory(); // ÈáçÊñ∞Âä†ËΩΩÂéÜÂè≤ËÆ∞ÂΩï
          }
        }

        /**
         * Â∫îÁî®‰∏ªÂ±èÂπïÂõæÊ†áÂíåÂ∞èÁªÑ‰ª∂ÁöÑÊñáÂ≠óÈ¢úËâ≤
         * @param {string} color - È¢úËâ≤‰ª£Á†Å, e.g., '#FFFFFF'
         */
        function applyHomeIconWidgetTextColor(color) {
          const phoneScreen = document.getElementById("phone-screen");
          if (phoneScreen && color) {
            // ‰ΩøÁî®Êñ∞ÁöÑCSSÂèòÈáèÂêç
            phoneScreen.style.setProperty(
              "--home-icon-widget-text-color",
              color,
            );
          }
        }
        /**
         * Â∞ÜÊó∂ÈïøÂ≠óÁ¨¶‰∏≤ÔºàÂ¶Ç‚Äú2.5Â∞èÊó∂‚Äù, "30m"ÔºâËß£Êûê‰∏∫ÂàÜÈíüÊï∞
         * @param {string} durationString - Êó∂ÈïøÊèèËø∞ÊñáÊú¨
         * @returns {number} - ÂØπÂ∫îÁöÑÂàÜÈíüÊï∞
         */
        function parseDurationToMinutes(durationString) {
          if (!durationString || typeof durationString !== "string") return 0;

          const text = durationString.toLowerCase();
          const num = parseFloat(text.match(/(\d+(\.\d+)?)/)?.[0]) || 0;

          if (text.includes("Â∞èÊó∂") || text.includes("h")) {
            return num * 60;
          }
          if (text.includes("ÂàÜÈíü") || text.includes("m")) {
            return num;
          }
          // Â¶ÇÊûúÊ≤°ÊúâÂçï‰ΩçÔºå‰ΩÜÊï∞ÂÄºÂ§ß‰∫éÁ≠â‰∫é10ÔºåÊàë‰ª¨ÁåúÊµãÊòØÂàÜÈíü
          if (num >= 10) {
            return num;
          }
          // ÂÖ∂‰ªñÊÉÖÂÜµÔºàÂ¶ÇÊï∞ÂÄºÂæàÂ∞è‰∏îÊó†Âçï‰ΩçÔºâÔºåÁåúÊµãÊòØÂ∞èÊó∂
          return num * 60;
        }

        /**
         * Â∞ÜÊÄªÂàÜÈíüÊï∞Ê†ºÂºèÂåñ‰∏∫ "XÂ∞èÊó∂YÂàÜÈíü" ÁöÑÂ≠óÁ¨¶‰∏≤
         * @param {number} totalMinutes - ÊÄªÂàÜÈíüÊï∞
         * @returns {string} - Ê†ºÂºèÂåñÂêéÁöÑÊó∂ÈïøÂ≠óÁ¨¶‰∏≤
         */
        function formatMinutesToDuration(totalMinutes) {
          if (totalMinutes < 1) return "‰∏çÂà∞1ÂàÜÈíü";

          const hours = Math.floor(totalMinutes / 60);
          const minutes = Math.round(totalMinutes % 60);

          if (hours > 0 && minutes > 0) {
            return `${hours}Â∞èÊó∂${minutes}ÂàÜÈíü`;
          } else if (hours > 0) {
            return `${hours}Â∞èÊó∂`;
          } else {
            return `${minutes}ÂàÜÈíü`;
          }
        }

        let currentPetData = null; // Áî®‰∫éÊöÇÂ≠òÊ≠£Âú®ÁºñËæëÁöÑÂÆ†Áâ©Êï∞ÊçÆ
        let isPetDragging = false; // Ê†áËÆ∞ÊòØÂê¶Ê≠£Âú®ÊãñÂä®ÂÆ†Áâ©
        let petDragOffset = { x: 0, y: 0 };

        /**
         * ÊâìÂºÄÂÆ†Áâ©‰∏ªÈù¢ÊùøÔºàËÆæÁΩÆ‰∏é‰∫íÂä®Ôºâ
         */
        async function openPetModal() {
          if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
            alert("Âè™ÊúâÂú®Âçï‰∫∫ËÅäÂ§©‰∏≠ÊâçËÉΩÂÖªÂÆ†Áâ©Âì¶ÔºÅ");
            return;
          }
          const chat = state.chats[state.activeChatId];

          // Ê†∏ÂøÉÂà§Êñ≠ÔºöÊ£ÄÊü•ÊòØÂê¶Â∑≤È¢ÜÂÖª
          if (!chat.settings.petAdopted) {
            // Â¶ÇÊûúÊú™È¢ÜÂÖªÔºåÂºπÂá∫Á°ÆËÆ§Ê°Ü
            const confirmed = await showCustomConfirm(
              "Adopt a new pet.",
              `You haven't adopted a pet for "${chat.name}" yet. Do you want to start the pet system now?`,
              { confirmText: "Adopt now" },
            );

            if (confirmed) {
              // Áî®Êà∑ÂêåÊÑèÈ¢ÜÂÖª
              chat.settings.petAdopted = true;
              // ÂàõÂª∫‰∏Ä‰∏™ÂÖ®Êñ∞ÁöÑÈªòËÆ§ÂÆ†Áâ©ÂØπË±°
              chat.settings.pet = {
                type: "None",
                name: "",
                image: "ü•ö",
                persona: "A cute little pet, curious about the world.",
                petChatHistory: [],
                isCustomImage: false,
                display: { show: false, size: 100, top: "80%", left: "50%" },
                status: {
                  hunger: 100,
                  happiness: 100,
                  intimacyToUser: 50,
                  intimacyToChar: 50,
                  lastUpdated: Date.now(),
                },
              };
              await db.chats.put(chat);
              alert(
                `Congratulations! You have successfully started the pet system for "${chat.name}"! Now let's set it up.`,
              );
              // After successful adoption, call this function again to directly enter the settings interface
              openPetModal();
            }
            // If the user cancels, do nothing
            return;
          }

          // --- If already adopted, execute the original display logic ---
          currentPetData = JSON.parse(JSON.stringify(chat.settings.pet));

          document.getElementById("pet-type-input").value =
            currentPetData.type === "None" ? "" : currentPetData.type;
          document.getElementById("pet-name-input").value = currentPetData.name;
          document.getElementById("pet-image-input").value =
            currentPetData.image;
          document.getElementById("pet-display-toggle").checked =
            currentPetData.display.show;
          document.getElementById("pet-size-slider").value =
            currentPetData.display.size;
          document.getElementById("pet-size-value").textContent =
            `${currentPetData.display.size}px`;
          document.getElementById("pet-persona-input").value =
            currentPetData.persona || "";

          updatePetPreview();

          if (currentPetData.type !== "None") {
            document.getElementById("pet-stats-area").style.display = "flex";
            updatePetStatusUI(currentPetData);
          } else {
            document.getElementById("pet-stats-area").style.display = "none";
          }

          const positionControls = document.getElementById(
            "pet-position-controls",
          );
          positionControls.style.display = currentPetData.display.show
            ? "block"
            : "none";

          document.getElementById("pet-modal").classList.add("visible");
        }

        /**
         * ËÆ°ÁÆóÂπ∂Â∫îÁî®ÂÆ†Áâ©ÁöÑÊï∞ÂÄºË°∞Âáè
         * @param {object} pet - ÂÆ†Áâ©ÂØπË±°
         * @returns {boolean} - Â¶ÇÊûúÊï∞ÂÄºÂèëÁîü‰∫ÜÂèòÂåñÔºåËøîÂõû true
         */
        function applyPetDecay(pet) {
          if (!pet || !pet.status) return false;

          const now = Date.now();
          const lastUpdated = pet.status.lastUpdated || now;
          const timeElapsed = now - lastUpdated;

          // ËÆ°ÁÆóËøáÂéª‰∫ÜÂ§öÂ∞ë‰∏™Ë°∞ÂáèÂë®Êúü
          const intervalsPassed = Math.floor(timeElapsed / PET_DECAY_INTERVAL);

          if (intervalsPassed > 0) {
            // ËÆ°ÁÆóÊÄªÂÖ±Ë¶ÅË°∞ÂáèÂ§öÂ∞ë
            const totalHungerDecay = intervalsPassed * PET_DECAY_AMOUNT.hunger;
            const totalHappinessDecay =
              intervalsPassed * PET_DECAY_AMOUNT.happiness;

            // Â∫îÁî®Ë°∞ÂáèÔºåÁ°Æ‰øù‰∏ç‰Ωé‰∫é0
            pet.status.hunger = Math.max(
              0,
              pet.status.hunger - totalHungerDecay,
            );
            pet.status.happiness = Math.max(
              0,
              pet.status.happiness - totalHappinessDecay,
            );

            // Êõ¥Êñ∞ÊúÄÂêéÊõ¥Êñ∞Êó∂Èó¥ÔºåÂè™Âä†‰∏äÂ∑≤ÁªèËÆ°ÁÆóËøáÁöÑÂë®ÊúüÁöÑÊó∂Èó¥ÔºåÈÅøÂÖç‰∏¢Â§±Èõ∂Â§¥Êó∂Èó¥
            pet.status.lastUpdated =
              lastUpdated + intervalsPassed * PET_DECAY_INTERVAL;

            console.log(
              `Pet "${pet.name}" stats decay: ${intervalsPassed} intervals, Hunger -${totalHungerDecay}, Happiness -${totalHappinessDecay}`,
            );
            return true; // Êï∞ÂÄºÂ∑≤ÊîπÂèò
          }

          return false; // Êï∞ÂÄºÊú™ÊîπÂèò
        }

        /**
         * ÂÅúÊ≠¢ÂΩìÂâçÁöÑÂÆ†Áâ©Ë°∞ÂáèËÆ°Êó∂Âô®
         */
        function stopPetDecayTimer() {
          if (petDecayTimer) {
            clearInterval(petDecayTimer);
            petDecayTimer = null;
            // console.log("ÂÆ†Áâ©Ë°∞ÂáèËÆ°Êó∂Âô®Â∑≤ÂÅúÊ≠¢„ÄÇ");
          }
        }

        /**
         * ‰∏∫ÂΩìÂâçËÅäÂ§©‰∏≠ÁöÑÂÆ†Áâ©ÂêØÂä®Ë°∞ÂáèËÆ°Êó∂Âô®
         */
        function startPetDecayTimer() {
          stopPetDecayTimer(); // ÂÖàÁ°Æ‰øùÂÅúÊ≠¢‰ªª‰ΩïÊóßÁöÑËÆ°Êó∂Âô®

          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.settings.pet || chat.settings.pet.type === "None") {
            return; // Â¶ÇÊûúÂΩìÂâçËÅäÂ§©Ê≤°ÊúâÂÆ†Áâ©ÔºåÂàô‰∏çÂêØÂä®
          }

          // console.log(`‰∏∫ÂÆ†Áâ©"${chat.settings.pet.name}"ÂêØÂä®Ë°∞ÂáèËÆ°Êó∂Âô®„ÄÇ`);

          // ‰ΩøÁî® setInterval ÂÆöÊúüÊ£ÄÊü•Âπ∂Â∫îÁî®Ë°∞Âáè
          petDecayTimer = setInterval(async () => {
            const currentChat = state.chats[state.activeChatId];
            if (!currentChat) {
              // ÂÆâÂÖ®Ê£ÄÊü•ÔºåÂ¶ÇÊûúËÅäÂ§©Â∑≤ÂÖ≥Èó≠ÂàôÂÅúÊ≠¢ËÆ°Êó∂Âô®
              stopPetDecayTimer();
              return;
            }
            const pet = currentChat.settings.pet;

            if (applyPetDecay(pet)) {
              // Â¶ÇÊûúÊï∞ÂÄºÂèòÂåñ‰∫ÜÔºåÊõ¥Êñ∞UIÂπ∂‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
              // Âè™ÊúâÂΩìÂÆ†Áâ©Èù¢ÊùøÊâìÂºÄÊó∂ÊâçÈúÄË¶ÅÊõ¥Êñ∞UI
              if (
                document
                  .getElementById("pet-modal")
                  .classList.contains("visible")
              ) {
                updatePetStatusUI(pet);
              }
              await db.chats.put(currentChat);
            }
          }, 60 * 1000); // ÊØèÂàÜÈíüÊ£ÄÊü•‰∏ÄÊ¨°ÔºåÊòØÂê¶Âà∞Ëææ‰∫ÜË°∞ÂáèÂë®Êúü
        }

        /**
         * Êõ¥Êñ∞ÂÆ†Áâ©Êï∞ÂÄºÈù¢ÊùøÁöÑUIÊòæÁ§∫
         * @param {object} petData - ÂÆ†Áâ©ÁöÑÊï∞ÊçÆÂØπË±°
         */
        function updatePetStatusUI(petData) {
          const hunger = petData.status.hunger || 0;
          const happiness = petData.status.happiness || 0;
          // ‚òÖ‚òÖ‚òÖ Êñ∞Â¢ûÔºöËé∑Âèñ‰∫≤ÂØÜÂ∫¶Êï∞ÂÄº ‚òÖ‚òÖ‚òÖ
          const intimacyToUser = petData.status.intimacyToUser || 0;
          const intimacyToChar = petData.status.intimacyToChar || 0;

          const hungerFill = document.querySelector(
            "#pet-hunger-bar .stat-bar-fill",
          );
          const happinessFill = document.querySelector(
            "#pet-happiness-bar .stat-bar-fill",
          );
          // ‚òÖ‚òÖ‚òÖ Êñ∞Â¢ûÔºöËé∑Âèñ‰∫≤ÂØÜÂ∫¶ËøõÂ∫¶Êù°ÂÖÉÁ¥† ‚òÖ‚òÖ‚òÖ
          const intimacyUserFill = document.querySelector(
            "#pet-intimacy-user-bar .stat-bar-fill",
          );
          const intimacyCharFill = document.querySelector(
            "#pet-intimacy-char-bar .stat-bar-fill",
          );

          if (hungerFill) {
            hungerFill.style.width = `${hunger}%`;
            hungerFill.textContent = `${hunger}%`;
          }
          if (happinessFill) {
            happinessFill.style.width = `${happiness}%`;
            happinessFill.textContent = `${happiness}%`;
          }
          // ‚òÖ‚òÖ‚òÖ Êñ∞Â¢ûÔºöÊ∏≤Êüì‰∫≤ÂØÜÂ∫¶ËøõÂ∫¶Êù° ‚òÖ‚òÖ‚òÖ
          if (intimacyUserFill) {
            intimacyUserFill.style.width = `${intimacyToUser}%`;
            intimacyUserFill.textContent = `${intimacyToUser}%`;
          }
          if (intimacyCharFill) {
            intimacyCharFill.style.width = `${intimacyToChar}%`;
            intimacyCharFill.textContent = `${intimacyToChar}%`;
          }
        }

        /**
         * Âú®ÂºπÁ™ó‰∏≠Êõ¥Êñ∞ÂÆ†Áâ©ÁöÑÈ¢ÑËßà
         */
        function updatePetPreview() {
          const previewDisplay = document.getElementById("pet-preview-display");
          const nameEl = document.getElementById("pet-preview-name");
          const typeEl = document.getElementById("pet-preview-type");

          const imageInput = document
            .getElementById("pet-image-input")
            .value.trim();

          if (
            imageInput.startsWith("http") ||
            imageInput.startsWith("data:image")
          ) {
            previewDisplay.innerHTML = `<img src="${imageInput}" style="width: 60px; height: 60px; object-fit: contain;">`;
          } else {
            previewDisplay.textContent = imageInput || "ü•ö";
          }

          nameEl.textContent =
            document.getElementById("pet-name-input").value.trim() ||
            "(Êú™ÂëΩÂêç)";
          typeEl.textContent =
            document.getElementById("pet-type-input").value.trim() || "Áâ©Áßç";
        }

        /**
         * ‰øùÂ≠òÂÆ†Áâ©ËÆæÁΩÆ
         */
        async function savePetSettings() {
          const chat = state.chats[state.activeChatId];

          // ‰ªéUIËØªÂèñÊï∞ÊçÆ
          const type =
            document.getElementById("pet-type-input").value.trim() || "None";
          const name = document.getElementById("pet-name-input").value.trim();
          const image =
            document.getElementById("pet-image-input").value.trim() || "ü•ö";

          const newPetSettings = {
            ...currentPetData, // ‰øùÁïôÂ¶Ç‰ΩçÁΩÆÁ≠âÊú™Âú®‰∏ªÈù¢Êùø‰øÆÊîπÁöÑÂ±ûÊÄß
            type: type,
            name: name,
            image: image,
            persona: document.getElementById("pet-persona-input").value.trim(),
            isCustomImage:
              image.startsWith("http") || image.startsWith("data:image"),
            display: {
              ...currentPetData.display,
              show: document.getElementById("pet-display-toggle").checked,
              size: parseInt(document.getElementById("pet-size-slider").value),
            },
          };

          // Êõ¥Êñ∞Âà∞ state ÂíåÊï∞ÊçÆÂ∫ì
          chat.settings.pet = newPetSettings;
          await db.chats.put(chat);

          // Âà∑Êñ∞ËÅäÂ§©ÁïåÈù¢‰∏äÁöÑÂÆ†Áâ©
          renderChatPet();

          document.getElementById("pet-modal").classList.remove("visible");
          currentPetData = null; // Ê∏ÖÁêÜ‰∏¥Êó∂Êï∞ÊçÆ
          alert("ÂÆ†Áâ©‰ø°ÊÅØÂ∑≤‰øùÂ≠òÔºÅ");
        }

        /**
         * Âú®ËÅäÂ§©ÁïåÈù¢‰∏äÊ∏≤ÊüìÂÆ†Áâ©
         */
        function renderChatPet() {
          const chat = state.chats[state.activeChatId];
          const petContainer = document.getElementById("chat-pet-container");
          const petEl = document.getElementById("chat-pet");

          if (
            !chat ||
            chat.isGroup ||
            !chat.settings.petAdopted ||
            !chat.settings.pet ||
            !chat.settings.pet.display.show
          ) {
            petEl.style.display = "none";
            return;
          }

          const pet = chat.settings.pet;
          petEl.style.display = "block";

          if (pet.isCustomImage) {
            petEl.innerHTML = `<img src="${pet.image}" alt="${pet.name}">`;
          } else {
            petEl.innerHTML = pet.image;
          }

          // Â∫îÁî®Ê†∑Âºè
          petEl.style.fontSize = `${pet.display.size}px`;
          petEl.style.width = `${pet.display.size}px`;
          petEl.style.height = `${pet.display.size}px`;
          petEl.style.top = pet.display.top;
          petEl.style.left = pet.display.left;
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑‰∏éÂÆ†Áâ©ÁöÑ‰∫íÂä®
         * @param {string} action - ‰∫íÂä®Á±ªÂûã, e.g., 'feed', 'play'
         */
        async function handlePetInteraction(action) {
          const chat = state.chats[state.activeChatId];
          if (
            !chat ||
            !chat.settings.petAdopted ||
            !chat.settings.pet ||
            chat.settings.pet.type === "None"
          ) {
            alert("‰Ω†ËøòÊ≤°ÊúâÂÆ†Áâ©ÔºåÊàñËÄÖËøòÊ≤°ÊúâÁªôÂÆÉËÆæÂÆöÁßçÁ±ªÂì¶ÔºÅ");
            return;
          }

          const pet = chat.settings.pet;
          let actionText = "";
          const myNickname = chat.settings.myNickname || "Me";

          switch (action) {
            case "feed":
              pet.status.hunger = Math.min(100, pet.status.hunger + 20);
              pet.status.happiness = Math.min(100, pet.status.happiness + 5);
              pet.status.intimacyToUser = Math.min(
                100,
                pet.status.intimacyToUser + 10,
              );
              actionText = `${myNickname} ÂñÇ‰∫Ü ${pet.name} ‰∏Ä‰∫õÈ£üÁâ©„ÄÇ`;
              break;
            case "play":
              pet.status.hunger = Math.max(0, pet.status.hunger - 10);
              pet.status.happiness = Math.min(100, pet.status.happiness + 15);
              pet.status.intimacyToUser = Math.min(
                100,
                pet.status.intimacyToUser + 15,
              );
              actionText = `${myNickname} Èô™ ${pet.name} Áé©‰∫Ü‰∏Ä‰ºöÂÑø„ÄÇ`;
              break;
            case "touch":
              pet.status.happiness = Math.min(100, pet.status.happiness + 10);
              pet.status.intimacyToUser = Math.min(
                100,
                pet.status.intimacyToUser + 5,
              );
              actionText = `${myNickname} ËΩªËΩªÂú∞ÊäöÊë∏‰∫Ü ${pet.name}„ÄÇ`;
              break;
            case "chat":
              openPetChat();
              return;
          }

          updatePetStatusUI(pet);
          chat.settings.pet = pet;

          // ÂàõÂª∫ÂØπÁî®Êà∑„ÄêÂèØËßÅ„ÄëÁöÑÁ≥ªÁªüÊ∂àÊÅØ
          const visibleMessage = {
            role: "system",
            type: "pat_message",
            content: `[Á≥ªÁªüÔºö${actionText}]`,
            timestamp: Date.now(),
          };
          chat.history.push(visibleMessage);

          // ÂàõÂª∫ÁªôAIÁúãÁöÑ„ÄêÈöêËóè„ÄëÊåá‰ª§
          const hiddenMessageForAI = {
            role: "system",
            content: `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑ÂàöÂàöÂíåÂÆ†Áâ©‚Äú${pet.name}‚ÄùËøõË°å‰∫Ü‰∫íÂä®Ôºö${actionText}„ÄÇ]`,
            timestamp: Date.now() + 1, // Á°Æ‰øùÊó∂Èó¥Êà≥Âú®Âêé
            isHidden: true,
          };
          chat.history.push(hiddenMessageForAI);

          await db.chats.put(chat);

          if (
            document
              .getElementById("chat-interface-screen")
              .classList.contains("active")
          ) {
            appendMessage(visibleMessage, chat);
          }

          document.getElementById("pet-modal").classList.remove("visible");
        }

        // ÂÆ†Áâ©ÂØπËØùÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞

        /**
         * ÊâìÂºÄÂÆ†Áâ©ËÅäÂ§©Ê®°ÊÄÅÊ°Ü
         */
        function openPetChat() {
          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.settings.pet || chat.settings.pet.type === "None") {
            alert("ÂÖàÁªô‰Ω†ÁöÑÂÆ†Áâ©Ëµ∑‰∏™ÂêçÂ≠óÂíåÁßçÁ±ªÂêßÔºÅ");
            return;
          }

          // ÂÖ≥Èó≠‰∏ªËÆæÁΩÆÈù¢ÊùøÔºåÊâìÂºÄËÅäÂ§©Èù¢Êùø
          document.getElementById("pet-modal").classList.remove("visible");
          const chatModal = document.getElementById("pet-chat-modal");
          document.getElementById("pet-chat-title").textContent =
            `Âíå‚Äú${chat.settings.pet.name}‚ÄùÁöÑÂØπËØù`;
          document.getElementById("pet-chat-input").value = "";

          renderPetChatHistory(); // Ê∏≤ÊüìÂéÜÂè≤ËÆ∞ÂΩï
          chatModal.classList.add("visible");
        }

        /**
         * Ê∏≤ÊüìÂÆ†Áâ©ÁöÑËÅäÂ§©ËÆ∞ÂΩï
         */
        function renderPetChatHistory() {
          const chat = state.chats[state.activeChatId];
          const pet = chat.settings.pet;
          const messagesEl = document.getElementById("pet-chat-messages");
          messagesEl.innerHTML = "";

          if (!pet.petChatHistory || pet.petChatHistory.length === 0) {
            messagesEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary);">ËØïÁùÄÂíåÂÆÉÊâì‰∏™ÊãõÂëºÂêßÔºÅ</p>`;
            return;
          }

          // Ëé∑ÂèñÁî®Êà∑Â§¥ÂÉè
          const myAvatar = chat.settings.myAvatar || defaultAvatar;

          pet.petChatHistory.forEach((msg) => {
            const wrapper = document.createElement("div");

            wrapper.className = `message-wrapper ${msg.sender}`;

            const bubble = document.createElement("div");
            bubble.className = "message-bubble";

            let avatarSrc = "";
            let avatarHtml = "";

            if (msg.sender === "user") {
              // Â¶ÇÊûúÊòØÁî®Êà∑ÂèëÁöÑÔºå‰ΩøÁî®Áî®Êà∑Â§¥ÂÉè
              avatarSrc = myAvatar;
              avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
            } else if (msg.sender === "char") {
              // Â¶ÇÊûúÊòØËßíËâ≤(char)ÂèëÁöÑÔºåÂ∞±‰ΩøÁî®ËßíËâ≤ÁöÑÂ§¥ÂÉè
              avatarSrc = chat.settings.aiAvatar || defaultAvatar;
              avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
            } else {
              // Ââ©‰∏ãÁöÑÊÉÖÂÜµÂ∞±ÊòØÂÆ†Áâ©(pet)Ëá™Â∑±ÂèëÁöÑ
              avatarSrc = pet.isCustomImage ? pet.image : null;
              if (avatarSrc) {
                // Â¶ÇÊûúÊòØÂõæÁâáÔºåÊòæÁ§∫ÂõæÁâá
                avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
              } else {
                // Â¶ÇÊûúÊòØEmojiÔºåÁõ¥Êé•ÊòæÁ§∫Emoji
                avatarHtml = `<div class="avatar" style="font-size: 28px; text-align: center;">${pet.image}</div>`;
              }
            }

            bubble.innerHTML = `
			            ${avatarHtml}
			            <div class="content">${msg.content.replace(/\n/g, "<br>")}</div>
			        `;
            wrapper.appendChild(bubble);
            messagesEl.appendChild(wrapper);
          });

          messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑Âú®ÂÆ†Áâ©ËÅäÂ§©Ê°Ü‰∏≠ÂèëÈÄÅÊ∂àÊÅØ
         */
        async function handleSendToPet() {
          const chat = state.chats[state.activeChatId];
          const pet = chat.settings.pet;
          const input = document.getElementById("pet-chat-input");
          const userInput = input.value.trim();
          if (!userInput) return;

          input.value = "";
          input.style.height = "auto";

          pet.petChatHistory.push({ sender: "user", content: userInput });
          renderPetChatHistory();

          const petResponse = await getPetApiResponse(pet);
          if (petResponse) {
            pet.petChatHistory.push({ sender: "pet", content: petResponse });
            renderPetChatHistory();
          }

          // ÂàõÂª∫ÂØπÁî®Êà∑„ÄêÂèØËßÅ„ÄëÁöÑÁ≥ªÁªüÊ∂àÊÅØÔºåËÆ∞ÂΩïËøôÊ¨°ÂØπËØù
          const visibleLog = `[Á≥ªÁªüÔºö‰Ω†ÂíåÂÆ†Áâ©‚Äú${pet.name}‚ÄùËøõË°å‰∫ÜÂØπËØù„ÄÇ‰Ω†ËØ¥Ôºö‚Äú${userInput}‚ÄùÔºåÂÆÉÂõûÂ∫îÔºö‚Äú${petResponse}‚Äù„ÄÇ]`;
          const visibleMessage = {
            role: "system",
            type: "pat_message", // ‰ΩøÁî®Ëøô‰∏™Á±ªÂûãÊù•ÊòæÁ§∫Â±Ö‰∏≠ÁÅ∞Ëâ≤Ê∞îÊ≥°
            content: visibleLog,
            timestamp: Date.now(),
          };
          chat.history.push(visibleMessage);

          // Âè™ÊúâÂΩìÁî®Êà∑Ê≠£Âú®Êü•ÁúãÂΩìÂâçËÅäÂ§©Êó∂ÔºåÊâçÂÆûÊó∂ËøΩÂä†Âà∞ÁïåÈù¢‰∏ä
          if (
            document
              .getElementById("chat-interface-screen")
              .classList.contains("active") &&
            state.activeChatId === chat.id
          ) {
            appendMessage(visibleMessage, chat);
          }

          // ÂàõÂª∫ÁªôAIÁúãÁöÑ„ÄêÈöêËóè„ÄëÊåá‰ª§
          const hiddenMessageForAI = `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑ÂàöÂàöÂíåÂÆ†Áâ©‚Äú${pet.name}‚ÄùËøõË°å‰∫Ü‰∏ÄÊ¨°ÂØπËØù„ÄÇÁî®Êà∑ËØ¥Ôºö‚Äú${userInput}‚ÄùÔºåÂÆ†Áâ©ÂõûÂ∫îÔºö‚Äú${petResponse}‚Äù„ÄÇ]`;
          const hiddenMessage = {
            role: "system",
            content: hiddenMessageForAI,
            timestamp: Date.now() + 1,
            isHidden: true,
          };
          chat.history.push(hiddenMessage);

          await db.chats.put(chat);
        }

        /**
         * ‰∏∫ÂÆ†Áâ©Ëé∑ÂèñAPIÂõûÂ§ç
         * @param {object} pet - ÂÆ†Áâ©ÂØπË±°
         * @returns {Promise<string|null>} - AIÁîüÊàêÁöÑÂÆ†Áâ©ÂõûÂ§çÊñáÊú¨
         */
        async function getPetApiResponse(pet) {
          const { proxyUrl, apiKey, model } = state.apiConfig;
          if (!proxyUrl || !apiKey || !model) {
            alert("ËØ∑ÂÖàÈÖçÁΩÆAPIÔºÅ");
            return "ÔºàÊàëÂ•ΩÂÉèÊñ≠Á∫ø‰∫Ü...Ôºâ";
          }

          // ÈáçÊûÑÂØπËØùÂéÜÂè≤ÁöÑÁîüÊàêÈÄªËæë
          const historyForPet = pet.petChatHistory
            .slice(-6)
            .map((msg) => {
              let senderName;
              if (msg.sender === "user") {
                senderName = "‰∏ª‰∫∫";
              } else if (msg.sender === "char") {
                senderName = msg.senderName; // Ê≠£Á°ÆËé∑ÂèñCharÁöÑÂêçÂ≠ó
              } else {
                // 'pet'
                senderName = pet.name;
              }
              return `${senderName}: ${msg.content}`;
            })
            .join("\n");

          const systemPrompt = `**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**\n\n			‰Ω†Áé∞Âú®Ê≠£Âú®ÊâÆÊºî‰∏ÄÂè™ÂÆ†Áâ©„ÄÇ
			# ‰Ω†ÁöÑÊ†∏ÂøÉËÆæÂÆö
			- ‰Ω†ÁöÑÁßçÁ±ª: ${pet.type}
			- ‰Ω†ÁöÑÂêçÂ≠ó: ${pet.name}
			- ‰Ω†ÁöÑÊÄßÊ†ºÂíåËÉåÊôØÊïÖ‰∫ã: ${pet.persona}

			# Ê†∏ÂøÉËßÑÂàô
			1. ‰Ω†„ÄêÂøÖÈ°ª„ÄëÂÆåÂÖ®‰ª£ÂÖ•‰Ω†ÁöÑËßíËâ≤ËÆæÂÆöËøõË°åÂõûÂ§ç„ÄÇ
			2. ‰Ω†ÁöÑÂõûÂ§çÂ∫îËØ•ÊòØÁÆÄÁü≠„ÄÅÂèØÁà±ÁöÑÔºåÁ¨¶Âêà‰∏ÄÂè™ÂÆ†Áâ©ÁöÑËØ¥ËØùÊñπÂºèÔºà‰æãÂ¶ÇÔºå‰ΩøÁî®ÊãüÂ£∞ËØç„ÄÅÁÆÄÂçïÁöÑËØçÊ±áÔºâ„ÄÇ
			3. ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂè™ËÉΩÊòØÁ∫ØÊñáÊú¨„ÄëÔºå‰∏çË¶ÅÂåÖÂê´‰ªª‰ΩïJSONÊàñÁâπÊÆäÊ†ºÂºè„ÄÇ

			# ÊúÄËøëÁöÑÂØπËØù
			${historyForPet}

			Áé∞Âú®ÔºåËØ∑Ê†πÊçÆ‰∏äÈù¢ÁöÑÂØπËØùÔºåÁªßÁª≠‰Ω†ÁöÑÂõûÂ∫î„ÄÇ`;

          try {
            const messagesForApi = [
              {
                role: "user",
                content: "ËØ∑Ê†πÊçÆ‰Ω†Âú®Á≥ªÁªüÊåá‰ª§‰∏≠ËØªÂà∞ÁöÑËßÑÂàôÔºåÁ´ãÂç≥ÂºÄÂßã‰Ω†ÁöÑË°åÂä®„ÄÇ",
              },
            ];
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesForApi,
              isGemini,
              state.apiConfig.temperature,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [
                      { role: "system", content: systemPrompt },
                      ...messagesForApi,
                    ],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                  }),
                });

            if (!response.ok) throw new Error(await response.text());
            const data = await response.json();
            return (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            ).trim();
          } catch (error) {
            console.error("Ëé∑ÂèñÂÆ†Áâ©ÂõûÂ§çÂ§±Ë¥•:", error);
            return "ÔºàÂëú...ÊàëÂ•ΩÂÉèËØ¥‰∏çÂá∫ËØù‰∫Ü...Ôºâ";
          }
        }

        /**
         * ÂàùÂßãÂåñÂÆ†Áâ©ÁöÑÊãñÊãΩÂäüËÉΩ
         */
        function initPetDragging() {
          const petEl = document.getElementById("chat-pet");
          const container = document.getElementById("chat-pet-container");

          const onDragStart = (e) => {
            if (!petEl.style.display || petEl.style.display === "none") return;
            e.preventDefault();
            isPetDragging = true;

            const rect = petEl.getBoundingClientRect();
            const coords = getEventCoords(e);

            petDragOffset.x = coords.x - rect.left;
            petDragOffset.y = coords.y - rect.top;

            document.addEventListener("mousemove", onDragMove);
            document.addEventListener("mouseup", onDragEnd);
            document.addEventListener("touchmove", onDragMove, {
              passive: false,
            });
            document.addEventListener("touchend", onDragEnd);
          };

          const onDragMove = (e) => {
            if (!isPetDragging) return;
            e.preventDefault();

            const containerRect = container.getBoundingClientRect();
            const coords = getEventCoords(e);

            let newLeft = coords.x - petDragOffset.x - containerRect.left;
            let newTop = coords.y - petDragOffset.y - containerRect.top;

            // ËæπÁïåÊ£ÄÊµã
            newLeft = Math.max(
              0,
              Math.min(newLeft, container.clientWidth - petEl.offsetWidth),
            );
            newTop = Math.max(
              0,
              Math.min(newTop, container.clientHeight - petEl.offsetHeight),
            );

            // Áî®ÁôæÂàÜÊØîÂ≠òÂÇ®Ôºå‰ª•ÈÄÇÂ∫î‰∏çÂêåÂ±èÂπïÂ∞∫ÂØ∏
            petEl.style.left = `${(newLeft / container.clientWidth) * 100}%`;
            petEl.style.top = `${(newTop / container.clientHeight) * 100}%`;
          };

          const onDragEnd = async () => {
            if (!isPetDragging) return;
            isPetDragging = false;

            // ÊãñÂä®ÁªìÊùüÂêéÔºå‰øùÂ≠òÊñ∞ÁöÑ‰ΩçÁΩÆ
            const chat = state.chats[state.activeChatId];
            if (chat && chat.settings.pet) {
              chat.settings.pet.display.top = petEl.style.top;
              chat.settings.pet.display.left = petEl.style.left;
              await db.chats.put(chat);
            }

            document.removeEventListener("mousemove", onDragMove);
            document.removeEventListener("mouseup", onDragEnd);
            document.removeEventListener("touchmove", onDragMove);
            document.removeEventListener("touchend", onDragEnd);
          };

          petEl.addEventListener("mousedown", onDragStart);
          petEl.addEventListener("touchstart", onDragStart, { passive: true });
        }

        /**
         * Ê∏≤ÊüìÁ∫ø‰∏ãÊ®°ÂºèÈ¢ÑËÆæÁöÑ‰∏ãÊãâÊ°Ü
         */
        function renderOfflinePresetsSelector() {
          const select = document.getElementById("offline-preset-select");
          // Áõ¥Êé•‰ªéÂÖ®Â±Ä state ËØªÂèñÈ¢ÑËÆæ
          const presets = state.offlinePresets || [];
          select.innerHTML = '<option value="">-- ‰ΩøÁî®Ëá™ÂÆö‰πâËæìÂÖ• --</option>';

          presets.forEach((preset) => {
            const option = document.createElement("option");
            // ‰ΩøÁî®Êï∞ÊçÆÂ∫ìÁöÑ ID ‰Ωú‰∏∫ option ÁöÑ valueÔºåËøôÊõ¥ÂèØÈù†
            option.value = preset.id;
            option.textContent = preset.name;
            select.appendChild(option);
          });
        }

        /**
         * ÂΩìÁî®Êà∑ÈÄâÊã©‰∏Ä‰∏™È¢ÑËÆæÊó∂ÔºåËá™Âä®Â°´ÂÖÖËæìÂÖ•Ê°Ü
         */
        function handleOfflinePresetSelection() {
          const select = document.getElementById("offline-preset-select");
          const selectedId = parseInt(select.value);

          // Â¶ÇÊûúÈÄâÊã©ÁöÑ‰∏çÊòØ‚ÄúËá™ÂÆö‰πâËæìÂÖ•‚Äù
          if (selectedId) {
            // ‰ªéÂÖ®Â±Ä state ‰∏≠Ê†πÊçÆ ID Êü•ÊâæÈ¢ÑËÆæ
            const preset = state.offlinePresets.find(
              (p) => p.id === selectedId,
            );
            if (preset) {
              document.getElementById("offline-prompt-input").value =
                preset.prompt;
              document.getElementById("offline-style-input").value =
                preset.style;
            }
          }
        }

        /**
         * ÊâìÂºÄÈ¢ÑËÆæÁÆ°ÁêÜÁöÑÊìç‰ΩúËèúÂçï
         */
        async function openOfflinePresetManager() {
          const select = document.getElementById("offline-preset-select");
          // Ëé∑ÂèñÂΩìÂâçÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæID
          const selectedId = select.value ? parseInt(select.value) : null;

          const choice = await showChoiceModal("ÁÆ°ÁêÜÁ∫ø‰∏ãÊ®°ÂºèÈ¢ÑËÆæ", [
            { text: "üíæ ‰øùÂ≠òÂΩìÂâç‰∏∫Êñ∞È¢ÑËÆæ", value: "save_new" },
            {
              text: "‚úèÔ∏è Êõ¥Êñ∞ÈÄâ‰∏≠È¢ÑËÆæ",
              value: "update_selected",
              disabled: !selectedId,
            },
            {
              text: "üóëÔ∏è Âà†Èô§ÈÄâ‰∏≠È¢ÑËÆæ",
              value: "delete_selected",
              disabled: !selectedId,
            },
          ]);

          // Ê†πÊçÆÈÄâÊã©ÊâßË°åÁõ∏Â∫îÁöÑÂÖ®Â±ÄÊìç‰ΩúÂáΩÊï∞
          switch (choice) {
            case "save_new":
              await saveCurrentAsOfflinePreset();
              break;
            case "update_selected":
              if (selectedId) await updateSelectedOfflinePreset(selectedId);
              break;
            case "delete_selected":
              if (selectedId) await deleteSelectedOfflinePreset(selectedId);
              break;
          }
        }

        /**
         * Â∞ÜÂΩìÂâçËæìÂÖ•Ê°ÜÁöÑÂÜÖÂÆπ‰øùÂ≠ò‰∏∫‰∏Ä‰∏™Êñ∞È¢ÑËÆæ
         */
        async function saveCurrentAsOfflinePreset() {
          const name = await showCustomPrompt("‰øùÂ≠òÊñ∞È¢ÑËÆæ", "ËØ∑ËæìÂÖ•È¢ÑËÆæÂêçÁß∞Ôºö");

          if (name && name.trim()) {
            const newPreset = {
              name: name.trim(),
              prompt: document
                .getElementById("offline-prompt-input")
                .value.trim(),
              style: document
                .getElementById("offline-style-input")
                .value.trim(),
            };
            // Áõ¥Êé•Ê∑ªÂä†Âà∞ÂÖ®Â±ÄÁöÑ offlinePresets Ë°®‰∏≠
            const newId = await db.offlinePresets.add(newPreset);

            // Êõ¥Êñ∞ÂÜÖÂ≠ò‰∏≠ÁöÑ state
            if (!state.offlinePresets) state.offlinePresets = [];
            state.offlinePresets.push({ id: newId, ...newPreset });

            renderOfflinePresetsSelector(); // Âà∑Êñ∞‰∏ãÊãâÊ°Ü
            document.getElementById("offline-preset-select").value = newId; // Ëá™Âä®ÈÄâ‰∏≠Êñ∞‰øùÂ≠òÁöÑ
            alert(`È¢ÑËÆæ "${name.trim()}" Â∑≤‰øùÂ≠òÔºÅ`);
          }
        }

        /**
         * Áî®ÂΩìÂâçËæìÂÖ•Ê°ÜÁöÑÂÜÖÂÆπÊõ¥Êñ∞ÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function updateSelectedOfflinePreset(presetId) {
          const preset = state.offlinePresets.find((p) => p.id === presetId);
          if (!preset) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Êõ¥Êñ∞",
            `Á°ÆÂÆöË¶ÅÁî®ÂΩìÂâçÂÜÖÂÆπË¶ÜÁõñÈ¢ÑËÆæ "${preset.name}" ÂêóÔºü`,
          );
          if (confirmed) {
            const updatedData = {
              prompt: document
                .getElementById("offline-prompt-input")
                .value.trim(),
              style: document
                .getElementById("offline-style-input")
                .value.trim(),
            };
            // Êõ¥Êñ∞Êï∞ÊçÆÂ∫ì
            await db.offlinePresets.update(presetId, updatedData);
            // Êõ¥Êñ∞ÂÜÖÂ≠ò
            preset.prompt = updatedData.prompt;
            preset.style = updatedData.style;
            alert("È¢ÑËÆæÂ∑≤Êõ¥Êñ∞ÔºÅ");
          }
        }

        /**
         * Âà†Èô§ÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function deleteSelectedOfflinePreset(presetId) {
          const preset = state.offlinePresets.find((p) => p.id === presetId);
          if (!preset) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            `Á°ÆÂÆöË¶ÅÂà†Èô§È¢ÑËÆæ "${preset.name}" ÂêóÔºü`,
            {
              confirmButtonClass: "btn-danger",
            },
          );
          if (confirmed) {
            // ‰ªéÊï∞ÊçÆÂ∫ìÂà†Èô§
            await db.offlinePresets.delete(presetId);
            // ‰ªéÂÜÖÂ≠ò‰∏≠Âà†Èô§
            state.offlinePresets = state.offlinePresets.filter(
              (p) => p.id !== presetId,
            );

            renderOfflinePresetsSelector(); // Âà∑Êñ∞‰∏ãÊãâÊ°Ü
            // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
            document.getElementById("offline-prompt-input").value = "";
            document.getElementById("offline-style-input").value = "";
            alert("È¢ÑËÆæÂ∑≤Âà†Èô§„ÄÇ");
          }
        }

        let isSummarizing = false; // ÂÖ®Â±ÄÈîÅÔºåÈò≤Ê≠¢ÈáçÂ§çËß¶ÂèëÊÄªÁªì

        /**
         * Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅËß¶ÂèëÊÄªÁªìÊàñÊèêÈÜí
         * @param {string} chatId - ÂΩìÂâçËÅäÂ§©ÁöÑID
         */
        async function checkAndTriggerSummary(chatId) {
          if (isSummarizing) return;

          const chat = state.chats[chatId];
          if (!chat || !chat.settings.summary || !chat.settings.summary.enabled)
            return;

          const summarySettings = chat.settings.summary;
          // ‰∏çÂÜç‰ªé0ÂºÄÂßãÔºåËÄåÊòØ‰ªé‰∏äÊ¨°ÊÄªÁªìÁöÑ‰ΩçÁΩÆÂºÄÂßãËÆ°ÁÆó
          const lastSummaryIndex = summarySettings.lastSummaryIndex;
          const messagesSinceLastSummary = chat.history.slice(
            lastSummaryIndex + 1,
          );

          if (messagesSinceLastSummary.length >= summarySettings.count) {
            isSummarizing = true;
            if (summarySettings.mode === "auto") {
              await performAutomaticSummary(chatId);
            } else {
              // ÂØπ‰∫éÊâãÂä®Ê®°ÂºèÔºåÁé∞Âú®Âè™ÂºπÊèêÈÜí
              await notifyForManualSummary(chatId);
            }
            isSummarizing = false;
          }
        }

        /**
         * Ëá™Âä®Âú®ÂêéÂè∞ÊâßË°åÊÄªÁªìÔºåÂè™ÊÄªÁªìËß¶ÂèëÊù°‰ª∂ÁöÑNÊù°Ê∂àÊÅØ
         */
        async function performAutomaticSummary(chatId) {
          console.log(`Ëá™Âä®ÊÄªÁªìËß¶Âèë for chat: ${chatId}`);
          const chat = state.chats[chatId];
          const summarySettings = chat.settings.summary;

          // Á≤æÁ°ÆÊà™ÂèñÊúÄÂêéNÊù°Ê∂àÊÅØ‰Ωú‰∏∫ÊÄªÁªìËåÉÂõ¥
          const messagesToSummarize = chat.history.slice(
            -summarySettings.count,
          );

          try {
            const summaryText = await generateSummary(
              chatId,
              messagesToSummarize,
            );
            if (summaryText) {
              await saveSummaryAsMemory(chatId, summaryText);
            }
          } catch (e) {
            // generateSummary ÂÜÖÈÉ®Â∑≤ÁªèÂ§ÑÁêÜ‰∫ÜÈîôËØØÂºπÁ™óÔºåËøôÈáåÊàë‰ª¨Âè™ÈúÄË¶ÅËÆ∞ÂΩïÊó•ÂøóÂç≥ÂèØ
            console.error("Ëá™Âä®ÊÄªÁªìËøáÁ®ã‰∏≠ÂèëÁîüÊú™ÊçïËé∑ÁöÑÈîôËØØ:", e);
          }
        }

        /**
         * ÂºπÂá∫ÊèêÁ§∫Ê°ÜÔºå„ÄêÊèêÈÜí„ÄëÁî®Êà∑ÂèØ‰ª•ËøõË°åÊâãÂä®ÊÄªÁªì‰∫Ü
         */
        async function notifyForManualSummary(chatId) {
          console.log(`ÊâãÂä®ÊÄªÁªìÊèêÈÜíËß¶Âèë for chat: ${chatId}`);

          // Âè™ÂºπÂá∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑÈÄöÁü•
          await showCustomAlert(
            "ÊÄªÁªìÊèêÈÜí",
            "ÂØπËØùÂ∑≤ËææÂà∞ËÆæÂÆöÈïøÂ∫¶Ôºå‰Ω†ÂèØ‰ª•ÈöèÊó∂Âú®‚ÄúËÅäÂ§©ËÆæÁΩÆ‚Äù‰∏≠ÁÇπÂáª‚ÄúÁ´ãÂç≥ÊâãÂä®ÊÄªÁªì‚ÄùÊù•ÁîüÊàêÂØπËØùËÆ∞ÂøÜ„ÄÇ",
          );

          // ËøôÊÑèÂë≥ÁùÄËÆ°Êó∂Âô®‰ºö‰ªéÁé∞Âú®ÈáçÊñ∞ÂºÄÂßãËÆ°ÁÆó„ÄÇ
          const chat = state.chats[chatId];
          chat.settings.summary.lastSummaryIndex = chat.history.length - 1;
          await db.chats.put(chat);
        }

        /**
         * Ë∞ÉÁî®APIÁîüÊàêÊÄªÁªìÂÜÖÂÆπ
         * @param {string} chatId - ËÅäÂ§©ÁöÑID
         * @param {Array | null} specificMessages - Â¶ÇÊûúÊèê‰æõÔºåÂàôÂè™ÊÄªÁªìËøô‰∏™Êï∞ÁªÑÈáåÁöÑÊ∂àÊÅØÔºõÂ¶ÇÊûú‰∏∫nullÔºåÂàôÊÄªÁªìËá™‰∏äÊ¨°‰ª•Êù•ÁöÑÊâÄÊúâÊ∂àÊÅØ„ÄÇ
         * @returns {Promise<string|null>} - AIÁîüÊàêÁöÑÊÄªÁªìÊñáÊú¨
         */
        async function generateSummary(chatId, specificMessages = null) {
          const chat = state.chats[chatId];
          const { proxyUrl, apiKey, model } = state.apiConfig;

          if (!proxyUrl || !apiKey || !model) {
            throw new Error("APIÊú™ÈÖçÁΩÆÔºåÊó†Ê≥ïÁîüÊàêÊÄªÁªì„ÄÇ");
          }

          const summarySettings = chat.settings.summary;
          let messagesToSummarize;

          if (specificMessages && specificMessages.length > 0) {
            messagesToSummarize = specificMessages;
          } else {
            const lastSummaryIndex =
              summarySettings.lastSummaryIndex > -1
                ? summarySettings.lastSummaryIndex
                : 0;
            messagesToSummarize = chat.history.slice(lastSummaryIndex + 1);
          }

          const filteredMessagesForSummary = messagesToSummarize.filter(
            (msg) => msg.type !== "summary",
          );

          if (filteredMessagesForSummary.length === 0) {
            if (!specificMessages) {
              await showCustomAlert(
                "Êó†ÈúÄÊÄªÁªì",
                "Ëá™‰∏äÊ¨°ÊÄªÁªì‰ª•Êù•Ê≤°ÊúâÊñ∞ÁöÑÂØπËØùÂÜÖÂÆπ„ÄÇ",
              );
            }
            return null;
          }

          // --- Âú®ÊûÑÂª∫ÂØπËØùÊñáÊú¨Êó∂ÔºåÂä†ÂÖ•Êó∂Èó¥Êà≥ ---
          const conversationText = filteredMessagesForSummary
            .map((msg) => {
              const sender =
                msg.role === "user"
                  ? chat.isGroup
                    ? chat.settings.myNickname || "Me"
                    : "Me"
                  : msg.senderName || chat.name;
              let content = "";
              if (typeof msg.content === "string") {
                content = msg.content;
              } else if (Array.isArray(msg.content)) {
                content = "[ÂõæÁâá]";
              } else if (msg.type) {
                content = `[${msg.type}]`;
              }
              // Â∞ÜÊØ´ÁßíÊó∂Èó¥Êà≥ËΩ¨Êç¢‰∏∫‰∫∫Á±ªÂèØËØªÁöÑÊó•ÊúüÊó∂Èó¥Â≠óÁ¨¶‰∏≤
              const readableTime = new Date(msg.timestamp).toLocaleString(
                "en-GB",
                { hour12: false },
              );
              return `[${readableTime}] ${sender}: ${content}`;
            })
            .join("\n");

          // --- Êõ¥Êñ∞Á≥ªÁªüÊåá‰ª§ÔºåË¶ÅÊ±ÇAI‰ΩøÁî®Êó∂Èó¥Êà≥ ---
          const systemPrompt =
            summarySettings.prompt +
            `\n\nÈáçË¶ÅÊèêÁ§∫ÔºöÊØèÊù°Ê∂àÊÅØÂºÄÂ§¥ÈÉΩÊúâ‰∏Ä‰∏™ [Êó∂Èó¥] Ê†áËÆ∞„ÄÇ‰Ω†Âú®ÊÄªÁªìÊó∂Ôºå„ÄêÂøÖÈ°ª„ÄëÂèÇËÄÉËøô‰∫õÊó∂Èó¥ÔºåÂú®ÊÄªÁªìÂÖ≥ÈîÆ‰∫ã‰ª∂Êó∂ÈôÑ‰∏äÂØπÂ∫îÁöÑÊó∂Èó¥ËåÉÂõ¥ÊàñÂÖ∑‰ΩìÊó∂Èó¥ÁÇπÔºåËÆ©ÊÄªÁªìÂåÖÂê´Êó∂Èó¥Á∫øÁ¥¢„ÄÇ\n\n--- ÂØπËØùÂºÄÂßã ---\n${conversationText}\n--- ÂØπËØùÁªìÊùü ---`;

          try {
            if (!specificMessages) {
              await showCustomAlert(
                "Ê≠£Âú®ÁîüÊàê...",
                "AIÊ≠£Âú®Âä™ÂäõÊÄªÁªì‰Ω†‰ª¨ÁöÑÂØπËØùÔºåËØ∑Á®çÂÄô...",
              );
            }

            const isGemini = proxyUrl === GEMINI_API_URL;
            const messagesForApi = [{ role: "user", content: systemPrompt }];
            const geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesForApi,
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.3,
                  }),
                });

            if (!response.ok) throw new Error(await response.text());
            const data = await response.json();
            const aiContent = isGemini
              ? data?.candidates?.[0]?.content?.parts?.[0]?.text
              : data?.choices?.[0]?.message?.content;

            if (!aiContent) {
              throw new Error("AIËøîÂõû‰∫ÜÁ©∫ÂÜÖÂÆπ„ÄÇ");
            }

            return aiContent;
          } catch (error) {
            console.error("ÁîüÊàêÊÄªÁªìÂ§±Ë¥•:", error);
            await showCustomAlert("ÊÄªÁªìÂ§±Ë¥•", `ÂèëÁîüÈîôËØØ: ${error.message}`);
            return null;
          }
        }

        /**
         * Â∞ÜÁîüÊàêÁöÑÊÄªÁªì‰Ωú‰∏∫‰∏ÄÊù°ÁâπÊÆäÁöÑËÆ∞ÂøÜÊ∂àÊÅØ‰øùÂ≠òËµ∑Êù•
         */
        async function saveSummaryAsMemory(chatId, summaryText) {
          const chat = state.chats[chatId];

          // ËÆ∞ÂΩï‰∏ãÊÄªÁªìÊìç‰ΩúÂèëÁîüÊó∂ÁöÑÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÁöÑÁ¥¢Âºï
          const newLastSummaryIndex = chat.history.length - 1;

          const summaryMessage = {
            role: "system",
            type: "summary", // ÁâπÊÆäÁ±ªÂûã
            content: summaryText,
            timestamp: Date.now(),
            isHidden: true, // ËøôÊù°Ê∂àÊÅØÂØπAIÂèØËßÅÔºå‰ΩÜÂØπÁî®Êà∑ÈöêËóè
          };

          chat.history.push(summaryMessage);
          chat.settings.summary.lastSummaryIndex = newLastSummaryIndex; // Êõ¥Êñ∞Á¥¢Âºï

          await db.chats.put(chat);
          console.log(`Êñ∞ÁöÑÊÄªÁªìÂ∑≤‰Ωú‰∏∫ËÆ∞ÂøÜ‰øùÂ≠ò for chat: ${chatId}`);
        }

        // --- ÊÄªÁªìÁÆ°ÁêÜÁïåÈù¢ÁöÑÂáΩÊï∞ ---

        let editingSummaryTimestamp = null;

        async function openSummaryViewer() {
          const chat = state.chats[state.activeChatId];
          document.getElementById("summary-viewer-title").textContent =
            `‚Äú${chat.name}‚ÄùÁöÑÂØπËØùËÆ∞ÂøÜ`;

          const listEl = document.getElementById("summary-list");
          listEl.innerHTML = "";

          const summaries = chat.history.filter(
            (msg) => msg.type === "summary",
          );

          if (summaries.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a;">ËøòÊ≤°ÊúâÁîüÊàêËøá‰ªª‰ΩïÊÄªÁªì„ÄÇ</p>';
          } else {
            [...summaries].reverse().forEach((summary) => {
              const card = document.createElement("div");
              card.className = "summary-item-card";

              card.innerHTML = `
			                <div class="summary-actions">
			                    <button class="concise-summary-btn" data-timestamp="${
                            summary.timestamp
                          }" title="Á≤æÁÆÄÊÄªÁªì">‚ú®</button>
			                    <button class="edit-summary-btn" data-timestamp="${summary.timestamp}" title="ÁºñËæë">‚úèÔ∏è</button>
			                    <button class="delete-summary-btn" data-timestamp="${summary.timestamp}" title="Delete">üóëÔ∏è</button>
			                </div>
			                <div class="summary-content">${summary.content.replace(/\n/g, "<br>")}</div>
			                <div class="summary-meta">
			                    <span>ÁîüÊàê‰∫é: ${new Date(summary.timestamp).toLocaleString(
                            "en-GB",
                            {
                              dateStyle: "short",
                              timeStyle: "short",
                            },
                          )}</span>
			                </div>
			            `;
              listEl.appendChild(card);
            });
          }

          document
            .getElementById("chat-settings-modal")
            .classList.remove("visible");
          document
            .getElementById("summary-viewer-modal")
            .classList.add("visible");
        }

        /**
         * ÁºñËæë‰∏ÄÊù°ÊÄªÁªì
         */
        async function editSummary(timestamp) {
          const chat = state.chats[state.activeChatId];
          const summary = chat.history.find(
            (msg) => msg.timestamp === timestamp,
          );
          if (!summary) return;

          const newContent = await showCustomPrompt(
            "ÁºñËæëÊÄªÁªì",
            "‰øÆÊîπÊÄªÁªìÂÜÖÂÆπ:",
            summary.content,
            "textarea",
          );

          if (newContent !== null) {
            summary.content = newContent.trim();
            await db.chats.put(chat);
            openSummaryViewer(); // ÈáçÊñ∞Ê∏≤ÊüìÂàóË°®
          }
        }

        /**
         * Âà†Èô§‰∏ÄÊù°ÊÄªÁªìÔºåÂπ∂Êô∫ËÉΩÊõ¥Êñ∞ÊÄªÁªìÁ¥¢Âºï
         */
        async function deleteSummary(timestamp) {
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ÊÄªÁªìËÆ∞ÂøÜÂêóÔºüËøôÂèØËÉΩ‰ºöÂΩ±ÂìçAIÁöÑÈïøÊúüËÆ∞ÂøÜ„ÄÇ",
            { confirmButtonClass: "btn-danger" },
          );
          if (confirmed) {
            const chat = state.chats[state.activeChatId];

            // 1. ‰ªéÂéÜÂè≤ËÆ∞ÂΩï‰∏≠ËøáÊª§ÊéâË¢´Âà†Èô§ÁöÑÊÄªÁªì
            chat.history = chat.history.filter(
              (msg) => msg.timestamp !== timestamp,
            );

            // 2. --- ÈáçÊñ∞ËÆ°ÁÆó lastSummaryIndex ---
            // ÊâæÂà∞Ââ©‰∏ãÁöÑÊÄªÁªì‰∏≠ÔºåÊúÄÊñ∞ÁöÑÈÇ£‰∏ÄÊù°
            const lastRemainingSummary = chat.history
              .filter((m) => m.type === "summary")
              .pop();

            let newLastSummaryIndex;

            if (lastRemainingSummary) {
              // 3. Â¶ÇÊûúËøòÊúâÂÖ∂‰ªñÊÄªÁªìÔºåÂ∞±ÊâæÂà∞ÂÆÉÂú®ÂéÜÂè≤ËÆ∞ÂΩï‰∏≠ÁöÑ‰ΩçÁΩÆ
              const lastSummaryMessageIndexInHistory = chat.history.findIndex(
                (m) => m.timestamp === lastRemainingSummary.timestamp,
              );
              // 4. Êñ∞ÁöÑÁ¥¢ÂºïÂ∞±ÊòØÂÆÉÂâçÈù¢ÈÇ£Êù°ÊôÆÈÄöÊ∂àÊÅØÁöÑÁ¥¢Âºï
              newLastSummaryIndex =
                lastSummaryMessageIndexInHistory > 0
                  ? lastSummaryMessageIndexInHistory - 1
                  : -1;
            } else {
              // 5. Â¶ÇÊûú‰∏ÄÊù°ÊÄªÁªìÈÉΩ‰∏çÂâ©‰∫ÜÔºåÂ∞±ÂΩªÂ∫ïÈáçÁΩÆÁ¥¢Âºï
              newLastSummaryIndex = -1;
            }

            // 6. Êõ¥Êñ∞ËÆæÁΩÆ
            if (chat.settings.summary) {
              chat.settings.summary.lastSummaryIndex = newLastSummaryIndex;
            }

            // ‰øùÂ≠òÊõ¥ÊîπÂπ∂Âà∑Êñ∞UI
            await db.chats.put(chat);
            openSummaryViewer();
            await showCustomAlert("Êìç‰ΩúÊàêÂäü", "ÊÄªÁªìÂ∑≤Âà†Èô§ÔºÅ");
          }
        }

        /**
         * Ë∞ÉÁî®APIÂ∞ÜÊåáÂÆöÊñáÊú¨Á≤æÁÆÄ‰∏∫ÊëòË¶Å
         * @param {string} originalText - ÂéüÂßãÁöÑ„ÄÅËæÉÈïøÁöÑÊÄªÁªìÊñáÊú¨
         * @returns {Promise<string|null>} - AIÁîüÊàêÁöÑÁ≤æÁÆÄÊëòË¶ÅÔºåÂ¶ÇÊûúÂ§±Ë¥•ÂàôËøîÂõûnull
         */
        async function generateConciseSummary(originalText) {
          const { proxyUrl, apiKey, model } = state.apiConfig;
          if (!proxyUrl || !apiKey || !model) {
            throw new Error("APIÊú™ÈÖçÁΩÆÔºåÊó†Ê≥ïÁîüÊàêÁ≤æÁÆÄÊëòË¶Å„ÄÇ");
          }

          // Ê†∏ÂøÉPromptÔºöÊåáÁ§∫AIÂ∞ÜÂÜÖÂÆπÁ≤æÁÆÄ‰∏∫‰∏ÄÂè•ËØù
          const systemPrompt = `ËØ∑‰Ω†Â∞Ü‰ª•‰∏ãÂÜÖÂÆπÁ≤æÁÆÄ‰∏∫‰∏ÄÂè•ËØùÁöÑÊ†∏ÂøÉÊëòË¶ÅÔºå‰øùÁïôÊúÄÂÖ≥ÈîÆÁöÑ‰∫∫Áâ©„ÄÅ‰∫ã‰ª∂ÂíåÁªìËÆ∫ÔºåÂ≠óÊï∞ÊéßÂà∂Âú®20Â≠ó‰ª•ÂÜÖÔºö\n\n--- ÂÜÖÂÆπÂºÄÂßã ---\n${originalText}\n--- ÂÜÖÂÆπÁªìÊùü ---`;

          try {
            const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${apiKey}`,
              },
              body: JSON.stringify({
                model: model,
                messages: [{ role: "user", content: systemPrompt }],
                temperature: parseFloat(state.apiConfig.temperature) || 0.5,
              }),
            });

            if (!response.ok) throw new Error(await response.text());
            const data = await response.json();
            return data.choices[0].message.content;
          } catch (error) {
            console.error("ÁîüÊàêÁ≤æÁÆÄÊëòË¶ÅÂ§±Ë¥•:", error);
            await showCustomAlert("Á≤æÁÆÄÂ§±Ë¥•", `ÂèëÁîüÈîôËØØ: ${error.message}`);
            return null;
          }
        }

        /**
         * Â§ÑÁêÜÂçïÊù°ÊÄªÁªìÁöÑÁ≤æÁÆÄ
         * @param {number} timestamp - Ë¶ÅÁ≤æÁÆÄÁöÑÊÄªÁªìÊ∂àÊÅØÁöÑÊó∂Èó¥Êà≥
         */
        async function handleConciseSummary(timestamp) {
          const chat = state.chats[state.activeChatId];
          const summary = chat.history.find(
            (msg) => msg.timestamp === timestamp,
          );
          if (!summary) return;

          await showCustomAlert("Please wait...", "AIÊ≠£Âú®Âä™Âäõ‰∏∫ÊÇ®Á≤æÁÆÄÂÜÖÂÆπ...");

          const conciseText = await generateConciseSummary(summary.content);

          if (conciseText) {
            summary.content = conciseText.trim();
            await db.chats.put(chat); // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
            await openSummaryViewer(); // ÈáçÊñ∞Ê∏≤ÊüìÂàóË°®
            await showCustomAlert("ÊàêÂäü", "Êú¨Êù°ÊÄªÁªìÂ∑≤Á≤æÁÆÄÔºÅ");
          }
        }

        /**
         * Â§ÑÁêÜÂÖ®ÈÉ®ÊÄªÁªìÁöÑÁ≤æÁÆÄ
         */
        async function handleConciseAllSummaries() {
          const chat = state.chats[state.activeChatId];
          const summaries = chat.history.filter(
            (msg) => msg.type === "summary",
          );

          if (summaries.length === 0) {
            alert("Ê≤°ÊúâÂèØ‰ª•Á≤æÁÆÄÁöÑÊÄªÁªì„ÄÇ");
            return;
          }

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§ÂÖ®ÈÉ®Á≤æÁÆÄ",
            `Á°ÆÂÆöË¶ÅÁ≤æÁÆÄÂÖ®ÈÉ® ${summaries.length} Êù°ÊÄªÁªìÂêóÔºüÊ≠§Êìç‰Ωú‰ºöË¶ÜÁõñÂéüÂßãÂÜÖÂÆπ‰∏î‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
            { confirmButtonClass: "btn-danger" },
          );
          if (!confirmed) return;

          await showCustomAlert(
            "Please wait...",
            `Ê≠£Âú®ÊâπÈáèÁ≤æÁÆÄ ${summaries.length} Êù°ÊÄªÁªìÔºåËøôÂèØËÉΩÈúÄË¶Å‰∏Ä‰∫õÊó∂Èó¥...`,
          );

          try {
            // ‰ΩøÁî® for...of Âæ™ÁéØÊù•ÈÄêÊù°Â§ÑÁêÜÔºåÈÅøÂÖçÂêåÊó∂ÂèëÈÄÅÂ§™Â§öAPIËØ∑Ê±ÇÂØºËá¥Ë¢´ÈôêÂà∂
            for (const summary of summaries) {
              const conciseText = await generateConciseSummary(summary.content);
              if (conciseText) {
                summary.content = conciseText.trim();
              }
              // ÊØèÂ§ÑÁêÜÂÆå‰∏ÄÊù°ÔºåÁ®çÂæÆÁ≠âÂæÖ‰∏Ä‰∏ãÔºåÁªôAPI‰∏ÄÁÇπÂñòÊÅØÊó∂Èó¥
              await new Promise((resolve) => setTimeout(resolve, 500));
            }

            await db.chats.put(chat);
            await openSummaryViewer();
            await showCustomAlert("ÊàêÂäü", "ÊâÄÊúâÊÄªÁªìÈÉΩÂ∑≤Á≤æÁÆÄÂÆåÊØïÔºÅ");
          } catch (error) {
            // generateConciseSummary ÂÜÖÈÉ®Â∑≤ÁªèÂ§ÑÁêÜ‰∫ÜÈîôËØØÂºπÁ™óÔºåËøôÈáåÊàë‰ª¨Âè™ÈúÄË¶ÅÁ°Æ‰øùÊµÅÁ®ãÊ≠£Â∏∏ÁªìÊùü
            console.error("ÊâπÈáèÁ≤æÁÆÄÊó∂Âá∫Èîô:", error);
          }
        }

        /**
         * Áî®Êà∑ÁÇπÂáª‚ÄúÁ´ãÂç≥ÊâãÂä®ÊÄªÁªì‚ÄùÊåâÈíÆÊó∂Ëß¶ÂèëÁöÑÂáΩÊï∞ (ÊîØÊåÅ‰∏çÂêåÊ®°Âºè)
         * @param {'latest' | 'range'} mode - ÊÄªÁªìÊ®°Âºè
         * @param {{start: number, end: number} | null} range - Â¶ÇÊûúÊòØËåÉÂõ¥Ê®°ÂºèÔºåÂàô‰∏∫Ëµ∑ÂßãÂíåÁªìÊùüÂ∫èÂè∑
         */
        async function triggerManualSummaryNow(mode = "latest", range = null) {
          if (isSummarizing) {
            alert("Ê≠£Âú®Â§ÑÁêÜ‰∏ä‰∏Ä‰∏™ÊÄªÁªì‰ªªÂä°ÔºåËØ∑Á®çÂÄô...");
            return;
          }

          const chat = state.chats[state.activeChatId];
          if (!chat) {
            alert("ÈîôËØØÔºöÊâæ‰∏çÂà∞ÂΩìÂâçËÅäÂ§©ÔºåÊó†Ê≥ïÊÄªÁªì„ÄÇ");
            return;
          }

          isSummarizing = true; // ‰∏äÈîÅ

          try {
            let messagesToSummarize = [];

            // 1. Ê†πÊçÆ‰º†ÂÖ•ÁöÑÊ®°ÂºèÔºåÂÜ≥ÂÆöË¶ÅÊà™ÂèñÂì™‰∫õÊ∂àÊÅØ
            if (mode === "latest") {
              const summarySettings = chat.settings.summary;
              const count =
                summarySettings && summarySettings.count > 0
                  ? summarySettings.count
                  : 20;
              messagesToSummarize = chat.history.slice(-count);
              console.log(`ÊâãÂä®ÊÄªÁªìÊúÄÊñ∞ ${count} Êù°Ê∂àÊÅØ...`);
            } else if (mode === "range" && range) {
              // Ê≥®ÊÑèÔºöÊï∞ÁªÑÁ¥¢Âºï‰ªé0ÂºÄÂßãÔºåËÄåÁî®Êà∑ËæìÂÖ•‰ªé1ÂºÄÂßãÔºåÊâÄ‰ª•ÈúÄË¶Å-1
              messagesToSummarize = chat.history.slice(
                range.start - 1,
                range.end,
              );
              console.log(
                `ÊâãÂä®ÊÄªÁªì‰ªé ${range.start} Âà∞ ${range.end} ÁöÑÊ∂àÊÅØ...`,
              );
            } else {
              throw new Error("Êó†ÊïàÁöÑÊÄªÁªìÊ®°ÂºèÊàñËåÉÂõ¥„ÄÇ");
            }

            // ÂêéÁª≠ÁöÑÈÄªËæë‰øùÊåÅ‰∏çÂèò
            if (messagesToSummarize.length === 0) {
              alert("ÈÄâÂÆöÁöÑËåÉÂõ¥ÂÜÖÊ≤°ÊúâÂèØÊÄªÁªìÁöÑËÅäÂ§©ËÆ∞ÂΩï„ÄÇ");
              isSummarizing = false; // Ëß£ÈîÅ
              return;
            }

            const summaryText = await generateSummary(
              state.activeChatId,
              messagesToSummarize,
            );

            if (summaryText) {
              await saveSummaryAsMemory(state.activeChatId, summaryText);
              await showCustomAlert("ÊÄªÁªìÂÆåÊàê", "Êñ∞ÁöÑÂØπËØùËÆ∞ÂøÜÂ∑≤ÁîüÊàêÔºÅ");
              if (
                document
                  .getElementById("summary-viewer-modal")
                  .classList.contains("visible")
              ) {
                openSummaryViewer();
              }
            }
          } catch (e) {
            console.error("ÊâãÂä®ÊÄªÁªìËøáÁ®ã‰∏≠ÂèëÁîüÊú™ÊçïËé∑ÁöÑÈîôËØØ:", e);
            await showCustomAlert(
              "ÈîôËØØ",
              "ÊâãÂä®ÊÄªÁªìÊó∂ÂèëÁîüÈîôËØØÔºåËØ¶ÊÉÖËØ∑Êü•ÁúãÊéßÂà∂Âè∞„ÄÇ",
            );
          } finally {
            isSummarizing = false; // Âà´Âøò‰∫ÜÊó†ËÆ∫ÊàêÂäüÂ§±Ë¥•ÈÉΩË¶ÅËß£ÈîÅ
          }
        }

        /**
         * Êõ¥Êñ∞ËßíËâ≤ÊâãÊú∫Èí±ÂåÖÁöÑ‰ΩôÈ¢ùÂíå‰∫§ÊòìËÆ∞ÂΩï
         * @param {string} charId - Ë¶ÅÊõ¥Êñ∞Èí±ÂåÖÁöÑËßíËâ≤ID
         * @param {number} amount - ‰∫§ÊòìÈáëÈ¢ù (Ê≠£Êï∞‰∏∫Êî∂ÂÖ•, Ë¥üÊï∞‰∏∫ÊîØÂá∫)
         * @param {string} description - ‰∫§ÊòìÊèèËø∞ (‰æãÂ¶Ç: "ËΩ¨Ë¥¶Áªô XX", "Êî∂Âà∞ XX ÁöÑÁ∫¢ÂåÖ")
         */
        async function updateCharacterBankBalance(charId, amount, description) {
          // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÂ¶ÇÊûúÁº∫Â∞ëÂÖ≥ÈîÆ‰ø°ÊÅØÔºåÂàôÁõ¥Êé•ËøîÂõû
          if (!charId || !amount || isNaN(amount)) {
            console.warn(
              "updateCharacterBankBalance Ë∞ÉÁî®Â§±Ë¥•ÔºöÁº∫Â∞ëcharIdÊàñÊúâÊïàÁöÑamount„ÄÇ",
            );
            return;
          }

          // ‰ªéÂÖ®Â±ÄÁä∂ÊÄÅ‰∏≠Ëé∑ÂèñËßíËâ≤ÂØπË±°
          const chat = state.chats[charId];
          // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÁ°Æ‰øùËßíËâ≤Â≠òÂú®‰∏î‰∏çÊòØÁæ§ËÅä
          if (!chat || chat.isGroup) {
            console.warn(
              `updateCharacterBankBalance Ë∑≥ËøáÔºöÊâæ‰∏çÂà∞ID‰∏∫ ${charId} ÁöÑËßíËâ≤ÊàñËØ•ID‰∏∫Áæ§ËÅä„ÄÇ`,
            );
            return;
          }

          // --- Á°Æ‰øùÊï∞ÊçÆÁªìÊûÑÂÆåÊï¥ÔºåÂÖºÂÆπÊóßÊï∞ÊçÆ ---
          if (!chat.characterPhoneData) {
            chat.characterPhoneData = {};
          }
          if (!chat.characterPhoneData.bank) {
            chat.characterPhoneData.bank = { balance: 0, transactions: [] };
          }
          // Â¶ÇÊûúÊóßÊï∞ÊçÆÁöÑ‰ΩôÈ¢ù‰∏çÊòØÊï∞Â≠óÔºåÂàôÂº∫Âà∂ËÆæ‰∏∫0
          if (typeof chat.characterPhoneData.bank.balance !== "number") {
            chat.characterPhoneData.bank.balance = 0;
          }
          // Â¶ÇÊûúÊóßÊï∞ÊçÆÁöÑ‰∫§ÊòìËÆ∞ÂΩï‰∏çÊòØÊï∞ÁªÑÔºåÂàôÂàõÂª∫‰∏Ä‰∏™Á©∫Êï∞ÁªÑ
          if (!Array.isArray(chat.characterPhoneData.bank.transactions)) {
            chat.characterPhoneData.bank.transactions = [];
          }

          // --- Ê†∏ÂøÉÈÄªËæë ---
          // 1. ÂàõÂª∫‰∏ÄÊù°Êñ∞ÁöÑ‰∫§ÊòìËÆ∞ÂΩï
          const newTransaction = {
            type: amount > 0 ? "Income" : "Paid",
            amount: Math.abs(amount), // ‰∫§ÊòìËÆ∞ÂΩïÈáåÁöÑÈáëÈ¢ùÊÄªÊòØÊ≠£Êï∞
            description: description,
            timestamp: Date.now(), // ËÆ∞ÂΩï‰∫§ÊòìÂèëÁîüÁöÑÊó∂Èó¥
          };

          // 2. Êõ¥Êñ∞‰ΩôÈ¢ù
          chat.characterPhoneData.bank.balance += amount;

          // 3. Â∞ÜÊñ∞‰∫§ÊòìËÆ∞ÂΩïÊ∑ªÂä†Âà∞ÂàóË°®ÁöÑÂºÄÂ§¥ÔºàËÆ©ÊúÄÊñ∞ÁöÑÊòæÁ§∫Âú®ÊúÄÂâçÈù¢Ôºâ
          chat.characterPhoneData.bank.transactions.unshift(newTransaction);

          // 4. Â∞ÜÊõ¥Êñ∞ÂêéÁöÑËßíËâ≤Êï∞ÊçÆ‰øùÂ≠òÂõûÊï∞ÊçÆÂ∫ì
          await db.chats.put(chat);

          console.log(
            `‚úÖ Èí±ÂåÖÂêåÊ≠•ÊàêÂäü: ËßíËâ≤[${chat.name}], ‰∫§Êòì[${description}], ÈáëÈ¢ù[${amount.toFixed(
              2,
            )}], Êñ∞‰ΩôÈ¢ù[${chat.characterPhoneData.bank.balance.toFixed(2)}]`,
          );
        }

        /**
         * ÊâìÂºÄËßíËâ≤ÊâãÊú∫ÁöÑÂ§ñËßÇËÆæÁΩÆÈ°µÈù¢
         */
        function openCharPhoneAppearanceSettings() {
          renderCharPhoneAppearanceScreen(); // Ê∏≤ÊüìÈ°µÈù¢ÂÜÖÂÆπ
          showCharacterPhonePage("character-phone-appearance-screen"); // ÊòæÁ§∫È°µÈù¢
          loadCharPhonePresetsToDropdown();
        }

        /**
         * Ê∏≤ÊüìËßíËâ≤ÊâãÊú∫ÁöÑÂ§ñËßÇËÆæÁΩÆÈ°µÈù¢
         */
        function renderCharPhoneAppearanceScreen() {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];
          if (!chat) return;

          // --- Ê∏≤ÊüìÂ£ÅÁ∫∏È¢ÑËßà ---
          const wallpaperPreview = document.getElementById(
            "char-phone-wallpaper-preview",
          );
          const wallpaperUrl = chat.characterPhoneData.wallpaper || "";
          if (wallpaperUrl) {
            wallpaperPreview.style.backgroundImage = `url(${wallpaperUrl})`;
            wallpaperPreview.textContent = "";
          } else {
            wallpaperPreview.style.backgroundImage = "none";
            wallpaperPreview.textContent = "ÊöÇÊó†Â£ÅÁ∫∏";
          }
          // --- Ê∏≤ÊüìAppÂÜÖÂ£ÅÁ∫∏È¢ÑËßà ---
          const appWallpaperPreview = document.getElementById(
            "char-phone-app-wallpaper-preview",
          );
          const appWallpaperUrl =
            newAppWallpaperBase64 || chat.characterPhoneData.appWallpaper || "";
          if (appWallpaperUrl) {
            appWallpaperPreview.style.backgroundImage = `url(${appWallpaperUrl})`;
            appWallpaperPreview.textContent = "";
          } else {
            appWallpaperPreview.style.backgroundImage = "none";
            appWallpaperPreview.textContent = "ÁÇπÂáª‰∏ãÊñπ‰∏ä‰º†";
          }
          // --- Ê∏≤ÊüìAppÂõæÊ†áËÆæÁΩÆÂàóË°® ---
          const iconGrid = document.getElementById(
            "char-phone-icon-settings-grid",
          );
          iconGrid.innerHTML = "";
          const customIcons = chat.characterPhoneData.appIcons || {};

          CHAR_PHONE_APPS.forEach((app) => {
            const customIconUrl = customIcons[app.id];
            // ‰ΩøÁî®ÈªòËÆ§ÂõæÊ†á‰Ωú‰∏∫Â§áÁî®
            const currentIconUrl =
              customIconUrl || DEFAULT_APP_ICONS[app.id] || "";
            const currentIconHtml = currentIconUrl
              ? `<img src="${currentIconUrl}" style="width:100%; height:100%; object-fit:cover;">`
              : app.svg;

            const itemEl = document.createElement("div");
            itemEl.className = "icon-setting-item";
            itemEl.dataset.iconId = app.id;
            itemEl.innerHTML = `
			            <div class="icon-preview" style="width: 50px; height: 50px; border-radius: 12px; display: flex; justify-content: center; align-items: center; padding: 8px; background: #f0f2f5;">
			                ${currentIconHtml}
			            </div>
			            <span style="font-size: 13px;">${app.name}</span>
			            <button class="change-icon-btn" data-icon-id="${app.id}" style="padding: 4px 10px; font-size: 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer;">Êõ¥Êç¢</button>
			        `;
            iconGrid.appendChild(itemEl);
          });

          // --- Ê∏≤ÊüìÂ∞èÁªÑ‰ª∂È¢ÑËßà (ÈÄªËæë‰∏çÂèò) ---
          const widgets = chat.characterPhoneData.widgets || {};
          const widgetPreview1 = document.getElementById(
            "char-phone-widget-preview-1",
          );
          const widgetPreview2 = document.getElementById(
            "char-phone-widget-preview-2",
          );

          if (widgets.widget1_url) {
            widgetPreview1.style.backgroundImage = `url(${widgets.widget1_url})`;
            widgetPreview1.textContent = "";
          } else {
            widgetPreview1.style.backgroundImage = "none";
            widgetPreview1.textContent = "ÁÇπÂáª‰∏ä‰º†";
          }

          if (widgets.widget2_url) {
            widgetPreview2.style.backgroundImage = `url(${widgets.widget2_url})`;
            widgetPreview2.textContent = "";
          } else {
            widgetPreview2.style.backgroundImage = "none";
            widgetPreview2.textContent = "ÁÇπÂáª‰∏ä‰º†";
          }
        }

        /**
         * Â§ÑÁêÜËßíËâ≤ÊâãÊú∫Â£ÅÁ∫∏ÁöÑÊõ¥Êç¢ÂíåÁßªÈô§
         * @param {string} newUrl - Êñ∞ÁöÑÂ£ÅÁ∫∏URLÔºåÂ¶ÇÊûú‰∏∫Á©∫Â≠óÁ¨¶‰∏≤ÂàôË°®Á§∫ÁßªÈô§
         */
        async function handleCharPhoneWallpaperChange(newUrl) {
          if (!activeCharacterPhoneId) return;
          const chat = state.chats[activeCharacterPhoneId];

          chat.characterPhoneData.wallpaper = newUrl;
          await db.chats.put(chat);

          // Á´ãÂç≥Â∫îÁî®Â£ÅÁ∫∏Âà∞ËßíËâ≤ÊâãÊú∫‰∏ªÂ±èÂπï
          const phoneScreen = document.getElementById("character-phone-screen");
          if (newUrl) {
            phoneScreen.style.backgroundImage = `url(${newUrl})`;
            phoneScreen.style.backgroundColor = "transparent";
          } else {
            phoneScreen.style.backgroundImage = "none";
            const isDarkMode = document
              .getElementById("phone-screen")
              .classList.contains("dark-mode");
            phoneScreen.style.backgroundColor = isDarkMode ? "#000" : "#f0f2f5";
          }

          // Âà∑Êñ∞ËÆæÁΩÆÈ°µÈù¢ÁöÑÈ¢ÑËßà
          renderCharPhoneAppearanceScreen();
          alert(newUrl ? "Â£ÅÁ∫∏Â∑≤Êõ¥Êñ∞ÔºÅ" : "Â£ÅÁ∫∏Â∑≤ÁßªÈô§ÔºÅ");
        }

        /**
         * Â§ÑÁêÜËßíËâ≤ÊâãÊú∫AppÂõæÊ†áÁöÑÊõ¥Êç¢
         * @param {string} iconId - Ë¶ÅÊõ¥Êç¢ÁöÑAppÁöÑID
         */
        async function handleChangeCharPhoneIcon(iconId) {
          if (!activeCharacterPhoneId) return;

          const choice = await showChoiceModal("Êõ¥Êç¢ÂõæÊ†á", [
            { text: "üìÅ Upload from local", value: "local" },
            { text: "üåê Use URL", value: "url" },
            { text: "üîÑ ÊÅ¢Â§çÈªòËÆ§", value: "reset" },
          ]);

          let newIconUrl = null;

          if (choice === "local") {
            newIconUrl = await uploadImageLocally();
          } else if (choice === "url") {
            newIconUrl = await showCustomPrompt("ÂõæÊ†áURL", "ËØ∑ËæìÂÖ•ÂõæÁâáÈìæÊé•");
          } else if (choice === "reset") {
            const chat = state.chats[activeCharacterPhoneId];
            if (
              chat.characterPhoneData.appIcons &&
              chat.characterPhoneData.appIcons[iconId]
            ) {
              delete chat.characterPhoneData.appIcons[iconId];
              await db.chats.put(chat);
              renderCharPhoneAppearanceScreen();
              renderCharacterAppGrid();
              alert("ÂõæÊ†áÂ∑≤ÊÅ¢Â§çÈªòËÆ§„ÄÇ");
            }
            return;
          }

          if (newIconUrl && newIconUrl.trim()) {
            const chat = state.chats[activeCharacterPhoneId];
            if (!chat.characterPhoneData.appIcons) {
              chat.characterPhoneData.appIcons = {};
            }
            chat.characterPhoneData.appIcons[iconId] = newIconUrl.trim();
            await db.chats.put(chat);

            renderCharPhoneAppearanceScreen(); // Âà∑Êñ∞ËÆæÁΩÆÈ°µÈù¢
            renderCharacterAppGrid(); // Âà∑Êñ∞‰∏ªÂ±èÂπï
            alert("ÂõæÊ†áÂ∑≤Êõ¥Êñ∞ÔºÅ");
          }
        }

        let isIntentionalStop = false;
        let isTtsPlaying = false;
        let currentTtsAudioBubble = null;

        /**
         * Êü•Êâæ‰ªéÊåáÂÆö‰ΩçÁΩÆÂºÄÂßãÁöÑÊâÄÊúâËøûÁª≠AIËØ≠Èü≥Ê∂àÊÅØ
         * @param {Array} history - ÂÆåÊï¥ÁöÑËÅäÂ§©ÂéÜÂè≤ËÆ∞ÂΩïÊï∞ÁªÑ
         * @param {number} startIndex - ÂºÄÂßãÊü•ÊâæÁöÑÁ¥¢Âºï‰ΩçÁΩÆ
         * @returns {Array} - ‰∏Ä‰∏™ÂåÖÂê´ÊâÄÊúâËøûÁª≠AIËØ≠Èü≥Ê∂àÊÅØÂØπË±°ÁöÑÊï∞ÁªÑ
         */
        function findConsecutiveAiVoiceMessages(history, startIndex) {
          const messagesToPlay = [];
          if (startIndex < 0 || startIndex >= history.length) {
            return messagesToPlay;
          }

          // ‰ªéÁÇπÂáªÁöÑÈÇ£Êù°Ê∂àÊÅØÂºÄÂßãÔºåÂêëÂêéÈÅçÂéÜ
          for (let i = startIndex; i < history.length; i++) {
            const msg = history[i];
            // Ê£ÄÊü•ËøôÊù°Ê∂àÊÅØÊòØÂê¶ÊòØAIÂèëÈÄÅÁöÑÔºåÂπ∂‰∏îÁ±ªÂûãÊòØËØ≠Èü≥
            if (msg.role === "assistant" && msg.type === "voice_message") {
              messagesToPlay.push(msg); // Â¶ÇÊûúÊòØÔºåÂ∞±ÊääÂÆÉÂä†ÂÖ•ÂæÖÊí≠ÊîæÂàóË°®
            } else {
              // ‰∏ÄÊó¶ÈÅáÂà∞‰∏çÊòØAIËØ≠Èü≥ÁöÑÊ∂àÊÅØÔºàÊØîÂ¶ÇÁî®Êà∑ÁöÑÂõûÂ§çÔºåÊàñAIÁöÑÂõæÁâá/ÊñáÂ≠óÊ∂àÊÅØÔºâÔºåÂ∞±Á´ãÂàªÂÅúÊ≠¢Êü•Êâæ
              break;
            }
          }
          return messagesToPlay;
        }
        /**
         * ÂÅúÊ≠¢ÂΩìÂâçÊ≠£Âú®Êí≠ÊîæÁöÑMinimax TTSËØ≠Èü≥
         */
        function stopMinimaxAudio() {
          if (!isTtsPlaying) return;

          isIntentionalStop = true;
          const ttsPlayer = document.getElementById("tts-audio-player");
          ttsPlayer.pause();
          ttsPlayer.src = ""; // Ëøô‰ºöËß¶Âèë onerror ‰∫ã‰ª∂Ôºå‰ªéËÄåÊâßË°åÊ∏ÖÁêÜ

          if (window.currentAnimatingBubbles) {
            window.currentAnimatingBubbles.forEach((b) => {
              const spinner = b.querySelector(".loading-spinner");
              if (spinner) spinner.style.display = "none";
              b.classList.remove("playing");
            });
          }

          isTtsPlaying = false;
          currentTtsAudioBubble = null;
          window.currentAnimatingBubbles = null;

          setTimeout(() => {
            isIntentionalStop = false;
          }, 100);
        }

        /**
         * „ÄêËæÖÂä©ÂáΩÊï∞„ÄëÂ∞ÜHexÂ≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫ÂèØÊí≠ÊîæÁöÑBlob URL
         * @param {string} hex - ÂçÅÂÖ≠ËøõÂà∂ÁºñÁ†ÅÁöÑÈü≥È¢ëÊï∞ÊçÆ
         * @returns {string|null} - Blob URL Êàñ null
         */
        function hexToBlobUrl(hex) {
          if (!hex) return null;
          const cleanHex = hex.replace(/[^0-9a-fA-F]/g, "");
          const length = cleanHex.length;
          if (length % 2 !== 0) {
            console.error("Hex string has an odd length.");
            return null;
          }
          const buffer = new Uint8Array(length / 2);
          for (let i = 0; i < length; i += 2) {
            buffer[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
          }
          // Ê†πÊçÆÊñáÊ°£ÔºåÊé®Ëçê‰ΩøÁî® mp3 Ê†ºÂºè
          const blob = new Blob([buffer], { type: "audio/mpeg" });
          return URL.createObjectURL(blob);
        }

        /**
         * Ë∞ÉÁî® Minimax TTS API ÁîüÊàêËØ≠Èü≥Âπ∂Êí≠Êîæ
         * @param {string} text - Ë¶ÅËΩ¨Êç¢‰∏∫ËØ≠Èü≥ÁöÑÂêàÂπ∂ÂêéÁöÑÊñáÊú¨
         * @param {string} voiceId - Minimax ÁöÑËØ≠Èü≥ ID
         * @param {Array<HTMLElement>} bubblesToAnimate - ÈúÄË¶ÅÊí≠ÊîæÂä®ÁîªÁöÑÊâÄÊúâËØ≠Èü≥Ê∞îÊ≥°ÂÖÉÁ¥†ÁöÑÊï∞ÁªÑ
         */
        async function playMinimaxAudio(text, voiceId, bubblesToAnimate) {
          stopMinimaxAudio();
          await new Promise((resolve) => setTimeout(resolve, 50));

          const ttsPlayer = document.getElementById("tts-audio-player");
          const firstBubble = bubblesToAnimate[0];
          if (!firstBubble) return;

          isTtsPlaying = true;
          currentTtsAudioBubble = firstBubble;
          window.currentAnimatingBubbles = bubblesToAnimate;
          bubblesToAnimate.forEach((b) => {
            const spinner = b.querySelector(".loading-spinner");
            if (spinner) spinner.style.display = "block";
          });

          const mainAudioPlayer = document.getElementById("audio-player");
          if (mainAudioPlayer && !mainAudioPlayer.paused) {
            mainAudioPlayer.pause();
            state.musicState.isPlaying = false;
            updatePlayerUI();
          }

          const groupId = state.apiConfig.minimaxGroupId;
          const apiKey = state.apiConfig.minimaxApiKey;
          if (!groupId || !apiKey) {
            await showCustomAlert(
              "ËØ≠Èü≥Êí≠ÊîæÂ§±Ë¥•",
              "Â∞öÊú™ÈÖçÁΩÆMinimaxÁöÑGroup IDÂíåAPI Key„ÄÇ",
            );
            stopMinimaxAudio();
            return;
          }

          const chat = state.chats[state.activeChatId];
          if (!chat) {
            stopMinimaxAudio();
            return;
          }

          const provider = state.apiConfig.minimaxProvider || "cn";
          const speechModel =
            state.apiConfig.minimaxSpeechModel || "speech-01-turbo";
          const baseUrl =
            provider === "cn"
              ? "https://api.minimaxi.com"
              : "https://api.minimax.io";
          const requestUrl = `${baseUrl}/v1/t2a_v2`;
          // 1. ‰ªéÂΩìÂâçËßíËâ≤ÁöÑËÆæÁΩÆ‰∏≠ËØªÂèñËØ≠ÈÄüÂíåËØ≠Ë®ÄÂ¢ûÂº∫
          const speed = chat.settings.speed ?? 1.0;
          const langBoost = chat.settings.language_boost; // Â¶ÇÊûúÊòØnullÊàñundefined, Â∞±ËÆ©ÂÆÉÊòØnull/undefined

          const textForTts = text
            .replace(/\(.*?\)|Ôºà.*?Ôºâ|„Äê.*?„Äë/g, "")
            .trim();

          // 2. ÊûÑÂª∫ÂåÖÂê´Êñ∞ÂèÇÊï∞ÁöÑËØ∑Ê±Ç‰Ωì
          const requestBody = {
            model: speechModel,
            text: textForTts, // <--- Ê†∏ÂøÉ‰øÆÊîπÂú®ËøôÈáåÔºÅ‰ΩøÁî®ËøáÊª§ÂêéÁöÑÊñáÊú¨
            voice_setting: {
              voice_id: voiceId,
              speed: speed, // ‚òÖ Âú®ËøôÈáåÂä†ÂÖ•ËØ≠ÈÄü
            },
          };

          // 3. Â¶ÇÊûú language_boost ÊúâÊïàÔºåÊâçÂ∞ÜÂÆÉÊ∑ªÂä†Âà∞ËØ∑Ê±Ç‰Ωì‰∏≠
          if (langBoost) {
            requestBody.language_boost = langBoost;
          }

          console.log(`[Minimax TTS] Request to ${requestUrl}`, requestBody);

          try {
            const response = await fetch(`${requestUrl}?GroupId=${groupId}`, {
              method: "POST",
              headers: {
                Authorization: `Bearer ${apiKey}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify(requestBody),
            });

            const result = await response.json();

            if (
              !response.ok ||
              (result.base_resp && result.base_resp.status_code !== 0)
            ) {
              throw new Error(
                `APIÈîôËØØÁ†Å ${
                  result.base_resp?.status_code || response.status
                }: ${result.base_resp?.status_msg || response.statusText}`,
              );
            }

            if (!result.data || !result.data.audio) {
              throw new Error("APIÂìçÂ∫î‰∏≠Êú™ÊâæÂà∞ÊúâÊïàÁöÑÈü≥È¢ëÊï∞ÊçÆ„ÄÇ");
            }

            const audioUrl = hexToBlobUrl(result.data.audio);
            if (!audioUrl) {
              throw new Error("HexÈü≥È¢ëÊï∞ÊçÆËΩ¨Êç¢Â§±Ë¥•„ÄÇ");
            }

            bubblesToAnimate.forEach((b) => {
              const spinner = b.querySelector(".loading-spinner");
              if (spinner) spinner.style.display = "none";
              b.classList.add("playing");
            });

            ttsPlayer.src = audioUrl;

            const cleanupAndReset = () => {
              if (isTtsPlaying) {
                isTtsPlaying = false;
                URL.revokeObjectURL(audioUrl);
                if (window.currentAnimatingBubbles) {
                  window.currentAnimatingBubbles.forEach((b) =>
                    b.classList.remove("playing"),
                  );
                }
                currentTtsAudioBubble = null;
                window.currentAnimatingBubbles = null;
              }
            };

            ttsPlayer.onended = cleanupAndReset;

            ttsPlayer.onerror = (e) => {
              if (!isIntentionalStop) {
                console.error("TTSÈü≥È¢ëÊí≠ÊîæÊó∂ÂèëÁîüÈîôËØØ:", e);
              }
              cleanupAndReset();
            };

            await ttsPlayer.play();
          } catch (error) {
            console.error("Minimax TTS Ë∞ÉÁî®Â§±Ë¥•:", error);
            await showCustomAlert("ËØ≠Èü≥ÂêàÊàêÂ§±Ë¥•", `ÈîôËØØ‰ø°ÊÅØ: ${error.message}`);
            stopMinimaxAudio();
          }
        }

        // ËßíËâ≤ÊâãÊú∫Â§ñËßÇÈ¢ÑËÆæÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞

        /**
         * ÂêØÁî®ÊàñÁ¶ÅÁî®ËßíËâ≤ÊâãÊú∫È¢ÑËÆæÁÆ°ÁêÜÊåâÈíÆ
         * @param {boolean} isEnabled - ÊòØÂê¶ÂêØÁî®
         */
        function toggleCharPhonePresetButtons(isEnabled) {
          document.getElementById("apply-char-phone-preset-btn").disabled =
            !isEnabled;
          document.getElementById("update-char-phone-preset-btn").disabled =
            !isEnabled;
          document.getElementById("rename-char-phone-preset-btn").disabled =
            !isEnabled;
          document.getElementById("delete-char-phone-preset-btn").disabled =
            !isEnabled;
          document.getElementById("export-char-phone-preset-btn").disabled =
            !isEnabled;
        }

        /**
         * Âä†ËΩΩËßíËâ≤ÊâãÊú∫Â§ñËßÇÈ¢ÑËÆæÂà∞‰∏ãÊãâÊ°Ü
         */
        async function loadCharPhonePresetsToDropdown() {
          const selector = document.getElementById(
            "char-phone-preset-selector",
          );
          if (!selector) return;
          selector.innerHTML = '<option value="">-- ËØ∑ÈÄâÊã©‰∏Ä‰∏™È¢ÑËÆæ --</option>';
          const presets = await db.charPhonePresets.toArray();
          presets.forEach((preset) => {
            const option = document.createElement("option");
            option.value = preset.id;
            option.textContent = preset.name;
            selector.appendChild(option);
          });
          activeCharPhonePresetId = null;
          toggleCharPhonePresetButtons(false);
        }

        /**
         * ÂΩìÁî®Êà∑‰ªé‰∏ãÊãâÊ°ÜÈÄâÊã©‰∏Ä‰∏™È¢ÑËÆæÊó∂Ëß¶Âèë
         */
        function handleCharPhonePresetSelection() {
          const selector = document.getElementById(
            "char-phone-preset-selector",
          );
          activeCharPhonePresetId = selector.value
            ? parseInt(selector.value)
            : null;
          toggleCharPhonePresetButtons(!!activeCharPhonePresetId);
        }

        async function applySelectedCharPhonePreset() {
          if (!activeCharPhonePresetId) {
            alert("ËØ∑ÂÖà‰ªé‰∏ãÊãâÊ°Ü‰∏≠ÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÂ∫îÁî®ÁöÑÈ¢ÑËÆæ„ÄÇ");
            return;
          }
          if (!activeCharacterPhoneId) {
            alert("ÈîôËØØÔºöÊ≤°ÊúâÊâæÂà∞ÂΩìÂâçÊ≠£Âú®Êìç‰ΩúÁöÑËßíËâ≤ÊâãÊú∫„ÄÇ");
            return;
          }
          const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
          const chat = state.chats[activeCharacterPhoneId];

          if (preset && preset.data && chat) {
            // Â∞ÜÈ¢ÑËÆæÊï∞ÊçÆÊ∑±Êã∑Ë¥ù‰∏Ä‰ªΩÔºåÂ∫îÁî®Âà∞ËßíËâ≤ÁöÑÊâãÊú∫Êï∞ÊçÆ‰∏ä
            chat.characterPhoneData.wallpaper = preset.data.wallpaper || "";
            chat.characterPhoneData.appIcons = {
              ...DEFAULT_APP_ICONS,
              ...(preset.data.appIcons || {}),
            };
            chat.characterPhoneData.widgets = {
              ...(preset.data.widgets || {}),
            };

            // ‚òÖ‚òÖ‚òÖ ËøôÂ∞±ÊòØÊàë‰ª¨Êñ∞Â¢ûÁöÑ‰∏ÄË°åÔºÅ‚òÖ‚òÖ‚òÖ
            chat.characterPhoneData.appWallpaper =
              preset.data.appWallpaper || "";

            await db.chats.put(chat);

            // Âà∑Êñ∞ÊâãÊú∫ÁïåÈù¢‰ª•ÊòæÁ§∫Êñ∞Â§ñËßÇ
            openCharacterPhone(activeCharacterPhoneId);

            // Âà∑Êñ∞Â§ñËßÇËÆæÁΩÆÈ°µÈù¢Ôºå‰ª•‰æøÈ¢ÑËßàÂíåÊï∞ÊçÆÂêåÊ≠•
            renderCharPhoneAppearanceScreen();

            alert(`Â∑≤ÊàêÂäü‰∏∫‚Äú${chat.name}‚ÄùÂ∫îÁî®È¢ÑËÆæ: "${preset.name}"ÔºÅ`);
          } else {
            alert("Â∫îÁî®È¢ÑËÆæÂ§±Ë¥•ÔºåÊâæ‰∏çÂà∞È¢ÑËÆæÊàñËßíËâ≤Êï∞ÊçÆ„ÄÇ");
          }
        }

        /**
         * ‰øùÂ≠òÂΩìÂâçËßíËâ≤ÊâãÊú∫ÁöÑÂ§ñËßÇËÆæÁΩÆ‰∏∫‰∏Ä‰∏™Êñ∞ÁöÑÈ¢ÑËÆæ
         */
        async function saveCurrentCharPhonePreset() {
          if (!activeCharacterPhoneId) return;

          const presetName = await showCustomPrompt(
            "‰øùÂ≠òÈ¢ÑËÆæ",
            "ËØ∑‰∏∫Ëøô‰∏™Â§ñËßÇÊñπÊ°àËµ∑‰∏™ÂêçÂ≠óÔºö",
          );
          if (!presetName || !presetName.trim()) {
            if (presetName !== null) alert("ÂêçÂ≠ó‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
            return;
          }

          const chat = state.chats[activeCharacterPhoneId];
          // ‰ªéÂΩìÂâçËßíËâ≤ÁöÑÊï∞ÊçÆ‰∏≠ÊèêÂèñÂ§ñËßÇËÆæÁΩÆ
          const presetData = {
            wallpaper: chat.characterPhoneData.wallpaper || "",
            appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
            widgets: { ...(chat.characterPhoneData.widgets || {}) },
            appWallpaper: chat.characterPhoneData.appWallpaper || "",
          };

          await db.charPhonePresets.add({
            name: presetName.trim(),
            data: presetData,
          });
          await loadCharPhonePresetsToDropdown();
          alert(`Â§ñËßÇÈ¢ÑËÆæ "${presetName.trim()}" Â∑≤‰øùÂ≠òÔºÅ`);
        }

        /**
         * Êõ¥Êñ∞ÂΩìÂâçÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function updateSelectedCharPhonePreset() {
          if (!activeCharPhonePresetId || !activeCharacterPhoneId) return;

          const currentPreset = await db.charPhonePresets.get(
            activeCharPhonePresetId,
          );
          if (!currentPreset) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Êõ¥Êñ∞",
            `Á°ÆÂÆöË¶ÅÁî®ÂΩìÂâçÊâãÊú∫ÁöÑÂ§ñËßÇË¶ÜÁõñÈ¢ÑËÆæ "${currentPreset.name}" ÂêóÔºü`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            const chat = state.chats[activeCharacterPhoneId];
            const presetData = {
              wallpaper: chat.characterPhoneData.wallpaper || "",
              appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
              widgets: { ...(chat.characterPhoneData.widgets || {}) },
              appWallpaper: chat.characterPhoneData.appWallpaper || "",
            };
            await db.charPhonePresets.update(activeCharPhonePresetId, {
              data: presetData,
            });
            await showCustomAlert(
              "ÊàêÂäü",
              `È¢ÑËÆæ "${currentPreset.name}" Â∑≤Êõ¥Êñ∞ÔºÅ`,
            );
          }
        }

        /**
         * ÈáçÂëΩÂêçÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function renameSelectedCharPhonePreset() {
          if (!activeCharPhonePresetId) return;
          const currentPreset = await db.charPhonePresets.get(
            activeCharPhonePresetId,
          );
          const newName = await showCustomPrompt(
            "ÈáçÂëΩÂêç",
            "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂêçÁß∞Ôºö",
            currentPreset.name,
          );
          if (newName && newName.trim()) {
            await db.charPhonePresets.update(activeCharPhonePresetId, {
              name: newName.trim(),
            });
            await loadCharPhonePresetsToDropdown();
            document.getElementById("char-phone-preset-selector").value =
              activeCharPhonePresetId;
            alert("ÈáçÂëΩÂêçÊàêÂäüÔºÅ");
          }
        }

        /**
         * Âà†Èô§ÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function deleteSelectedCharPhonePreset() {
          if (!activeCharPhonePresetId) return;
          const currentPreset = await db.charPhonePresets.get(
            activeCharPhonePresetId,
          );
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            `Á°ÆÂÆöË¶ÅÂà†Èô§È¢ÑËÆæ "${currentPreset.name}" ÂêóÔºü`,
            {
              confirmButtonClass: "btn-danger",
            },
          );
          if (confirmed) {
            await db.charPhonePresets.delete(activeCharPhonePresetId);
            await loadCharPhonePresetsToDropdown();
            alert("È¢ÑËÆæÂ∑≤Âà†Èô§„ÄÇ");
          }
        }

        /**
         * ÂØºÂá∫ÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ
         */
        async function exportCharPhonePreset() {
          if (!activeCharPhonePresetId) return;
          const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
          const blob = new Blob([JSON.stringify(preset, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `[CharPhone]${preset.name}.json`;
          a.click();
          URL.revokeObjectURL(url);
        }

        /**
         * ÂØºÂÖ•È¢ÑËÆæÊñá‰ª∂
         */
        function importCharPhonePreset(file) {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (data.name && data.data) {
                await db.charPhonePresets.add({
                  name: `${data.name} (Import)`,
                  data: data.data,
                });
                await loadCharPhonePresetsToDropdown();
                alert(`È¢ÑËÆæ "${data.name}" ÂØºÂÖ•ÊàêÂäüÔºÅ`);
              } else {
                alert("ÂØºÂÖ•Â§±Ë¥•ÔºöÊñá‰ª∂Ê†ºÂºè‰∏çÊ≠£Á°Æ„ÄÇ");
              }
            } catch (error) {
              alert(`ÂØºÂÖ•Â§±Ë¥•ÔºöÊñá‰ª∂Ëß£ÊûêÈîôËØØ„ÄÇ${error.message}`);
            }
          };
          reader.readAsText(file);
        }

        /**
         * Âú®Â§ñËßÇËÆæÁΩÆÈ°µÈù¢Ê∏≤ÊüìÂá∫ÊâÄÊúâAppÁöÑÂêçÁß∞ËÆæÁΩÆÈ°π
         */
        function renderAppNameSettings() {
          const grid = document.getElementById("icon-rename-grid");
          if (!grid) return;
          grid.innerHTML = "";

          const appLabels = state.globalSettings.appLabels || {};

          // ÈÅçÂéÜÈªòËÆ§Ê†áÁ≠æÂØπË±°Ôºå‰ª•Á°Æ‰øùÊâÄÊúâappÈÉΩÊúâËÆæÁΩÆÈ°π
          for (const appId in DEFAULT_APP_LABELS) {
            if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
              const defaultName = DEFAULT_APP_LABELS[appId];
              const currentName = appLabels[appId] || defaultName;

              const item = document.createElement("div");
              item.className = "form-group";
              item.style.marginBottom = "0"; // ËÆ©Â∏ÉÂ±ÄÊõ¥Á¥ßÂáë
              item.innerHTML = `
			                <label for="rename-input-${appId}">${defaultName}</label>
			                <input type="text" id="rename-input-${appId}" class="app-rename-input" data-appid="${appId}" value="${currentName}">
			            `;
              grid.appendChild(item);
            }
          }
        }

        /**
         * Â∞Ü‰øùÂ≠òÁöÑAppÂêçÁß∞Â∫îÁî®Âà∞‰∏ªÂ±èÂπïÁöÑÂõæÊ†á‰∏ä
         */
        function applyAppLabels() {
          const appLabels = state.globalSettings.appLabels || {};

          for (const appId in DEFAULT_APP_LABELS) {
            if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
              const defaultName = DEFAULT_APP_LABELS[appId];
              const customName = appLabels[appId] || defaultName;

              // Ëøô‰∏™ÈÄâÊã©Âô®‰ºöÂêåÊó∂ÊâæÂà∞‰∏ªÂ±èÂπïÂíåDockÊ†è‰∏äÁöÑÊâÄÊúâÂõæÊ†á
              const icons = document.querySelectorAll(
                `.desktop-app-icon [id="icon-img-${appId}"]`,
              );

              icons.forEach((iconImg) => {
                const appIconContainer = iconImg.closest(".desktop-app-icon");
                if (appIconContainer) {
                  const labelElement = appIconContainer.querySelector(".label");
                  if (labelElement) {
                    labelElement.textContent = customName;
                  }
                }
              });
            }
          }
        }

        /**
         * ‰ªéËæìÂÖ•Ê°ÜËØªÂèñÂπ∂‰øùÂ≠òÁî®Êà∑‰øÆÊîπÁöÑAppÂêçÁß∞
         */
        function saveAppLabels() {
          const appNameInputs = document.querySelectorAll(".app-rename-input");
          if (!state.globalSettings.appLabels) {
            state.globalSettings.appLabels = {};
          }

          appNameInputs.forEach((input) => {
            const appId = input.dataset.appid;
            const newName = input.value.trim();
            const defaultName = DEFAULT_APP_LABELS[appId];

            // Â¶ÇÊûúÁî®Êà∑ËæìÂÖ•‰∫ÜÊñ∞ÂêçÂ≠óÔºå‰∏îÂíåÈªòËÆ§ÂêçÂ≠ó‰∏ç‰∏ÄÊ†∑ÔºåÂ∞±‰øùÂ≠ò
            if (newName && newName !== defaultName) {
              state.globalSettings.appLabels[appId] = newName;
            } else {
              // Â¶ÇÊûúÁî®Êà∑Ê∏ÖÁ©∫‰∫ÜËæìÂÖ•Ê°ÜÔºåÊàñËÄÖÊîπÂõû‰∫ÜÈªòËÆ§ÂêçÂ≠óÔºåÂ∞±Âà†Èô§‰øùÂ≠òËÆ∞ÂΩïÔºå‰ª•ÊÅ¢Â§çÈªòËÆ§
              delete state.globalSettings.appLabels[appId];
            }
          });
        }

        /**
         * Â§ÑÁêÜÂØºÂÖ•ÁöÑSillyTavern‰∏ñÁïå‰π¶Êñá‰ª∂
         * @param {File} file - Áî®Êà∑ÈÄâÊã©ÁöÑJSONÊñá‰ª∂
         */
        async function handleImportSillyTavernWorldBook(file) {
          // ‰ΩøÁî®FileReaderÊù•ËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const text = e.target.result;
              const data = JSON.parse(text);

              // È™åËØÅÊñá‰ª∂Ê†ºÂºèÊòØÂê¶Ê≠£Á°ÆÔºåÁ°Æ‰øùÂåÖÂê´'entries'ÂØπË±°
              if (!data.entries || typeof data.entries !== "object") {
                throw new Error(
                  "Êñá‰ª∂Ê†ºÂºèÊó†Êïà„ÄÇSillyTavern‰∏ñÁïå‰π¶Â∫îÂåÖÂê´'entries'ÂØπË±°„ÄÇ",
                );
              }

              // ‰ªéÊñá‰ª∂ÂêçÊèêÂèñÂêçÁß∞Ôºå‰Ωú‰∏∫Êñ∞ÁöÑÂàÜÁ±ªÂêç
              let categoryName = file.name
                .replace(/\.(json|jsonl)$/i, "")
                .trim();
              if (!categoryName) categoryName = "ÂØºÂÖ•ÁöÑ‰∏ñÁïå‰π¶";

              // Ê£ÄÊü•ËØ•ÂàÜÁ±ªÊòØÂê¶Â∑≤Â≠òÂú®ÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÂàõÂª∫
              let category = await db.worldBookCategories
                .where("name")
                .equals(categoryName)
                .first();
              if (!category) {
                const newCategoryId = await db.worldBookCategories.add({
                  name: categoryName,
                });
                category = { id: newCategoryId, name: categoryName };
                console.log(
                  `ÂàõÂª∫‰∫ÜÊñ∞ÁöÑ‰∏ñÁïå‰π¶ÂàÜÁ±ª: ${categoryName} (ID: ${newCategoryId})`,
                );
              } else {
                console.log(
                  `Â∞ÜÊù°ÁõÆÊ∑ªÂä†Âà∞Â∑≤Â≠òÂú®ÁöÑÂàÜÁ±ª: ${categoryName} (ID: ${category.id})`,
                );
              }

              const newBooks = [];
              // ÈÅçÂéÜSillyTavern worldbook‰∏≠ÁöÑÊâÄÊúâÊù°ÁõÆ
              for (const key in data.entries) {
                const entry = data.entries[key];

                if (entry) {
                  // ‰ΩøÁî®entry.comment‰Ωú‰∏∫‰π¶ÂêçÔºåÂ¶ÇÊûú‰∏∫Á©∫Âàô‰ΩøÁî®"Êù°ÁõÆ key"‰Ωú‰∏∫Â§áÁî®
                  const entryName = (entry.comment || `Êù°ÁõÆ ${key}`).trim();
                  const entryContent = (entry.content || "").trim();
                  // Á°Æ‰øù‰π¶ÂêçÂíåÂÜÖÂÆπÈÉΩ‰∏ç‰∏∫Á©∫
                  if (entryName && entryContent) {
                    newBooks.push({
                      id: "wb_" + Date.now() + Math.random(), // ÂàõÂª∫ÂîØ‰∏ÄID
                      name: entryName,
                      content: entryContent,
                      categoryId: category.id, // ÂΩíÂ±ûÂà∞Êñ∞ÁöÑÂàÜÁ±ª
                    });
                  }
                }
              }

              if (newBooks.length === 0) {
                alert("Ê≤°ÊúâÊâæÂà∞‰ªª‰ΩïÂèØÂØºÂÖ•ÁöÑÊúâÊïàÊù°ÁõÆ„ÄÇ");
                return;
              }

              // ÊâπÈáèÂ∞ÜÊñ∞‰π¶Ê∑ªÂä†Âà∞Êï∞ÊçÆÂ∫ìÔºåÊïàÁéáÊõ¥È´ò
              await db.worldBooks.bulkAdd(newBooks);
              // Êõ¥Êñ∞ÂÜÖÂ≠ò‰∏≠ÁöÑstateÔºå‰ª•‰æøUIËÉΩÁ´ãÂç≥Âà∑Êñ∞
              state.worldBooks.push(...newBooks);

              // ÈáçÊñ∞Ê∏≤Êüì‰∏ñÁïå‰π¶ÂàóË°®ÔºåÊòæÁ§∫Êñ∞ÂÜÖÂÆπ
              await renderWorldBookScreen();
              await showCustomAlert(
                "ÂØºÂÖ•ÊàêÂäü",
                `ÊàêÂäüÂ∞Ü„Ää${categoryName}„Äã‰∏≠ÁöÑ ${newBooks.length} ‰∏™Êù°ÁõÆÂØºÂÖ•Âà∞‰∏ñÁïå‰π¶ÔºÅ`,
              );
            } catch (error) {
              console.error("ÂØºÂÖ•‰∏ñÁïå‰π¶Â§±Ë¥•:", error);
              await showCustomAlert(
                "ÂØºÂÖ•Â§±Ë¥•",
                `Êó†Ê≥ïËß£ÊûêÊñá‰ª∂ÔºåËØ∑Á°Æ‰øùÂÆÉÊòØÊúâÊïàÁöÑSillyTavern‰∏ñÁïå‰π¶JSONÊñá‰ª∂„ÄÇ\n\nÈîôËØØ: ${error.message}`,
              );
            }
          };
          // ‰ª•UTF-8ÁºñÁ†ÅËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ
          reader.readAsText(file, "UTF-8");
        }

        // ÂøÉÂ£∞ËÉåÊôØÊõ¥Êç¢ÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞

        /**
         * ÂΩìÁî®Êà∑ÁÇπÂáª‚ÄúÊõ¥Êç¢ËÉåÊôØ‚ÄùÊåâÈíÆÊó∂ÔºåÂºπÂá∫Êìç‰ΩúËèúÂçï
         */
        async function handleInnerVoiceBgChange() {
          const choice = await showChoiceModal("Êõ¥Êç¢ÂøÉÂ£∞ËÉåÊôØ", [
            { text: "‰∏ä‰º†Êñ∞ËÉåÊôØ", value: "upload" },
            { text: "ÊÅ¢Â§çÈªòËÆ§", value: "reset" },
          ]);

          if (choice === "upload") {
            // Ëß¶ÂèëÈöêËóèÁöÑÊñá‰ª∂ÈÄâÊã©Âô®
            document.getElementById("inner-voice-bg-input").click();
          } else if (choice === "reset") {
            // Ë∞ÉÁî®‰øùÂ≠òÂáΩÊï∞Âπ∂‰º†ÂÖ•Á©∫Â≠óÁ¨¶‰∏≤ÔºåË°®Á§∫ÊÅ¢Â§çÈªòËÆ§
            await saveInnerVoiceBackground("");
          }
        }

        /**
         * ‰øùÂ≠òÊñ∞ÁöÑËÉåÊôØÂõæÁâáURLÂà∞„ÄêÂΩìÂâçËßíËâ≤„Äë
         * @param {string} url - ÂõæÁâáÁöÑURL (ÂèØ‰ª•ÊòØÁΩëÁªúÈìæÊé•ÊàñBase64)
         */
        async function saveInnerVoiceBackground(url) {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          // 1. Â∞ÜËÉåÊôØURL‰øùÂ≠òÂú®ÂΩìÂâçËßíËâ≤ÁöÑÊï∞ÊçÆ‰∏≠
          chat.innerVoiceBackground = url;

          // 2. Â∞ÜÊõ¥Êñ∞ÂêéÁöÑÊï¥‰∏™ chat ÂØπË±°‰øùÂ≠òÂõûÊï∞ÊçÆÂ∫ì
          await db.chats.put(chat);

          // 3. Á´ãÂç≥Â∫îÁî®Êñ∞ÁöÑËÉåÊôØ
          applyInnerVoiceBackground(url);

          // 4. ÁªôÁî®Êà∑‰∏Ä‰∏™ÂèçÈ¶à
          alert(url ? "ÂΩìÂâçËßíËâ≤ËÉåÊôØÂ∑≤Êõ¥Êñ∞ÔºÅ" : "ÂΩìÂâçËßíËâ≤ËÉåÊôØÂ∑≤ÊÅ¢Â§çÈªòËÆ§„ÄÇ");
        }

        /**
         * Â∞ÜÊåáÂÆöÁöÑËÉåÊôØÂõæÂ∫îÁî®Âà∞ÂøÉÂ£∞Èù¢Êùø‰∏ä
         * @param {string} url - ÂõæÁâáÁöÑURL
         */
        function applyInnerVoiceBackground(url) {
          const panel = document.getElementById("inner-voice-main-panel");
          if (!panel) return;

          if (url) {
            panel.style.backgroundImage = `url(${url})`;
          } else {
            // Â¶ÇÊûúURL‰∏∫Á©∫ÔºåÂ∞±ÁßªÈô§ËÉåÊôØÂõæÔºåÊÅ¢Â§çCSS‰∏≠ÂÆö‰πâÁöÑÈªòËÆ§Ê†∑Âºè
            panel.style.backgroundImage = "none";
          }
        }

        function calculateTokenCount(text) {
          if (!text) return 0;
          // ÁÆÄÂçï‰º∞ÁÆóÔºöÂ¶ÇÊûúÊòØ‰∏≠ÊñáÁéØÂ¢ÉÔºåÈÄöÂ∏∏ÂèØ‰ª•Áõ¥Êé•Áî®Â≠óÁ¨¶Êï∞‰Ωú‰∏∫ÂèÇËÄÉ
          // ÊàñËÄÖÁ≤óÁï•‰º∞ÁÆóÔºöToken ‚âà Â≠óÁ¨¶Êï∞
          // Â¶ÇÊûú‰Ω†ÊÉ≥ÊòæÁ§∫ÁöÑÊï∞ÂÄºÂ∞è‰∏ÄÁÇπÔºàÊõ¥Êé•ËøëGPTÁöÑTokenÔºâÔºåÂèØ‰ª•‰πò‰ª• 0.7
          return text.length;
        }

        /**
         * „ÄêÂçáÁ∫ßÁâà„ÄëËé∑ÂèñTokenËØ¶ÊÉÖ + ÂºÇÂ∏∏Ê∂àÊÅØÊ£ÄÊµã
         * @param {string} chatId - ÁõÆÊ†áËÅäÂ§©ÁöÑID
         */
        async function getTokenDetailedBreakdown(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return null;

          const settings = chat.settings;
          const breakdown = [];
          const outlierThreshold = 300; // ËÆæÂÆöÈòàÂÄºÔºöË∂ÖËøá300Â≠óÁ¨¶Ë¢´ËßÜ‰∏∫"Â§ßÊ∂àÊÅØ"
          let outliers = []; // Áî®‰∫éÂ≠òÂÇ®ÂºÇÂ∏∏Â§ßÁöÑÊ∂àÊÅØ

          // ... (Ââç1-4ÈÉ®ÂàÜ‰øùÊåÅ‰∏çÂèò: ‰∫∫ËÆæ„ÄÅ‰∏ñÁïå‰π¶„ÄÅË°®ÊÉÖÂåÖ„ÄÅÊÄªÁªì) ...
          // 1. Ê†∏ÂøÉ‰∫∫ËÆæ
          let personaText = chat.isGroup
            ? `Áæ§ËÅä...${chat.members.map((m) => m.persona).join("")}`
            : (chat.settings.aiPersona || "") + (chat.settings.myPersona || "");
          breakdown.push({
            name: "Ê†∏ÂøÉ‰∫∫ËÆæ",
            count: calculateTokenCount(personaText),
          });

          // 2. World Book
          let wbText = "";
          if (settings.linkedWorldBookIds) {
            wbText = settings.linkedWorldBookIds
              .map((id) => {
                const b = state.worldBooks.find((wb) => wb.id === id);
                return b ? b.content : "";
              })
              .join("");
          }
          breakdown.push({
            name: "World Book",
            count: calculateTokenCount(wbText),
          });

          // 3. Ë°®ÊÉÖÂåÖÂÆö‰πâ
          let stickerText = "";
          const allStickers = [
            ...(settings.stickerLibrary || []),
            ...(state.charStickers || []),
          ];
          if (allStickers.length > 0)
            stickerText = allStickers.map((s) => s.name).join("");
          breakdown.push({
            name: "Ë°®ÊÉÖÂåÖÂÆö‰πâ",
            count: calculateTokenCount(stickerText),
          });

          // 4. ÈïøÊúüËÆ∞ÂøÜ
          const summaryText = chat.history
            .filter((m) => m.type === "summary")
            .map((s) => s.content)
            .join("");
          breakdown.push({
            name: "ÈïøÊúüËÆ∞ÂøÜ(ÊÄªÁªì)",
            count: calculateTokenCount(summaryText),
          });

          // 5. Áü≠ÊúüËÆ∞ÂøÜ (ÂØπËØù) - „ÄêÊ†∏ÂøÉ‰øÆÊîπÈÉ®ÂàÜ„Äë
          const history = chat.history.filter((msg) => !msg.isHidden);
          const memoryDepth = settings.maxMemory || 10;
          const contextMessages = history.slice(-memoryDepth);

          let userMsgLen = 0;
          let aiMsgLen = 0;

          contextMessages.forEach((msg) => {
            let content =
              typeof msg.content === "string"
                ? msg.content
                : JSON.stringify(msg.content);
            let len = calculateTokenCount(content);

            // --- ÂºÇÂ∏∏Ê£ÄÊµãÈÄªËæë ---
            if (len > outlierThreshold) {
              outliers.push({
                role: msg.role,
                preview: content.substring(0, 15) + "...", // È¢ÑËßàÂâç15‰∏™Â≠ó
                count: len,
                timestamp: msg.timestamp, // Áî®‰∫éË∑≥ËΩ¨
              });
            }
            // ------------------

            if (msg.role === "user") userMsgLen += len;
            else aiMsgLen += len;
          });

          // ÂØπÂºÇÂ∏∏Ê∂àÊÅØÊåâÂ§ßÂ∞èÊéíÂ∫è (ÊúÄÂ§ßÁöÑÂú®ÂâçÈù¢)
          outliers.sort((a, b) => b.count - a.count);

          breakdown.push({ name: "Áü≠ÊúüËÆ∞ÂøÜ(Áî®Êà∑)", count: userMsgLen });
          breakdown.push({ name: "Áü≠ÊúüËÆ∞ÂøÜ(AI)", count: aiMsgLen });
          breakdown.push({ name: "Á≥ªÁªüÊ†ºÂºèÊåá‰ª§", count: 800 });

          // ËøîÂõûÊï∞ÊçÆÂ¢ûÂä†‰∫Ü outliers Â≠óÊÆµ
          return { items: breakdown, outliers: outliers };
        }

        /**
         * ‰∏∫TokenËÆ°ÁÆóÂáÜÂ§áÂÆåÊï¥ÁöÑ‰∏ä‰∏ãÊñáÂíåÊèêÁ§∫ËØç
         * @param {string} chatId - ÁõÆÊ†áËÅäÂ§©ÁöÑID
         * @returns {Promise<string>} - ÊãºÊé•Â•ΩÁöÑ„ÄÅÂ∞ÜË¶ÅÂèëÈÄÅÁªôAIÁöÑÂÆåÊï¥ÊñáÊú¨
         */
        async function getContextForTokenCalculation(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return "";

          let combinedText = "";
          const settings = chat.settings;

          // 1. Ê∑ªÂä†Ê†∏ÂøÉÊèêÁ§∫ËØç (‰∫∫ËÆæ)
          if (chat.isGroup) {
            const membersList = chat.members
              .map((m) => `- **${m.originalName}**: ${m.persona}`)
              .join("\n");
            const myNickname = chat.settings.myNickname || "Me";
            combinedText += `‰Ω†ÊòØ‰∏Ä‰∏™Áæ§ËÅäAI... # Áæ§ÊàêÂëòÂàóË°®Âèä‰∫∫ËÆæ\n${membersList}\n# Áî®Êà∑ÁöÑËßíËâ≤\n- **${myNickname}**: ${chat.settings.myPersona}`;
          } else {
            combinedText += chat.settings.aiPersona || "";
            combinedText += chat.settings.myPersona || "";
          }

          // 2. Ê∑ªÂä†‰∏ñÁïå‰π¶ÂÜÖÂÆπ
          if (
            settings.linkedWorldBookIds &&
            settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId,
                );
                return worldBook ? worldBook.content : "";
              })
              .join("\n");
            combinedText += linkedContents;
          }

          // 3. Ê∑ªÂä†ÊâÄÊúâÊÄªÁªì‰Ωú‰∏∫ÈïøÊúüËÆ∞ÂøÜ
          const summaryContext = chat.history
            .filter((msg) => msg.type === "summary")
            .map((s) => s.content)
            .join("\n");
          combinedText += summaryContext;

          // 4. Ê∑ªÂä†ÊúÄËøëÁöÑÂØπËØùËÆ∞ÂΩï (‰∏ä‰∏ãÊñáËÆ∞ÂøÜ)
          const history = chat.history.filter((msg) => !msg.isHidden);
          const memoryDepth = settings.maxMemory || 10;
          const contextMessages = history.slice(-memoryDepth);

          const messageText = contextMessages
            .map((msg) => {
              let content = "";
              if (typeof msg.content === "string") {
                content = msg.content;
              } else if (Array.isArray(msg.content)) {
                content = "[ÂõæÁâá]"; // Â∞ÜÂõæÁâáÁÆÄÂåñ‰∏∫Âç†‰ΩçÁ¨¶
              } else if (msg.type) {
                content = `[${msg.type}]`;
              }
              const sender =
                msg.role === "user" ? "Áî®Êà∑" : msg.senderName || chat.name;
              return `${sender}: ${content}`;
            })
            .join("\n");

          combinedText += "\n" + messageText;

          return combinedText;
        }
        /**
         * Ê∏ÖÁêÜÊâÄÊúâ‰∏éÂ∑≤Âà†Èô§ËßíËâ≤ÂÖ≥ËÅîÁöÑÂ§±ÊïàÊï∞ÊçÆ
         */
        async function clearOrphanedData() {
          // 1. Âú®ÊâßË°åÊïèÊÑüÊìç‰ΩúÂâçÔºåÂÖàÂºπÁ™óÂêëÁî®Êà∑Á°ÆËÆ§
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Ê∏ÖÁêÜ",
            "Ê≠§Êìç‰ΩúÂ∞ÜÊâ´ÊèèÂπ∂Âà†Èô§ÊâÄÊúâ‰∏é„ÄêÂ∑≤‰∏çÂ≠òÂú®ÁöÑËßíËâ≤„ÄëÂÖ≥ËÅîÁöÑÊï∞ÊçÆÔºàÂ¶ÇÂä®ÊÄÅ„ÄÅÂæÆÂçö„ÄÅÂõûÂøÜ„ÄÅÈÄöËØùËÆ∞ÂΩïÁ≠âÔºâÔºåÈáäÊîæÂ≠òÂÇ®Á©∫Èó¥„ÄÇ\n\nÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄÔºåÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü",
            { confirmButtonClass: "btn-danger" }, // ‰ΩøÁî®ÈÜíÁõÆÁöÑÁ∫¢Ëâ≤ÊåâÈíÆ
          );

          // Â¶ÇÊûúÁî®Êà∑ÁÇπ‰∫Ü‚ÄúÂèñÊ∂à‚ÄùÔºåÂàôÁõ¥Êé•ÈÄÄÂá∫
          if (!confirmed) return;

          // ÊòæÁ§∫‰∏Ä‰∏™‚ÄúÂ§ÑÁêÜ‰∏≠‚ÄùÁöÑÊèêÁ§∫ÔºåÈÅøÂÖçÁî®Êà∑‰ª•‰∏∫Á®ãÂ∫èÂç°Ê≠ª
          await showCustomAlert("Please wait...", "Ê≠£Âú®Êâ´ÊèèÂπ∂Ê∏ÖÁêÜÂ§±ÊïàÊï∞ÊçÆ...");

          try {
            let totalDeletedCount = 0;

            // 2. Ëé∑ÂèñÊâÄÊúâ‰ªçÁÑ∂Â≠òÂú®ÁöÑ„ÄÅÊúâÊïàÁöÑËßíËâ≤IDÂàóË°®
            const validChatIds = new Set(
              (await db.chats.toArray()).map((c) => c.id),
            );
            validChatIds.add("user"); // 'user' (Âç≥‚ÄúÊàë‚Äù) Ê∞∏ËøúÊòØÊúâÊïàÁöÑ‰ΩúËÄÖ

            // 3. ÂÆö‰πâÊàë‰ª¨ÈúÄË¶ÅÊ£ÄÊü•ÁöÑÊï∞ÊçÆÂ∫ìË°®ÂíåÂÆÉ‰ª¨Áî®Êù•ÂÖ≥ËÅîËßíËâ≤IDÁöÑÂ≠óÊÆµÂêç
            const tablesToCheck = [
              { name: "qzonePosts", idField: "authorId", typeName: "Âä®ÊÄÅ" },
              { name: "weiboPosts", idField: "authorId", typeName: "Weibo" },
              { name: "memories", idField: "chatId", typeName: "ÂõûÂøÜ/Á∫¶ÂÆö" },
              { name: "callRecords", idField: "chatId", typeName: "ÈÄöËØùËÆ∞ÂΩï" },
            ];

            // 4. ÈÅçÂéÜÊØè‰∏Ä‰∏™ÈúÄË¶ÅÊ£ÄÊü•ÁöÑË°®
            for (const tableInfo of tablesToCheck) {
              const table = db[tableInfo.name];
              const allItems = await table.toArray();

              // ÊâæÂá∫ÊâÄÊúâ‰ΩúËÄÖIDÂ∑≤Áªè‰∏çÂ≠òÂú®ÁöÑ‚ÄúÂ≠§ÂÑø‚ÄùÊï∞ÊçÆ
              const idsToDelete = allItems
                .filter((item) => !validChatIds.has(item[tableInfo.idField]))
                .map((item) => item.id);

              // Â¶ÇÊûúÊâæÂà∞‰∫ÜÈúÄË¶ÅÂà†Èô§ÁöÑÊï∞ÊçÆ
              if (idsToDelete.length > 0) {
                await table.bulkDelete(idsToDelete); // ÊâπÈáèÂà†Èô§ÔºåÊïàÁéáÊõ¥È´ò
                console.log(
                  `‰ªé ${tableInfo.name} Ë°®‰∏≠Ê∏ÖÈô§‰∫Ü ${idsToDelete.length} Êù°Â§±ÊïàÊï∞ÊçÆ„ÄÇ`,
                );
                totalDeletedCount += idsToDelete.length;
              }
            }

            // 5. Ê†πÊçÆÊ∏ÖÁêÜÁªìÊûúÔºåÁªôÁî®Êà∑ÊúÄÁªàÁöÑÂèçÈ¶à
            if (totalDeletedCount > 0) {
              await showCustomAlert(
                "Ê∏ÖÁêÜÂÆåÊàê",
                `Â∑≤ÊàêÂäüÊ∏ÖÁêÜ ${totalDeletedCount} Êù°Â§±ÊïàÊï∞ÊçÆÔºÅ`,
              );
            } else {
              await showCustomAlert("Êâ´ÊèèÂÆåÊàê", "Êú™ÂèëÁé∞‰ªª‰ΩïÂèØÊ∏ÖÁêÜÁöÑÂ§±ÊïàÊï∞ÊçÆ„ÄÇ");
            }
          } catch (error) {
            console.error("Ê∏ÖÁêÜÂ§±ÊïàÊï∞ÊçÆÊó∂Âá∫Èîô:", error);
            await showCustomAlert(
              "Êìç‰ΩúÂ§±Ë¥•",
              `Ê∏ÖÁêÜËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: ${error.message}`,
            );
          }
        }

        /**
         * Â§ÑÁêÜÂèñÊ∂àÊÉÖ‰æ£Á©∫Èó¥
         */
        async function handleCancelLoversSpace() {
          if (!activeLoversSpaceCharId) return;
          const confirmed = await showCustomConfirm(
            "ÂèñÊ∂àÊÉÖ‰æ£Á©∫Èó¥",
            "Á°ÆÂÆöË¶ÅÂèñÊ∂àÊÉÖ‰æ£Á©∫Èó¥ÂêóÔºüËøô‰ºö‰ΩøÁ©∫Èó¥Âèò‰∏∫Êú™ÂêØÁî®Áä∂ÊÄÅÔºå‰ΩÜÊâÄÊúâÊï∞ÊçÆÔºàËØ¥ËØ¥„ÄÅÁÖßÁâáÁ≠âÔºâÈÉΩ‰ºöË¢´‰øùÁïô„ÄÇÊ≠§Êìç‰Ωú‰∏ç‰ºöÈÄöÁü•ÂØπÊñπ„ÄÇ",
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            const chat = state.chats[activeLoversSpaceCharId];
            if (chat && chat.loversSpaceData) {
              // Â∞ÜÊÉÖ‰æ£Á©∫Èó¥Êï∞ÊçÆËÆæÁΩÆ‰∏∫nullÔºåÂç≥ÂèØÁ¶ÅÁî®ÂÆÉ
              chat.loversSpaceData = null;
              await db.chats.put(chat);
              document
                .getElementById("ls-settings-modal")
                .classList.remove("visible");
              alert("ÊÉÖ‰æ£Á©∫Èó¥Â∑≤ÂèñÊ∂à„ÄÇ");
              // ËøîÂõûÂà∞ËÅäÂ§©ÂàóË°®‰∏ªÂ±èÂπï
              showScreen("chat-list-screen");
            }
          }
        }

        /**
         * Â§ÑÁêÜËß£Èô§ÊÉÖ‰æ£ÂÖ≥Á≥ª
         */
        async function handleDisconnectLoversSpace() {
          if (!activeLoversSpaceCharId) return;
          const chat = state.chats[activeLoversSpaceCharId];
          if (!chat) return;

          const confirmed = await showCustomConfirm(
            "Ëß£Èô§ÂÖ≥Á≥ª",
            `Á°ÆÂÆöË¶Å‰∏é‚Äú${chat.name}‚ÄùËß£Èô§ÂÖ≥Á≥ªÂêóÔºüÊÉÖ‰æ£Á©∫Èó¥Â∞ÜË¢´ÂèñÊ∂àÔºåÂπ∂‰∏îÂØπÊñπ‰ºöÊî∂Âà∞ÈÄöÁü•Âπ∂ÂØπÊ≠§ÂèëË°®ÊÑèËßÅ„ÄÇ`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            // 1. Á¶ÅÁî®Á©∫Èó¥
            chat.loversSpaceData = null;

            // 2. ÂàõÂª∫ÊÇ®ÂèëÂá∫ÁöÑ„ÄÅÂú®Âè≥‰æßÁöÑ‚ÄúËß£Èô§Âç°Áâá‚Äù
            const userDisconnectCardMessage = {
              role: "user",
              type: "lovers_space_disconnect", // ‰∏Ä‰∏™Êñ∞Á±ªÂûãÔºåÁî®‰∫éÊ∏≤ÊüìÂç°Áâá
              content: `ÊÉÖ‰æ£Á©∫Èó¥Â∑≤Ëß£Èô§`, // Âç°ÁâáÂ∫ïÂ±ÇÂèØÁºñËæëÁöÑÊñáÂ≠ó
              timestamp: Date.now(),
            };
            chat.history.push(userDisconnectCardMessage);

            // 3. ÂàõÂª∫Â±Ö‰∏≠ÁöÑ„ÄÅÁÅ∞Ëâ≤ÁöÑ‚ÄúÁ≥ªÁªüÈÄöÁü•‚Äù
            const systemNotification = {
              role: "system",
              type: "pat_message", // Â§çÁî®‚ÄúÊãç‰∏ÄÊãç‚ÄùÁöÑÂ±Ö‰∏≠ÁÅ∞Ëâ≤Ê∞îÊ≥°Ê†∑Âºè
              content: `‰Ω†Âíå ${chat.name} ÁöÑÊÉÖ‰æ£Á©∫Èó¥Â∑≤Ëß£Èô§`,
              timestamp: Date.now() + 1, // Êó∂Èó¥Êà≥+1Á°Æ‰øùÂú®Âç°Áâá‰πãÂêé
            };
            chat.history.push(systemNotification);

            // 4. ÁªôAIÁúãÁöÑÈöêËóèÊåá‰ª§
            const hiddenMessageForAI = {
              role: "system",
              content: `[Á≥ªÁªüÊåá‰ª§ÔºöÁî®Êà∑ÂàöÂàöËß£Èô§‰∫Ü‰∏é‰Ω†ÁöÑÊÉÖ‰æ£ÂÖ≥Á≥ª„ÄÇ]`,
              timestamp: Date.now() + 2, // Êó∂Èó¥Êà≥ÂÜç+1
              isHidden: true,
            };
            chat.history.push(hiddenMessageForAI);

            // 5. ‰øùÂ≠ò„ÄÅÂÖ≥Èó≠ÂºπÁ™ó„ÄÅË∑≥ËΩ¨„ÄÅËß¶ÂèëÂõûÂ∫î
            await db.chats.put(chat);
            document
              .getElementById("ls-settings-modal")
              .classList.remove("visible");
            document
              .getElementById("lovers-space-screen")
              .classList.remove("visible");

            openChat(activeLoversSpaceCharId);

            alert("ÂÖ≥Á≥ªÂ∑≤Ëß£Èô§ÔºåÂØπÊñπÂ∑≤Áü•Êôì„ÄÇ");
            triggerAiResponse();
          }
        }

        /**
         * ÊâìÂºÄÊâãÂä®ÊÄªÁªìÁöÑÊ®°ÂºèÈÄâÊã©ÂºπÁ™ó
         */
        async function openManualSummaryOptions() {
          const choice = await showChoiceModal("ÊâãÂä®ÊÄªÁªì", [
            { text: "ÊÄªÁªìÊúÄÊñ∞ÂÜÖÂÆπ", value: "latest" },
            { text: "ÊÄªÁªìÊåáÂÆöËåÉÂõ¥", value: "range" },
          ]);

          if (choice === "latest") {
            // Áî®Êà∑ÈÄâÊã©ÊÄªÁªìÊúÄÊñ∞ÔºåË∞ÉÁî®‰∏ªÂáΩÊï∞Âπ∂‰º†ÂÖ•'latest'Ê®°Âºè
            await triggerManualSummaryNow("latest");
          } else if (choice === "range") {
            // Áî®Êà∑ÈÄâÊã©ÊÄªÁªìËåÉÂõ¥ÔºåË∞ÉÁî®ËåÉÂõ¥ËæìÂÖ•ÂáΩÊï∞
            await promptForSummaryRange();
          }
        }

        /**
         * ÊèêÁ§∫Áî®Êà∑ËæìÂÖ•Ë¶ÅÊÄªÁªìÁöÑÊ∂àÊÅØËåÉÂõ¥
         */
        async function promptForSummaryRange() {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const totalMessages = chat.history.length;
          if (totalMessages === 0) {
            alert("ËÅäÂ§©ËÆ∞ÂΩï‰∏∫Á©∫ÔºåÊó†Ê≥ïËøõË°åÊÄªÁªì„ÄÇ");
            return;
          }

          // ÂºπÂá∫ËæìÂÖ•Ê°ÜÔºåËÆ©Áî®Êà∑ËæìÂÖ•ÂºÄÂßãÂ∫èÂè∑
          const startStr = await showCustomPrompt(
            "ÊåáÂÆöËåÉÂõ¥",
            `ËØ∑ËæìÂÖ•ÂºÄÂßãÁöÑÊ∂àÊÅØÂ∫èÂè∑ (1 - ${totalMessages})`,
            "1",
            "number",
          );
          if (startStr === null) return; // Áî®Êà∑ÁÇπÂáª‰∫ÜÂèñÊ∂à

          const startNum = parseInt(startStr);
          if (isNaN(startNum) || startNum < 1 || startNum > totalMessages) {
            alert("ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÂºÄÂßãÂ∫èÂè∑„ÄÇ");
            return;
          }

          // ÂºπÂá∫ËæìÂÖ•Ê°ÜÔºåËÆ©Áî®Êà∑ËæìÂÖ•ÁªìÊùüÂ∫èÂè∑
          const endStr = await showCustomPrompt(
            "ÊåáÂÆöËåÉÂõ¥",
            `ËØ∑ËæìÂÖ•ÁªìÊùüÁöÑÊ∂àÊÅØÂ∫èÂè∑ (${startNum} - ${totalMessages})`,
            totalMessages,
            "number",
          );
          if (endStr === null) return; // Áî®Êà∑ÁÇπÂáª‰∫ÜÂèñÊ∂à

          const endNum = parseInt(endStr);
          if (isNaN(endNum) || endNum < startNum || endNum > totalMessages) {
            alert("ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÁªìÊùüÂ∫èÂè∑„ÄÇ");
            return;
          }

          // Ë∞ÉÁî®‰∏ªÂáΩÊï∞Âπ∂‰º†ÂÖ•'range'Ê®°ÂºèÂíåÂÖ∑‰ΩìÁöÑËåÉÂõ¥
          await triggerManualSummaryNow("range", {
            start: startNum,
            end: endNum,
          });
        }

        /**
         * Â∞ÜÊó∂Èó¥Â≠óÁ¨¶‰∏≤ÔºàÂ¶Ç "20:00", "Êó©‰∏ä9ÁÇπ"ÔºâËß£Êûê‰∏∫ÂàÜÈíüÊï∞
         * @param {string} timeStr - Êó∂Èó¥Â≠óÁ¨¶‰∏≤
         * @returns {number} - ‰ªéÂçàÂ§ú0ÁÇπÂºÄÂßãÁöÑÂàÜÈíüÊï∞
         */
        function parseTime(timeStr) {
          if (!timeStr || typeof timeStr !== "string") return -1; // ÈîôËØØÊàñÊó†ÊïàËæìÂÖ•ËøîÂõû-1

          let hours = 0;
          let minutes = 0;

          // ÂåπÈÖç "HH:mm" Êàñ "H:mm" Ê†ºÂºè
          const match = timeStr.match(/(\d{1,2}):(\d{2})/);
          if (match) {
            hours = parseInt(match[1], 10);
            minutes = parseInt(match[2], 10);
          } else {
            // Â¶ÇÊûú‰∏çÊòØÊ†áÂáÜÊ†ºÂºèÔºåÂ∞ùËØïÂåπÈÖç‰∏≠ÊñáÊèèËø∞
            const numMatch = timeStr.match(/(\d+)/);
            const num = numMatch ? parseInt(numMatch[0], 10) : -1;

            if (num !== -1) {
              if (timeStr.includes("‰∏ãÂçà") || timeStr.includes("Êôö‰∏ä")) {
                // ‰∏ãÂçà1ÁÇπ(13ÁÇπ)Âà∞Êôö‰∏ä11ÁÇπ(23ÁÇπ)
                if (num < 12) {
                  hours = num + 12;
                } else {
                  hours = num; // Â¶ÇÊûúÂ∑≤ÁªèÊòØ24Â∞èÊó∂Âà∂Â¶Ç‚ÄúÊôö‰∏ä20ÁÇπ‚ÄùÔºåÁõ¥Êé•‰ΩøÁî®
                }
              } else {
                // Êó©‰∏äÊàñ‰∏äÂçà
                hours = num;
              }
            } else {
              return -1; // Êó†Ê≥ïËß£Êûê
            }
          }

          // Â§ÑÁêÜÁâπÊÆäÊÉÖÂÜµÔºåÂ¶ÇÊôö‰∏ä12ÁÇπÂ∫î‰∏∫0ÁÇπ
          if (
            (timeStr.includes("Êôö‰∏ä") || timeStr.includes("ÂáåÊô®")) &&
            hours === 12
          ) {
            hours = 0;
          }
          // Â§ÑÁêÜ‰∏ãÂçà12ÁÇπÂ∫î‰∏∫12ÁÇπ
          if (
            (timeStr.includes("‰∏ãÂçà") || timeStr.includes("‰∏≠Âçà")) &&
            hours === 24
          ) {
            hours = 12;
          }

          return hours * 60 + minutes;
        }
        /**
         * Ê£ÄÊü•Âπ∂Êõ¥Êñ∞ÁÅ´Ëä±Â§©Êï∞ (Â∑≤‰øÆÂ§çÁÜÑÁÅ≠Âêé‰ªé1ÂºÄÂßãÁöÑÈóÆÈ¢ò)
         * @param {string} chatId - Ë¶ÅÊõ¥Êñ∞ÁÅ´Ëä±ÁöÑËÅäÂ§©ID
         * @returns {Promise<boolean>} - Â¶ÇÊûúÁÅ´Ëä±Â§©Êï∞ÊúâÂèòÂåñÔºåÂàôËøîÂõûtrue
         */
        async function updateStreak(chatId) {
          const chat = state.chats[chatId];
          // Â¶ÇÊûú‰∏çÊòØÂçïËÅäÔºåÊàñËÄÖÂäüËÉΩÊú™ÂºÄÂêØÔºåÁõ¥Êé•ËøîÂõû
          if (!chat || chat.isGroup || !chat.settings.streak?.enabled) {
            return false;
          }

          const streak = chat.settings.streak;
          const today = new Date().toISOString().split("T")[0]; // YYYY-MM-DDÊ†ºÂºè

          // Â¶ÇÊûú‰ªäÂ§©Â∑≤Áªè‰∫íÂä®Ëøá‰∫ÜÔºåÂ∞±‰ªÄ‰πàÈÉΩ‰∏çÂÅö
          if (streak.lastInteractionDate === today) {
            return false;
          }

          let changed = false;

          // Ê£ÄÊü•ÁÅ´Ëä±ÊòØÂê¶Â∑≤ÁÜÑÁÅ≠
          if (streak.lastInteractionDate && streak.extinguishThreshold !== -1) {
            const lastDate = new Date(streak.lastInteractionDate);
            const todayDate = new Date(today);
            // ‰∏∫‰∫ÜÁ≤æÁ°ÆËÆ°ÁÆóÂ§©Êï∞Â∑ÆÂºÇÔºåÊàë‰ª¨Â∞Ü‰∏§‰∏™Êó•ÊúüÈÉΩËÆæÁΩÆ‰∏∫UTCÊó∂Èó¥ÁöÑÂçàÂ§ú
            const lastDateUTC = Date.UTC(
              lastDate.getFullYear(),
              lastDate.getMonth(),
              lastDate.getDate(),
            );
            const todayDateUTC = Date.UTC(
              todayDate.getFullYear(),
              todayDate.getMonth(),
              todayDate.getDate(),
            );

            const daysDiff =
              (todayDateUTC - lastDateUTC) / (1000 * 60 * 60 * 24);

            if (daysDiff >= streak.extinguishThreshold) {
              // Â¶ÇÊûúÊñ≠ËÅîÂ§©Êï∞ËææÂà∞‰∫Ü‰Ω†ËÆæÁΩÆÁöÑÈòàÂÄºÔºåÂ∞±Â∞ÜÂΩìÂâçÁÅ´Ëä±Â§©Êï∞ÂΩíÈõ∂„ÄÇ
              streak.currentDays = 0;
              console.log(
                `üî• ‰∏é ${chat.name} ÁöÑÁÅ´Ëä±Âõ†Ë∂ÖËøá ${streak.extinguishThreshold} Â§©Êú™ËÅîÁ≥ªËÄåÁÜÑÁÅ≠ÔºåÂ∞ÜÈáçÊñ∞‰ªé 1 ÂºÄÂßãËÆ°ÁÆó„ÄÇ`,
              );
              changed = true;
            }
          }

          // ‰ªäÂ§©ÊòØÊñ∞ÁöÑ‰∫íÂä®Êó•ÔºåÂ§©Êï∞+1
          // Â¶ÇÊûúÊòØÊ∞∏‰∏çÁÜÑÁÅ≠Ê®°ÂºèÔºåcurrentDays ‰∏∫ -1, ‰∏çÂ∫îËØ•Â¢ûÂä†
          if (streak.currentDays >= 0) {
            streak.currentDays++;
            changed = true;
          }

          // Êó†ËÆ∫ÁÅ´Ëä±ÊòØÂê¶ÁÜÑÁÅ≠ÔºåÂè™Ë¶Å‰ªäÂ§©‰∫íÂä®‰∫ÜÔºåÂ∞±Êää‚ÄúÊúÄÂêé‰∫íÂä®Êó•Êúü‚ÄùÊõ¥Êñ∞‰∏∫‰ªäÂ§©„ÄÇ
          streak.lastInteractionDate = today;

          await db.chats.put(chat);

          if (changed) {
            console.log(
              `üî• ‰∏é ${chat.name} ÁöÑÁÅ´Ëä±Â§©Êï∞Êõ¥Êñ∞‰∏∫: ${streak.currentDays}`,
            );
          }

          return changed; // ËøîÂõûÊòØÂê¶ÂèëÁîü‰∫ÜÂèòÂåñ
        }

        /**
         * Â§ÑÁêÜËÆæÁΩÆ/ÂèñÊ∂àÁÆ°ÁêÜÂëò
         */
        async function handleToggleAdmin(memberId) {
          const chat = state.chats[state.activeChatId];
          // ÊùÉÈôêÊ£ÄÊü•ÔºöÁ°Æ‰øùÊìç‰ΩúËÄÖÊòØÁæ§‰∏ª
          if (!chat || chat.ownerId !== "user") {
            alert("You are not the group owner and do not have permission to perform this action!");
            return;
          }

          let targetNickname;
          let isAdminNow;

          // 1. Âà§Êñ≠Êìç‰ΩúÁõÆÊ†áÊòØ‰∏çÊòØÁî®Êà∑Ëá™Â∑±
          if (memberId === "user") {
            // Â¶ÇÊûúÊòØÁî®Êà∑ÔºåÂ∞±‰øÆÊîπ chat.settings ÈáåÁöÑ‰∏ìÂ±ûÊ†áÂøó
            // Êàë‰ª¨‰ΩøÁî® isUserAdmin Â±ûÊÄßÊù•ËÆ∞ÂΩïÁî®Êà∑ÊòØÂê¶ÊòØÁÆ°ÁêÜÂëò
            chat.settings.isUserAdmin = !chat.settings.isUserAdmin;
            targetNickname = chat.settings.myNickname || "Me";
            isAdminNow = chat.settings.isUserAdmin;
          } else {
            // Â¶ÇÊûúÊòØÂÖ∂‰ªñÊàêÂëòÔºå‰øùÊåÅÂéüÊúâÈÄªËæë‰∏çÂèò
            const member = chat.members.find((m) => m.id === memberId);
            if (!member) return;

            // ‰∏çËÉΩÂ∞ÜÁæ§‰∏ªËÆæ‰∏∫ÁÆ°ÁêÜÂëòÊàñÂèñÊ∂àÂÖ∂ÁÆ°ÁêÜÂëòË∫´‰ªΩ
            if (member.id === chat.ownerId) {
              alert("Cannot perform this action on the group owner.");
              return;
            }

            member.isAdmin = !member.isAdmin;
            targetNickname = member.groupNickname;
            isAdminNow = member.isAdmin;
          }

          await db.chats.put(chat);

          // ÂáÜÂ§áÂπ∂ÂèëÈÄÅÁ≥ªÁªüÈÄöÁü•Ê∂àÊÅØ
          const actionText = isAdminNow ? "Promoted to admin" : "Removed admin privileges";
          const myNickname = chat.settings.myNickname || "Me";
          // ËøôÈáåÊàë‰ª¨Áî® logSystemMessage ÂáΩÊï∞Êù•ÂèëÈÄÅÈÄöÁü•ÔºåÂÆÉ‰ºöËá™Âä®Âà∑Êñ∞UI
          await logSystemMessage(
            chat.id,
            `‚Äú${myNickname}‚Äù${actionText}‚Äú${targetNickname}‚Äù„ÄÇ`,
          );

          // Âà∑Êñ∞ÊàêÂëòÁÆ°ÁêÜÂàóË°®ÁöÑÊòæÁ§∫
          renderMemberManagementList();
        }

        /**
         * Â§ÑÁêÜËÆæÁΩÆÁæ§ÊàêÂëòÂ§¥Ë°î
         */
        async function handleSetMemberTitle(memberId) {
          const chat = state.chats[state.activeChatId];
          // ÊùÉÈôêÊ£ÄÊü•ÔºöÁæ§‰∏ªÊàñÁÆ°ÁêÜÂëòÊâçËÉΩËÆæÁΩÆ
          const isOwner = chat.ownerId === "user";
          const isAdmin = chat.settings.isUserAdmin;

          if (!chat || (!isOwner && !isAdmin)) {
            alert("‰Ω†‰∏çÊòØÁæ§‰∏ªÊàñÁÆ°ÁêÜÂëòÔºåÊ≤°ÊúâÊùÉÈôêÊâßË°åÊ≠§Êìç‰ΩúÔºÅ");
            return;
          }

          let targetNickname;
          let oldTitle;

          if (memberId === "user") {
            targetNickname = chat.settings.myNickname || "Me";
            oldTitle = chat.settings.myGroupTitle || "";
          } else {
            const member = chat.members.find((m) => m.id === memberId);
            if (!member) return;
            targetNickname = member.groupNickname;
            oldTitle = member.groupTitle || "";
          }

          const newTitle = await showCustomPrompt(
            `‰∏∫‚Äú${targetNickname}‚ÄùËÆæÁΩÆÂ§¥Ë°î`,
            "ÁïôÁ©∫Âàô‰∏∫ÂèñÊ∂àÂ§¥Ë°î",
            oldTitle,
          );

          if (newTitle !== null) {
            const trimmedTitle = newTitle.trim();

            if (memberId === "user") {
              chat.settings.myGroupTitle = trimmedTitle;
            } else {
              const member = chat.members.find((m) => m.id === memberId);
              if (member) member.groupTitle = trimmedTitle;
            }

            await db.chats.put(chat);

            const myNickname = chat.settings.myNickname || "Me";
            await logTitleChange(
              chat.id,
              myNickname,
              targetNickname,
              trimmedTitle,
            );

            renderMemberManagementList();
          }
        }

        /**
         * Â§ÑÁêÜËΩ¨ËÆ©Áæ§‰∏ª (Â∑≤Ê∑ªÂä†Á≥ªÁªüÊ∂àÊÅØÈÄöÁü•)
         */
        async function handleTransferOwnership(memberId) {
          const chat = state.chats[state.activeChatId];
          const newOwner = chat.members.find((m) => m.id === memberId);
          if (!newOwner) return;

          // Ëé∑ÂèñÊóßÁæ§‰∏ªÁöÑÊòµÁß∞Ôºå‰πüÂ∞±ÊòØ‰Ω†Ëá™Â∑±ÁöÑÊòµÁß∞
          const oldOwnerNickname = chat.settings.myNickname || "Me";

          const confirmed = await showCustomConfirm(
            "ËΩ¨ËÆ©Áæ§‰∏ª",
            `‰Ω†Á°ÆÂÆöË¶ÅÂ∞ÜÁæ§‰∏ªË∫´‰ªΩËΩ¨ËÆ©Áªô‚Äú${newOwner.groupNickname}‚ÄùÂêóÔºü\nÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄÔºå‰Ω†Â∞ÜÂ§±ÂéªÁæ§‰∏ªÊùÉÈôê„ÄÇ`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            // Êõ¥Êñ∞Áæ§‰∏ªID
            chat.ownerId = newOwner.id;

            // Â∞ÜÊñ∞Áæ§‰∏ªËÆæ‰∏∫ÁÆ°ÁêÜÂëòÔºàÂ¶ÇÊûú‰ªñ‰πãÂâç‰∏çÊòØÔºâ
            newOwner.isAdmin = true;

            // 1. ÊûÑÂª∫Á≥ªÁªüÊ∂àÊÅØÁöÑÂÜÖÂÆπ
            const message = `‚Äú${oldOwnerNickname}‚ÄùÂ∑≤Â∞ÜÁæ§‰∏ªËΩ¨ËÆ©Áªô‚Äú${newOwner.groupNickname}‚Äù`;

            // 2. Ë∞ÉÁî®‰Ω†Â∑≤ÊúâÁöÑÂáΩÊï∞Êù•ÂèëÈÄÅËøôÊù°Á≥ªÁªüÊ∂àÊÅØ
            //    Ëøô‰∏™ÂáΩÊï∞‰ºöËá™Âä®‰øùÂ≠òÊï∞ÊçÆÂπ∂Âà∑Êñ∞ËÅäÂ§©ÂàóË°®ÔºåÈùûÂ∏∏Êñπ‰æøÔºÅ
            await logSystemMessage(chat.id, message);

            // Âà∑Êñ∞ÊàêÂëòÁÆ°ÁêÜÂàóË°®ÁöÑÊòæÁ§∫
            renderMemberManagementList();

            // ÁªôÂá∫ÊàêÂäüÊèêÁ§∫
            await showCustomAlert(
              "Êìç‰ΩúÊàêÂäü",
              `Áæ§‰∏ªÂ∑≤ÊàêÂäüËΩ¨ËÆ©Áªô‚Äú${newOwner.groupNickname}‚Äù„ÄÇ`,
            );
          }
        }

        /**
         * ÂèëÈÄÅ‰∏ÄÊù°Â±Ö‰∏≠ÊòæÁ§∫ÁöÑÁ≥ªÁªüÊ∂àÊÅØÂà∞ÂΩìÂâçËÅäÂ§©
         * @param {string} chatId - ÁõÆÊ†áËÅäÂ§©ÁöÑID
         * @param {string} messageContent - Ë¶ÅÊòæÁ§∫ÁöÑÊ∂àÊÅØÂÜÖÂÆπ
         */
        async function logSystemMessage(chatId, messageContent) {
          const chat = state.chats[chatId];
          if (!chat) return;

          // 1. ÂàõÂª∫Á≥ªÁªüÊ∂àÊÅØÂØπË±°
          const systemMessage = {
            role: "system", // ËøôÊòØ‰∏Ä‰∏™Á≥ªÁªüËßíËâ≤ÁöÑÊ∂àÊÅØ
            type: "pat_message", // Â§çÁî®‚ÄúÊãç‰∏ÄÊãç‚ÄùÁöÑÂ±Ö‰∏≠ÁÅ∞Ëâ≤Ê∞îÊ≥°Ê†∑Âºè
            content: messageContent,
            timestamp: Date.now(),
          };

          // 2. Â∞ÜÊ∂àÊÅØÊ∑ªÂä†Âà∞ËÅäÂ§©ËÆ∞ÂΩïÂπ∂‰øùÂ≠ò
          chat.history.push(systemMessage);
          await db.chats.put(chat);

          // 3. Â¶ÇÊûúÁî®Êà∑Ê≠£Âú®Êü•ÁúãÊ≠§ËÅäÂ§©ÔºåÂàôÁ´ãÂç≥ÊòæÁ§∫Êñ∞Ê∂àÊÅØ
          if (
            state.activeChatId === chatId &&
            document
              .getElementById("chat-interface-screen")
              .classList.contains("active")
          ) {
            appendMessage(systemMessage, chat);
          }

          // 4. Âà∑Êñ∞ËÅäÂ§©ÂàóË°®‰ª•Êõ¥Êñ∞È¢ÑËßà
          await renderChatList();

          console.log(`Á≥ªÁªüÊ∂àÊÅØÂ∑≤ËÆ∞ÂΩï: ${messageContent}`);
        }

        /**
         * ËÆ∞ÂΩïÂπ∂ÂèëÈÄÅÁæ§Â§¥Ë°îÂèòÊõ¥ÁöÑÁ≥ªÁªüÊ∂àÊÅØ
         * @param {string} chatId - ÂèëÁîüÂèòÊõ¥ÁöÑÁæ§ËÅäID
         * @param {string} actorName - ÊâßË°åÊìç‰ΩúÁöÑ‰∫∫ÁöÑÊòµÁß∞
         * @param {string} targetName - Ë¢´‰øÆÊîπÂ§¥Ë°îÁöÑ‰∫∫ÁöÑÊòµÁß∞
         * @param {string} newTitle - Êñ∞ÁöÑÂ§¥Ë°î
         */
        async function logTitleChange(chatId, actorName, targetName, newTitle) {
          // 1. ÊûÑÈÄ†Ê∂àÊÅØÂÜÖÂÆπ
          const messageContent = newTitle
            ? `${actorName} Â∞Ü‚Äú${targetName}‚ÄùÁöÑÁæ§Â§¥Ë°î‰øÆÊîπ‰∏∫‚Äú${newTitle}‚Äù`
            : `${actorName} ÂèñÊ∂à‰∫Ü‚Äú${targetName}‚ÄùÁöÑÁæ§Â§¥Ë°î`;

          // 2. Ë∞ÉÁî®ÈÄöÁî®ÁöÑÁ≥ªÁªüÊ∂àÊÅØÂáΩÊï∞
          await logSystemMessage(chatId, messageContent);
        }

        /* Áæ§ÂÖ¨ÂëäÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞ */

        /**
         * ÊâìÂºÄÁæ§ÂÖ¨ÂëäÂºπÁ™óÂπ∂Ê∏≤ÊüìÂÜÖÂÆπ
         */
        function openGroupAnnouncementModal() {
          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.isGroup) return;

          const modal = document.getElementById("group-announcement-modal");
          const contentArea = document.getElementById(
            "announcement-content-area",
          );
          const footer = document.getElementById("announcement-footer");

          const announcement = chat.settings.groupAnnouncement || "ÊöÇÊó†ÂÖ¨Âëä";
          contentArea.innerHTML = announcement.replace(/\n/g, "<br>");

          const canEdit = chat.ownerId === "user" || chat.settings.isUserAdmin;

          footer.innerHTML = "";
          if (canEdit) {
            const editBtn = document.createElement("button");
            editBtn.className = "cancel";
            editBtn.textContent = "ÁºñËæë";
            // ÊîπÁî® addEventListener Êù•ÁªëÂÆö‰∫ã‰ª∂ÔºåÊõ¥ÂÆâÂÖ®ÂèØÈù†
            editBtn.addEventListener("click", editGroupAnnouncement);
            footer.appendChild(editBtn);
          }

          const closeBtn = document.createElement("button");
          closeBtn.className = "save";
          closeBtn.textContent = "ÂÖ≥Èó≠";
          // ÂêåÊ†∑ÊîπÁî® addEventListener
          closeBtn.addEventListener("click", closeGroupAnnouncementModal);
          footer.appendChild(closeBtn);

          modal.classList.add("visible");
        }

        /**
         * ËøõÂÖ•ÂÖ¨ÂëäÁºñËæëÊ®°Âºè
         */
        function editGroupAnnouncement() {
          const chat = state.chats[state.activeChatId];
          const contentArea = document.getElementById(
            "announcement-content-area",
          );
          const footer = document.getElementById("announcement-footer");

          const currentContent = chat.settings.groupAnnouncement || "";
          contentArea.innerHTML = `<textarea id="announcement-editor">${currentContent}</textarea>`;

          // ËøôÈáå‰πüÂÖ®ÈÉ®ÊîπÁî® addEventListener ÁöÑÊñπÂºèÁªëÂÆö
          footer.innerHTML = ""; // ÂÖàÊ∏ÖÁ©∫

          const cancelBtn = document.createElement("button");
          cancelBtn.className = "cancel";
          cancelBtn.textContent = "Cancel";
          cancelBtn.addEventListener("click", closeGroupAnnouncementModal); // Áõ¥Êé•Ë∞ÉÁî®ÂáΩÊï∞

          const saveBtn = document.createElement("button");
          saveBtn.className = "save";
          saveBtn.textContent = "‰øùÂ≠ò";
          saveBtn.addEventListener("click", saveGroupAnnouncement); // Áõ¥Êé•Ë∞ÉÁî®ÂáΩÊï∞

          footer.appendChild(cancelBtn);
          footer.appendChild(saveBtn);

          document.getElementById("announcement-editor").focus();
        }

        /**
         * ‰øùÂ≠òÊñ∞ÁöÑÁæ§ÂÖ¨Âëä
         */
        async function saveGroupAnnouncement() {
          const chat = state.chats[state.activeChatId];
          const newContent = document
            .getElementById("announcement-editor")
            .value.trim();

          chat.settings.groupAnnouncement = newContent;
          await db.chats.put(chat);

          const myNickname = chat.settings.myNickname || "Me";
          await logSystemMessage(chat.id, `‚Äú${myNickname}‚Äù‰øÆÊîπ‰∫ÜÁæ§ÂÖ¨Âëä„ÄÇ`);

          closeGroupAnnouncementModal();
          alert("Áæ§ÂÖ¨ÂëäÂ∑≤Êõ¥Êñ∞ÔºÅ");
        }

        /**
         * ÂÖ≥Èó≠Áæ§ÂÖ¨ÂëäÂºπÁ™ó
         */
        function closeGroupAnnouncementModal() {
          // ÂÖ≥Èó≠ÂêéÔºåÈáçÊñ∞Ê∏≤Êüì‰∏ÄÊ¨°Êü•ÁúãÁä∂ÊÄÅÔºå‰ª•Èò≤Áî®Êà∑ÂèñÊ∂à‰∫ÜÁºñËæë
          const modal = document.getElementById("group-announcement-modal");
          modal.classList.remove("visible");
          // Âª∂Ëøü‰∏ÄÁÇπÁÇπÂÜçÊâìÂºÄÔºåÂèØ‰ª•ÈÅøÂÖçËßÜËßâ‰∏äÁöÑÂÜ≤Á™Å
          setTimeout(() => {
            if (modal.classList.contains("visible")) {
              // ÂÅö‰∏™Ê£ÄÊü•Ôºå‰∏á‰∏ÄÁî®Êà∑Âø´ÈÄüÊìç‰Ωú
              openGroupAnnouncementModal();
            }
          }, 10);
          // Áõ¥Êé•ÂÖ≥Èó≠Ôºå‰∏çÂÜçÈáçÊñ∞ÊâìÂºÄ
          document
            .getElementById("group-announcement-modal")
            .classList.remove("visible");
        }

        /**
         * Ëé∑ÂèñÂπ∂Ê†ºÂºèÂåñÂΩìÂâçËÅäÂ§©ÁöÑÁª≠ÁÅ´Ëä±Áä∂ÊÄÅÔºåÁîüÊàêÁªôAIÁúãÁöÑ‰∏ä‰∏ãÊñá
         * @param {object} chat - ÂΩìÂâçÁöÑËÅäÂ§©ÂØπË±°
         * @returns {string} - Ê†ºÂºèÂåñÂêéÁöÑÁÅ´Ëä±Áä∂ÊÄÅÊñáÊú¨ÔºåÊàñÁ©∫Â≠óÁ¨¶‰∏≤
         */
        async function getStreakContext(chat) {
          // 1. ÂÆâÂÖ®Ê£ÄÊü•ÔºöÂ¶ÇÊûú‰∏çÊòØÂçïËÅäÔºåÊàñËÄÖÂäüËÉΩÊú™ÂºÄÂêØÔºåÂàôÁõ¥Êé•ËøîÂõûÁ©∫ÂÜÖÂÆπ
          if (!chat || chat.isGroup || !chat.settings.streak?.enabled) {
            return "";
          }

          const streak = chat.settings.streak;
          const currentDays = streak.currentDays || 0;
          const extinguishThreshold = streak.extinguishThreshold || 1;
          const lastInteractionDate = streak.lastInteractionDate;
          let isExtinguished = false;

          // 2. Âà§Êñ≠ÁÅ´Ëä±ÊòØÂê¶Â∑≤ÁÜÑÁÅ≠
          if (lastInteractionDate && extinguishThreshold !== -1) {
            const lastDate = new Date(lastInteractionDate);
            const todayDate = new Date();
            todayDate.setHours(0, 0, 0, 0); // Â∞ÜÊó∂Èó¥ËÆæ‰∏∫ÂΩìÊó•Èõ∂ÁÇπÔºå‰ª•Á≤æÁ°ÆËÆ°ÁÆóÂ§©Êï∞

            // ËÆ°ÁÆóÊúÄÂêé‰∏ÄÊ¨°‰∫íÂä®Âà∞‰ªäÂ§©Ëøá‰∫ÜÂ§öÂ∞ëÂ§©
            const daysDiff =
              (todayDate.getTime() - lastDate.getTime()) /
              (1000 * 60 * 60 * 24);

            if (daysDiff >= extinguishThreshold) {
              isExtinguished = true;
            }
          }

          let statusText = "";

          // 3. Ê†πÊçÆ‰∏çÂêåÁä∂ÊÄÅÔºåÁîüÊàêÁªôAIÁúãÁöÑ‰∏çÂêåÊñáÊú¨
          if (isExtinguished && currentDays > 0) {
            // ËøôÁßçÁä∂ÊÄÅË°®Á§∫‚ÄúÊõæÁªèÊúâËøáÁÅ´Ëä±Ôºå‰ΩÜÁé∞Âú®Êñ≠‰∫Ü‚Äù
            statusText = `‰Ω†‰ª¨ÁöÑËÅäÂ§©ÁÅ´Ëä±„ÄêÂ∑≤ÁÜÑÁÅ≠„Äë„ÄÇ‰πãÂâçÊõæËøûÁª≠ËÅä‰∫Ü ${currentDays} Â§©Ôºå‰ΩÜÁé∞Âú®‰∏≠Êñ≠‰∫Ü„ÄÇ`;
          } else if (currentDays > 10) {
            statusText = `‰Ω†‰ª¨ÁöÑËÅäÂ§©ÁÅ´Ëä±Ê≠£Âú®ÁÉ≠ÁÉàÁáÉÁÉßÔºåÂ∑≤ÁªèÊåÅÁª≠‰∫Ü„Äê${currentDays}„ÄëÂ§©‰∫ÜÔºÅËøôÊòØ‰∏Ä‰∏™ÂÄºÂæóÁ∫™ÂøµÁöÑÊï∞Â≠ó„ÄÇ`;
          } else if (currentDays > 0) {
            statusText = `‰Ω†‰ª¨ÁöÑËÅäÂ§©ÁÅ´Ëä±Ê≠£Âú®Âª∂Áª≠ÔºåÂ∑≤ÁªèÊåÅÁª≠‰∫Ü„Äê${currentDays}„ÄëÂ§©„ÄÇ`;
          } else {
            // Â§©Êï∞‰∏∫0ÔºåËØ¥ÊòéÊòØÂàöÂºÄÂêØÊàñÂàöÈáçÁΩÆ
            statusText = "‰Ω†‰ª¨ÂàöÂàöÁÇπÁáÉ‰∫ÜËÅäÂ§©ÁÅ´Ëä±ÔºåË¶ÅÁªßÁª≠‰øùÊåÅÂì¶ÔºÅ";
          }

          // 4. ÊãºÊé•ÊàêÊúÄÁªàÁöÑ‰∏ä‰∏ãÊñáÊ†ºÂºè
          return `\n- **ËÅäÂ§©ÁÅ´Ëä±Áä∂ÊÄÅ**: ${statusText}`;
        }

        // Áî®Êà∑Ë°®ÊÉÖÂåÖÊâπÈáèÂà†Èô§Ê†∏ÂøÉÂáΩÊï∞

        function toggleUserStickerSelectionMode() {
          isUserStickerSelectionMode = !isUserStickerSelectionMode;
          const stickerPanel = document.getElementById("sticker-panel");

          selectedUserStickers.clear();
          // Âú®ËøôÈáåÁªôÁà∂ÂÆπÂô®Ê∑ªÂä†/ÁßªÈô§‰∏Ä‰∏™class
          stickerPanel.classList.toggle(
            "selection-mode",
            isUserStickerSelectionMode,
          );

          document.getElementById("edit-user-stickers-btn").style.display =
            isUserStickerSelectionMode ? "none" : "block";
          document.getElementById("done-user-stickers-btn").style.display =
            isUserStickerSelectionMode ? "block" : "none";
          document.getElementById("sticker-panel-footer").style.display =
            isUserStickerSelectionMode ? "flex" : "none";

          const deleteBtn = document.getElementById(
            "delete-selected-user-stickers-btn",
          );
          deleteBtn.textContent = `Âà†Èô§Â∑≤ÈÄâ (0)`;
          deleteBtn.disabled = true;

          const moveBtn = document.getElementById("move-selected-stickers-btn");
          moveBtn.disabled = true;

          renderStickerPanel(); // Ëøô‰∏ÄÊ≠•‰ºöË∞ÉÁî® renderStickerCategoriesÔºåÂπ∂Ê†πÊçÆÊñ∞ÁöÑÊ®°ÂºèÈáçÊñ∞Ê∏≤Êüì
        }

        /**
         * ÈÄÄÂá∫Áî®Êà∑Ë°®ÊÉÖÂåÖÁöÑÈÄâÊã©Ê®°Âºè
         */
        function exitUserStickerSelectionMode() {
          if (isUserStickerSelectionMode) {
            toggleUserStickerSelectionMode();
          }
        }

        // ËßíËâ≤Ë°®ÊÉÖÂåÖÊâπÈáèÂà†Èô§Ê†∏ÂøÉÂáΩÊï∞

        /**
         * ÂàáÊç¢ËßíËâ≤Ë°®ÊÉÖÂåÖÁöÑÈÄâÊã©Ê®°Âºè
         */
        function toggleCharStickerSelectionMode() {
          isCharStickerSelectionMode = !isCharStickerSelectionMode;
          const screen = document.getElementById("char-sticker-manager-screen");

          // Ê∏ÖÁ©∫ÈÄâÊã©ÈõÜÂπ∂Êõ¥Êñ∞UI
          selectedCharStickers.clear();
          screen.classList.toggle("selection-mode", isCharStickerSelectionMode);

          document.getElementById("edit-char-stickers-btn").style.display =
            isCharStickerSelectionMode ? "none" : "block";
          document.getElementById("done-char-stickers-btn").style.display =
            isCharStickerSelectionMode ? "block" : "none";
          document.getElementById("char-sticker-footer").style.display =
            isCharStickerSelectionMode ? "block" : "none";
          document.getElementById(
            "delete-selected-char-stickers-btn",
          ).textContent = `Âà†Èô§Â∑≤ÈÄâ (0)`;
          document.getElementById(
            "delete-selected-char-stickers-btn",
          ).disabled = true;

          // ÈáçÊñ∞Ê∏≤ÊüìÂΩìÂâçÊøÄÊ¥ªÁöÑÈ°µÁ≠æ
          const activeTab = document.querySelector(
            "#char-sticker-manager-screen .frame-tab.active",
          );
          if (activeTab) {
            renderCharStickers(
              activeTab.id === "sticker-tab-exclusive" ? "exclusive" : "common",
            );
          }
        }

        /**
         * ÈÄÄÂá∫ËßíËâ≤Ë°®ÊÉÖÂåÖÁöÑÈÄâÊã©Ê®°Âºè
         */
        function exitCharStickerSelectionMode() {
          if (isCharStickerSelectionMode) {
            toggleCharStickerSelectionMode();
          }
        }

        /**
         * ÂΩìÁî®Êà∑ÁÇπÂáªÂøÉÂ£∞Èù¢ÊùøÁöÑÁºñËæëÊåâÈíÆÊó∂ÔºåÊâìÂºÄÊìç‰ΩúËèúÂçï
         */
        async function showInnerVoiceEditOptions() {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const borderHidden =
            chat.settings.innerVoiceHideHeaderBorder || false;
          const borderOptionText = borderHidden ? "ÊòæÁ§∫ÂàÜÂâ≤Á∫ø" : "ÈöêËóèÂàÜÂâ≤Á∫ø";

          // ÈÄâÈ°πÊï∞ÁªÑÈáåÊñ∞Â¢û 'editStyles'
          const choice = await showChoiceModal("ÁºñËæëÂøÉÂ£∞Èù¢Êùø", [
            { text: "üé® ÁºñËæëÈù¢ÊùøÊ†∑Âºè", value: "editStyles" },
            { text: borderOptionText, value: "toggleBorder" },
            { text: "‰øÆÊîπÈ¢ÜÂÖª‰∫∫", value: "editAdopter" },
          ]);

          if (choice === "editStyles") {
            openInnerVoiceStyleEditor(); // Ë∞ÉÁî®Êàë‰ª¨Êñ∞ÂÜôÁöÑÂáΩÊï∞Êù•ÊâìÂºÄÊ†∑ÂºèÁºñËæëÂô®
          } else if (choice === "toggleBorder") {
            await toggleInnerVoiceHeaderBorder();
          } else if (choice === "editAdopter") {
            await editInnerVoiceAdopterName();
          }
        }

        /**
         * ÂàáÊç¢ÂøÉÂ£∞Èù¢ÊùøÂ§¥ÈÉ®ÂàÜÂâ≤Á∫øÁöÑÊòæÁ§∫/ÈöêËóè
         */
        async function toggleInnerVoiceHeaderBorder() {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          // Á°Æ‰øù chat.settings Â≠òÂú®
          if (!chat.settings) chat.settings = {};

          // ÂàáÊç¢Â∏ÉÂ∞îÂÄº
          chat.settings.innerVoiceHideHeaderBorder = !(
            chat.settings.innerVoiceHideHeaderBorder || false
          );

          // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
          await db.chats.put(chat);

          // Êõ¥Êñ∞UI
          const header = document.querySelector(
            "#inner-voice-main-panel .modal-header",
          );
          if (header) {
            header.classList.toggle(
              "no-border",
              chat.settings.innerVoiceHideHeaderBorder,
            );
          }

          await showCustomAlert(
            "Êìç‰ΩúÊàêÂäü",
            `ÂàÜÂâ≤Á∫øÂ∑≤${chat.settings.innerVoiceHideHeaderBorder ? "ÈöêËóè" : "ÊòæÁ§∫"}„ÄÇ`,
          );
        }

        /**
         * ‰øÆÊîπ‚ÄúÈ¢ÜÂÖª‰∫∫‚ÄùÁöÑÊ†áÁ≠æÊ®°Êùø
         */
        async function editInnerVoiceAdopterName() {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          // Ëé∑ÂèñÂΩìÂâçÁöÑÊ†áÁ≠æÊ®°ÊùøÔºåÂ¶ÇÊûúÊ≤°ÊúâËÆæÁΩÆËøáÔºåÂ∞±‰ΩøÁî®ÈªòËÆ§ÂÄº
          const currentFormat =
            chat.settings.innerVoiceAdopterLabelFormat || "È¢ÜÂÖª‰∫∫: {{user}}";

          // ÂºπÂá∫ËæìÂÖ•Ê°ÜÔºåËÆ©Áî®Êà∑ÁºñËæëÊï¥‰∏™Ê®°ÊùøÂ≠óÁ¨¶‰∏≤
          const newFormat = await showCustomPrompt(
            "‰øÆÊîπÈ¢ÜÂÖª‰∫∫Ê†áÁ≠æ",
            "‰Ω†ÂèØ‰ª•‰øÆÊîπÊï¥‰∏™Ê†áÁ≠æÔºåÂÖ∂‰∏≠ {{user}} ‰ºöË¢´Ëá™Âä®ÊõøÊç¢‰∏∫‰Ω†ÁöÑÊòµÁß∞„ÄÇ",
            currentFormat,
          );

          // Â¶ÇÊûúÁî®Êà∑ËæìÂÖ•‰∫ÜÊñ∞ÂÜÖÂÆπÔºà‰∏çÊòØÂèñÊ∂àÔºâ
          if (newFormat !== null) {
            // ‰øùÂ≠òÊñ∞Ê®°ÊùøÔºåÂ¶ÇÊûúËæìÂÖ•‰∏∫Á©∫ÂàôÊÅ¢Â§çÈªòËÆ§
            chat.settings.innerVoiceAdopterLabelFormat =
              newFormat.trim() || "È¢ÜÂÖª‰∫∫: {{user}}";
            await db.chats.put(chat);

            // ÈáçÊñ∞Ê∏≤ÊüìÂøÉÂ£∞Èù¢Êùø‰ª•ÊòæÁ§∫Êñ∞Ê†áÁ≠æ
            openInnerVoiceModal();
            await showCustomAlert("‰øÆÊîπÊàêÂäü", "È¢ÜÂÖª‰∫∫Ê†áÁ≠æÂ∑≤Êõ¥Êñ∞ÔºÅ");
          }
        }

        /* ‚ñº‚ñº‚ñº ÂøÉÂ£∞Èù¢ÊùøÊ†∑ÂºèÁºñËæëÂäüËÉΩÁöÑÊ†∏ÂøÉÂáΩÊï∞ ‚ñº‚ñº‚ñº */

        /**
         * Â∞ÜÂçÅÂÖ≠ËøõÂà∂È¢úËâ≤(#FFFFFF)ËΩ¨Êç¢‰∏∫ "R, G, B" Â≠óÁ¨¶‰∏≤ (255, 255, 255)
         * @param {string} hex - ÂçÅÂÖ≠ËøõÂà∂È¢úËâ≤‰ª£Á†Å
         * @returns {string} - RGBÂ≠óÁ¨¶‰∏≤
         */
        function hexToRgb(hex) {
          if (!hex || hex.length < 4) return "255, 255, 255";
          let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}`
            : "255, 255, 255";
        }

        /**
         * Â∞Ü‰øùÂ≠òÁöÑÊ†∑ÂºèÂ∫îÁî®Âà∞ÂøÉÂ£∞Èù¢Êùø
         */
        function applySavedInnerVoiceStyles() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.settings.innerVoiceStyles) return;

          const styles = chat.settings.innerVoiceStyles;
          const panel = document.getElementById("inner-voice-main-panel");

          panel.style.setProperty("--iv-color-clothing", styles.clothingColor);
          panel.style.setProperty("--iv-color-behavior", styles.behaviorColor);
          panel.style.setProperty("--iv-color-thoughts", styles.thoughtsColor);
          panel.style.setProperty("--iv-color-naughty", styles.naughtyColor);
          panel.style.setProperty(
            "--iv-card-bg-rgb",
            hexToRgb(styles.cardBgColor),
          );
          panel.style.setProperty("--iv-card-opacity", styles.cardOpacity);

          // Â∫îÁî®‰øùÂ≠òÁöÑÂõæÊ†áÈ¢úËâ≤
          panel.style.setProperty(
            "--iv-icon-color",
            styles.iconColor || "#ff8a80",
          );
        }

        /**
         * ÊâìÂºÄÂøÉÂ£∞Èù¢ÊùøÊ†∑ÂºèÁºñËæëÂô®
         */
        function openInnerVoiceStyleEditor() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.settings.innerVoiceStyles) return;

          document
            .getElementById("inner-voice-edit-options-modal")
            ?.classList.remove("visible");

          const styles = chat.settings.innerVoiceStyles;
          // === „Äê‰øÆÂ§çÈáçÁÇπ„ÄëÔºöÂÆâÂÖ®Ëé∑ÂèñÊ†áÁ≠æÈÖçÁΩÆ ===
          const tags = chat.settings.innerVoiceTags || {};
          const modal = document.getElementById("inner-voice-editor-modal");

          // Âä†ËΩΩÊ†áÁ≠æÂêçÂíåÊåá‰ª§ÔºàÂ¶ÇÊûú‰∏∫Á©∫ÂàôÊòæÁ§∫ÈªòËÆ§ÂÄºÔºâ
          document.getElementById("iv-label-clothing").value =
            tags.clothing_label || "Clothing";
          document.getElementById("iv-prompt-clothing").value =
            tags.clothing_prompt || "Describe in detail your current outfit from head to toe.";

          document.getElementById("iv-label-behavior").value =
            tags.behavior_label || "Behavior";
          document.getElementById("iv-prompt-behavior").value =
            tags.behavior_prompt || "Describe subtle actions or facial expressions that match the current chat situation.";

          document.getElementById("iv-label-thoughts").value =
            tags.thoughts_label || "Thoughts";
          document.getElementById("iv-prompt-thoughts").value =
            tags.thoughts_prompt ||
            "Describe your current rich and delicate inner thoughts (around 50 words).";

          document.getElementById("iv-label-naughty").value =
            tags.naughty_label || "Naughty";
          document.getElementById("iv-prompt-naughty").value =
            tags.naughty_prompt ||
            "Describe your current mischievous or naughty thoughts related to the situation, must align with the character.";

          // Âä†ËΩΩÂΩìÂâçÊ†∑ÂºèÂà∞ÁºñËæëÂô®
          document.getElementById("iv-color-clothing").value =
            styles.clothingColor;
          document.getElementById("iv-color-behavior").value =
            styles.behaviorColor;
          document.getElementById("iv-color-thoughts").value =
            styles.thoughtsColor;
          document.getElementById("iv-color-naughty").value =
            styles.naughtyColor;
          document.getElementById("iv-card-bg-color").value =
            styles.cardBgColor;
          document.getElementById("iv-opacity-slider").value =
            styles.cardOpacity;
          document.getElementById("iv-opacity-value").textContent =
            `${Math.round(styles.cardOpacity * 100)}%`;

          // Âä†ËΩΩ‰øùÂ≠òÁöÑÂõæÊ†áÈ¢úËâ≤
          document.getElementById("iv-icon-color").value =
            styles.iconColor || "#ff8a80";

          modal.classList.add("visible");
        }

        /**
         * ‰øùÂ≠òÁî®Êà∑‰øÆÊîπÁöÑÊ†∑Âºè„ÄÅÊ†áÁ≠æÂíåÊåá‰ª§
         */
        async function saveInnerVoiceStyles() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];

          // 1. ‰øùÂ≠òÊ†∑Âºè (‰øùÊåÅ‰∏çÂèò)
          const newStyles = {
            clothingColor: document.getElementById("iv-color-clothing").value,
            behaviorColor: document.getElementById("iv-color-behavior").value,
            thoughtsColor: document.getElementById("iv-color-thoughts").value,
            naughtyColor: document.getElementById("iv-color-naughty").value,
            cardBgColor: document.getElementById("iv-card-bg-color").value,
            cardOpacity: parseFloat(
              document.getElementById("iv-opacity-slider").value,
            ),
            iconColor: document.getElementById("iv-icon-color").value,
          };

          // 2. ‰øùÂ≠òÊ†áÁ≠æÂêçÂíåÊåá‰ª§ (Êñ∞Â¢û)
          // Â¶ÇÊûúÁî®Êà∑ÁïôÁ©∫ÔºåÂ∞±‰ΩøÁî®ÈªòËÆ§ÂÄºÂÖúÂ∫ï
          const newTags = {
            clothing_label:
              document.getElementById("iv-label-clothing").value.trim() ||
              "Clothing",
            clothing_prompt:
              document.getElementById("iv-prompt-clothing").value.trim() ||
              "Describe in detail your current outfit from head to toe.",

            behavior_label:
              document.getElementById("iv-label-behavior").value.trim() ||
              "Behavior",
            behavior_prompt:
              document.getElementById("iv-prompt-behavior").value.trim() ||
              "Describe subtle actions or facial expressions that match the current chat situation.",

            thoughts_label:
              document.getElementById("iv-label-thoughts").value.trim() ||
              "Inner Thoughts",
            thoughts_prompt:
              document.getElementById("iv-prompt-thoughts").value.trim() ||
              "Describe your rich and nuanced genuine inner thoughts at this moment (around 50 words).",

            naughty_label:
              document.getElementById("iv-label-naughty").value.trim() ||
              "Mischievous Thoughts",
            naughty_prompt:
              document.getElementById("iv-prompt-naughty").value.trim() ||
              "Describe any slightly dark or teasing thoughts related to the current situation, staying consistent with the character setting.",
          };

          // Êõ¥Êñ∞Âà∞stateÂíåÊï∞ÊçÆÂ∫ì
          chat.settings.innerVoiceStyles = newStyles;
          chat.settings.innerVoiceTags = newTags;

          await db.chats.put(chat);

          // ÂÖ≥Èó≠ÂºπÁ™ó
          document
            .getElementById("inner-voice-editor-modal")
            .classList.remove("visible");

          // ÈáçÊñ∞Â∫îÁî®Ê†∑Âºè
          applySavedInnerVoiceStyles();

          // Â¶ÇÊûúÈù¢ÊùøÂºÄÁùÄÔºåÈáçÊñ∞ÊâìÂºÄ‰∏Ä‰∏ã‰ª•Âà∑Êñ∞Ê†áÁ≠æÊñáÂ≠ó
          if (
            document
              .getElementById("inner-voice-modal")
              .classList.contains("visible")
          ) {
            openInnerVoiceModal();
          }

          await showCustomAlert(
            "‰øùÂ≠òÊàêÂäü",
            "ÂøÉÂ£∞ÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞ÔºÅ\nAIÂ∞ÜÂú®‰∏ãÊ¨°ÂõûÂ§çÊó∂ÈÅµÂæ™‰Ω†ÁöÑÊñ∞Êåá‰ª§„ÄÇ",
          );
        }

        /**
         * ÊâìÂºÄAIÁîüÊàêÁæ§ÊàêÂëòÁöÑÊ®°ÊÄÅÊ°Ü
         */
        function openAiGenerateMembersModal() {
          // Ê∏ÖÁ©∫‰∏äÊ¨°ÁöÑËæìÂÖ•
          document.getElementById("ai-member-count-input").value = "3";
          document.getElementById("ai-member-prompt-input").value = "";
          // ÊòæÁ§∫ÂºπÁ™ó
          document
            .getElementById("ai-generate-members-modal")
            .classList.add("visible");
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑ÁÇπÂáª‚ÄúÂºÄÂßãÁîüÊàê‚ÄùÊåâÈíÆÁöÑÈÄªËæë
         */
        async function handleGenerateMembers() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          if (!chat || !chat.isGroup) return;

          const count = parseInt(
            document.getElementById("ai-member-count-input").value,
          );
          const requirements = document
            .getElementById("ai-member-prompt-input")
            .value.trim();

          if (isNaN(count) || count < 1 || count > 20) {
            alert("ËØ∑ËæìÂÖ•1Âà∞20‰πãÈó¥ÁöÑÊúâÊïà‰∫∫Êï∞ÔºÅ");
            return;
          }

          document
            .getElementById("ai-generate-members-modal")
            .classList.remove("visible");
          await showCustomAlert(
            "Please wait...",
            `AIÊ≠£Âú®‰∏∫‚Äú${chat.name}‚ÄùÂàõÈÄ† ${count} ‰ΩçÊñ∞ÊúãÂèã...`,
          );

          const systemPrompt = `
			**„ÄêLANGUAGE RULE - HIGHEST PRIORITY„Äë: You MUST reply in Vietnamese (Ti·∫øng Vi·ªát) for ALL messages. Never use Chinese or any other language.**

			# ‰ªªÂä°
			‰Ω†ÊòØ‰∏Ä‰∏™Áæ§ËÅäÊàêÂëòÁîüÊàêÂô®„ÄÇËØ∑Ê†πÊçÆÁî®Êà∑ÁöÑË¶ÅÊ±ÇÔºå‰∏∫Áæ§ËÅä"${chat.name}"ÂàõÂª∫${count}‰∏™Êñ∞ÊàêÂëò„ÄÇ

			# Áî®Êà∑Ë¶ÅÊ±Ç:
			${requirements || "Êó†ÁâπÊÆäË¶ÅÊ±ÇÔºåËØ∑Ëá™Áî±ÂèëÊå•„ÄÇ"}

			# Ê†∏ÂøÉËßÑÂàô
			1.  ‰Ω†ÁîüÊàêÁöÑÊØè‰∏™ÊàêÂëòÈÉΩÂøÖÈ°ªÊúâÁã¨ÁâπÁöÑÂêçÂ≠ó(name)ÂíåÈ≤úÊòéÁöÑÊÄßÊ†º‰∫∫ËÆæ(persona)„ÄÇ
			2.  ‰∫∫ËÆæÊèèËø∞Ë¶ÅÁîüÂä®„ÄÅÂÖ∑‰ΩìÔºåËÉΩ‰ΩìÁé∞Âá∫ËßíËâ≤ÁöÑÁâπÁÇπ„ÄÇ
			3.  „ÄêÊ†ºÂºèÈìÅÂæã„Äë: ‰Ω†ÁöÑÂõûÂ§ç„ÄêÂøÖÈ°ª‰∏îÂè™ËÉΩ„ÄëÊòØ‰∏Ä‰∏™‰∏•Ê†ºÁöÑJSONÊï∞ÁªÑÔºåÁõ¥Êé•‰ª•'['ÂºÄÂ§¥, ‰ª•']'ÁªìÂ∞æ„ÄÇÊï∞ÁªÑ‰∏≠ÁöÑÊØè‰∏™ÂÖÉÁ¥†ÈÉΩÊòØ‰∏Ä‰∏™‰ª£Ë°®ÊàêÂëòÁöÑJSONÂØπË±°„ÄÇ

			# JSONËæìÂá∫Ê†ºÂºèÁ§∫‰æã:
			[
			  {
			    "name": "ÊûóÈ£é",
			    "persona": "‰∏Ä‰∏™Èò≥ÂÖâÂºÄÊúóÁöÑËøêÂä®Á≥ªÂ∞ëÂπ¥ÔºåÁÉ≠Áà±ÁØÆÁêÉÔºåÊÄßÊ†ºÁõ¥ÁàΩÔºåÊòØÂõ¢ÈòüÈáåÁöÑÊ∞îÊ∞õÊãÖÂΩì„ÄÇ"
			  },
			  {
			    "name": "ÈôàÈõ™",
			    "persona": "ÊñáÈùôÂÜÖÂêëÁöÑÂ≠¶Èú∏Â∞ëÂ•≥ÔºåÂñúÊ¨¢ËØª‰π¶ÂíåÁîªÁîªÔºåÂøÉÊÄùÁªÜËÖªÔºå‰∏çÂñÑË®ÄËæû‰ΩÜËßÇÂØüÂäõÊïèÈîê„ÄÇ"
			  }
			]
			`;

          try {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            let isGemini = proxyUrl === GEMINI_API_URL;
            let messagesForApi = [{ role: "user", content: systemPrompt }];
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesForApi,
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 1.0,
                  }),
                });

            if (!response.ok)
              throw new Error(
                `APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} - ${await response.text()}`,
              );

            const data = await response.json();
            const rawContent = (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            )
              .replace(/^```json\s*|```$/g, "")
              .trim();
            const newMembersData = JSON.parse(rawContent);

            if (Array.isArray(newMembersData) && newMembersData.length > 0) {
              const addedNames = [];
              newMembersData.forEach((memberData, index) => {
                if (memberData.name && memberData.persona) {
                  const newMember = {
                    id: "npc_" + (Date.now() + index),
                    originalName: memberData.name.trim(),
                    groupNickname: memberData.name.trim(),
                    avatar: defaultGroupMemberAvatar,
                    persona: memberData.persona.trim(),
                    avatarFrame: "",
                    isAdmin: false,
                    groupTitle: "",
                  };
                  chat.members.push(newMember);
                  addedNames.push(`‚Äú${newMember.groupNickname}‚Äù`);
                }
              });

              if (addedNames.length > 0) {
                await db.chats.put(chat);
                await logSystemMessage(
                  chat.id,
                  `ÈÇÄËØ∑‰∫Ü ${addedNames.length} ‰ΩçÊñ∞ÊàêÂëò: ${addedNames.join("„ÄÅ")}Âä†ÂÖ•‰∫ÜÁæ§ËÅä„ÄÇ`,
                );
                await showCustomAlert(
                  "ÁîüÊàêÊàêÂäüÔºÅ",
                  `${addedNames.length} ‰ΩçÊñ∞ÊàêÂëòÂ∑≤Âä†ÂÖ•Áæ§ËÅäÔºÅ`,
                );
                renderMemberManagementList(); // Âà∑Êñ∞ÊàêÂëòÁÆ°ÁêÜÂàóË°®
              } else {
                throw new Error(
                  "AIËøîÂõûÁöÑÊï∞ÊçÆÊ†ºÂºè‰∏çÊ≠£Á°ÆÔºåÁº∫Â∞ënameÊàñpersonaÂ≠óÊÆµ„ÄÇ",
                );
              }
            } else {
              throw new Error("AIËøîÂõûÁöÑÊï∞ÊçÆ‰∏çÊòØÊúâÊïàÁöÑÊï∞ÁªÑ„ÄÇ");
            }
          } catch (error) {
            console.error("AIÁîüÊàêÁæ§ÊàêÂëòÂ§±Ë¥•:", error);
            await showCustomAlert(
              "ÁîüÊàêÂ§±Ë¥•",
              `ÂèëÁîü‰∫Ü‰∏Ä‰∏™ÈîôËØØÔºö\n${error.message}`,
            );
          }
        }

        async function renderStickerCategories() {
          const tabsContainer = document.getElementById(
            "sticker-category-tabs",
          );
          if (!tabsContainer) return;

          tabsContainer.innerHTML = ""; // Ê∏ÖÁ©∫ÊóßÁöÑÊ†áÁ≠æ
          const categories = await db.userStickerCategories
            .orderBy("name")
            .toArray();
          userStickerCategories = categories; // Êõ¥Êñ∞ÂÖ®Â±ÄÁºìÂ≠ò

          // 1. Ê∏≤Êüì‚ÄúÊú™ÂàÜÁ±ª‚ÄùÊåâÈíÆÔºàËøô‰∏™ÊåâÈíÆÊ≤°ÊúâÂà†Èô§ÂäüËÉΩÔºâ
          const uncategorizedBtn = document.createElement("button");
          uncategorizedBtn.className = "sticker-category-btn";
          uncategorizedBtn.textContent = "Êú™ÂàÜÁ±ª";
          uncategorizedBtn.dataset.categoryId = "uncategorized";
          if (activeStickerCategoryId === "uncategorized") {
            uncategorizedBtn.classList.add("active");
          }
          tabsContainer.appendChild(uncategorizedBtn);

          // 2. Ê∏≤ÊüìÊâÄÊúâËá™ÂÆö‰πâÂàÜÁ±ª
          for (const category of categories) {
            const btn = document.createElement("button");
            btn.className = "sticker-category-btn";
            // Â∞ÜIDÂíåÂêçÁß∞ÈÉΩÂ≠òÂÇ®Âú®Áà∂ÊåâÈíÆ‰∏äÔºåÊñπ‰æø‰∫ã‰ª∂ÂßîÊâòËé∑Âèñ
            btn.dataset.categoryId = category.id;
            btn.dataset.categoryName = category.name;

            const nameSpan = document.createElement("span");
            nameSpan.textContent = category.name;
            btn.appendChild(nameSpan);

            // Â¶ÇÊûúÊòØÂΩìÂâçÊøÄÊ¥ªÁöÑÂàÜÁ±ªÔºåÊ∑ªÂä†È´ò‰∫Æ
            if (activeStickerCategoryId === category.id) {
              btn.classList.add("active");
            }

            // Âè™Âú®ÁºñËæëÊ®°Âºè‰∏ãÔºåÊâçÂàõÂª∫ÂíåÊ∑ªÂä†Âà†Èô§ÊåâÈíÆ
            if (isUserStickerSelectionMode) {
              const deleteBtn = document.createElement("span");
              deleteBtn.className = "sticker-category-delete-btn";
              deleteBtn.textContent = "√ó";
              deleteBtn.title = `Âà†Èô§ÂàÜÁ±ª "${category.name}"`; // Â¢ûÂä†ÊÇ¨ÊµÆÊèêÁ§∫
              btn.appendChild(deleteBtn);
            }

            tabsContainer.appendChild(btn);
          }
        }

        /**
         * ÊâìÂºÄÁßªÂä®Ë°®ÊÉÖÂà∞ÂàÜÁ±ªÁöÑÊ®°ÊÄÅÊ°Ü
         */
        async function openStickerCategoryModal() {
          if (selectedUserStickers.size === 0) {
            alert("ËØ∑ÂÖàÈÄâÊã©Ë¶ÅÁßªÂä®ÁöÑË°®ÊÉÖÂåÖÔºÅ");
            return;
          }

          const modal = document.getElementById("sticker-category-modal");
          const listEl = document.getElementById("sticker-category-list");
          const inputEl = document.getElementById("new-sticker-category-input");
          listEl.innerHTML = "";
          inputEl.value = "";

          const categories = await db.userStickerCategories.toArray();
          if (categories.length > 0) {
            categories.forEach((cat) => {
              const label = document.createElement("label");
              label.innerHTML = `<input type="radio" name="sticker_category_select" value="${cat.id}"> ${cat.name}`;
              listEl.appendChild(label);
            });
          } else {
            listEl.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary);">ËøòÊ≤°Êúâ‰ªª‰ΩïÂàÜÁ±ª„ÄÇ</p>';
          }

          modal.classList.add("visible");
        }

        /**
         * Â§ÑÁêÜ‚ÄúÁ°ÆËÆ§ÁßªÂä®‚ÄùÊåâÈíÆÁöÑÁÇπÂáªÈÄªËæë
         */
        async function handleMoveStickers() {
          const newCategoryName = document
            .getElementById("new-sticker-category-input")
            .value.trim();
          const selectedRadio = document.querySelector(
            'input[name="sticker_category_select"]:checked',
          );

          let targetCategoryId = null;

          if (newCategoryName) {
            try {
              // Ê£ÄÊü•ÂàÜÁ±ªÊòØÂê¶Â∑≤Â≠òÂú®
              let existingCategory = await db.userStickerCategories
                .where("name")
                .equalsIgnoreCase(newCategoryName)
                .first();
              if (existingCategory) {
                targetCategoryId = existingCategory.id;
              } else {
                targetCategoryId = await db.userStickerCategories.add({
                  name: newCategoryName,
                });
              }
            } catch (error) {
              alert("ÂàõÂª∫Êñ∞ÂàÜÁ±ªÂ§±Ë¥•ÔºåÂèØËÉΩÊòØÂêçÁß∞ÈáçÂ§çÊàñÊï∞ÊçÆÂ∫ìÈîôËØØ„ÄÇ");
              return;
            }
          } else if (selectedRadio) {
            targetCategoryId = parseInt(selectedRadio.value);
          } else {
            alert("ËØ∑ÈÄâÊã©‰∏Ä‰∏™ÂàÜÁ±ªÊàñÂàõÂª∫‰∏Ä‰∏™Êñ∞ÂàÜÁ±ªÔºÅ");
            return;
          }

          try {
            const stickerIdsToMove = Array.from(selectedUserStickers);
            const stickers = await db.userStickers.bulkGet(stickerIdsToMove);

            stickers.forEach((sticker) => {
              if (sticker) {
                sticker.categoryId = targetCategoryId;
              }
            });

            await db.userStickers.bulkPut(stickers);

            // Êõ¥Êñ∞ÂÜÖÂ≠ò‰∏≠ÁöÑ state.userStickers
            stickers.forEach((updatedSticker) => {
              const index = state.userStickers.findIndex(
                (s) => s.id === updatedSticker.id,
              );
              if (index > -1) {
                state.userStickers[index].categoryId = targetCategoryId;
              }
            });

            document
              .getElementById("sticker-category-modal")
              .classList.remove("visible");
            exitUserStickerSelectionMode(); // ÈÄÄÂá∫ÁºñËæëÊ®°Âºè
            alert(`ÊàêÂäüÁßªÂä® ${stickerIdsToMove.length} ‰∏™Ë°®ÊÉÖÔºÅ`);
          } catch (error) {
            console.error("ÁßªÂä®Ë°®ÊÉÖÂ§±Ë¥•:", error);
            alert("ÁßªÂä®Ë°®ÊÉÖÊó∂ÂèëÁîüÈîôËØØ„ÄÇ");
          }
        }

        // ËßÜÈ¢ëÈÄöËØùÊéßÂà∂ÊåâÈíÆÁöÑ‰∫ã‰ª∂ÂßîÊâò
        // Ëøô‰∏™ÂáΩÊï∞Áî®‰∫éÁªü‰∏ÄÂ§ÑÁêÜÊâÄÊúâÈÄöËØùÊéßÂà∂ÊåâÈíÆÁöÑÁÇπÂáª
        function handleCallControls(event) {
          // ÊâæÂà∞Ë¢´ÁÇπÂáªÁöÑÈÇ£‰∏™ÊåâÈíÆÂÖÉÁ¥†
          const button = event.target.closest(".control-btn");
          if (!button) return; // Â¶ÇÊûúÁÇπÂáªÁöÑ‰∏çÊòØÊåâÈíÆÔºåÂ∞±‰ªÄ‰πà‰πü‰∏çÂÅö

          // Ê†πÊçÆÊåâÈíÆÁöÑIDÊù•ÊâßË°å‰∏çÂêåÁöÑÊìç‰Ωú
          switch (button.id) {
            case "user-speak-btn":
            case "user-speak-btn-visual":
              // ËøôÈáåË∞ÉÁî®‰Ω†ÂéüÊú¨Â§ÑÁêÜ‚ÄúÁî®Êà∑ÂèëË®Ä‚ÄùÁöÑÂáΩÊï∞
              handleUserSpeakInCall(); // ÂÅáËÆæ‰Ω†ÁöÑÂáΩÊï∞ÂêçÂè´Ëøô‰∏™
              break;
            case "hang-up-btn":
            case "hang-up-btn-visual":
              // Ë∞ÉÁî®‰Ω†ÂéüÊú¨Â§ÑÁêÜ‚ÄúÊåÇÊñ≠‚ÄùÁöÑÂáΩÊï∞
              endVideoCall();
              break;
            case "join-call-btn":
              // Ë∞ÉÁî®‰Ω†ÂéüÊú¨Â§ÑÁêÜ‚ÄúÂä†ÂÖ•ÈÄöËØù‚ÄùÁöÑÂáΩÊï∞
              handleUserJoinCall();
              break;
            case "reroll-call-btn":
            case "reroll-call-btn-text":
              // Ë∞ÉÁî®‰Ω†ÂéüÊú¨Â§ÑÁêÜ‚ÄúÈáçroll‚ÄùÁöÑÂáΩÊï∞
              handleVideoCallReroll();
              break;
            case "flip-real-camera-btn":
              handleCameraFlip();
              break;
            case "switch-camera-btn":
              // Ë∞ÉÁî®‰Ω†ÂéüÊú¨Â§ÑÁêÜ‚ÄúÂàáÊç¢ÈïúÂ§¥‚ÄùÁöÑÂáΩÊï∞
              switchVideoViews();
              break;
          }
        }

        // Âú®init()ÂáΩÊï∞‰∏≠Ôºå‰∏∫‰∏§‰∏™ÊéßÂà∂Ê†èÂÆπÂô®ÁªëÂÆö‰∫ã‰ª∂
        // Ê≥®ÊÑèÔºöÂõ†‰∏∫‰Ω†ÁöÑHTML‰∏≠Êúâ‰∏§‰∏™ controls divÔºåÊâÄ‰ª•Êàë‰ª¨ÈúÄË¶ÅÂàÜÂà´ÁªëÂÆö
        const textModeControls = document.querySelector(
          "#text-call-interface .video-call-controls",
        );
        if (textModeControls) {
          textModeControls.addEventListener("click", handleCallControls);
        }

        const visualModeControls = document.querySelector(
          "#visual-call-interface .video-call-controls",
        );
        if (visualModeControls) {
          visualModeControls.addEventListener("click", handleCallControls);
        }

        /**
         * Â§ÑÁêÜÁî®Êà∑Âú®ÈÄöËØù‰∏≠ÁÇπÂáª‚ÄúÂèëË®Ä‚ÄùÊåâÈíÆÁöÑÈÄªËæë
         */
        async function handleUserSpeakInCall() {
          // ÂÆâÂÖ®Ê£ÄÊü•ÔºåÂ¶ÇÊûúÈÄöËØùÊú™ÊøÄÊ¥ªÂàô‰∏çÊâßË°å
          if (!videoCallState.isActive) return;

          // ÊâæÂà∞Áî®Êà∑Â§¥ÂÉèÂπ∂Ê∑ªÂä†‚ÄúÊ≠£Âú®ÂèëË®Ä‚ÄùÁöÑÈ´ò‰∫ÆÊïàÊûúÔºåÊèêÂçá‰∫§‰∫íÊÑü
          const userAvatar = document.querySelector(
            '.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar',
          );
          if (userAvatar) {
            userAvatar.classList.add("speaking");
          }

          // ÂºπÂá∫‰Ω†Â∑≤ÁªèÂÜôÂ•ΩÁöÑËá™ÂÆö‰πâËæìÂÖ•Ê°Ü
          const userInput = await showCustomPrompt(
            "‰Ω†ËØ¥",
            "ËØ∑ËæìÂÖ•‰Ω†ÊÉ≥ËØ¥ÁöÑËØù...",
          );

          // Êó†ËÆ∫Áî®Êà∑ÊòØÂê¶ËæìÂÖ•ÔºåÂè™Ë¶ÅËæìÂÖ•Ê°ÜÂÖ≥Èó≠ÔºåÂ∞±Á´ãÂàªÁßªÈô§Â§¥ÂÉèÁöÑÈ´ò‰∫ÆÊïàÊûú
          if (userAvatar) {
            userAvatar.classList.remove("speaking");
          }

          // Â¶ÇÊûúÁî®Êà∑Á°ÆÂÆûËæìÂÖ•‰∫ÜÂÜÖÂÆπÔºåÂ∞±Ë∞ÉÁî®‰Ω†Â∑≤ÊúâÁöÑÂáΩÊï∞Êù•Ëß¶ÂèëAIÂìçÂ∫î
          if (userInput && userInput.trim()) {
            triggerAiInCallAction(userInput.trim());
          }
        }

        /**
         * ÂàùÂßãÂåñÈªòËÆ§ÁöÑÂ∞èÁªÑ
         */
        async function initializeDefaultGroups() {
          const groupCount = await db.forumGroups.count();
          if (groupCount === 0) {
            const defaultGroups = [
              { name: "Â®±‰πêÂ∞èÁªÑ", description: "ÂàÜ‰∫´ÂÖ´Âç¶ÂíåÂø´‰πê", icon: "üçø" },
              { name: "ÁÅµÂºÇÂ∞èÁªÑ", description: "ÂàÜ‰∫´‰Ω†ÁöÑÁÅµÂºÇÁªèÂéÜ", icon: "üëª" },
              {
                name: "‰ªäÂ§©Êàëcrush‰∫ÜÂêó",
                description: "ËÆ∞ÂΩïÂøÉÂä®Áû¨Èó¥",
                icon: "üíñ",
              },
              {
                name: "ËØ∑Â∏ÆÊàëÈÄâÊã©Â∞èÁªÑ",
                description: "ÈÄâÊã©Âõ∞ÈöæÁóáÊÇ£ËÄÖ‰∫íÂä©",
                icon: "ü§î",
              },
              {
                name: "Âêå‰∫∫ÊñáÂ∞èÁªÑ",
                description: "‰∏∫Áà±ÂèëÁîµÔºåÂàõ‰ΩúÊïÖ‰∫ã",
                icon: "‚úçÔ∏è",
              },

              {
                name: "Ê¢¶ËßíÂ∞èÁªÑ",
                description: "Char‰ª¨ÂàÜ‰∫´ÂÖ≥‰∫éuserÁöÑÊ¢¶Â¢É",
                icon: "üåô",
              },
            ];
            await db.forumGroups.bulkAdd(defaultGroups);
            console.log("Â∑≤ÊàêÂäüÂàõÂª∫ÈªòËÆ§Â∞èÁªÑÔºàÂåÖÂê´Ê¢¶ËßíÂ∞èÁªÑÔºâ„ÄÇ");
          }
        }

        /**
         * ÊâìÂºÄÈ´òÁ∫ßÂØºÂÖ•ÂØºÂá∫Ê®°ÊÄÅÊ°ÜÔºåÂπ∂Âä®ÊÄÅÁîüÊàêÈÄâÈ°πÂàóË°®
         */
        async function openAdvancedTransferModal() {
          const appsListEl = document.getElementById("export-apps-list");
          const charactersListEl = document.getElementById(
            "export-characters-list",
          );
          appsListEl.innerHTML = "";
          charactersListEl.innerHTML = "";

          // 1. ÂÆö‰πâÂèØÁã¨Á´ãÂØºÂá∫ÁöÑAppÊï∞ÊçÆÂèäÂÖ∂ÂÖ≥ËÅîÁöÑÊï∞ÊçÆÂ∫ìË°®
          const appsToExport = [
            {
              id: "weibo",
              name: "Weibo (ÂÖ®ÈÉ®Â∏ñÂ≠ê/ËßíËâ≤ËµÑÊñô/Á≤â‰∏ùÊï∞Á≠â)",
              tables: ["weiboPosts", "qzoneSettings"],
            },
            {
              id: "forum",
              name: "Forum (Â∞èÁªÑ/Â∏ñÂ≠ê/ËØÑËÆ∫/ÂàÜÁ±ª/ËøûËΩΩ)",
              tables: [
                "forumGroups",
                "forumPosts",
                "forumComments",
                "forumCategories",
                "forumSeries",
                "forumChapters",
              ],
            },
            {
              id: "taobao",
              name: "Taobao (ÊâÄÊúâÂïÜÂìÅ/ËÆ¢Âçï/Shopping Cart/‰ΩôÈ¢ùËÆ∞ÂΩï)",
              tables: [
                "taobaoProducts",
                "taobaoOrders",
                "taobaoCart",
                "userWalletTransactions",
              ],
            },
            {
              id: "worldBooks",
              name: "World Book (ÂÖ®ÈÉ®‰π¶Á±çÂèäÂàÜÁ±ª)",
              tables: ["worldBooks", "worldBookCategories"],
            },

            {
              id: "dateALive",
              name: "Date-A-Live (Âú∫ÊôØ/È¢ÑËÆæ/Á´ãÁªò/ÂéÜÂè≤)",
              tables: [
                "datingScenes",
                "datingPresets",
                "datingSpriteGroups",
                "datingSprites",
                "datingHistory",
              ],
            },

            {
              id: "tukeyAccounting",
              name: "ÂÖîkËÆ∞Ë¥¶ (Ë¥¶Êà∑/Áæ§ËÅä/Ë¥¶Âçï/ËÆæÁΩÆ)",
              tables: [
                "tukeyAccounts",
                "tukeyAccountingGroups",
                "tukeyAccountingRecords",
                "tukeyAccountingReplies",
                "tukeyUserSettings",
                "tukeyCustomConfig",
              ],
            },

            {
              id: "studio",
              name: "Studio (ÊâÄÊúâÂâßÊú¨/ÊºîÁªéËÆ∞ÂΩï)",
              tables: ["studioScripts", "studioHistory"],
            },

            {
              id: "userStickers",
              name: "ÊàëÁöÑË°®ÊÉÖÂåÖ (ÂåÖÂê´ÂàÜÁ±ª)",
              tables: ["userStickers", "userStickerCategories"],
            },
            {
              id: "charStickers",
              name: "ËßíËâ≤ÈÄöÁî®Ë°®ÊÉÖÂåÖ",
              tables: ["charStickers"],
            },
            {
              id: "gameData",
              name: "Ê∏∏ÊàèÂ§ßÂéÖÊï∞ÊçÆ (ÂâßÊú¨ÊùÄ/È£ûË°åÊ£ãÈ¢òÂ∫ìÁ≠â)",
              tables: [
                "scriptKillScripts",
                "ludoQuestionBanks",
                "ludoQuestions",
              ],
            },
            {
              id: "appearance",
              name: "ÈÄöÁî®Â§ñËßÇÈ¢ÑËÆæ (‰∏ªÈ¢ò/Font/Â§¥ÂÉèÊ°ÜÁ≠â)",
              tables: [
                "themes",
                "fontPresets",
                "homeScreenPresets",
                "customAvatarFrames",
                "apiPresets",
                "bubbleStylePresets",
              ],
            },
          ];

          appsToExport.forEach((app) => {
            appsListEl.innerHTML += `
			            <label style="display: block; margin-bottom: 5px;">
			                <input type="checkbox" class="export-app-checkbox" value="${app.id}"> ${app.name}
			            </label>
			        `;
          });

          // 2. Âä†ËΩΩÊâÄÊúâÂçïËÅäËßíËâ≤
          const characters = Object.values(state.chats).filter(
            (chat) => !chat.isGroup,
          );
          if (characters.length === 0) {
            charactersListEl.innerHTML = "<p>Ê≤°ÊúâÂèØÂØºÂá∫ÁöÑËßíËâ≤</p>";
          } else {
            characters.forEach((char) => {
              charactersListEl.innerHTML += `
			                <label style="display: block; margin-bottom: 5px;">
			                    <input type="checkbox" class="export-char-checkbox" value="${char.id}"> ${char.name}
			                </label>
			            `;
            });
          }

          // ÈáçÁΩÆÂπ∂ÁªëÂÆöÂÖ®ÈÄâÊ°Ü
          const selectAllCheckbox = document.getElementById(
            "select-all-characters-checkbox",
          );
          selectAllCheckbox.checked = false;

          // ‰ΩøÁî®ÂÖãÈöÜËäÇÁÇπÊäÄÂ∑ßÔºåÈò≤Ê≠¢‰∫ã‰ª∂ÈáçÂ§çÁªëÂÆö
          const newSelectAllCheckbox = selectAllCheckbox.cloneNode(true);
          selectAllCheckbox.parentNode.replaceChild(
            newSelectAllCheckbox,
            selectAllCheckbox,
          );
          newSelectAllCheckbox.addEventListener("change", (e) => {
            document.querySelectorAll(".export-char-checkbox").forEach((cb) => {
              cb.checked = e.target.checked;
            });
          });

          // 3. ÊòæÁ§∫Ê®°ÊÄÅÊ°Ü
          document
            .getElementById("advanced-transfer-modal")
            .classList.add("visible");
        }

        /**
         * ÊâßË°åÂàÜÂùóÂØºÂá∫ (v3.0)
         */
        async function exportChunkedData() {
          await showCustomAlert("Please wait...", "Ê≠£Âú®ÊâìÂåÖÊÇ®ÈÄâÊã©ÁöÑÊï∞ÊçÆ...");

          const backupData = {
            type: "EPhoneChunkedBackup",
            version: 3,
            exportedAt: Date.now(),
            contains: [],
            data: {},
          };

          try {
            const appCheckboxes = document.querySelectorAll(
              ".export-app-checkbox:checked",
            );
            const charCheckboxes = document.querySelectorAll(
              ".export-char-checkbox:checked",
            );

            if (appCheckboxes.length === 0 && charCheckboxes.length === 0) {
              alert("ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏ÄÈ°πË¶ÅÂØºÂá∫ÁöÑÂÜÖÂÆπÔºÅ");
              hideCustomModal();
              return;
            }

            const appsToExportMap = {
              weibo: { tables: ["weiboPosts", "qzoneSettings"] },
              forum: {
                tables: [
                  "forumGroups",
                  "forumPosts",
                  "forumComments",
                  "forumCategories",
                  "forumSeries",
                  "forumChapters",
                ],
              },
              taobao: {
                tables: [
                  "taobaoProducts",
                  "taobaoOrders",
                  "taobaoCart",
                  "userWalletTransactions",
                ],
              },
              worldBooks: { tables: ["worldBooks", "worldBookCategories"] },

              dateALive: {
                tables: [
                  "datingScenes",
                  "datingPresets",
                  "datingSpriteGroups",
                  "datingSprites",
                  "datingHistory",
                ],
              },

              tukeyAccounting: {
                tables: [
                  "tukeyAccounts",
                  "tukeyAccountingGroups",
                  "tukeyAccountingRecords",
                  "tukeyAccountingReplies",
                  "tukeyUserSettings",
                  "tukeyCustomConfig",
                ],
              },

              studio: {
                tables: ["studioScripts", "studioHistory"],
              },

              userStickers: {
                tables: ["userStickers", "userStickerCategories"],
              },
              charStickers: { tables: ["charStickers"] },
              gameData: {
                tables: [
                  "scriptKillScripts",
                  "ludoQuestionBanks",
                  "ludoQuestions",
                ],
              },
              appearance: {
                tables: [
                  "themes",
                  "fontPresets",
                  "homeScreenPresets",
                  "customAvatarFrames",
                  "apiPresets",
                  "bubbleStylePresets",
                ],
              },
            };

            // 1. ÂØºÂá∫ÈÄâ‰∏≠ÁöÑAppÊï∞ÊçÆ
            for (const checkbox of appCheckboxes) {
              const appId = checkbox.value;
              const appInfo = appsToExportMap[appId];
              if (appInfo) {
                backupData.contains.push(appId);
                for (const tableName of appInfo.tables) {
                  backupData.data[tableName] = await db[tableName].toArray();
                  console.log(`Â∑≤ÊâìÂåÖAppÊï∞ÊçÆË°®: ${tableName}`);
                }
              }
            }

            // 2. ÂØºÂá∫ÈÄâ‰∏≠ÁöÑËßíËâ≤Êï∞ÊçÆ
            const charIds = Array.from(charCheckboxes).map((cb) => cb.value);
            if (charIds.length > 0) {
              backupData.data.chats = await db.chats.bulkGet(charIds);
              backupData.contains.push(
                ...charIds.map((id) => `character_${id}`),
              );

              // ÊâìÂåÖÊâÄÊúâ‰∏éËøô‰∫õËßíËâ≤ÂÖ≥ËÅîÁöÑÊï∞ÊçÆ
              const relatedDataTables = [
                "memories",
                "callRecords",
                "qzonePosts",
                "weiboPosts",
                "datingHistory",
                "pomodoroSessions",
              ];
              const relatedKey = {
                memories: "chatId",
                callRecords: "chatId",
                qzonePosts: "authorId",
                weiboPosts: "authorId",
                datingHistory: "characterId",
                pomodoroSessions: "chatId",
              };

              for (const tableName of relatedDataTables) {
                const items = await db[tableName]
                  .where(relatedKey[tableName])
                  .anyOf(charIds)
                  .toArray();
                if (items.length > 0) {
                  if (!backupData.data[tableName])
                    backupData.data[tableName] = [];
                  // ‰ΩøÁî®SetÂéªÈáçÔºåÈò≤Ê≠¢Âõ†Â§öËßíËâ≤ÂÖ≥ËÅîÂêå‰∏ÄÊï∞ÊçÆËÄåÈáçÂ§çÊâìÂåÖ
                  const existingIds = new Set(
                    backupData.data[tableName].map((i) => i.id),
                  );
                  items.forEach((item) => {
                    if (!existingIds.has(item.id)) {
                      backupData.data[tableName].push(item);
                      existingIds.add(item.id);
                    }
                  });
                }
              }
              console.log(`Â∑≤ÊâìÂåÖ ${charIds.length} ‰∏™ËßíËâ≤ÁöÑÊ†∏ÂøÉÂèäÂÖ≥ËÅîÊï∞ÊçÆ„ÄÇ`);
            }

            // 3. ÂàõÂª∫JSONÊñá‰ª∂Âπ∂Ëß¶Âèë‰∏ãËΩΩ
            const blob = new Blob([JSON.stringify(backupData, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `EPhone-Partial-Backup-${new Date().toISOString().split("T")[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            await showCustomAlert("ÂØºÂá∫ÊàêÂäü", "Â∑≤ÊàêÂäüÂØºÂá∫ÊÇ®ÈÄâ‰∏≠ÁöÑÊï∞ÊçÆÔºÅ");
          } catch (error) {
            console.error("ÂàÜÂùóÂØºÂá∫Â§±Ë¥•:", error);
            await showCustomAlert("ÂØºÂá∫Â§±Ë¥•", `ÂèëÁîüÈîôËØØ: ${error.message}`);
          } finally {
            document
              .getElementById("advanced-transfer-modal")
              .classList.remove("visible");
          }
        }

        /**
         * ÊâßË°åË°•ÂÖÖÂºèÂØºÂÖ•
         * @param {File} file - Áî®Êà∑ÈÄâÊã©ÁöÑJSONÊñá‰ª∂
         */
        async function importChunkedData(file) {
          if (!file) return;

          let data;
          try {
            const text = await file.text();
            data = JSON.parse(text);
          } catch (error) {
            await showCustomAlert(
              "ÂØºÂÖ•Â§±Ë¥•",
              "Êñá‰ª∂ËØªÂèñÊàñËß£ÊûêÂ§±Ë¥•ÔºåËØ∑Á°Æ‰øùÊñá‰ª∂ÊòØÊúâÊïàÁöÑJSONÊ†ºÂºè„ÄÇ",
            );
            return;
          }

          if (data.type !== "EPhoneChunkedBackup") {
            const confirmed = await showCustomConfirm(
              "Êñá‰ª∂Á±ªÂûã‰∏çÂåπÈÖç",
              "ËøôÊòØ‰∏Ä‰∏™„ÄêÂÖ®ÈáèÂ§á‰ªΩ„ÄëÊñá‰ª∂ÔºåÁªßÁª≠ÂØºÂÖ•Â∞Ü‰ºö„ÄêË¶ÜÁõñ„ÄëÊâÄÊúâÊï∞ÊçÆÔºÅÊòØÂê¶Ë¶ÅÁªßÁª≠Ôºü",
              { confirmButtonClass: "btn-danger" },
            );
            if (confirmed) importBackup(file);
            return;
          }

          const contentList = data.contains
            .map((item) => {
              const appNameMap = {
                weibo: "Weibo",
                forum: "Forum",
                taobao: "Taobao",
                worldBooks: "World Book",

                dateALive: "Á∫¶‰ºöÂ§ß‰ΩúÊàòÊï∞ÊçÆ",

                tukeyAccounting: "ÂÖîkËÆ∞Ë¥¶Êï∞ÊçÆ",

                studio: "Â∞èÂâßÂú∫Êï∞ÊçÆ",

                userStickers: "ÊàëÁöÑË°®ÊÉÖÂåÖ",
                charStickers: "ËßíËâ≤ÈÄöÁî®Ë°®ÊÉÖÂåÖ",
                gameData: "Ê∏∏ÊàèÂ§ßÂéÖÊï∞ÊçÆ",
                appearance: "ÈÄöÁî®Â§ñËßÇÈ¢ÑËÆæ",
              };
              if (item.startsWith("character_")) {
                const charId = item.replace("character_", "");
                const charData = data.data.chats?.find((c) => c.id === charId);
                return `ËßíËâ≤Êï∞ÊçÆÔºö${charData ? charData.name : "Êú™Áü•ËßíËâ≤"}`;
              }
              return appNameMap[item] || item;
            })
            .join("\n- ");

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§ÂØºÂÖ•",
            `Âç≥Â∞ÜÂØºÂÖ•‰ª•‰∏ãÂÜÖÂÆπÔºö\n\n- ${contentList}\n\nÊ≥®ÊÑèÔºöÂ¶ÇÊûúÁé∞ÊúâÊï∞ÊçÆ‰∏≠Â∑≤Â≠òÂú®Áõ∏ÂêåIDÁöÑÂÜÖÂÆπÔºàÂ¶ÇÂêåÂêçËßíËâ≤ÔºâÔºå‰ªñ‰ª¨ÁöÑÊï∞ÊçÆÂ∞Ü‰ºöË¢´ÂØºÂÖ•ÁöÑÊï∞ÊçÆ„ÄêÂÆåÂÖ®Ë¶ÜÁõñ„Äë„ÄÇÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄÔºÅ`,
          );

          if (!confirmed) return;

          await showCustomAlert("Please wait...", "Ê≠£Âú®ÂØºÂÖ•Êï∞ÊçÆÔºåËØ∑ÂãøÂÖ≥Èó≠È°µÈù¢...");

          try {
            // 1. Ëé∑ÂèñÂØºÂÖ•Êñá‰ª∂‰∏≠ÊúâÂì™‰∫õÊï∞ÊçÆË°®
            const tablesInBackup = Object.keys(data.data);

            // 2. Ëé∑ÂèñÂΩìÂâçÊï∞ÊçÆÂ∫ì‰∏≠ÂÆûÈôÖÂ≠òÂú®ÁöÑÊâÄÊúâÊï∞ÊçÆË°®ÂêçÁß∞
            const validTableNames = db.tables.map((t) => t.name);

            // 3. ÊâæÂá∫‰∫åËÄÖÁöÑ‰∫§ÈõÜÔºåËøôÊâçÊòØÊàë‰ª¨ÁúüÊ≠£ÈúÄË¶ÅÊìç‰ΩúÁöÑÊï∞ÊçÆË°®
            const tablesToUpdate = tablesInBackup.filter((t) =>
              validTableNames.includes(t),
            );

            console.log("Âç≥Â∞ÜÊìç‰ΩúÁöÑÊúâÊïàÊï∞ÊçÆË°®:", tablesToUpdate);

            // 4. Âè™ÂØπËøô‰∫õÊúâÊïàÁöÑÊï∞ÊçÆË°®ÂºÄÂêØ‰∏Ä‰∏™Êï∞ÊçÆÂ∫ì‰∫ãÂä°
            await db.transaction("rw", tablesToUpdate, async () => {
              for (const tableName of tablesToUpdate) {
                if (Array.isArray(data.data[tableName])) {
                  console.log(
                    `Ê≠£Âú®ÂêëË°®Ê†º "${tableName}" ‰∏≠Ë°•ÂÖÖ/Ë¶ÜÁõñ ${data.data[tableName].length} Êù°Êï∞ÊçÆ...`,
                  );
                  await db[tableName].bulkPut(data.data[tableName]);
                }
              }
            });

            await loadAllDataFromDB();
            await renderChatList();

            await showCustomAlert(
              "ÂØºÂÖ•ÊàêÂäü",
              "Êï∞ÊçÆÂ∑≤ÊàêÂäüË°•ÂÖÖÔºÅÂ∫îÁî®Â∞ÜÂà∑Êñ∞‰ª•Á°Æ‰øùÊâÄÊúâÊï∞ÊçÆÊ≠£Á°ÆÂä†ËΩΩ„ÄÇ",
            );
            setTimeout(() => window.location.reload(), 1500);
          } catch (error) {
            console.error("Ë°•ÂÖÖÂºèÂØºÂÖ•Â§±Ë¥•:", error);
            await showCustomAlert(
              "ÂØºÂÖ•Â§±Ë¥•",
              `ÂÜôÂÖ•Êï∞ÊçÆÂ∫ìÊó∂ÂèëÁîüÈîôËØØ: ${error.message}`,
            );
          } finally {
            document
              .getElementById("advanced-transfer-modal")
              .classList.remove("visible");
          }
        }

        /**
         * „ÄêÂÖºÂÆπ330„ÄëÂ∞ÜÂΩìÂâçAppÁöÑÊï∞ÊçÆÂØºÂá∫‰∏∫ÂÖºÂÆπEPhone 330ÁöÑÊ†ºÂºè
         */
        async function exportDataFor330() {
          await showCustomAlert("Please wait...", "Ê≠£Âú®‰∏∫‰Ω†ÂáÜÂ§áÂÖºÂÆπÊÄßÂ§á‰ªΩÊñá‰ª∂...");

          const backupData = {
            version: 3, // Â∞ÜÁâàÊú¨Âè∑Âº∫Âà∂ÂÜô‰∏∫3ÔºåËÆ©330ÁâàÊú¨ËÉΩËØÜÂà´
            timestamp: Date.now(),
            data: {},
          };

          try {
            const [
              chatsFromDB,
              worldBooksFromDB,
              userStickersFromDB,
              apiConfigFromDB,
              globalSettingsFromDB,
              qzonePostsFromDB,
              qzoneAlbumsFromDB,
              qzonePhotosFromDB,
              qzoneSettingsFromDB,
              personaPresetsFromDB,
              memoriesFromDB,
              apiPresetsFromDB,
              favoritesFromDB,
              worldBookCategoriesFromDB,
              callRecordsFromDB,
              stickerCategoriesFromDB,
            ] = await Promise.all([
              db.chats.toArray(),
              db.worldBooks.toArray(),
              db.userStickers.toArray(),
              db.apiConfig.get("main"),
              db.globalSettings.get("main"),
              db.qzonePosts.toArray(),
              db.qzoneAlbums.toArray(),
              db.qzonePhotos.toArray(),
              db.qzoneSettings.get("main"),
              db.personaPresets.toArray(),
              db.memories.toArray(),
              db.apiPresets.toArray(),
              db.favorites.toArray(),
              db.worldBookCategories.toArray(),
              db.callRecords.toArray(),
              db.userStickerCategories.toArray(),
            ]);

            const transformedWorldBooks = worldBooksFromDB.map((book) => {
              const newBookFor330 = { ...book };
              if (
                typeof newBookFor330.content === "string" &&
                newBookFor330.content.trim()
              ) {
                newBookFor330.content = [
                  {
                    keys: [book.name],
                    comment: `‰ªé EPhone ÂØºÂÖ•ÁöÑÊù°ÁõÆ`,
                    content: book.content,
                    enabled: true,
                  },
                ];
              } else {
                newBookFor330.content = [];
              }
              return newBookFor330;
            });

            const transformedChats = chatsFromDB.map((chat) => {
              if (chat.isGroup) return chat;
              const settingsFor330 = {
                ...chat.settings,
                "ai-persona": chat.settings.aiPersona,
                "my-persona": chat.settings.myPersona,
                "ai-avatar": chat.settings.aiAvatar,
                "my-avatar": chat.settings.myAvatar,
              };
              return { ...chat, settings: settingsFor330 };
            });

            const transformedNpcs = [];
            const npcIdSet = new Set();
            for (const chat of chatsFromDB) {
              if (!chat.isGroup && Array.isArray(chat.npcLibrary)) {
                chat.npcLibrary.forEach((npc) => {
                  if (!npcIdSet.has(npc.id)) {
                    transformedNpcs.push({
                      id: npc.id,
                      name: npc.name,
                      avatar: npc.avatar,
                      persona: npc.persona,
                      associatedWith: [chat.id],
                    });
                    npcIdSet.add(npc.id);
                  } else {
                    const existingNpc = transformedNpcs.find(
                      (n) => n.id === npc.id,
                    );
                    if (existingNpc) existingNpc.associatedWith.push(chat.id);
                  }
                });
              }
            }

            const transformedQzoneSettings = {
              id: "main",
              nickname: qzoneSettingsFromDB?.nickname || "Your nickname",
              avatar:
                qzoneSettingsFromDB?.avatar ||
                "https://files.catbox.moe/q6z5fc.jpeg",
              banner:
                qzoneSettingsFromDB?.banner ||
                "https://files.catbox.moe/r5heyt.gif",
            };

            const transformedDoubanPosts = qzonePostsFromDB
              .filter((p) => p.authorId !== "user")
              .map((p) => ({
                id: p.id,
                timestamp: p.timestamp,
                groupName: "‰ªéÂä®ÊÄÅÂØºÂÖ•ÁöÑÂ∞èÁªÑ",
                postTitle: (p.publicText || p.content || "Êó†Ê†áÈ¢ò").substring(
                  0,
                  50,
                ),
                authorName: state.chats[p.authorId]?.name || "Êú™Áü•‰ΩúËÄÖ",
                authorOriginalName: state.chats[p.authorId]?.name || "Êú™Áü•‰ΩúËÄÖ",
                content: p.content || p.publicText || "[ÂõæÁâá]",
                likesCount: p.likes?.length || 0,
                commentsCount: p.comments?.length || 0,
                comments: (p.comments || []).map((c) => ({
                  commenter: c.commenterName,
                  text: c.text,
                })),
              }));

            backupData.data = {
              chats: transformedChats,
              npcs: transformedNpcs,
              worldBooks: transformedWorldBooks,
              worldBookCategories: worldBookCategoriesFromDB,
              userStickers: userStickersFromDB,
              stickerCategories: stickerCategoriesFromDB,
              apiConfig: apiConfigFromDB ? [apiConfigFromDB] : [],
              globalSettings: globalSettingsFromDB
                ? [globalSettingsFromDB]
                : [],
              qzoneSettings: [transformedQzoneSettings],
              qzonePosts: qzonePostsFromDB,
              qzoneAlbums: qzoneAlbumsFromDB,
              qzonePhotos: qzonePhotosFromDB,
              personaPresets: personaPresetsFromDB,
              memories: memoriesFromDB,
              apiPresets: apiPresetsFromDB,
              favorites: favoritesFromDB,
              doubanPosts: transformedDoubanPosts,
              callRecords: callRecordsFromDB,
            };

            const blob = new Blob([JSON.stringify(backupData, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            const dateStr = new Date().toISOString().split("T")[0];
            link.href = url;
            link.download = `EPhone-Compatible-Backup-v330-${dateStr}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            await showCustomAlert(
              "ÂØºÂá∫ÊàêÂäü",
              "Â∑≤ÊàêÂäüÁîüÊàêÂÖºÂÆπ330ÁâàÊú¨ÁöÑÂ§á‰ªΩÊñá‰ª∂ÔºÅÁé∞Âú®‰Ω†ÂèØ‰ª•Âéª330ÁâàÊú¨ÂØºÂÖ•ÂÆÉ‰∫Ü„ÄÇ",
            );
          } catch (error) {
            console.error("ÂÖºÂÆπÊÄßÂØºÂá∫Â§±Ë¥•:", error);
            await showCustomAlert(
              "ÂØºÂá∫Â§±Ë¥•",
              `ÂèëÁîü‰∫Ü‰∏Ä‰∏™ÈîôËØØ: ${error.message}`,
            );
          } finally {
            const modal = document.getElementById("advanced-transfer-modal");
            if (modal) {
              modal.classList.remove("visible");
            }
          }
        }

        /**
         * Â§ÑÁêÜÂπ∂ÂØºÂÖ•Êù•Ëá™330ÁâàÊú¨Ê†ºÂºèÁöÑÂ§á‰ªΩÊñá‰ª∂
         * @param {File} file - Áî®Êà∑ÈÄâÊã©ÁöÑ330Ê†ºÂºèÁöÑJSONÊñá‰ª∂
         */
        async function importFrom330Format(file) {
          if (!file) return;

          const confirmed = await showCustomConfirm(
            "‰∏•ÈáçË≠¶ÂëäÔºÅ",
            "ÊÇ®Ê≠£Âú®‰ªé330ÁâàÊú¨ÂØºÂÖ•Êï∞ÊçÆÔºåËøôÂ∞Ü„ÄêÂÆåÂÖ®Ë¶ÜÁõñ„ÄëÊÇ®ÂΩìÂâçÁöÑÊâÄÊúâÊï∞ÊçÆÔºÅÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄÔºÅÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü",
            { confirmButtonClass: "btn-danger" },
          );
          if (!confirmed) return;

          await showCustomAlert("Please wait...", "Ê≠£Âú®Ëß£ÊûêÂπ∂ËΩ¨Êç¢330ÁâàÊú¨ÁöÑÊï∞ÊçÆ...");

          try {
            const text = await file.text();
            const importedData = JSON.parse(text);

            if (importedData.version !== 3) {
              throw new Error(
                `Êñá‰ª∂ÁâàÊú¨‰∏çÂåπÈÖçÔºÅÈúÄË¶ÅÁâàÊú¨3Ôºå‰ΩÜÊèê‰æõÁöÑÊòØÁâàÊú¨ ${importedData.version}„ÄÇ`,
              );
            }

            const data330 = importedData.data;

            // ËøôÊòØ‰∏Ä‰∏™ÂÆâÂÖ®ÂàóË°®ÔºåÁ°Æ‰øùÊàë‰ª¨Âè™Êìç‰ΩúÊÇ®Êï∞ÊçÆÂ∫ì‰∏≠Â≠òÂú®ÁöÑË°®
            const existingTables = [
              "chats",
              "worldBooks",
              "worldBookCategories",
              "userStickers",
              "userStickerCategories",
              "apiConfig",
              "globalSettings",
              "qzonePosts",
              "qzoneAlbums",
              "qzonePhotos",
              "qzoneSettings",
              "personaPresets",
              "memories",
              "apiPresets",
              "favorites",
              "musicLibrary",
              "callRecords",
              "customAvatarFrames",
              "themes",
              "bubbleStylePresets",
              "fontPresets",
              "homeScreenPresets",
              "weiboPosts",
              "forumGroups",
              "forumPosts",
              "forumComments",
              "forumCategories",
              "forumSeries",
              "forumChapters",
              "tarotReadings",
              "pomodoroSessions",
              "scriptKillScripts",
              "taobaoProducts",
              "taobaoOrders",
              "taobaoCart",
              "userWalletTransactions",
              "ludoQuestionBanks",
              "ludoQuestions",
              "datingScenes",
              "datingPresets",
              "datingSpriteGroups",
              "datingSprites",
              "datingHistory",
            ];

            await db.transaction("rw", existingTables, async () => {
              for (const tableName of existingTables) {
                if (db[tableName]) {
                  await db[tableName].clear();
                }
              }
              console.log("330ÂØºÂÖ•ÔºöÂ∑≤Ê∏ÖÁ©∫ÂÖ±ÊúâÁöÑÊï∞ÊçÆË°®ÔºåÂáÜÂ§áÂØºÂÖ•...");

              // ‰∏ñÁïå‰π¶ÂØºÂÖ•ÈÄªËæë
              // ‰∏çÂÜçÂêàÂπ∂ÔºåËÄåÊòØÂ∞Ü330ÁöÑÊØè‰∏™ËØçÊù°ÊãÜÂàÜÊàêÁã¨Á´ãÁöÑ‰∏ñÁïå‰π¶Êù°ÁõÆ
              if (data330.worldBooks && Array.isArray(data330.worldBooks)) {
                const allNewWorldBookEntries = []; // ÂàõÂª∫‰∏Ä‰∏™Êñ∞Êï∞ÁªÑÊù•Êî∂ÈõÜÊâÄÊúâÊãÜÂàÜÂêéÁöÑÊù°ÁõÆ
                let entryCounter = 0; // Áî®‰∫éÁîüÊàêÂîØ‰∏ÄID

                // 1. ÈÅçÂéÜ330ÁöÑÊØè‰∏Ä‰∏™‚Äú‰∏ñÁïå‰π¶ÂêàÈõÜ‚Äù
                data330.worldBooks.forEach((book_330) => {
                  if (Array.isArray(book_330.content)) {
                    // 2. ÈÅçÂéÜÂêàÈõÜ‰∏≠ÁöÑÊØè‰∏Ä‰∏™ËØçÊù°
                    book_330.content.forEach((entry) => {
                      entryCounter++;

                      // 3. ‰∏∫ÊØè‰∏™ËØçÊù°ÁîüÊàêÊñ∞ÁöÑÁã¨Á´ã‰∏ñÁïå‰π¶ÂêçÁß∞
                      // ‰ºòÂÖà‰ΩøÁî®ËØçÊù°ÁöÑ `keys` ‰Ωú‰∏∫ÂêçÁß∞ÔºåÂÖ∂Ê¨°ÊòØ `comment`ÔºåÊúÄÂêéÊòØËá™Âä®ÁîüÊàê
                      let newName = `ÂØºÂÖ•Êù°ÁõÆ ${entryCounter}`;
                      if (entry.keys && entry.keys.length > 0) {
                        newName = entry.keys.join(", "); // Áî®ÂÖ≥ÈîÆËØç‰Ωú‰∏∫Êñ∞ÂêçÁß∞
                      } else if (entry.comment) {
                        newName = entry.comment; // ÂÖ∂Ê¨°Áî®Â§áÊ≥®‰Ωú‰∏∫Êñ∞ÂêçÁß∞
                      }

                      // 4. ‰∏∫ÊØè‰∏™ËØçÊù°ÂàõÂª∫‰∏Ä‰∏™ÂÖ®Êñ∞ÁöÑ„ÄÅÁã¨Á´ãÁöÑ‰∏ñÁïå‰π¶ÂØπË±°
                      const newBookEntry = {
                        id: `imported_wb_${Date.now()}_${entryCounter}`, // ÁîüÊàêÂîØ‰∏ÄID
                        name: newName,
                        content: entry.content || "", // ÂÜÖÂÆπÂ∞±ÊòØËØçÊù°ÁöÑÂÜÖÂÆπ
                        categoryId: book_330.categoryId || 0, // ÁªßÊâøÂéüÂêàÈõÜÁöÑÂàÜÁ±ªID
                        isEnabled: entry.enabled !== false, // ÁªßÊâøÂêØÁî®Áä∂ÊÄÅÔºåÈªòËÆ§‰∏∫true
                      };

                      // 5. Â∞ÜËøô‰∏™ÂÖ®Êñ∞ÁöÑÁã¨Á´ãÊù°ÁõÆÊ∑ªÂä†Âà∞Êàë‰ª¨ÁöÑÊî∂ÈõÜ‰∏≠
                      allNewWorldBookEntries.push(newBookEntry);
                    });
                  }
                });

                // 6. ‰∏ÄÊ¨°ÊÄßÂ∞ÜÊâÄÊúâÊãÜÂàÜÂêéÁöÑÊñ∞Êù°ÁõÆÂÜôÂÖ•Êï∞ÊçÆÂ∫ì
                await db.worldBooks.bulkPut(allNewWorldBookEntries);
                console.log(
                  `330ÂØºÂÖ•ÔºöÊàêÂäü‚ÄúÊãÜÂàÜ‚ÄùÂπ∂ÂØºÂÖ• ${allNewWorldBookEntries.length} Êù°Áã¨Á´ã‰∏ñÁïå‰π¶Êù°ÁõÆ„ÄÇ`,
                );
              }
              // ÂàÜÁ±ª‰ø°ÊÅØ‰øùÊåÅ‰∏çÂèòÔºåÊ≠£Â∏∏ÂØºÂÖ•
              if (data330.worldBookCategories)
                await db.worldBookCategories.bulkPut(
                  data330.worldBookCategories,
                );

              // ËΩ¨Êç¢Âπ∂ÂØºÂÖ•„ÄêËÅäÂ§©ÂíåNPC„Äë
              if (data330.chats && Array.isArray(data330.chats)) {
                const chatsToImport = [...data330.chats];
                const npcs = data330.npcs || [];
                chatsToImport.forEach((chat) => {
                  if (!chat.isGroup) {
                    chat.npcLibrary = [];
                    npcs.forEach((npc) => {
                      if (
                        npc.associatedWith &&
                        npc.associatedWith.includes(chat.id)
                      ) {
                        chat.npcLibrary.push({
                          id: npc.id,
                          name: npc.name,
                          persona: npc.persona,
                          avatar: npc.avatar,
                        });
                      }
                    });
                  }
                });
                await db.chats.bulkPut(chatsToImport);
                console.log(
                  `330ÂØºÂÖ•ÔºöÊàêÂäüËΩ¨Êç¢Âπ∂ÂØºÂÖ• ${chatsToImport.length} ‰∏™ËÅäÂ§©„ÄÇ`,
                );
              }

              // ËΩ¨Êç¢Âπ∂ÂØºÂÖ•„ÄêË±ÜÁì£/ÂúàÂ≠ê„ÄëÊï∞ÊçÆ
              if (data330.doubanPosts && Array.isArray(data330.doubanPosts)) {
                const groupMap = new Map();
                for (const post of data330.doubanPosts) {
                  let groupId;
                  if (groupMap.has(post.groupName)) {
                    groupId = groupMap.get(post.groupName);
                  } else {
                    const newGroup = {
                      name: post.groupName,
                      description: "‰ªé330ÂØºÂÖ•ÁöÑÂ∞èÁªÑ",
                      icon: "üìñ",
                    };
                    groupId = await db.forumGroups.add(newGroup);
                    groupMap.set(post.groupName, groupId);
                  }
                  await db.forumPosts.add({
                    id: post.id,
                    groupId: groupId,
                    title: post.postTitle,
                    content: post.content,
                    authorNickname: post.authorName,
                    timestamp: post.timestamp,
                    lengthType: "short",
                    likes: post.likesCount || 0,
                  });
                  if (post.comments && post.comments.length > 0) {
                    const commentsToSave = post.comments.map((c) => ({
                      postId: post.id,
                      author: c.commenter,
                      content: c.text,
                      timestamp: Date.now(),
                    }));
                    await db.forumComments.bulkAdd(commentsToSave);
                  }
                }
                console.log(
                  `330ÂØºÂÖ•ÔºöÊàêÂäüËΩ¨Êç¢Âπ∂ÂØºÂÖ• ${data330.doubanPosts.length} Êù°ÂúàÂ≠êÂ∏ñÂ≠ê„ÄÇ`,
                );
              }

              // ËΩ¨Êç¢Âπ∂ÂØºÂÖ•ÂçïÂØπË±°ËÆæÁΩÆ
              if (data330.apiConfig?.[0])
                await db.apiConfig.put(data330.apiConfig[0]);
              if (data330.globalSettings?.[0])
                await db.globalSettings.put(data330.globalSettings[0]);
              if (data330.qzoneSettings?.[0])
                await db.qzoneSettings.put(data330.qzoneSettings[0]);
              if (data330.musicLibrary?.[0])
                await db.musicLibrary.put(data330.musicLibrary[0]);

              // Áõ¥Êé•ÂØºÂÖ•ÂÖ∂‰ªñÁªìÊûÑÁõ∏ÂêåÁöÑ„ÄêÂÖ±Êúâ„ÄëÊï∞ÊçÆË°®
              const directImportTables = [
                "userStickers",
                "personaPresets",
                "qzonePosts",
                "qzoneAlbums",
                "qzonePhotos",
                "favorites",
                "memories",
                "callRecords",
                "apiPresets",
                "stickerCategories",
                "customAvatarFrames",
              ];
              for (const tableName of directImportTables) {
                if (
                  data330[tableName] &&
                  Array.isArray(data330[tableName]) &&
                  db[tableName]
                ) {
                  await db[tableName].bulkPut(data330[tableName]);
                  console.log(
                    `330ÂØºÂÖ•ÔºöÊàêÂäüÂØºÂÖ• ${data330[tableName].length} Êù°Êï∞ÊçÆÂà∞ ${tableName}„ÄÇ`,
                  );
                }
              }
            });

            // ÂØºÂÖ•ÊàêÂäüÂêéÂà∑Êñ∞È°µÈù¢
            await showCustomAlert(
              "ÂØºÂÖ•ÊàêÂäü",
              "Êù•Ëá™330ÁâàÊú¨ÁöÑÊï∞ÊçÆÂ∑≤ÊàêÂäüÂØºÂÖ•ÔºÅÂ∫îÁî®Âç≥Â∞ÜÂà∑Êñ∞‰ª•Â∫îÁî®ÊâÄÊúâÊõ¥Êîπ„ÄÇ",
            );
            setTimeout(() => {
              window.location.reload();
            }, 1500);
          } catch (error) {
            console.error("‰ªé330Ê†ºÂºèÂØºÂÖ•Â§±Ë¥•:", error);
            await showCustomAlert(
              "ÂØºÂÖ•Â§±Ë¥•",
              `Êñá‰ª∂Ê†ºÂºè‰∏çÊ≠£Á°ÆÊàñÊï∞ÊçÆÂ∑≤ÊçüÂùè: ${error.message}`,
            );
          }
        }

        /**
         * ÂéãÁº©ÂõæÁâáËá≥ÊåáÂÆöË¥®ÈáèÂπ∂ËøîÂõûBase64ÔºåÂêåÊó∂Ë∑≥ËøáGIF
         * @param {string} base64Str - ÂéüÂßãÂõæÁâáÁöÑBase64Â≠óÁ¨¶‰∏≤ (data:...)
         * @param {number} quality - ÂéãÁº©Ë¥®Èáè (0.1 - 1.0)
         * @returns {Promise<string>} - ËøîÂõûÂéãÁº©ÂêéÁöÑJPEGÊ†ºÂºèÁöÑBase64Â≠óÁ¨¶‰∏≤ÔºåÊàñÂéüÂßãÁöÑGIF/PNGÂ≠óÁ¨¶‰∏≤
         */
        function compressImage(base64Str, quality) {
          return new Promise((resolve, reject) => {
            // Â¶ÇÊûúÊòØ GIFÔºåÊàñËÄÖË¥®ÈáèËÆæÁΩÆ‰∏∫1.0Ôºà‰∏çÂéãÁº©ÔºâÔºåÁõ¥Êé•ËøîÂõûÂéüÂõæÔºå‰∏çËøõË°å‰ªª‰ΩïÂ§ÑÁêÜ„ÄÇ
            if (
              base64Str.startsWith("data:image/gif") ||
              quality >= 1.0 ||
              !base64Str.startsWith("data:image")
            ) {
              resolve(base64Str);
              return;
            }

            const img = new Image();
            img.src = base64Str;

            img.onload = () => {
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");
              canvas.width = img.width;
              canvas.height = img.height;
              ctx.drawImage(img, 0, 0);

              // Á°Æ‰øù PNG ÂíåÂÖ∂‰ªñÈùôÊÄÅÂõæËÉΩË¢´Ê≠£Á°ÆÂéãÁº©„ÄÇ
              const compressedBase64 = canvas.toDataURL("image/jpeg", quality);
              resolve(compressedBase64);
            };

            img.onerror = (err) => {
              console.error("ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•ÔºåÊó†Ê≥ïÂéãÁº©:", err);
              reject(new Error("ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•ÔºåÊó†Ê≥ïÂéãÁº©"));
            };
          });
        }

        /**
         * ÈÄöÁî®Êñá‰ª∂‰∏ä‰º†Âπ∂ÂéãÁº©Â§ÑÁêÜÂáΩÊï∞
         * @param {File} file - Áî®Êà∑ÈÄâÊã©ÁöÑÊñá‰ª∂
         * @returns {Promise<string>} - ËøîÂõûÂéãÁº©ÂêéÁöÑBase64Â≠óÁ¨¶‰∏≤
         */
        async function handleImageUploadAndCompress(file) {
          const base64Url = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
          });

          const quality = state.globalSettings.imageCompressionQuality || 0.7;
          console.log(`ÂáÜÂ§áÂéãÁº©ÂõæÁâáÔºåË¥®Èáè: ${quality}`);

          const compressedBase64 = await compressImage(base64Url, quality);
          console.log(
            `ÂõæÁâáÂéãÁº©ÂÆåÊàê„ÄÇÂéüÂßãÂ§ßÂ∞è: ${base64Url.length}, ÂéãÁº©ÂêéÂ§ßÂ∞è: ${compressedBase64.length}`,
          );

          return compressedBase64;
        }
        window.handleImageUploadAndCompress = handleImageUploadAndCompress;
        /**
         * ËÆ°ÁÆóBase64Â≠óÁ¨¶‰∏≤ÁöÑËøë‰ººÊñá‰ª∂Â§ßÂ∞è
         * @param {string} base64Str - Base64Â≠óÁ¨¶‰∏≤ (ÂèØ‰ª•Â∏¶'data:...'ÂâçÁºÄ)
         * @returns {number} - Â≠óËäÇÂ§ßÂ∞è
         */
        function getBase64Size(base64Str) {
          if (
            !base64Str ||
            typeof base64Str !== "string" ||
            !base64Str.startsWith("data:image")
          )
            return 0;
          const base64 = base64Str.split(",")[1] || base64Str;
          const padding = base64.endsWith("==")
            ? 2
            : base64.endsWith("=")
              ? 1
              : 0;
          return (base64.length * 3) / 4 - padding;
        }

        /**
         * Â∞ÜÂ≠óËäÇÊï∞Ê†ºÂºèÂåñ‰∏∫ÊòìËØªÁöÑÂ≠óÁ¨¶‰∏≤ (KB, MB, GB)
         * @param {number} bytes - Â≠óËäÇÊï∞
         * @returns {string} - Ê†ºÂºèÂåñÂêéÁöÑÂ≠óÁ¨¶‰∏≤
         */
        function formatBytes(bytes) {
          if (bytes === 0) return "0 Bytes";
          const k = 1024;
          const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
          );
        }

        /**
         * ËÆ°ÁÆóÂπ∂ÊòæÁ§∫Êï∞ÊçÆÂ∫ì‰∏≠ÊâÄÊúâÂõæÁâáÁöÑÊÄªÂ§ßÂ∞èÔºåÂπ∂ËøîÂõûÊï∞ÂÄº
         * @returns {Promise<number>} - ËøîÂõûÊÄªÂ≠óËäÇÊï∞
         */
        async function calculateTotalImageSize() {
          const displayEl = document.getElementById("image-data-size-display");
          displayEl.textContent = "Ê≠£Âú®ËÆ°ÁÆó‰∏≠...";

          let totalSize = 0;
          const processedUrls = new Set();

          const calculateSize = (url) => {
            if (
              !url ||
              typeof url !== "string" ||
              !url.startsWith("data:image") ||
              processedUrls.has(url)
            ) {
              return 0;
            }
            const size = getBase64Size(url);
            processedUrls.add(url);
            return size;
          };

          try {
            const allTables = db.tables.map((table) => table.name);
            for (const tableName of allTables) {
              try {
                const items = await db[tableName].toArray();
                for (const item of items) {
                  const findImagesRecursive = (obj) => {
                    for (const key in obj) {
                      if (typeof obj[key] === "string") {
                        totalSize += calculateSize(obj[key]);
                      } else if (
                        typeof obj[key] === "object" &&
                        obj[key] !== null
                      ) {
                        findImagesRecursive(obj[key]);
                      }
                    }
                  };
                  findImagesRecursive(item);
                }
              } catch (e) {
                console.warn(`Êâ´ÊèèË°® ${tableName} Âá∫Èîô:`, e);
              }
            }

            displayEl.textContent = `ÂΩìÂâçÂõæÁâáÊï∞ÊçÆÊÄªÈáèÁ∫¶: ${formatBytes(totalSize)}`;
            return totalSize; // ËøîÂõûËÆ°ÁÆóÂá∫ÁöÑÊÄªÂ§ßÂ∞è
          } catch (error) {
            console.error("ËÆ°ÁÆóÂõæÁâáÂ§ßÂ∞èÊó∂Âá∫Èîô:", error);
            displayEl.textContent = "ËÆ°ÁÆóÂ§±Ë¥•ÔºåËØ∑Êü•ÁúãÊéßÂà∂Âè∞„ÄÇ";
            return 0;
          }
        }

        /**
         * ‰∏ÄÈîÆÂéãÁº©Êï∞ÊçÆÂ∫ì‰∏≠ÊâÄÊúâÂõæÁâáÁöÑÊ†∏ÂøÉÂáΩÊï∞
         */
        async function compressAllImagesInDB() {
          const confirmed = await showCustomConfirm(
            "È´òÈ£éÈô©Êìç‰ΩúÁ°ÆËÆ§",
            "Ê≠§Êìç‰ΩúÂ∞ÜÊâ´ÊèèÂπ∂„ÄêÊ∞∏‰πÖÊÄßÂú∞„ÄëÂéãÁº©Êï∞ÊçÆÂ∫ì‰∏≠ÁöÑ„ÄêÊâÄÊúâÈùôÊÄÅÂõæÁâáÔºàPNG/JPGÁ≠âÔºâ„Äë„ÄÇ<br><br>„ÄêGIFÂä®Âõæ‰ºöË¢´Ëá™Âä®Ë∑≥ËøáÔºå‰∏ç‰ºöË¢´ÂéãÁº©„Äë„ÄÇ<br><br>ÂéãÁº©ÊòØ‰∏çÂèØÈÄÜÁöÑÔºåÂª∫ËÆÆÂú®Êìç‰ΩúÂâçÂÖà„ÄêÂØºÂá∫Êï∞ÊçÆ„ÄëËøõË°åÂ§á‰ªΩÔºÅ<br><br>Á°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü",
            { confirmButtonClass: "btn-danger" },
          );

          if (!confirmed) return;

          const loadingOverlay = document.getElementById("generation-overlay");
          const loadingText = loadingOverlay.querySelector("p");
          loadingText.textContent = "Ê≠£Âú®ÂÖ®ÂäõÂéãÁº©ÂõæÁâáÔºåËØ∑ËÄêÂøÉÁ≠âÂæÖ...";
          loadingOverlay.classList.add("visible");

          try {
            const quality =
              parseFloat(
                document.getElementById("image-quality-slider").value,
              ) || 0.7;
            const originalTotalSize = await calculateTotalImageSize();
            let itemsProcessed = 0;
            let compressedCount = 0;

            const findAndCompressImagesInObject = async (obj) => {
              let hasCompressed = false;
              for (const key in obj) {
                if (
                  typeof obj[key] === "string" &&
                  obj[key].startsWith("data:image")
                ) {
                  const originalUrl = obj[key];
                  const compressedUrl = await compressImage(
                    originalUrl,
                    quality,
                  );
                  if (originalUrl !== compressedUrl) {
                    obj[key] = compressedUrl;
                    hasCompressed = true;
                    compressedCount++; // ËÆ∞ÂΩïÂéãÁº©‰∫ÜÂ§öÂ∞ëÂº†ÂõæÁâá
                  }
                } else if (typeof obj[key] === "object" && obj[key] !== null) {
                  if (await findAndCompressImagesInObject(obj[key])) {
                    hasCompressed = true;
                  }
                }
              }
              return hasCompressed;
            };

            const allTables = db.tables.map((table) => table.name);
            for (const tableName of allTables) {
              loadingText.textContent = `Ê≠£Âú®Êâ´ÊèèË°®: ${tableName}...`;
              const itemsToUpdate = [];
              const allItems = await db[tableName].toArray();

              for (const item of allItems) {
                if (await findAndCompressImagesInObject(item)) {
                  itemsToUpdate.push(item);
                }
                itemsProcessed++;
                if (itemsProcessed % 20 === 0) {
                  loadingText.textContent = `Â∑≤Â§ÑÁêÜ ${itemsProcessed} Êù°Êï∞ÊçÆ... ÂéãÁº©‰∫Ü ${compressedCount} Âº†ÂõæÁâá...`;
                }
              }

              if (itemsToUpdate.length > 0) {
                loadingText.textContent = `Ê≠£Âú®‰øùÂ≠ò ${tableName} ÁöÑÂéãÁº©ÁªìÊûú...`;
                await db[tableName].bulkPut(itemsToUpdate);
                console.log(
                  `Ë°® ${tableName} ‰∏≠Êúâ ${itemsToUpdate.length} Êù°ËÆ∞ÂΩïÁöÑÂõæÁâáË¢´ÂéãÁº©„ÄÇ`,
                );
              }
            }

            loadingOverlay.classList.remove("visible");

            const newTotalSize = await calculateTotalImageSize();
            const savedSize = originalTotalSize - newTotalSize;

            await showCustomAlert(
              "ÂéãÁº©ÂÆåÊàêÔºÅ",
              `Êìç‰ΩúÊàêÂäüÔºÅ\nÂéüÂßãÂ§ßÂ∞è: ${formatBytes(originalTotalSize)}\nÂéãÁº©ÂêéÂ§ßÂ∞è: ${formatBytes(
                newTotalSize,
              )}\nÊàêÂäü‰∏∫ÊÇ®ËäÇÁúÅ‰∫Ü ${formatBytes(savedSize)} ÁöÑÁ©∫Èó¥ÔºÅ\n\nÂ∫îÁî®Âç≥Â∞ÜÂà∑Êñ∞‰ª•Â∫îÁî®ÊâÄÊúâÊõ¥Êîπ„ÄÇ`,
            );

            setTimeout(() => window.location.reload(), 2000);
          } catch (error) {
            // Âá∫ÈîôÊó∂‰πüË¶ÅÁ°Æ‰øùÂä†ËΩΩÂä®ÁîªË¢´ÈöêËóè
            loadingOverlay.classList.remove("visible");
            console.error("ÂéãÁº©ÂÖ®ÈÉ®ÂõæÁâáÊó∂Âá∫Èîô:", error);
            await showCustomAlert(
              "ÂéãÁº©Â§±Ë¥•",
              `ÂèëÁîü‰∫Ü‰∏Ä‰∏™ÈîôËØØ: ${error.message}`,
            );
          }
        }

        /**
         * ÊµÅÂºèÂØºÂá∫ÂáΩÊï∞ (Â§ßÊï∞ÊçÆ‰∏ìÁî®)
         * ÂéüÁêÜÔºö‰∏çÂÜç‰∏ÄÊ¨°ÊÄßËØªÂèñÊâÄÊúâÊï∞ÊçÆÂ∫ìË°®Âà∞ÂÜÖÂ≠òÔºåËÄåÊòØÈÄê‰∏™Ë°®ËØªÂèñ„ÄÅÂÜôÂÖ•Ôºå
         * Âà©Áî® ReadableStream Âíå Response ÊµÅÂºè‰º†ËæìÁªôÁî®Êà∑Ôºå‰ªéËÄåÊûÅÂ§ßÈôç‰ΩéÂÜÖÂ≠òÂç†Áî®„ÄÇ
         */
        async function exportDataStream() {
          await showCustomAlert(
            "Please wait...",
            "Ê≠£Âú®ÂáÜÂ§áÊµÅÂºèÂØºÂá∫ÔºåËøôÂèØËÉΩÈúÄË¶Å‰∏Ä‰∫õÊó∂Èó¥Ôºå‰ΩÜ‰∏ç‰ºö‰ΩøÊµèËßàÂô®Â¥©Ê∫É„ÄÇ",
          );

          // ÂÆö‰πâÊâÄÊúâÈúÄË¶ÅÂ§á‰ªΩÁöÑÊï∞ÊçÆÂ∫ìË°®Âêç
          const tablesToExport = [
            "chats",
            "apiConfig",
            "globalSettings",
            "userStickers",
            "charStickers",
            "worldBooks",
            "musicLibrary",
            "personaPresets",
            "qzoneSettings",
            "qzonePosts",
            "qzoneAlbums",
            "qzonePhotos",
            "favorites",
            "qzoneGroups",
            "memories",
            "worldBookCategories",
            "callRecords",
            "customAvatarFrames",
            "themes",
            "apiPresets",
            "bubbleStylePresets",
            "fontPresets",
            "homeScreenPresets",
            "weiboPosts",
            "forumGroups",
            "forumPosts",
            "forumComments",
            "forumCategories",
            "forumSeries",
            "forumChapters",
            "tarotReadings",
            "pomodoroSessions",
            "scriptKillScripts",
            "taobaoProducts",
            "taobaoOrders",
            "taobaoCart",
            "userWalletTransactions",
            "userStickerCategories",
            "datingScenes",
            "datingPresets",
            "datingSpriteGroups",
            "datingSprites",
            "datingHistory",
          ];

          const stream = new ReadableStream({
            async start(controller) {
              const encoder = new TextEncoder();

              // 1. ÂÜôÂÖ•JSONÊñá‰ª∂ÁöÑÂºÄÂ§¥
              controller.enqueue(encoder.encode("{\n"));

              // 2. Ê∑ªÂä†ÁâàÊú¨ÂíåÊó∂Èó¥Êà≥ÂÖÉÊï∞ÊçÆ
              const metaData = `"version": 1,\n"timestamp": ${Date.now()},\n`;
              controller.enqueue(encoder.encode(metaData));

              // 3. ÈÄê‰∏™Â§ÑÁêÜÊï∞ÊçÆÂ∫ìË°®
              for (let i = 0; i < tablesToExport.length; i++) {
                const tableName = tablesToExport[i];
                console.log(`ÊµÅÂºèÂØºÂá∫ÔºöÊ≠£Âú®Â§ÑÁêÜË°® ${tableName}...`);

                try {
                  // 1. ÂÆö‰πâÂì™‰∫õË°®ÊòØÂçï‰∏™ÂØπË±°ÁöÑËÆæÁΩÆË°®
                  const singleObjectTables = [
                    "apiConfig",
                    "globalSettings",
                    "musicLibrary",
                    "qzoneSettings",
                    "tukeyUserSettings",
                    "tukeyCustomConfig",
                    "tukeyAccountingGroups",
                  ];

                  let tableData;
                  // 2. Âà§Êñ≠ÂΩìÂâçË°®ÊòØÂê¶ÊòØÂçï‰∏™ÂØπË±°ÁöÑËÆæÁΩÆË°®
                  if (singleObjectTables.includes(tableName)) {
                    // Â¶ÇÊûúÊòØÔºåÂ∞±Âè™Ëé∑ÂèñÁ¨¨‰∏Ä‰∏™Ôºà‰πüÂèØËÉΩÊòØÂîØ‰∏Ä‰∏Ä‰∏™ÔºâÂØπË±°
                    tableData = await db[tableName].toCollection().first();
                    // Â¶ÇÊûúË°®ÊòØÁ©∫ÁöÑÔºåfirst()‰ºöËøîÂõûundefinedÔºåJSON.stringify(undefined)‰ºöÂá∫ÈóÆÈ¢òÔºåÊâÄ‰ª•ËΩ¨‰∏∫null
                    if (tableData === undefined) {
                      tableData = null;
                    }
                  } else {
                    // Â¶ÇÊûúÊòØÊôÆÈÄöÁöÑÂ§öÊù°ËÆ∞ÂΩïË°®ÔºåÂ∞±ËøòÊòØËé∑ÂèñÊï¥‰∏™Êï∞ÁªÑ
                    tableData = await db[tableName].toArray();
                  }

                  const jsonString = JSON.stringify(tableData);

                  // ÂÜôÂÖ• "tableName": [...] Êàñ "tableName": {...}
                  controller.enqueue(
                    encoder.encode(`"${tableName}": ${jsonString}`),
                  );

                  // Â¶ÇÊûú‰∏çÊòØÊúÄÂêé‰∏Ä‰∏™Ë°®ÔºåÂ∞±Âä†‰∏äÈÄóÂè∑ÂíåÊç¢Ë°åÁ¨¶
                  if (i < tablesToExport.length - 1) {
                    controller.enqueue(encoder.encode(",\n"));
                  } else {
                    controller.enqueue(encoder.encode("\n"));
                  }
                } catch (e) {
                  console.error(`ÊµÅÂºèÂØºÂá∫Êó∂ÔºåÂ§ÑÁêÜË°® ${tableName} Â§±Ë¥•:`, e);
                  // Âç≥‰ΩøÊüê‰∏™Ë°®Â§±Ë¥•Ôºå‰πüÁªßÁª≠Â∞ùËØï‰∏ã‰∏Ä‰∏™
                }
              }

              // 4. ÂÜôÂÖ•JSONÊñá‰ª∂ÁöÑÁªìÂ∞æ
              controller.enqueue(encoder.encode("}"));

              // 5. ÈÄöÁü•ÊµÅÂ∑≤ÁªèÁªìÊùü
              controller.close();
              console.log("ÊµÅÂºèÂØºÂá∫ÔºöÊâÄÊúâÊï∞ÊçÆÂÜôÂÖ•ÂÆåÊàê„ÄÇ");
            },
          });

          // 6. ‰ΩøÁî® Response Â∞ÜÊµÅÂåÖË£ÖÊàêÂèØ‰∏ãËΩΩÁöÑÊñá‰ª∂
          const response = new Response(stream, {
            headers: { "Content-Type": "application/json" },
          });

          // 7. ÂàõÂª∫Âπ∂Ëß¶Âèë‰∏ãËΩΩÈìæÊé•
          const url = URL.createObjectURL(await response.blob());
          const link = document.createElement("a");
          link.href = url;
          link.download = `EPhone-Stream-Backup-${new Date().toISOString().split("T")[0]}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);

          // ÂÖ≥Èó≠‚ÄúËØ∑Á®çÂÄô‚ÄùÁöÑÂºπÁ™ó
          hideCustomModal();
        }
        /**
         * ÊÅ¢Â§çÊâÄÊúâAppÂêçÁß∞‰∏∫ÈªòËÆ§ÂÄº
         */
        async function resetAppNamesToDefault() {
          // 1. ÂºπÂá∫Á°ÆËÆ§Ê°ÜÔºåÈò≤Ê≠¢ËØØÊìç‰Ωú
          const confirmed = await showCustomConfirm(
            "ÊÅ¢Â§çÈªòËÆ§ÂêçÁß∞",
            "Á°ÆÂÆöË¶ÅÂ∞ÜÊâÄÊúâAppÁöÑÂêçÁß∞ÊÅ¢Â§ç‰∏∫ÈªòËÆ§ËÆæÁΩÆÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ",
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            // 2. Ê∏ÖÁ©∫Â≠òÂÇ®Ëá™ÂÆö‰πâÂêçÁß∞ÁöÑÂØπË±°
            state.globalSettings.appLabels = {};

            // 3. Â∞ÜÊõ¥Êîπ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
            await db.globalSettings.put(state.globalSettings);

            // 4. Á´ãÂç≥Â∫îÁî®Êõ¥ÊîπÂà∞UI
            applyAppLabels(); // Êõ¥Êñ∞‰∏ªÂ±èÂπï‰∏äAppÁöÑÊòæÁ§∫ÂêçÁß∞
            renderAppNameSettings(); // Âà∑Êñ∞Â§ñËßÇËÆæÁΩÆÈ°µÈù¢ÁöÑËæìÂÖ•Ê°ÜÔºåÊòæÁ§∫ÂõûÈªòËÆ§Âêç

            // 5. ÁªôÂá∫ÊàêÂäüÊèêÁ§∫
            await showCustomAlert("Êìç‰ΩúÊàêÂäü", "ÊâÄÊúâAppÂêçÁß∞Â∑≤ÊÅ¢Â§ç‰∏∫ÈªòËÆ§„ÄÇ");
          }
        }

        window.activeGroupId = null;

        const SYMBOL_THRESHOLDS = [
          {
            id: "first_heartbeat",
            level: 100,
            symbol:
              "https://i.postimg.cc/DZSsNzMB/5BF06FFB38AAF2B394F89F6270D328D5.png",
            name: "ÂàùËØÜÂøÉÂä®",
            description: "ÂøÉË∑≥ÊòØÊïÖ‰∫ãÁöÑÂºÄÂßã„ÄÇ",
          },
          {
            id: "shining_star",
            level: 300,
            symbol:
              "https://i.postimg.cc/L47gJRb3/7227080E4BF5950D1B182043D1F734DB.png",
            name: "ÊòüÂÖâÈó™ÁÉÅ",
            description: "‰Ω†‰ª¨ÁöÑÂÖ≥Á≥ªÂÉèÊòüÂÖâ‰∏ÄÊ†∑ÂºÄÂßãÈó™ËÄÄ„ÄÇ",
          },
          {
            id: "burning_passion",
            level: 700,
            symbol:
              "https://i.postimg.cc/yNQcnRvT/BD0C0CC3C6692D736014BACE73C07F8E.png",
            name: "ÁÉ≠ÊÉÖÂ¶ÇÁÅ´",
            description: "ÊØè‰∏ÄÊ¨°‰∫íÂä®ÈÉΩËÆ©ÊÑüÊÉÖÂçáÊ∏©„ÄÇ",
          },
          {
            id: "only_crown",
            level: 1500,
            symbol:
              "https://i.postimg.cc/B6jDzvVh/92DD1E30EFEEC589E3BE0FFB630F8B4E.png",
            name: "ÂîØ‰∏ÄÁéãÂÜ†",
            description: "Âú®ÂΩºÊ≠§ÁöÑ‰∏ñÁïåÈáåÔºåÂØπÊñπÊòØÁã¨‰∏ÄÊó†‰∫åÁöÑÂ≠òÂú®„ÄÇ",
          },
          {
            id: "eternal_diamond",
            level: 5000,
            symbol:
              "https://i.postimg.cc/C1RD2KQc/B0E2B3034728540DA4198357D5B8131C.png",
            name: "Ê∞∏ÊÅí‰πãÈíª",
            description: "‰Ω†‰ª¨ÁöÑÂÖ≥Á≥ªÂ¶ÇÈíªÁü≥Ëà¨ÂùöÂõ∫ËÄåÁíÄÁí®„ÄÇ",
          },
        ];

        /**
         * Ê†∏ÂøÉÔºöËÆ°ÁÆó‰∫≤ÂØÜÂÄº
         * @param {object} chat - ËÅäÂ§©ÂØπË±°
         * @returns {number} - ËÆ°ÁÆóÂá∫ÁöÑ‰∫≤ÂØÜÂÄºÂàÜÊï∞
         */
        function calculateIntimacy(chat) {
          if (!chat || !chat.settings.streak) return 0;

          // Âü∫Á°ÄÂàÜÔºöÁÅ´Ëä±Â§©Êï∞ÔºåÊØèÂ§©ÈÉΩÂæàÈáçË¶ÅÔºÅ
          const streakDays = chat.settings.streak.currentDays || 0;
          const streakScore = streakDays * 15; // ÊØèÂ§©ÁÅ´Ëä±Êèê‰æõ15ÁÇπÂü∫Á°ÄÂàÜ

          // ‰∫íÂä®ÂàÜÔºöÁ¥ØËÆ°Ê∂àÊÅØÊÄªÊï∞
          const stats = chat.interactionStats || {};
          const totalMessages = Object.values(stats).reduce(
            (sum, count) => sum + count,
            0,
          );
          const messageScore = totalMessages * 0.2; // ÊØèÊù°Ê∂àÊÅØÊèê‰æõ0.2ÁÇπ‰∫íÂä®ÂàÜ

          const intimacy = streakScore + messageScore;
          return Math.floor(intimacy); // ËøîÂõûÊï¥Êï∞
        }

        /**
         * Ê†∏ÂøÉÔºöÊ£ÄÊü•Âπ∂Ëß£ÈîÅÊñ∞ÁöÑÂæΩÁ´†
         * @param {object} chat - ËÅäÂ§©ÂØπË±°
         * @param {number} intimacyValue - ÂΩìÂâçÁöÑ‰∫≤ÂØÜÂÄº
         * @returns {Promise<boolean>} - Â¶ÇÊûúÊúâÊñ∞ÂæΩÁ´†Ëß£ÈîÅÔºåËøîÂõûtrue
         */
        async function checkAndUnlockSymbols(chat, intimacyValue) {
          let newUnlock = false;
          if (!chat.unlockedSymbols) chat.unlockedSymbols = [];

          SYMBOL_THRESHOLDS.forEach((threshold) => {
            // Ê£ÄÊü•Ôºö‰∫≤ÂØÜÂÄºÊòØÂê¶ËææÊ†áÔºüËøô‰∏™ÂæΩÁ´†ÊòØ‰∏çÊòØËøòÊ≤°Ëß£ÈîÅËøáÔºü
            if (
              intimacyValue >= threshold.level &&
              !chat.unlockedSymbols.some((s) => s.symbol === threshold.symbol)
            ) {
              // Â¶ÇÊûúÈÉΩÊª°Ë∂≥ÔºåÂ∞±Ëß£ÈîÅÔºÅ
              chat.unlockedSymbols.push({
                symbol: threshold.symbol,
                name: threshold.name,
                unlockedAt: Date.now(), // ËÆ∞ÂΩïËß£ÈîÅÁöÑÁ≤æÁ°ÆÊó∂Èó¥
              });
              newUnlock = true;
              console.log(
                `ÂæΩÁ´†Ëß£ÈîÅÔºÅËßíËâ≤: ${chat.name}, ÂæΩÁ´†: ${threshold.name}`,
              );
            }
          });

          // Â¶ÇÊûúÊúâÊñ∞Ëß£ÈîÅÁöÑÂæΩÁ´†ÔºåÂ∞±Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÂπ∂ÂºπÁ™óÊèêÁ§∫
          if (newUnlock) {
            await db.chats.put(chat);
            // ÊâæÂà∞ÊúÄÊñ∞Ëß£ÈîÅÁöÑÈÇ£‰∏™ÂæΩÁ´†Êù•ÊòæÁ§∫ÈÄöÁü•
            const latestUnlock =
              chat.unlockedSymbols[chat.unlockedSymbols.length - 1];
            await showCustomAlert(
              "Êñ∞ÂæΩÁ´†Â∑≤Ëß£ÈîÅÔºÅ",
              `ÊÅ≠Âñú‰Ω†Âíå‚Äú${chat.name}‚ÄùËß£ÈîÅ‰∫ÜÊñ∞ÁöÑ‰∫≤ÂØÜÂæΩÁ´†Ôºö${latestUnlock.name}`,
            );
          }
          return newUnlock;
        }

        async function openIntimacyPanel(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;

          // --- Êï∞ÊçÆËÆ°ÁÆó ---
          const intimacyValue = calculateIntimacy(chat);
          await checkAndUnlockSymbols(chat, intimacyValue);

          // --- Â°´ÂÖÖUI (ËøôÈÉ®ÂàÜÈÄªËæë‰∏çÂèò) ---
          document.getElementById("intimacy-score-display").textContent =
            intimacyValue;
          const today = new Date().toISOString().split("T")[0];
          const todayMsgs = chat.interactionStats?.[today] || 0;
          const totalMsgs = Object.values(chat.interactionStats || {}).reduce(
            (sum, count) => sum + count,
            0,
          );
          document.getElementById("intimacy-streak-days").textContent =
            `${chat.settings.streak?.currentDays || 0} Â§©`;
          document.getElementById("intimacy-today-msgs").textContent =
            `${todayMsgs} Êù°`;
          document.getElementById("intimacy-total-msgs").textContent =
            `${totalMsgs} Êù°`;

          // --- Ê∏≤ÊüìÂèØÁÇπÂáªÁöÑÂæΩÁ´†ÂàóË°® ---
          const symbolListContainer = document.getElementById(
            "symbol-list-container",
          );
          symbolListContainer.innerHTML = "";

          // Ê∑ªÂä†‰∏Ä‰∏™‚Äú‰∏ç‰Ω©Êà¥‚ÄùÁöÑÈÄâÈ°π
          const noneItem = document.createElement("div");
          noneItem.className = "symbol-item unlocked"; // ËÆ©ÂÆÉÊÄªÊòØÂèØÁÇπÂáª
          if (!chat.settings.selectedIntimacyBadge) {
            noneItem.classList.add("selected"); // Â¶ÇÊûúÂΩìÂâçÊ≤°‰Ω©Êà¥ÔºåÂ∞±È´ò‰∫ÆËøô‰∏™
          }
          noneItem.innerHTML = `<div class="symbol-icon no-badge">üö´</div><div class="symbol-name">‰∏ç‰Ω©Êà¥</div>`;
          noneItem.onclick = () => selectIntimacyBadge(chatId, ""); // ÁÇπÂáªÊó∂Ôºå‰º†ÂÖ•Á©∫Â≠óÁ¨¶‰∏≤Ë°®Á§∫‰∏ç‰Ω©Êà¥
          symbolListContainer.appendChild(noneItem);

          // Ê∏≤ÊüìÊâÄÊúâÂèØËß£ÈîÅÁöÑÂæΩÁ´†
          SYMBOL_THRESHOLDS.forEach((threshold) => {
            const isUnlocked = intimacyValue >= threshold.level;
            const isSelected =
              chat.settings.selectedIntimacyBadge === threshold.symbol;

            const item = document.createElement("div");
            item.className = `symbol-item ${isUnlocked ? "unlocked" : ""} ${isSelected ? "selected" : ""}`;

            // ‰ΩøÁî® <img> Ê†áÁ≠æÊù•ÊòæÁ§∫ÂõæÁâá
            item.innerHTML = `
			            <div class="symbol-icon ${!isUnlocked ? "not-unlocked" : ""}">
			                <img src="${threshold.symbol}" alt="${threshold.name}">
			            </div>
			            <div class="symbol-name">${threshold.name}</div>
			            <div class="symbol-level">${isUnlocked ? "Â∑≤Ëß£ÈîÅ" : `${threshold.level}ÂàÜËß£ÈîÅ`}</div>
			        `;

            // Âè™ÊúâËß£ÈîÅ‰∫ÜÁöÑÂæΩÁ´†ÊâçËÉΩÁÇπÂáª
            if (isUnlocked) {
              item.onclick = () =>
                selectIntimacyBadge(chatId, threshold.symbol);
            }

            symbolListContainer.appendChild(item);
          });

          // --- Ê∏≤ÊüìËß£ÈîÅËÆ∞ÂΩï ---
          const recordsContainer = document.getElementById(
            "unlocked-symbols-record",
          );
          recordsContainer.innerHTML = "";
          if (chat.unlockedSymbols && chat.unlockedSymbols.length > 0) {
            const sortedRecords = [...chat.unlockedSymbols].sort(
              (a, b) => b.unlockedAt - a.unlockedAt,
            );
            sortedRecords.forEach((record) => {
              const recordItem = document.createElement("div");
              recordItem.className = "record-item";
              recordItem.innerHTML = `<span class="symbol"><img src="${
                record.symbol
              }" style="height:1em; vertical-align:middle;"></span><span>${
                record.name
              }</span><span class="date">${new Date(record.unlockedAt).toLocaleDateString()}</span>`;
              recordsContainer.appendChild(recordItem);
            });
          } else {
            recordsContainer.innerHTML =
              '<p style="text-align:center; color:#999; font-size:13px;">ÊöÇÊó†Â∑≤Ëß£ÈîÅÁöÑÂæΩÁ´†</p>';
          }

          // --- ÊòæÁ§∫Èù¢Êùø ---
          document.getElementById("intimacy-panel").classList.add("visible");
        }

        /**
         * ÈÄâÊã©Âπ∂‰Ω©Êà¥‰∏Ä‰∏™‰∫≤ÂØÜÂæΩÁ´†
         * @param {string} chatId - ËßíËâ≤ID
         * @param {string} symbol - Ë¶Å‰Ω©Êà¥ÁöÑÂæΩÁ´†Á¨¶Âè∑ÔºåÊàñ''Ë°®Á§∫‰∏ç‰Ω©Êà¥
         */
        async function selectIntimacyBadge(chatId, symbol) {
          const chat = state.chats[chatId];
          if (!chat) return;

          // Êõ¥Êñ∞ÈÄâÊã©
          chat.settings.selectedIntimacyBadge = symbol;

          // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
          await db.chats.put(chat);

          // ÈáçÊñ∞Ê∏≤ÊüìÈù¢ÊùøÔºåÊõ¥Êñ∞È´ò‰∫ÆÁä∂ÊÄÅ
          await openIntimacyPanel(chatId);

          // ÈáçÊñ∞Ê∏≤ÊüìËÅäÂ§©ÂàóË°®ÔºåËÆ©ÂæΩÁ´†Á´ãÂàªÊòæÁ§∫Âá∫Êù•
          await renderChatList();
        }

        /**
         * Ê†∏ÂøÉÔºö‰∏∫ÊåáÂÆöËÅäÂ§©ÁöÑ‰ªäÂ§©Ê∂àÊÅØÊï∞+1
         * @param {string} chatId - ËÅäÂ§©ID
         */
        async function incrementMessageCount(chatId) {
          const chat = state.chats[chatId];
          // Âè™‰∏∫Âçï‰∫∫ËÅäÂ§©ËÆ°Êï∞
          if (!chat || chat.isGroup) return;

          const today = new Date().toISOString().split("T")[0]; // Ëé∑Âèñ YYYY-MM-DD Ê†ºÂºèÁöÑÊó•Êúü

          if (!chat.interactionStats) {
            chat.interactionStats = {};
          }

          chat.interactionStats[today] =
            (chat.interactionStats[today] || 0) + 1;

          // Â∞ÜÊõ¥Êñ∞ÂêéÁöÑËÅäÂ§©Êï∞ÊçÆ‰øùÂ≠òÂõûÊï∞ÊçÆÂ∫ì
          await db.chats.put(chat);
        }

        /**
         * Ëé∑ÂèñÊàñÁîüÊàêÂΩìÂâçËÆæÂ§áÁöÑÂîØ‰∏ÄËÆæÂ§áÁ†Å
         * @returns {string} - ‰∏ÄÈïø‰∏≤ÂîØ‰∏ÄÁöÑËÆæÂ§áÁ†Å
         */
        function getDeviceCode() {
          const deviceIdKey = "ephone-device-code"; // ‰ΩøÁî®‰∏Ä‰∏™Êñ∞ÁöÑÈîÆÂêç
          let deviceId = localStorage.getItem(deviceIdKey);
          if (!deviceId) {
            deviceId = crypto.randomUUID();
            localStorage.setItem(deviceIdKey, deviceId);
          }
          return deviceId;
        }

        /**
         * Ê†πÊçÆËÆæÂ§áÁ†ÅÁîüÊàêÂØπÂ∫îÁöÑPINÁ†Å (Ëøô‰∏™ÂáΩÊï∞ÂøÖÈ°ªÂíå get_pin.html ‰∏≠ÁöÑÂÆåÂÖ®‰∏ÄËá¥ÔºÅ)
         * @param {string} deviceCode - ËÆæÂ§áÁ†Å
         * @returns {string} - 6‰ΩçÂ§ßÂÜôÁöÑPINÁ†Å
         */
        function generatePinFromDeviceCode(deviceCode) {
          if (!deviceCode || deviceCode.length < 6) return "INVALID";
          // ÁÆóÊ≥ïÔºöÂ∞ÜËÆæÂ§áÁ†ÅÂèçËΩ¨ÔºåÂèñÂâç6‰ΩçÔºåËΩ¨Â§ßÂÜô
          return deviceCode
            .split("")
            .reverse()
            .join("")
            .substring(0, 6)
            .toUpperCase();
        }
        /**
         * Ê∏ÖÁ©∫ÊâÄÊúâÂ•ΩÂèãÂä®ÊÄÅÔºà‰∏çÂåÖÊã¨ÂæÆÂçöÂíåÂúàÂ≠êÔºâ
         */
        async function clearAllQzonePosts() {
          // 1. ÂºπÂá∫Á°ÆËÆ§Ê°ÜÔºåÈò≤Ê≠¢Áî®Êà∑ËØØÊìç‰Ωú
          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Ê∏ÖÁ©∫",
            "Ê≠§Êìç‰ΩúÂ∞ÜÊ∞∏‰πÖÂà†Èô§ÊâÄÊúâÂ•ΩÂèãÂä®ÊÄÅÔºà‰∏çÂåÖÊã¨ÂæÆÂçöÂíåÂúàÂ≠êÔºâÔºå‰∏îÊó†Ê≥ïÊÅ¢Â§ç„ÄÇÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü",
            { confirmButtonClass: "btn-danger" }, // ‰ΩøÁî®Á∫¢Ëâ≤ÊåâÈíÆË≠¶Á§∫
          );

          if (!confirmed) {
            return; // Â¶ÇÊûúÁî®Êà∑ÁÇπÂáª‚ÄúÂèñÊ∂à‚ÄùÔºåÂàô‰∏çÊâßË°å‰ªª‰ΩïÊìç‰Ωú
          }

          try {
            // 2. Ê∏ÖÁ©∫Êï∞ÊçÆÂ∫ì‰∏≠ÁöÑ `qzonePosts` Ë°®ÔºåËøôÊòØÂ≠òÂÇ®ÊâÄÊúâÂä®ÊÄÅÁöÑÂú∞Êñπ
            await db.qzonePosts.clear();
            console.log("`qzonePosts` table has been cleared.");

            // 3. Ê∏ÖÁêÜÊâÄÊúâËßíËâ≤ÁöÑÂéÜÂè≤ËÆ∞ÂΩïÔºåÁßªÈô§‰∏éÂä®ÊÄÅÁõ∏ÂÖ≥ÁöÑÁ≥ªÁªüÈÄöÁü•Ôºå‰øùÊåÅÊï∞ÊçÆ‰∏ÄËá¥ÊÄß
            const allChats = Object.values(state.chats);
            const chatsToUpdate = [];
            for (const chat of allChats) {
              const originalHistoryLength = chat.history.length;
              // Á≠õÈÄâÊéâÂÜÖÂÆπÂåÖÂê´‚ÄúÂèëÂ∏É‰∫Ü‚ÄùÁöÑÁ≥ªÁªüÊ∂àÊÅØ
              chat.history = chat.history.filter(
                (msg) =>
                  !(
                    msg.role === "system" &&
                    msg.content &&
                    msg.content.includes("ÂèëÂ∏É‰∫Ü")
                  ),
              );
              if (chat.history.length < originalHistoryLength) {
                chatsToUpdate.push(chat);
              }
            }
            if (chatsToUpdate.length > 0) {
              await db.chats.bulkPut(chatsToUpdate);
              console.log(
                `Â∑≤‰ªé ${chatsToUpdate.length} ‰∏™ËßíËâ≤ÁöÑÂéÜÂè≤ËÆ∞ÂΩï‰∏≠ÁßªÈô§Âä®ÊÄÅÈÄöÁü•„ÄÇ`,
              );
            }

            // 4. ÈáçÊñ∞Ê∏≤ÊüìÂä®ÊÄÅÂàóË°®ÔºåÁïåÈù¢‰ºöÊòæÁ§∫‰∏∫Á©∫
            await renderQzonePosts();

            // 5. ÁªôÂá∫ÊàêÂäüÊèêÁ§∫
            alert("ÊâÄÊúâÂ•ΩÂèãÂä®ÊÄÅÂ∑≤Ê∏ÖÁ©∫ÔºÅ");
          } catch (error) {
            console.error("Ê∏ÖÁ©∫Â•ΩÂèãÂä®ÊÄÅÊó∂Âá∫Èîô:", error);
            await showCustomAlert(
              "Êìç‰ΩúÂ§±Ë¥•",
              `Ê∏ÖÁ©∫Âä®ÊÄÅÊó∂ÂèëÁîüÈîôËØØ: ${error.message}`,
            );
          }
        }

        /**
         * ÂàáÊç¢‰∏ñÁïå‰π¶ÁöÑÁºñËæëÊ®°Âºè
         */
        async function toggleWorldBookEditMode() {
          isWorldBookEditMode = !isWorldBookEditMode;

          const screen = document.getElementById("world-book-screen");
          const listEl = document.getElementById("world-book-list");
          const editBtn = document.getElementById(
            "toggle-world-book-edit-mode-btn",
          );
          const manageBtn = document.getElementById(
            "manage-categories-in-edit-mode-btn",
          );
          const addBtn = document.getElementById("add-world-book-btn");
          const importBtn = document.getElementById("import-world-book-btn");

          const deleteBtn = document.getElementById(
            "world-book-delete-selected-btn",
          );

          screen.classList.toggle("selection-mode", isWorldBookEditMode);
          listEl.classList.toggle("selection-mode", isWorldBookEditMode);

          if (isWorldBookEditMode) {
            editBtn.textContent = "ÂÆåÊàê";
            manageBtn.style.display = "inline-block";
            deleteBtn.style.display = "inline-flex"; // ËÆ©Âà†Èô§ÊåâÈíÆÊòæÁ§∫
            addBtn.style.display = "none";
            importBtn.style.display = "none";
          } else {
            editBtn.textContent = "ÁºñËæëÊ®°Âºè";
            manageBtn.style.display = "none";
            deleteBtn.style.display = "none"; // ËÆ©Âà†Èô§ÊåâÈíÆÈöêËóè
            addBtn.style.display = "inline-block";
            importBtn.style.display = "inline-block";
            selectedWorldBooks.clear();
            updateWorldBookDeleteButton();
          }

          await renderWorldBookScreen();
        }

        /**
         * Â§ÑÁêÜ‰∏ñÁïå‰π¶ÂàóË°®È°πÁöÑÁÇπÂáª‰∫ã‰ª∂ÔºàÂÖºÂÆπÊôÆÈÄöÊ®°ÂºèÂíåÁºñËæëÊ®°ÂºèÔºâ
         */
        function handleWorldBookListClick(e) {
          const item = e.target.closest(".list-item");
          if (!item) return;

          const bookId = item.dataset.bookId;
          if (!bookId) return;

          if (isWorldBookEditMode) {
            // ÁºñËæëÊ®°ÂºèÔºöÂ§ÑÁêÜÈÄâÊã©/ÂèñÊ∂àÈÄâÊã©
            item.classList.toggle("selected");
            if (selectedWorldBooks.has(bookId)) {
              selectedWorldBooks.delete(bookId);
            } else {
              selectedWorldBooks.add(bookId);
            }
            updateWorldBookDeleteButton();
          } else {
            // ÊôÆÈÄöÊ®°ÂºèÔºöÊâìÂºÄÁºñËæëÂô®
            openWorldBookEditor(bookId);
          }
        }

        /**
         * Êõ¥Êñ∞Â§¥ÈÉ®Âà†Èô§ÊåâÈíÆÁöÑÁä∂ÊÄÅÂíåËÆ°Êï∞
         */
        function updateWorldBookDeleteButton() {
          const deleteBtn = document.getElementById(
            "world-book-delete-selected-btn",
          );
          const countSpan = document.getElementById("world-book-delete-count");
          const count = selectedWorldBooks.size;

          // Êõ¥Êñ∞ÊåâÈíÆÊóÅËæπÁöÑÊï∞Â≠ó
          if (count > 0) {
            countSpan.textContent = `(${count})`;
          } else {
            countSpan.textContent = "";
          }

          // ÂàáÊç¢ÊåâÈíÆÁöÑÁ¶ÅÁî®Áä∂ÊÄÅ
          deleteBtn.disabled = count === 0;
        }

        /**
         * Â§ÑÁêÜÊâπÈáèÂà†Èô§‰∏ñÁïå‰π¶ÁöÑÈÄªËæë
         */
        async function handleBulkDeleteWorldBooks() {
          if (selectedWorldBooks.size === 0) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§Âà†Èô§",
            `Á°ÆÂÆöË¶ÅÊ∞∏‰πÖÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${selectedWorldBooks.size} Êú¨‰∏ñÁïå‰π¶ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            const idsToDelete = Array.from(selectedWorldBooks);
            await db.worldBooks.bulkDelete(idsToDelete);

            state.worldBooks = state.worldBooks.filter(
              (wb) => !idsToDelete.includes(wb.id),
            );

            // ÈÄÄÂá∫ÁºñËæëÊ®°Âºè
            await toggleWorldBookEditMode();

            await showCustomAlert(
              "Âà†Èô§ÊàêÂäü",
              `${idsToDelete.length} Êú¨‰∏ñÁïå‰π¶Â∑≤Âà†Èô§„ÄÇ`,
            );
          }
        }

        /**
         * Âà†Èô§‰∏Ä‰∏™‰∏ñÁïå‰π¶ÂàÜÁ±ªÔºàÁé∞Âú®‰ºöÂºπÂá∫ÈÄâÈ°πÔºâ
         */
        async function deleteCategory(categoryId) {
          const category = await db.worldBookCategories.get(categoryId);
          if (!category) return;

          const choice = await showChoiceModal(`Âà†Èô§ÂàÜÁ±ª "${category.name}"`, [
            { text: "Âà†Èô§ÂàÜÁ±ªÂèäÂÖ∂ÊâÄÊúâ‰∏ñÁïå‰π¶", value: "delete_all" },
            {
              text: "‰ªÖÂà†Èô§ÂàÜÁ±ª (‰π¶Âèò‰∏∫Êú™ÂàÜÁ±ª)",
              value: "delete_category_only",
            },
          ]);

          if (!choice) return;

          if (choice === "delete_all") {
            const confirmed = await showCustomConfirm(
              "Âç±Èô©Êìç‰Ωú",
              `‰Ω†Á°ÆÂÆöË¶ÅÊ∞∏‰πÖÂà†Èô§ÂàÜÁ±ª "${category.name}" ‰ª•ÂèäÂÖ∂‰∏≠ÁöÑ„ÄêÊâÄÊúâ„Äë‰∏ñÁïå‰π¶ÂêóÔºüÊ≠§Êìç‰ΩúÊó†Ê≥ïÊÅ¢Â§çÔºÅ`,
              { confirmButtonClass: "btn-danger" },
            );
            if (!confirmed) return;

            const booksToDelete = await db.worldBooks
              .where("categoryId")
              .equals(categoryId)
              .toArray();
            const bookIdsToDelete = booksToDelete.map((book) => book.id);
            if (bookIdsToDelete.length > 0) {
              await db.worldBooks.bulkDelete(bookIdsToDelete);
              state.worldBooks = state.worldBooks.filter(
                (wb) => !bookIdsToDelete.includes(wb.id),
              );
            }
            await db.worldBookCategories.delete(categoryId);
            await showCustomAlert(
              "Âà†Èô§ÊàêÂäü",
              `ÂàÜÁ±ª "${category.name}" ÂèäÂÖ∂‰∏ãÁöÑÊâÄÊúâ‰∏ñÁïå‰π¶Â∑≤Ë¢´Âà†Èô§„ÄÇ`,
            );
          } else if (choice === "delete_category_only") {
            const booksToUpdate = await db.worldBooks
              .where("categoryId")
              .equals(categoryId)
              .toArray();
            if (booksToUpdate.length > 0) {
              for (const book of booksToUpdate) {
                book.categoryId = null;
              }
              await db.worldBooks.bulkPut(booksToUpdate);
              booksToUpdate.forEach((updatedBook) => {
                const bookInState = state.worldBooks.find(
                  (wb) => wb.id === updatedBook.id,
                );
                if (bookInState) bookInState.categoryId = null;
              });
            }
            await db.worldBookCategories.delete(categoryId);
            await showCustomAlert(
              "Âà†Èô§ÊàêÂäü",
              `ÂàÜÁ±ª "${category.name}" Â∑≤Ë¢´Âà†Èô§„ÄÇ`,
            );
          }

          await renderCategoryListInManager();
          await renderWorldBookScreen();
        }

        /**
         * Ê∏≤Êüì‰∏ñÁïå‰π¶ÂàóË°®ÁöÑËæÖÂä©ÂáΩÊï∞ÔºàÁßªÈô§‰∫ÜÊóßÁöÑÁÇπÂáª‰∫ã‰ª∂ÁªëÂÆöÔºâ
         */
        function createWorldBookGroup(groupName, books) {
          const groupContainer = document.createElement("div");
          groupContainer.className = "world-book-group-container";

          groupContainer.innerHTML = `
			        <div class="world-book-group-header">
			            <span class="arrow">‚ñº</span>
			            <span class="group-name">${groupName}</span>
			        </div>
			        <div class="world-book-group-content"></div>
			    `;

          const headerEl = groupContainer.querySelector(
            ".world-book-group-header",
          );
          const contentEl = groupContainer.querySelector(
            ".world-book-group-content",
          );

          headerEl.classList.add("collapsed");
          contentEl.classList.add("collapsed");

          books.sort((a, b) => a.name.localeCompare(b.name, "en-US"));
          books.forEach((book) => {
            const item = document.createElement("div");
            item.className = "list-item";
            item.dataset.bookId = book.id;
            item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(
              book.content || "ÊöÇÊó†ÂÜÖÂÆπ..."
            ).substring(0, 50)}</div>`;

            // ÊóßÁöÑ item.addEventListener('click', ...) Â∑≤Ë¢´ÁßªÈô§ÔºåÁî±‰∫ã‰ª∂ÂßîÊâòÁªü‰∏ÄÂ§ÑÁêÜ

            addLongPressListener(item, async () => {
              const confirmed = await showCustomConfirm(
                "Âà†Èô§‰∏ñÁïå‰π¶",
                `Á°ÆÂÆöË¶ÅÂà†Èô§„Ää${book.name}„ÄãÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ`,
                { confirmButtonClass: "btn-danger" },
              );
              if (confirmed) {
                await db.worldBooks.delete(book.id);
                state.worldBooks = state.worldBooks.filter(
                  (wb) => wb.id !== book.id,
                );
                renderWorldBookScreen();
              }
            });
            contentEl.appendChild(item);
          });

          return groupContainer;
        }

        // Âø´Êç∑ÂõûÂ§çÂäüËÉΩÊ†∏ÂøÉÈÄªËæë

        /**
         * ÊâìÂºÄÂø´Êç∑ÂõûÂ§çÂºπÁ™ó
         */
        function openQuickReplyModal() {
          renderQuickReplyList();
          document.getElementById("quick-reply-modal").classList.add("visible");
        }

        /**
         * Ê∏≤ÊüìÂø´Êç∑ÂõûÂ§çÂàóË°® (Â∏¶ÁºñËæëÂäüËÉΩ)
         */
        function renderQuickReplyList() {
          const listEl = document.getElementById("quick-reply-list");
          listEl.innerHTML = "";

          const replies = state.globalSettings.quickReplies || [];

          if (replies.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color:var(--text-secondary); padding:20px;">ÂàóË°®‰∏∫Á©∫ÔºåÁÇπÂáªÂè≥‰∏äËßí "+" Ê∑ªÂä†„ÄÇ</p>';
            return;
          }

          replies.forEach((item, index) => {
            const div = document.createElement("div");
            div.className = "quick-reply-item";

            // ÂÖºÂÆπÂ§ÑÁêÜ
            let type = typeof item === "string" ? "text" : item.type;
            let content = typeof item === "string" ? item : item.content;

            // Ê†áÁ≠æÁîüÊàê
            let typeBadge = "";
            if (type === "voice_message")
              typeBadge =
                '<span style="background:#4CAF50; color:white; padding:2px 6px; border-radius:4px; font-size:12px; margin-right:5px;">ËØ≠Èü≥</span>';
            else if (type === "ai_image")
              typeBadge =
                '<span style="background:#FF9800; color:white; padding:2px 6px; border-radius:4px; font-size:12px; margin-right:5px;">ÂõæÁâá</span>';
            else if (type === "transfer")
              typeBadge =
                '<span style="background:#E91E63; color:white; padding:2px 6px; border-radius:4px; font-size:12px; margin-right:5px;">ËΩ¨Ë¥¶</span>';
            else if (type === "waimai_request")
              typeBadge =
                '<span style="background:#2196F3; color:white; padding:2px 6px; border-radius:4px; font-size:12px; margin-right:5px;">Â§ñÂçñ</span>';

            div.innerHTML = `
      <!-- Â∑¶‰æßÔºöÁÇπÂáªÂèëÈÄÅÂå∫Âüü -->
      <div class="quick-reply-content" style="flex:1; display:flex; align-items:center; overflow:hidden; cursor:pointer;" title="ÁÇπÂáªÂèëÈÄÅ">
        ${typeBadge}
        <span style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${content}</span>
      </div>
      
      <!-- Âè≥‰æßÔºöÊìç‰ΩúÊåâÈíÆÂå∫Âüü -->
      <div class="quick-reply-actions">
        <!-- ÁºñËæëÂõæÊ†á (ÈìÖÁ¨î) -->
        <span class="quick-reply-action-btn btn-edit" title="ÁºñËæë" data-index="${index}">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
        </span>
        <!-- Âà†Èô§ÂõæÊ†á (ÂûÉÂúæÊ°∂) -->
        <span class="quick-reply-action-btn btn-delete" title="Delete" data-index="${index}">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </span>
      </div>
    `;

            // ÁªëÂÆö‰∫ã‰ª∂ÔºöÂèëÈÄÅ
            div
              .querySelector(".quick-reply-content")
              .addEventListener("click", () => {
                sendQuickReply(item);
              });

            // ÁªëÂÆö‰∫ã‰ª∂ÔºöÁºñËæë
            div.querySelector(".btn-edit").addEventListener("click", (e) => {
              e.stopPropagation(); // Èò≤Ê≠¢Ëß¶ÂèëÂèëÈÄÅ
              editQuickReply(index);
            });

            // ÁªëÂÆö‰∫ã‰ª∂ÔºöÂà†Èô§
            div.querySelector(".btn-delete").addEventListener("click", (e) => {
              e.stopPropagation(); // Èò≤Ê≠¢Ëß¶ÂèëÂèëÈÄÅ
              deleteQuickReply(index);
            });

            listEl.appendChild(div);
          });
        }
        /**
         * ÁºñËæëÂø´Êç∑ÂõûÂ§ç (ÊîØÊåÅ‰øÆÊîπÁ±ªÂûãÂíåÂÜÖÂÆπ)
         */
        async function editQuickReply(index) {
          const item = state.globalSettings.quickReplies[index];

          // 1. Ëé∑ÂèñÊóßÂÜÖÂÆπÔºå‰Ωú‰∏∫ÈªòËÆ§ÂÄºÂ°´ÂÖÖ
          const oldContent = typeof item === "string" ? item : item.content;

          const newType = await showChoiceModal("ÁºñËæë - ÈÄâÊã©Á±ªÂûã", [
            { text: "üìù ÊôÆÈÄöÊñáÊú¨", value: "text" },
            { text: "üé§ ËØ≠Èü≥Ê∂àÊÅØ", value: "voice_message" },
            { text: "üñºÔ∏è ÂõæÁâáÊèèËø∞", value: "ai_image" },
            { text: "üí∏ ËΩ¨Ë¥¶ (Â§áÊ≥®)", value: "transfer" },
            { text: "üçî Â§ñÂçñ (ÂïÜÂìÅÂêç)", value: "waimai_request" },
          ]);

          if (!newType) return; // Â¶ÇÊûúÁî®Êà∑ÂèñÊ∂àÈÄâÊã©Á±ªÂûãÔºåÂàôÂÅúÊ≠¢

          // 3. Ê†πÊçÆÈÄâÊã©ÁöÑÁ±ªÂûãËÆæÁΩÆÊèêÁ§∫ËØ≠
          let promptTitle = "ÁºñËæëÂÜÖÂÆπ";
          let promptDesc = "ËØ∑ËæìÂÖ•ÂõûÂ§çÂÜÖÂÆπ...";

          if (newType === "voice_message") {
            promptTitle = "ÁºñËæëËØ≠Èü≥ÂÜÖÂÆπ";
            promptDesc = "ËæìÂÖ•ËØ≠Èü≥ËΩ¨Êç¢ÁöÑÊñáÂ≠óÂÜÖÂÆπ";
          } else if (newType === "ai_image") {
            promptTitle = "ÁºñËæëÂõæÁâáÊèèËø∞";
            promptDesc = "ËæìÂÖ•ÂõæÁâáÁöÑÁîªÈù¢ÊèèËø∞";
          } else if (newType === "transfer") {
            promptTitle = "ÁºñËæëËΩ¨Ë¥¶Â§áÊ≥®";
            promptDesc = "ËæìÂÖ•ËΩ¨Ë¥¶ÁöÑÂ§áÊ≥®ÊñáÂ≠ó";
          } else if (newType === "waimai_request") {
            promptTitle = "ÁºñËæëÂ§ñÂçñÂïÜÂìÅ";
            promptDesc = "ËæìÂÖ•ÊÉ≥ÂêÉÁöÑÂïÜÂìÅÂêçÁß∞";
          }

          // 4. Á¨¨‰∫åÊ≠•ÔºöÂºπÂá∫ËæìÂÖ•Ê°ÜÔºåÂπ∂Â°´ÂÖ•ÊóßÂÜÖÂÆπ‰æõ‰øÆÊîπ
          const newContent = await showCustomPrompt(
            promptTitle,
            promptDesc,
            oldContent,
          );

          // 5. ‰øùÂ≠òÈÄªËæë
          if (newContent !== null && newContent.trim()) {
            // Áõ¥Êé•Ë¶ÜÁõñÊóßÂØπË±°
            state.globalSettings.quickReplies[index] = {
              type: newType,
              content: newContent.trim(),
            };

            await db.globalSettings.put(state.globalSettings);
            renderQuickReplyList(); // Âà∑Êñ∞ÂàóË°®
            // alert('‰øÆÊîπÊàêÂäüÔºÅ'); // ÂèØÈÄâÊèêÁ§∫
          }
        }

        /**
         * ÂèëÈÄÅÂø´Êç∑ÂõûÂ§ç (Ëá™Âä®ËØÜÂà´Á±ªÂûãÂπ∂Ê∏≤Êüì)
         */
        async function sendQuickReply(item) {
          if (!state.activeChatId) return;

          const chat = state.chats[state.activeChatId];
          const modal = document.getElementById("quick-reply-modal");
          const chatInput = document.getElementById("chat-input");

          // ÂÖ≥Èó≠ÂºπÁ™ó
          modal.classList.remove("visible");

          // 1. Ëß£ÊûêÊï∞ÊçÆ
          let type = "text";
          let content = "";

          if (typeof item === "string") {
            content = item;
          } else {
            type = item.type;
            content = item.content;
          }

          // 2. Â¶ÇÊûúÊòØÊôÆÈÄöÊñáÊú¨ÔºåËµ∞Ê†áÂáÜÊµÅÁ®ã (Â°´ÂÖ•ËæìÂÖ•Ê°ÜÂπ∂ÁÇπÂáªÂèëÈÄÅ)
          // ËøôÊ†∑ÂèØ‰ª•‰øùÁïôÂºïÁî®ÂõûÂ§çÁ≠âÊñáÊú¨ÁâπÊúâÁöÑÂäüËÉΩ
          if (type === "text") {
            chatInput.value = content;
            document.getElementById("send-btn").click();
            return;
          }

          // 3. Â¶ÇÊûúÊòØÁâπÊÆäÁ±ªÂûãÔºåÊâãÂä®ÊûÑÈÄ†Ê∂àÊÅØÂØπË±°Âπ∂ÂèëÈÄÅ
          // ËøôÊ†∑ÂèØ‰ª•ÈÅøÂºÄËæìÂÖ•Ê°ÜÔºåÁõ¥Êé•ÁîüÊàêÂØπÂ∫îÁöÑÂØåÊñáÊú¨Âç°Áâá

          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "Me"
            : "Me";
          const msg = {
            role: "user",
            timestamp: Date.now(),
          };

          if (type === "voice_message") {
            msg.type = "voice_message";
            msg.content = content;
          } else if (type === "ai_image") {
            // Áî®Êà∑ÂèëÈÄÅÁöÑÂõæÁâáÊèèËø∞ÔºåÁ≥ªÁªüÂÜÖÈÉ®ÈÄöÂ∏∏Ê†áËÆ∞‰∏∫ user_photo
            msg.type = "user_photo";
            msg.content = content;
          } else if (type === "transfer") {
            // ËΩ¨Ë¥¶ÈÄªËæëÔºöÈúÄË¶ÅÊâ£Ê¨æ
            const amount = 52.0; // Âø´Êç∑ËΩ¨Ë¥¶ÈªòËÆ§ÈáëÈ¢ùÔºå‰πüÂèØÊîπ‰∏∫‰ªé item ‰∏≠ËØªÂèñÊõ¥Â§çÊùÇÁöÑÈÖçÁΩÆ
            if ((state.globalSettings.userBalance || 0) < amount) {
              alert("‰ΩôÈ¢ù‰∏çË∂≥ÔºåÊó†Ê≥ïÂèëÈÄÅÂø´Êç∑ËΩ¨Ë¥¶ÔºÅ");
              return;
            }
            // Êâ£Ê¨æ
            await updateUserBalanceAndLogTransaction(
              -amount,
              `Âø´Êç∑ËΩ¨Ë¥¶Áªô ${chat.name}`,
            );

            msg.type = "transfer";
            msg.amount = amount;
            msg.note = content; // Â§áÊ≥®
            msg.senderName = myNickname;
            msg.receiverName = chat.isGroup ? "Áæ§ËÅä" : chat.name;
          } else if (type === "waimai_request") {
            // Â§ñÂçñËØ∑Ê±Ç
            msg.type = "waimai_request";
            msg.productInfo = content; // ÂïÜÂìÅÂêç
            msg.amount = 20; // ÈªòËÆ§ÈáëÈ¢ù
            msg.senderName = myNickname;
            msg.status = "pending";
            msg.countdownEndTime = Date.now() + 15 * 60 * 1000;
          }

          // 4. ‰øùÂ≠òÂπ∂Ê∏≤Êüì
          chat.history.push(msg);
          await db.chats.put(chat);

          // Ê∏≤ÊüìÂà∞ÁïåÈù¢
          appendMessage(msg, chat);
          renderChatList();

          // ÊªöÂä®Âà∞Â∫ïÈÉ®
          const messagesContainer = document.getElementById("chat-messages");
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        /**
         * Ê∑ªÂä†Êñ∞ÁöÑÂø´Êç∑ÂõûÂ§ç (Â∏¶Á±ªÂûãÈÄâÊã©)
         */
        async function addNewQuickReply() {
          // 1. ÂÖàËÆ©Áî®Êà∑ÈÄâÊã©Á±ªÂûã
          const type = await showChoiceModal("ÈÄâÊã©Ê∂àÊÅØÁ±ªÂûã", [
            { text: "üìù ÊôÆÈÄöÊñáÊú¨", value: "text" },
            { text: "üé§ ËØ≠Èü≥Ê∂àÊÅØ", value: "voice_message" },
            { text: "üñºÔ∏è ÂõæÁâáÊèèËø∞", value: "ai_image" },
            { text: "üí∏ ËΩ¨Ë¥¶ (Â§áÊ≥®)", value: "transfer" },
            { text: "üçî Â§ñÂçñ (ÂïÜÂìÅÂêç)", value: "waimai_request" },
          ]);

          if (!type) return; // Áî®Êà∑ÂèñÊ∂à

          // 2. Ê†πÊçÆÁ±ªÂûãËÆæÁΩÆÊèêÁ§∫ËØ≠
          let promptTitle = "ËæìÂÖ•ÂÜÖÂÆπ";
          let promptDesc = "ËØ∑ËæìÂÖ•ÂõûÂ§çÂÜÖÂÆπ...";

          if (type === "voice_message") {
            promptTitle = "Ê∑ªÂä†ËØ≠Èü≥";
            promptDesc = "ËæìÂÖ•ËØ≠Èü≥ËΩ¨Êç¢ÁöÑÊñáÂ≠óÂÜÖÂÆπ";
          } else if (type === "ai_image") {
            promptTitle = "Ê∑ªÂä†ÂõæÁâá";
            promptDesc = "ËæìÂÖ•ÂõæÁâáÁöÑÁîªÈù¢ÊèèËø∞";
          } else if (type === "transfer") {
            promptTitle = "Ê∑ªÂä†ËΩ¨Ë¥¶Â§áÊ≥®";
            promptDesc = "ËæìÂÖ•ËΩ¨Ë¥¶ÁöÑÂ§áÊ≥®ÊñáÂ≠ó (ÈªòËÆ§52ÂÖÉ)";
          } else if (type === "waimai_request") {
            promptTitle = "Ê∑ªÂä†Â§ñÂçñ";
            promptDesc = "ËæìÂÖ•ÊÉ≥ÂêÉÁöÑÂïÜÂìÅÂêçÁß∞ (ÈªòËÆ§20ÂÖÉ)";
          }

          // 3. ÂºπÂá∫ËæìÂÖ•Ê°Ü
          const content = await showCustomPrompt(promptTitle, promptDesc);

          if (content && content.trim()) {
            if (!state.globalSettings.quickReplies)
              state.globalSettings.quickReplies = [];

            // ‰øùÂ≠ò‰∏∫ÂØπË±°ÁªìÊûÑ
            state.globalSettings.quickReplies.push({
              type: type,
              content: content.trim(),
            });

            await db.globalSettings.put(state.globalSettings);
            renderQuickReplyList();
          }
        }

        /**
         * Âà†Èô§Âø´Êç∑ÂõûÂ§ç
         */
        async function deleteQuickReply(index) {
          // ‰∏çÈúÄË¶ÅÂºπÁ™óÁ°ÆËÆ§ÔºåÊèêÂçáÊìç‰ΩúÊïàÁéáÔºåÊàñËÄÖ‰øùÁïôÁ°ÆËÆ§Áúã‰Ω†ÂñúÂ•Ω
          // const confirmed = await showCustomConfirm('Á°ÆËÆ§Âà†Èô§', 'Á°ÆÂÆöË¶ÅÂà†Èô§ÂêóÔºü', {confirmButtonClass: 'btn-danger'});
          // if (confirmed) { ... }

          state.globalSettings.quickReplies.splice(index, 1);
          await db.globalSettings.put(state.globalSettings);
          renderQuickReplyList();
        }

        /**
         * ÂØºÂá∫Âø´Êç∑ÂõûÂ§ç
         */
        function exportQuickReplies() {
          const replies = state.globalSettings.quickReplies || [];
          const blob = new Blob([JSON.stringify(replies, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `EPhone-QuickReplies-${new Date().toISOString().split("T")[0]}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }

        /**
         * ÂØºÂÖ•Âø´Êç∑ÂõûÂ§ç
         */
        function importQuickReplies(file) {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (Array.isArray(data)) {
                if (!state.globalSettings.quickReplies)
                  state.globalSettings.quickReplies = [];

                // ÁÆÄÂçïÁöÑÊï∞ÊçÆÊ∏ÖÊ¥óÔºåÂÖºÂÆπÊóßÁöÑÂ≠óÁ¨¶‰∏≤Êï∞ÁªÑ
                const cleanedData = data.map((item) => {
                  if (typeof item === "string")
                    return { type: "text", content: item };
                  return item;
                });

                // ÂêàÂπ∂
                state.globalSettings.quickReplies.push(...cleanedData);

                await db.globalSettings.put(state.globalSettings);
                renderQuickReplyList();
                alert(`ÊàêÂäüÂØºÂÖ• ${cleanedData.length} Êù°Âø´Êç∑ÂõûÂ§ç„ÄÇ`);
              } else {
                alert("Êñá‰ª∂Ê†ºÂºè‰∏çÊ≠£Á°Æ„ÄÇ");
              }
            } catch (error) {
              alert("ÂØºÂÖ•Â§±Ë¥•Ôºö" + error.message);
            }
          };
          reader.readAsText(file);
        }

        /* Êó∂Èó¥ËΩ¥/Â≠òÊ°£ÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞ */

        /**
         * ÊâìÂºÄÊó∂Èó¥ËΩ¥ÁÆ°ÁêÜÂºπÁ™ó
         */
        function openBranchingModal() {
          if (!state.activeChatId) return;
          renderBranchList();
          document.getElementById("branching-modal").classList.add("visible");
        }

        /**
         * Ê∏≤ÊüìÂ≠òÊ°£ÂàóË°®
         */
        function renderBranchList() {
          const chat = state.chats[state.activeChatId];
          const listEl = document.getElementById("branch-list");
          listEl.innerHTML = "";

          if (!chat.checkpoints || chat.checkpoints.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color:#999; padding:20px;">ÊöÇÊó†Â≠òÊ°£ËÆ∞ÂΩï</p>';
            return;
          }

          // ÊåâÊó∂Èó¥ÂÄíÂ∫èÊéíÂàó
          const sortedCheckpoints = [...chat.checkpoints].sort(
            (a, b) => b.timestamp - a.timestamp,
          );

          sortedCheckpoints.forEach((cp) => {
            const dateStr = new Date(cp.timestamp).toLocaleString();
            const item = document.createElement("div");
            item.className = "branch-item";

            // Ëé∑ÂèñÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØ‰Ωú‰∏∫È¢ÑËßà
            const lastMsg =
              cp.history.length > 0
                ? cp.history[cp.history.length - 1].content
                : "Êó†ËÆ∞ÂΩï";
            const previewText =
              typeof lastMsg === "string"
                ? lastMsg.substring(0, 20)
                : "[ÁâπÊÆäÊ∂àÊÅØ]";

            item.innerHTML = `
            <div class="branch-info">
                <div class="branch-name">${cp.name}</div>
                <div class="branch-meta">${dateStr} ¬∑ ${cp.history.length}Êù°ËÆ∞ÂΩï</div>
                <div class="branch-meta" style="margin-top:2px;">Êú´Âè•: ${previewText}...</div>
            </div>
            <div class="branch-actions">
                <button class="branch-action-btn branch-load" onclick="loadBranchCheckpoint('${cp.id}')">ËØªÂèñ</button>
                <button class="branch-action-btn branch-delete" onclick="deleteBranchCheckpoint('${cp.id}')">Delete</button>
            </div>
        `;
            listEl.appendChild(item);
          });
        }

        /* Êó∂Èó¥ËΩ¥/Â≠òÊ°£ÂäüËÉΩÊ†∏ÂøÉÂáΩÊï∞ (Â∏¶ÂøÉÂ£∞Êï∞ÊçÆ) */

        /**
         * ÊâìÂºÄÊó∂Èó¥ËΩ¥ÁÆ°ÁêÜÂºπÁ™ó
         */
        function openBranchingModal() {
          if (!state.activeChatId) return;
          renderBranchList();
          document.getElementById("branching-modal").classList.add("visible");
        }

        /**
         * Ê∏≤ÊüìÂ≠òÊ°£ÂàóË°® (‰øùÊåÅ‰∏çÂèò)
         */
        function renderBranchList() {
          const chat = state.chats[state.activeChatId];
          const listEl = document.getElementById("branch-list");
          listEl.innerHTML = "";

          if (!chat.checkpoints || chat.checkpoints.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color:#999; padding:20px;">ÊöÇÊó†Â≠òÊ°£ËÆ∞ÂΩï</p>';
            return;
          }

          // ÊåâÊó∂Èó¥ÂÄíÂ∫èÊéíÂàó
          const sortedCheckpoints = [...chat.checkpoints].sort(
            (a, b) => b.timestamp - a.timestamp,
          );

          sortedCheckpoints.forEach((cp) => {
            const dateStr = new Date(cp.timestamp).toLocaleString();
            const item = document.createElement("div");
            item.className = "branch-item"; // Á°Æ‰øù‰Ω†ÁöÑCSSÈáåÊúâËøô‰∏™Á±ª

            // Ëé∑ÂèñÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØ‰Ωú‰∏∫È¢ÑËßà
            const lastMsg =
              cp.history.length > 0
                ? cp.history[cp.history.length - 1].content
                : "Êó†ËÆ∞ÂΩï";
            let previewText =
              typeof lastMsg === "string"
                ? lastMsg.substring(0, 20)
                : "[ÁâπÊÆäÊ∂àÊÅØ]";

            // Ëé∑ÂèñÂøÉÂ£∞È¢ÑËßà (Â¶ÇÊûúÊúâ)
            if (cp.latestInnerVoice && cp.latestInnerVoice.thoughts) {
              previewText += ` | ÂøÉÂ£∞: ${cp.latestInnerVoice.thoughts.substring(0, 10)}...`;
            }

            item.innerHTML = `
            <div class="branch-info">
                <div class="branch-name">${cp.name}</div>
                <div class="branch-meta">${dateStr} ¬∑ ${cp.history.length}Êù°ËÆ∞ÂΩï</div>
                <div class="branch-meta" style="margin-top:2px; color:#aaa;">${previewText}</div>
            </div>
            <div class="branch-actions">
                <button class="branch-action-btn branch-load" onclick="loadBranchCheckpoint('${cp.id}')">ËØªÂèñ</button>
                <button class="branch-action-btn branch-delete" onclick="deleteBranchCheckpoint('${cp.id}')">Delete</button>
            </div>
        `;
            listEl.appendChild(item);
          });
        }

        /**
         * ÂàõÂª∫ÂΩìÂâçËøõÂ∫¶ÁöÑÂ≠òÊ°£ (Â∑≤Âä†ÂÖ•ÂøÉÂ£∞‰øùÂ≠ò)
         */
        async function createBranchCheckpoint() {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const defaultName = `Â≠òÊ°£‰∫é ${new Date().toLocaleTimeString()}`;
          const name = await showCustomPrompt(
            "Êñ∞Âª∫Â≠òÊ°£",
            "ÁªôËøô‰∏™ËäÇÁÇπËµ∑‰∏™ÂêçÂ≠óÂêß",
            defaultName,
          );

          if (name) {
            const newCheckpoint = {
              id: "cp_" + Date.now(),
              name: name.trim(),
              timestamp: Date.now(),
              // 1. ‰øùÂ≠òËÅäÂ§©ÂéÜÂè≤
              history: JSON.parse(JSON.stringify(chat.history)),

              innerVoiceHistory: JSON.parse(
                JSON.stringify(chat.innerVoiceHistory || []),
              ),

              latestInnerVoice: chat.latestInnerVoice
                ? JSON.parse(JSON.stringify(chat.latestInnerVoice))
                : null,
            };

            chat.checkpoints.push(newCheckpoint);
            await db.chats.put(chat);
            renderBranchList();
            alert("Â≠òÊ°£ÊàêÂäüÔºÅ(ÂåÖÂê´ÂøÉÂ£∞)");
          }
        }

        /**
         * ËØªÂèñÂ≠òÊ°£ (Â∑≤Âä†ÂÖ•ÂøÉÂ£∞ÊÅ¢Â§ç)
         */
        window.loadBranchCheckpoint = async function (checkpointId) {
          const chat = state.chats[state.activeChatId];
          const checkpoint = chat.checkpoints.find(
            (cp) => cp.id === checkpointId,
          );

          if (!checkpoint) return;

          const confirmed = await showCustomConfirm(
            "Á°ÆËÆ§ËØªÂèñ",
            `Á°ÆÂÆöË¶ÅËØªÂèñÂ≠òÊ°£‚Äú${checkpoint.name}‚ÄùÂêóÔºü\n\n‚ö†Ô∏è Ê≥®ÊÑèÔºöËØªÂèñÂêéÔºåÂΩìÂâçÁöÑÊú™‰øùÂ≠òËøõÂ∫¶Â∞Ü‰ºö‰∏¢Â§±ÔºÅ`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            // 1. ÊÅ¢Â§çËÅäÂ§©ÂéÜÂè≤
            chat.history = JSON.parse(JSON.stringify(checkpoint.history));

            // 2. ÊÅ¢Â§çÂøÉÂ£∞ÂéÜÂè≤
            chat.innerVoiceHistory = JSON.parse(
              JSON.stringify(checkpoint.innerVoiceHistory || []),
            );

            // 3. ÊÅ¢Â§çÂΩìÂâçÂøÉÂ£∞Áä∂ÊÄÅ
            chat.latestInnerVoice = checkpoint.latestInnerVoice
              ? JSON.parse(JSON.stringify(checkpoint.latestInnerVoice))
              : null;

            await db.chats.put(chat);
            renderChatInterface(state.activeChatId); // Âà∑Êñ∞ËÅäÂ§©ÁïåÈù¢

            // Ëøô‰∏ÄÊ≠•ÂæàÈáçË¶ÅÔºöËôΩÁÑ∂Êàë‰ª¨Êõ¥Êñ∞‰∫ÜÊï∞ÊçÆÔºå‰ΩÜÂøÉÂ£∞Èù¢ÊùøÂèØËÉΩËøòÊòØÊòæÁ§∫ÊóßÁöÑ„ÄÇ
            // Êàë‰ª¨‰∏çÈúÄË¶ÅÂº∫Âà∂ÊâìÂºÄÈù¢ÊùøÔºå‰ΩÜÂ¶ÇÊûúÈù¢ÊùøÊòØÂºÄÁùÄÁöÑÔºåÊàë‰ª¨Â∫îËØ•Âà∑Êñ∞ÂÆÉ„ÄÇ
            // ÊúÄÁÆÄÂçïÁöÑÊñπÊ≥ïÊòØÂÖ≥Èó≠Âπ∂ÈáçÊñ∞ÊâìÂºÄ‰∏Ä‰∏ãÔºåÊàñËÄÖÁõ¥Êé•Êõ¥Êñ∞DOMÔºàÂ¶ÇÊûúÊ≠§Êó∂‰Ω†ÂÜô‰∫ÜupdateInnerVoiceUIÂáΩÊï∞Ôºâ
            // ËøôÈáåÊàë‰ª¨‰∏çÂÅöÈ¢ùÂ§ñÊìç‰ΩúÔºåÂõ†‰∏∫Áî®Êà∑‰∏ãÊ¨°ÊâìÂºÄÈù¢ÊùøÊó∂‰ºöËá™Âä®ËØªÂèñÊúÄÊñ∞ÁöÑ chat.latestInnerVoice„ÄÇ

            document
              .getElementById("branching-modal")
              .classList.remove("visible"); // ÂÖ≥Èó≠ÂºπÁ™ó
            alert(`Â∑≤ÂõûÊ∫ØËá≥Ôºö${checkpoint.name}`);
          }
        };

        /**
         * Âà†Èô§Â≠òÊ°£ (‰øùÊåÅ‰∏çÂèò)
         */
        window.deleteBranchCheckpoint = async function (checkpointId) {
          const chat = state.chats[state.activeChatId];
          const confirmed = await showCustomConfirm(
            "Âà†Èô§Â≠òÊ°£",
            "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Â≠òÊ°£ÂêóÔºü‰∏çÂèØÊÅ¢Â§ç„ÄÇ",
            {
              confirmButtonClass: "btn-danger",
            },
          );

          if (confirmed) {
            chat.checkpoints = chat.checkpoints.filter(
              (cp) => cp.id !== checkpointId,
            );
            await db.chats.put(chat);
            renderBranchList();
          }
        };

        /**
         * ÈáçÂºÄÊñ∞ÂâßÊÉÖ (Â∑≤Âä†ÂÖ•ÂøÉÂ£∞Ê∏ÖÁ©∫)
         */
        async function restartChatBranch() {
          const chat = state.chats[state.activeChatId];

          const confirmed = await showCustomConfirm(
            "ÈáçÂºÄÊñ∞ÂâßÊÉÖ",
            "Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÂΩìÂâçÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩïÔºåÂºÄÂßã‰∏ÄÊù°Êñ∞ÁöÑÊïÖ‰∫ãÁ∫øÂêóÔºü\nËøô‰πü‰ºöÊ∏ÖÁ©∫ÂΩìÂâçÁöÑÊâÄÊúâÂøÉÂ£∞ËÆ∞ÂΩï„ÄÇ\n\n‚ö†Ô∏è Âª∫ËÆÆÂÖàÁÇπÂè≥‰∏äËßí‰øùÂ≠òÂΩìÂâçËøõÂ∫¶‰∏∫Â≠òÊ°£ÔºÅ",
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            // 1. Ê∏ÖÁ©∫ËÅäÂ§©ÂéÜÂè≤
            chat.history = [];

            // 2. Ê∏ÖÁ©∫ÂøÉÂ£∞ÂéÜÂè≤
            chat.innerVoiceHistory = [];

            // 3. Ê∏ÖÁ©∫ÂΩìÂâçÂøÉÂ£∞
            chat.latestInnerVoice = null;

            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
            document
              .getElementById("branching-modal")
              .classList.remove("visible");

            alert("Â∑≤ÈáçÁΩÆÔºåÊñ∞ÁöÑÊïÖ‰∫ãÂºÄÂßã‰∫Ü„ÄÇ");
          }
        }

        /**
         * Âà†Èô§Â≠òÊ°£
         */
        window.deleteBranchCheckpoint = async function (checkpointId) {
          const chat = state.chats[state.activeChatId];
          const confirmed = await showCustomConfirm(
            "Âà†Èô§Â≠òÊ°£",
            "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Â≠òÊ°£ÂêóÔºü‰∏çÂèØÊÅ¢Â§ç„ÄÇ",
            {
              confirmButtonClass: "btn-danger",
            },
          );

          if (confirmed) {
            chat.checkpoints = chat.checkpoints.filter(
              (cp) => cp.id !== checkpointId,
            );
            await db.chats.put(chat);
            renderBranchList();
          }
        };
        // --- ÊûÅÂÖâÂäüËÉΩÁä∂ÊÄÅ ---
        let auroraState = {
          active: false, // ÊòØÂê¶ÂºÄÂêØ
          mode: "video", // 'video' Êàñ 'text'
          title: "", // ‰ΩúÂìÅÂêçÁß∞ (‰æãÂ¶Ç "Ê≥∞Âù¶Â∞ºÂÖãÂè∑")
          subtitles: [], // Â≠óÂπïÊï∞ÁªÑ [{start, end, text}]
          textContent: "", // Â∞èËØ¥ÂÖ®Êñá
          lastSyncTime: 0, // ‰∏äÊ¨°ÂêåÊ≠•Êó∂Èó¥ÔºåÈò≤Ê≠¢Ëøá‰∫éÈ¢ëÁπÅ
        };

        /**
         * ÊâìÂºÄÊº´Ê∏∏ËÆæÁΩÆÂºπÁ™ó
         */
        function openAuroraSetupModal() {
          // 1. Ê∏ÖÁ©∫ÊñáÊú¨ËæìÂÖ•
          const titleInput = document.getElementById("aurora-title-input");
          if (titleInput) titleInput.value = "";

          // 2. Ê∏ÖÁ©∫ÊâÄÊúâËæìÂÖ•Ê°Ü (ÂåÖÊã¨Êñ∞Âä†ÁöÑURLÊ°Ü)
          const idsToClear = [
            "aurora-video-file",
            "aurora-sub-file-video",
            "aurora-sub-url-video",
            "aurora-text-file",
            "aurora-text-url",
            "aurora-custom-img",
            "aurora-custom-audio",
            "aurora-sub-file-custom",
            "aurora-sub-url-custom",
          ];

          idsToClear.forEach((id) => {
            const el = document.getElementById(id);
            if (el) el.value = "";
          });

          // 3. ÈªòËÆ§ÈÄâ‰∏≠ËßÜÈ¢ëÊ®°Âºè
          const videoRadio = document.querySelector(
            'input[name="aurora-mode"][value="video"]',
          );
          if (videoRadio) videoRadio.checked = true;

          // 4. ÂàáÊç¢ÊòæÁ§∫Áä∂ÊÄÅ
          toggleAuroraInputs();

          // 5. ÊòæÁ§∫ÂºπÁ™ó
          document
            .getElementById("aurora-setup-modal")
            .classList.add("visible");
        }

        /**
         * ÂàáÊç¢ÂºπÁ™óÂÜÖÁöÑËæìÂÖ•ÊòæÁ§∫
         */
        function toggleAuroraInputs() {
          const mode = document.querySelector(
            'input[name="aurora-mode"]:checked',
          ).value;

          document.getElementById("aurora-video-inputs").style.display = "none";
          document.getElementById("aurora-text-inputs").style.display = "none";
          document.getElementById("aurora-custom-inputs").style.display =
            "none";

          if (mode === "video") {
            document.getElementById("aurora-video-inputs").style.display =
              "block";
          } else if (mode === "text") {
            document.getElementById("aurora-text-inputs").style.display =
              "block";
          } else if (mode === "custom") {
            document.getElementById("aurora-custom-inputs").style.display =
              "block";
          }
        }
        /**
         * Á°ÆËÆ§ËÆæÁΩÆÔºåÂêØÂä®Êº´Ê∏∏Êí≠ÊîæÂô®
         * (Â∑≤ÊîØÊåÅ URL ÂØºÂÖ•Â≠óÂπïÂíåTXT)
         */
        async function confirmAuroraSetup() {
          const title = document
            .getElementById("aurora-title-input")
            .value.trim();
          const mode = document.querySelector(
            'input[name="aurora-mode"]:checked',
          ).value;

          if (!title) {
            alert("ÁªôËøôÊ¨°Êº´Ê∏∏Ëµ∑‰∏™ÂêçÂ≠óÂêßÔºÅ");
            return;
          }

          // Êõ¥Êñ∞Áä∂ÊÄÅ
          auroraState = {
            active: true,
            mode: mode,
            title: title,
            subtitles: [],
            textContent: "",
            lastSyncTime: 0,
          };

          const playerOverlay = document.getElementById(
            "aurora-player-overlay",
          );
          const videoEl = document.getElementById("aurora-video-element");
          const textViewer = document.getElementById("aurora-text-viewer");
          const customViewer = document.getElementById("aurora-custom-viewer");
          const customAudio = document.getElementById(
            "aurora-custom-audio-element",
          );
          const customImg = document.getElementById("aurora-custom-bg-img");

          const statusTitle = document.getElementById("aurora-playing-title");
          const statusInfo = document.getElementById("aurora-info-status");

          // ÂÖ≥Èó≠ËÆæÁΩÆÂºπÁ™ó
          document
            .getElementById("aurora-setup-modal")
            .classList.remove("visible");

          // ÊòæÁ§∫Êí≠ÊîæÂô®
          playerOverlay.style.display = "flex";
          statusTitle.textContent = `Ê≠£Âú®Êº´Ê∏∏:„Ää${title}„Äã`;

          videoEl.style.display = "none";
          textViewer.style.display = "none";
          customViewer.style.display = "none";
          document.getElementById("aurora-save-book-btn").style.display =
            "none";
          videoEl.pause();
          customAudio.pause();

          // --- ËæÖÂä©ÂáΩÊï∞ÔºöÂ§ÑÁêÜÂ≠óÂπïÂÜÖÂÆπ ---
          const handleSubtitleContent = (content) => {
            auroraState.subtitles = parseSRT(content);
            statusInfo.textContent = `Â≠óÂπïÂ∑≤Âä†ËΩΩ`;
            // Â¶ÇÊûúÊòØËßÜÈ¢ëÊ®°ÂºèÔºåÊåÇËΩΩVTTËΩ®ÈÅì
            if (mode === "video") {
              const vttContent = "WEBVTT\n\n" + content.replace(/,/g, ".");
              const track = document.createElement("track");
              track.kind = "subtitles";
              track.label = "Chinese";
              track.srclang = "zh";
              track.default = true;
              track.src = URL.createObjectURL(
                new Blob([vttContent], { type: "text/vtt" }),
              );
              videoEl.innerHTML = "";
              videoEl.appendChild(track);
            }
          };

          if (mode === "video") {
            const videoFile =
              document.getElementById("aurora-video-file").files[0];
            const subFile = document.getElementById("aurora-sub-file-video")
              .files[0];
            const subUrl = document
              .getElementById("aurora-sub-url-video")
              .value.trim();

            if (!videoFile) {
              alert("ËØ∑ÈÄâÊã©ËßÜÈ¢ëÊñá‰ª∂ÔºÅ");
              return;
            }

            videoEl.style.display = "block";
            videoEl.src = URL.createObjectURL(videoFile);

            // ÂàùÂßã‰∏çÊòæÁ§∫Êéß‰ª∂ÔºåÁÇπÂáªËßÜÈ¢ëÂàáÊç¢ÊòæÁ§∫/ÈöêËóè
            videoEl.removeAttribute("controls");
            videoEl.onclick = () => {
              if (videoEl.hasAttribute("controls")) {
                videoEl.removeAttribute("controls");
              } else {
                videoEl.setAttribute("controls", "controls");
              }
            };

            // Â§ÑÁêÜÂ≠óÂπï (Êñá‰ª∂‰ºòÂÖàÔºåÂÖ∂Ê¨°URL)
            if (subFile) {
              const reader = new FileReader();
              reader.onload = (e) => handleSubtitleContent(e.target.result);
              reader.readAsText(subFile);
            } else if (subUrl) {
              statusInfo.textContent = "Ê≠£Âú®‰∏ãËΩΩÂ≠óÂπï...";
              fetch(subUrl)
                .then((r) => r.text())
                .then((txt) => handleSubtitleContent(txt))
                .catch(() => (statusInfo.textContent = "Â≠óÂπï‰∏ãËΩΩÂ§±Ë¥•"));
            } else {
              statusInfo.textContent = "Êó†Â≠óÂπï";
            }
          } else if (mode === "text") {
            const textFile =
              document.getElementById("aurora-text-file").files[0];
            const textUrl = document
              .getElementById("aurora-text-url")
              .value.trim();

            if (!textFile && !textUrl) {
              alert("ËØ∑ÈÄâÊã©ÊñáÊú¨Êñá‰ª∂ÊàñËæìÂÖ•ÈìæÊé•ÔºÅ");
              return;
            }
            document.getElementById("aurora-save-book-btn").style.display =
              "inline-block";
            textViewer.style.display = "block";

            // --- ËæÖÂä©ÂáΩÊï∞ÔºöÂ§ÑÁêÜÊñáÊú¨Buffer (Ëß£Á†ÅGBK/UTF8) ---
            const processTextBuffer = (buffer) => {
              let text = "";
              try {
                const decoder = new TextDecoder("utf-8", { fatal: true });
                text = decoder.decode(buffer);
              } catch (error) {
                console.log(
                  "Ê£ÄÊµãÂà∞ÈùûUTF-8ÁºñÁ†ÅÔºåÂ∞ùËØï‰ΩøÁî® GB18030 (ÂÖºÂÆπGBK/ANSI) Ëß£Á†Å...",
                );
                try {
                  const decoder = new TextDecoder("gb18030");
                  text = decoder.decode(buffer);
                } catch (err2) {
                  alert("Êä±Ê≠âÔºåÊó†Ê≥ïËØÜÂà´ËØ•Êñá‰ª∂ÁöÑÁºñÁ†ÅÊ†ºÂºè„ÄÇ");
                  return;
                }
              }
              auroraState.textContent = text;
              document.getElementById("aurora-text-body").textContent =
                auroraState.textContent;
              const statusInfo = document.getElementById("aurora-info-status");
              if (statusInfo) statusInfo.textContent = `ÊñáÊ°£Â∑≤Âä†ËΩΩ`;
            };

            if (textFile) {
              const reader = new FileReader();
              reader.onload = (e) => processTextBuffer(e.target.result);
              reader.readAsArrayBuffer(textFile);
            } else if (textUrl) {
              const statusInfo = document.getElementById("aurora-info-status");
              if (statusInfo) statusInfo.textContent = "Ê≠£Âú®‰∏ãËΩΩÊñáÊ°£...";

              fetch(textUrl)
                .then((res) => {
                  if (!res.ok) throw new Error("ÁΩëÁªúÈîôËØØ");
                  return res.arrayBuffer();
                })
                .then((buffer) => processTextBuffer(buffer))
                .catch((err) => {
                  console.error(err);
                  if (statusInfo) statusInfo.textContent = "‰∏ãËΩΩÂ§±Ë¥•";
                  alert("ÊñáÊ°£‰∏ãËΩΩÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÈìæÊé•Ë∑®ÂüüÈóÆÈ¢ò„ÄÇ");
                });
            }
          } else if (mode === "custom") {
            const imgFile =
              document.getElementById("aurora-custom-img").files[0];
            const audioFile = document.getElementById("aurora-custom-audio")
              .files[0];
            const subFile = document.getElementById("aurora-sub-file-custom")
              .files[0];
            const subUrl = document
              .getElementById("aurora-sub-url-custom")
              .value.trim();

            if (!imgFile || !audioFile) {
              alert("ÂõæÁâáÂíåÈü≥È¢ëÊñá‰ª∂ÈÉΩÊòØÂøÖÂ°´ÁöÑÂì¶ÔºÅ");
              return;
            }

            customViewer.style.display = "block";
            customImg.src = URL.createObjectURL(imgFile);
            customAudio.src = URL.createObjectURL(audioFile);

            customAudio.style.opacity = "0";
            customImg.onclick = () => {
              customAudio.style.opacity =
                customAudio.style.opacity === "0" ? "0.8" : "0";
            };

            // Â§ÑÁêÜÂ≠óÂπï (Êñá‰ª∂‰ºòÂÖàÔºåÂÖ∂Ê¨°URL)
            if (subFile) {
              const reader = new FileReader();
              reader.onload = (e) => {
                handleSubtitleContent(e.target.result);
                // ÂºÄÂêØÁõëÂê¨
                customAudio.ontimeupdate = () => {
                  const curTime = customAudio.currentTime;
                  const sub = auroraState.subtitles.find(
                    (s) => curTime >= s.start && curTime <= s.end,
                  );
                  document.getElementById(
                    "aurora-custom-subtitle-display",
                  ).textContent = sub ? sub.text : "";
                };
              };
              reader.readAsText(subFile);
            } else if (subUrl) {
              statusInfo.textContent = "Ê≠£Âú®‰∏ãËΩΩÂ≠óÂπï...";
              fetch(subUrl)
                .then((r) => r.text())
                .then((txt) => {
                  handleSubtitleContent(txt);
                  // ÂºÄÂêØÁõëÂê¨
                  customAudio.ontimeupdate = () => {
                    const curTime = customAudio.currentTime;
                    const sub = auroraState.subtitles.find(
                      (s) => curTime >= s.start && curTime <= s.end,
                    );
                    document.getElementById(
                      "aurora-custom-subtitle-display",
                    ).textContent = sub ? sub.text : "";
                  };
                })
                .catch(() => (statusInfo.textContent = "Â≠óÂπï‰∏ãËΩΩÂ§±Ë¥•"));
            } else {
              statusInfo.textContent = "Èü≥È¢ëÊó†Â≠óÂπï";
            }
          }
        }

        /**
         * Ëß£ÊûêÂ≠óÂπïÊñá‰ª∂ (ÊîØÊåÅ SRT, VTT, LRC)
         * Ëá™Âä®ËØÜÂà´Ê†ºÂºèÂπ∂ËΩ¨Êç¢‰∏∫Áªü‰∏ÄÁöÑ {start, end, text} Êï∞ÁªÑ
         */
        function parseSRT(data) {
          if (!data) return [];

          // 1. Áªü‰∏ÄÊç¢Ë°åÁ¨¶
          const normalizedData = data
            .replace(/\r\n/g, "\n")
            .replace(/\r/g, "\n")
            .trim();

          // --- LRC Ê†ºÂºèÂ§ÑÁêÜÈÄªËæë ---
          // Â¶ÇÊûúÂåÖÂê´ [mm:ss] ‰∏î‰∏çÂåÖÂê´ --> ÁÆ≠Â§¥ÔºåÂàôËÆ§‰∏∫ÊòØ LRC
          if (
            /^\[\d{1,2}:\d{1,2}/m.test(normalizedData) &&
            !normalizedData.includes("-->")
          ) {
            console.log("Ê£ÄÊµãÂà∞ LRC Ê†ºÂºèÂ≠óÂπïÔºåÊ≠£Âú®ËΩ¨Êç¢...");
            const lines = normalizedData.split("\n");
            const lrcEntries = [];
            // ÂåπÈÖç [mm:ss.xx] Êàñ [mm:ss]
            const timeRegex = /\[(\d{1,2}):(\d{1,2})(?:[.:](\d{1,3}))?\]/;

            // ÊèêÂèñÊâÄÊúâÊó∂Èó¥ÂíåÊñáÊú¨
            for (let line of lines) {
              const match = timeRegex.exec(line);
              if (match) {
                const m = parseInt(match[1], 10);
                const s = parseInt(match[2], 10);
                let ms = 0;
                if (match[3]) {
                  // Ë°•ÈΩêÊØ´Áßí‰ΩçÊï∞ÔºåÂ¶Ç .5 -> 500, .05 -> 050
                  ms = parseInt(match[3].padEnd(3, "0"), 10);
                }
                const seconds = m * 60 + s + ms / 1000;
                const text = line.replace(timeRegex, "").trim();
                if (text) {
                  lrcEntries.push({ time: seconds, text: text });
                }
              }
            }

            // ÊåâÊó∂Èó¥ÊéíÂ∫è
            lrcEntries.sort((a, b) => a.time - b.time);

            // ËΩ¨Êç¢‰∏∫ {start, end, text} Ê†ºÂºè
            // LRCÊ≤°ÊúâÁªìÊùüÊó∂Èó¥ÔºåÊää‰∏ã‰∏ÄÂè•ÁöÑÂºÄÂßãÊó∂Èó¥‰Ωú‰∏∫‰∏ä‰∏ÄÂè•ÁöÑÁªìÊùüÊó∂Èó¥
            const result = [];
            for (let i = 0; i < lrcEntries.length; i++) {
              const current = lrcEntries[i];
              const next = lrcEntries[i + 1];
              // Â¶ÇÊûúÊòØÊúÄÂêé‰∏ÄÂè•ÔºåÈªòËÆ§ÊòæÁ§∫ 5 Áßí
              const endTime = next ? next.time : current.time + 5;

              result.push({
                start: current.time,
                end: endTime,
                text: current.text,
              });
            }
            return result;
          }

          // --- SRT / VTT Ê†ºÂºèÂ§ÑÁêÜÈÄªËæë (‰øùÊåÅÂéüÊúâÂ¢ûÂº∫Áâà) ---
          // ÊîØÊåÅ VTT ÁöÑ "WEBVTT" Â§¥ÔºåÊîØÊåÅÁÇπÂè∑ÊàñÈÄóÂè∑ÁöÑÊó∂Èó¥Êà≥
          const pattern =
            /(\d{1,2}:\d{1,2}:\d{1,2}[.,]\d{1,3}) --> (\d{1,2}:\d{1,2}:\d{1,2}[.,]\d{1,3})(?:[^\n]*)\n([\s\S]*?)(?=\n\n|$|\n\d{1,2}:)/g;

          const subtitles = [];
          let match;

          while ((match = pattern.exec(normalizedData)) !== null) {
            subtitles.push({
              start: timeToSeconds(match[1]),
              end: timeToSeconds(match[2]),
              text: match[3].trim(), // ÁßªÈô§È¶ñÂ∞æÁ©∫ÁôΩ
            });
          }

          console.log(`ÊàêÂäüËß£ÊûêÂ≠óÂπïÊù°Êï∞: ${subtitles.length}`);
          return subtitles;
        }

        /**
         * Êó∂Èó¥Êà≥ËΩ¨ÁßíÊï∞
         * ÂÖºÂÆπ "00:00:00,000" Âíå "00:00:00.000"
         */
        function timeToSeconds(timeString) {
          if (!timeString) return 0;
          // Â∞ÜÈÄóÂè∑Áªü‰∏ÄÊõøÊç¢‰∏∫ÁÇπÂè∑ÔºåÊñπ‰æøÂ§ÑÁêÜ
          const normalized = timeString.replace(",", ".");
          const parts = normalized.split(":");

          // Â§ÑÁêÜ HH:MM:SS.ms
          const hours = parseInt(parts[0], 10);
          const minutes = parseInt(parts[1], 10);
          const seconds = parseFloat(parts[2]);

          return hours * 3600 + minutes * 60 + seconds;
        }

        /**
         * ÂàùÂßãÂåñÊûÅÂÖâÊí≠ÊîæÂô®ÁöÑÊãñÊãΩ
         */
        function initAuroraDrag() {
          const overlay = document.getElementById("aurora-player-overlay");
          const handle = document.getElementById("aurora-drag-handle");
          let isDragging = false;
          let startX, startY, initialLeft, initialTop;

          const startDrag = (e) => {
            isDragging = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            startX = clientX;
            startY = clientY;
            const rect = overlay.getBoundingClientRect();
            initialLeft = rect.left;
            initialTop = rect.top;
          };

          const onDrag = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const dx = clientX - startX;
            const dy = clientY - startY;
            overlay.style.transform = "none"; // Ê∏ÖÈô§Â±Ö‰∏≠
            overlay.style.left = `${initialLeft + dx}px`;
            overlay.style.top = `${initialTop + dy}px`;
          };

          const endDrag = () => {
            isDragging = false;
          };

          handle.addEventListener("mousedown", startDrag);
          document.addEventListener("mousemove", onDrag);
          document.addEventListener("mouseup", endDrag);

          handle.addEventListener("touchstart", startDrag, { passive: false });
          document.addEventListener("touchmove", onDrag, { passive: false });
          document.addEventListener("touchend", endDrag);
        }

        // ÂÖ≥Èó≠Êí≠ÊîæÂô®
        function closeAuroraPlayer() {
          document.getElementById("aurora-player-overlay").style.display =
            "none";
          document.getElementById("aurora-video-element").pause();
          // ‰πüË¶ÅÊöÇÂÅúËá™ÂÆö‰πâÈü≥È¢ë
          const customAudio = document.getElementById(
            "aurora-custom-audio-element",
          );
          if (customAudio) customAudio.pause();

          auroraState.active = false;
        }
        /* Êº´Ê∏∏‰π¶Êû∂ÂäüËÉΩÊ†∏ÂøÉÈÄªËæë */

        // 1. ÊâìÂºÄ‰π¶Êû∂ÁïåÈù¢
        async function openAuroraBookshelf() {
          // ÂÖ≥Èó≠ËÆæÁΩÆÂºπÁ™ó
          document
            .getElementById("aurora-setup-modal")
            .classList.remove("visible");
          // Ê∏≤Êüì‰π¶Êû∂
          await renderBookshelf();
          // ÊòæÁ§∫‰π¶Êû∂Â±èÂπï
          showScreen("aurora-bookshelf-screen");
        }

        // 2. Ê∏≤Êüì‰π¶Êû∂
        async function renderBookshelf() {
          const container = document.getElementById("bookshelf-container");
          container.innerHTML = "";

          // ‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÊâÄÊúâ‰π¶Á±çÔºåÊåâÊ∑ªÂä†Êó∂Èó¥ÂÄíÂ∫è
          const books = await db.auroraBooks
            .orderBy("addedAt")
            .reverse()
            .toArray();

          if (books.length === 0) {
            container.innerHTML =
              '<div class="bookshelf-row" style="justify-content:center; align-items:center; color:#8d6e63; font-size:14px;">‰π¶Êû∂Á©∫Á©∫Â¶Ç‰πü...</div>';
            return;
          }

          // ÂàÜÂ±ÇÊ∏≤ÊüìÔºåÊØèÂ±ÇÊîæ 6 Êú¨‰π¶ (‰∏∫‰∫ÜÁæéËßÇ)
          const booksPerRow = 6;
          for (let i = 0; i < books.length; i += booksPerRow) {
            const rowBooks = books.slice(i, i + booksPerRow);

            const rowDiv = document.createElement("div");
            rowDiv.className = "bookshelf-row";

            rowBooks.forEach((book) => {
              const bookEl = document.createElement("div");
              // ÈöèÊú∫ÂàÜÈÖç‰∏ÄÁßçÈ¢úËâ≤
              const colorClass = `book-color-${Math.floor(Math.random() * 5) + 1}`;
              bookEl.className = `retro-book ${colorClass}`;
              bookEl.title = book.title; // Èº†Ê†áÊÇ¨ÂÅúÊòæÁ§∫ÂÖ®Âêç
              bookEl.innerHTML = `<span class="book-spine-title">${book.title}</span>`;

              // ÁÇπÂáªÊâìÂºÄ‰π¶
              bookEl.addEventListener("click", () => loadBookFromShelf(book));

              // ÈïøÊåâÂà†Èô§
              addLongPressListener(bookEl, async () => {
                const confirmed = await showCustomConfirm(
                  "ÁßªÈô§‰π¶Á±ç",
                  `Ë¶ÅÊää„Ää${book.title}„Äã‰ªé‰π¶Êû∂‰∏äÊãøËµ∞ÂêóÔºü`,
                  {
                    confirmButtonClass: "btn-danger",
                  },
                );
                if (confirmed) {
                  await db.auroraBooks.delete(book.id);
                  await renderBookshelf();
                }
              });

              rowDiv.appendChild(bookEl);
            });

            container.appendChild(rowDiv);
          }

          // Â¶ÇÊûúÊúÄÂêé‰∏ÄË°å‰∏çÊª°Ôºå‰∏îÊÄª‰π¶‰∏çÂ§öÔºåË°•‰∏Ä‰∏™Á©∫‰π¶Êû∂ÊòæÂæóÊõ¥ÊúâÊ∞õÂõ¥
          if (books.length % booksPerRow !== 0 || books.length < 4) {
            const emptyRow = document.createElement("div");
            emptyRow.className = "bookshelf-row";
            container.appendChild(emptyRow);
          }
        }

        // 3. ‰øùÂ≠òÂΩìÂâçÊ≠£Âú®ËØªÁöÑÂ∞èËØ¥Âà∞‰π¶Êû∂
        async function saveCurrentNovelToShelf() {
          if (
            !auroraState.active ||
            auroraState.mode !== "text" ||
            !auroraState.textContent
          ) {
            alert("Ê≤°ÊúâÊ≠£Âú®ÈòÖËØªÁöÑÂ∞èËØ¥ÂÜÖÂÆπÔºÅ");
            return;
          }

          const title = auroraState.title || "Êú™ÂëΩÂêçÂ∞èËØ¥";

          // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
          const existing = await db.auroraBooks
            .where("title")
            .equals(title)
            .first();
          if (existing) {
            alert(`„Ää${title}„ÄãÂ∑≤ÁªèÂú®‰π¶Êû∂‰∏ä‰∫ÜÔºÅ`);
            return;
          }

          await db.auroraBooks.add({
            title: title,
            content: auroraState.textContent,
            addedAt: Date.now(),
          });

          alert(`„Ää${title}„ÄãÂ∑≤ÊàêÂäüÊîæÂÖ•‰π¶Êû∂ÔºÅ`);

          // ÈöêËóè‰øùÂ≠òÊåâÈíÆÔºåÈÅøÂÖçÈáçÂ§ç‰øùÂ≠ò
          document.getElementById("aurora-save-book-btn").style.display =
            "none";
        }

        // 4. ‰ªé‰π¶Êû∂Âä†ËΩΩ‰π¶Á±çÂπ∂ÈòÖËØª (Â∑≤Ê∑ªÂä†ËøõÂ∫¶ËÆ∞ÂøÜÂäüËÉΩ)
        function loadBookFromShelf(book) {
          // Êõ¥Êñ∞ÂÖ®Â±ÄÁä∂ÊÄÅ
          auroraState = {
            active: true,
            mode: "text",
            title: book.title,
            subtitles: [],
            textContent: book.content,
            lastSyncTime: 0,
            // ‚òÖ‚òÖ‚òÖ Êñ∞Â¢ûÔºöËÆ∞ÂΩïÂΩìÂâçÊ≠£Âú®ËØªÂì™Êú¨‰π¶ÁöÑIDÔºå‰ª•‰æø‰øùÂ≠òËøõÂ∫¶
            currentBookId: book.id,
          };

          const playerOverlay = document.getElementById(
            "aurora-player-overlay",
          );
          const statusTitle = document.getElementById("aurora-playing-title");
          const statusInfo = document.getElementById("aurora-info-status");
          const textViewer = document.getElementById("aurora-text-viewer");
          const videoEl = document.getElementById("aurora-video-element");
          const customViewer = document.getElementById("aurora-custom-viewer");
          const saveBtn = document.getElementById("aurora-save-book-btn");

          // UI ÂàáÊç¢ÈÄªËæë
          document
            .getElementById("aurora-bookshelf-screen")
            .classList.remove("active"); // ÈÄÄÂá∫‰π¶Êû∂

          if (state.activeChatId) {
            showScreen("chat-interface-screen");
          } else {
            showScreen("home-screen");
          }

          playerOverlay.style.display = "flex"; // ÊòæÁ§∫Êí≠ÊîæÂô®

          statusTitle.textContent = `Ê≠£Âú®Êº´Ê∏∏:„Ää${book.title}„Äã`;
          statusInfo.textContent = "Êù•Ëá™‰π¶Êû∂";

          videoEl.style.display = "none";
          customViewer.style.display = "none";
          textViewer.style.display = "block";

          document.getElementById("aurora-text-body").textContent =
            book.content;

          // Âõ†‰∏∫ÊòØ‰ªé‰π¶Êû∂ÊâìÂºÄÁöÑÔºåÊâÄ‰ª•ÈöêËóè‚Äú‰øùÂ≠ò‚ÄùÊåâÈíÆ
          saveBtn.style.display = "none";

          // ÊÅ¢Â§çÈòÖËØªËøõÂ∫¶
          // ‰ΩøÁî® setTimeout Á°Æ‰øùÊñáÊú¨Ê∏≤ÊüìÂÆåÊàêÂêéÂÜçÊªöÂä®
          setTimeout(() => {
            if (book.progress) {
              // progress ÊòØ‰∏Ä‰∏™ 0 Âà∞ 1 ‰πãÈó¥ÁöÑÊµÆÁÇπÊï∞ (ÁôæÂàÜÊØî)
              const scrollHeight =
                textViewer.scrollHeight - textViewer.clientHeight;
              const targetScrollTop = Math.floor(scrollHeight * book.progress);

              textViewer.scrollTop = targetScrollTop;
              console.log(
                `Â∑≤ÊÅ¢Â§çÈòÖËØªËøõÂ∫¶: ${(book.progress * 100).toFixed(1)}%`,
              );
            } else {
              textViewer.scrollTop = 0; // Â¶ÇÊûúÊ≤°ÊúâËÆ∞ÂΩïÔºå‰ªéÂ§¥ÂºÄÂßã
            }
          }, 50);
        }

        // ÁªëÂÆö‰π¶Êû∂ÂÖ•Âè£ÊåâÈíÆ
        document
          .getElementById("open-aurora-bookshelf-btn")
          .addEventListener("click", openAuroraBookshelf);

        document
          .getElementById("back-from-bookshelf")
          .addEventListener("click", () => {
            // 1. ÈöêËóè‰π¶Êû∂Â±èÂπï
            document
              .getElementById("aurora-bookshelf-screen")
              .classList.remove("active");

            // 2. ÊòæÂºèÂú∞ÂàáÊç¢ÂõûËÅäÂ§©ÁïåÈù¢
            if (state.activeChatId) {
              showScreen("chat-interface-screen");
            } else {
              showScreen("home-screen");
            }

            // 3. ÈáçÊñ∞ÊâìÂºÄËÆæÁΩÆÂºπÁ™ó (Ê®°‰ªøËøîÂõû‰∏ä‰∏ÄÁ∫ßËèúÂçïÁöÑÊïàÊûú)
            document
              .getElementById("aurora-setup-modal")
              .classList.add("visible");
          });

        // ÁªëÂÆö‰øùÂ≠òÊåâÈíÆ
        document
          .getElementById("aurora-save-book-btn")
          .addEventListener("click", saveCurrentNovelToShelf);
        /**
         * GitÊµÅÂºè‰∏ä‰º† (ÂàÜË°® + Ëá™Âä®ÂàáÁâá + ÈáçËØïÊú∫Âà∂)
         * ‰øÆÂ§çÔºöËß£ÂÜ≥ "Failed to fetch" ÁΩëÁªúË∂ÖÊó∂ÈóÆÈ¢ò
         */
        async function uploadBackupToGitHubStream() {
          let { githubToken, githubUsername, githubRepo, githubPath } =
            state.apiConfig;

          if (!githubToken || !githubUsername || !githubRepo) {
            alert("ËØ∑ÂÖàÂú® API ËÆæÁΩÆ‰∏≠Â°´ÂÜô GitHub ÈÖçÁΩÆÔºÅ");
            return;
          }

          // Êï¥ÁêÜË∑ØÂæÑ
          githubToken = githubToken.trim();
          githubUsername = githubUsername.trim();
          githubRepo = githubRepo
            .trim()
            .replace(/\/$/, "")
            .split("/")
            .pop()
            .replace(".git", "");
          let basePath = (githubPath || "ephone_backup").trim();
          if (basePath.endsWith(".json")) {
            basePath = basePath.replace(".json", "");
          }

          // ‚òÖ‚òÖ‚òÖ 2.Â¶ÇÊûúÊòØËá™Âä®Â§á‰ªΩÔºåË∑≥ËøáÁ°ÆËÆ§Ê°Ü ‚òÖ‚òÖ‚òÖ
          if (!isAuto) {
            const confirmed = await showCustomConfirm(
              "ÂºÄÂßãÊµÅÂºè‰∏ä‰º†",
              `Â∞ÜÊääÊï∞ÊçÆÊãÜÂàÜ‰∏∫Â§ö‰∏™Êñá‰ª∂‰∏ä‰º†„ÄÇ\nÂ∑≤‰ºòÂåñ‰∏∫ 15MB ÂàÜÁâá‰ª•Èò≤Ê≠¢ÁΩëÁªúË∂ÖÊó∂„ÄÇ\n\nÁ°ÆÂÆöË¶ÅÂºÄÂßãÂêóÔºü`,
            );
            if (!confirmed) return;
          }

          const loadingOverlay = document.getElementById("generation-overlay");
          const loadingText = loadingOverlay.querySelector("p");

          // ‚òÖ‚òÖ‚òÖ 3. Âè™Êúâ‰∏çÊòØËá™Âä®Â§á‰ªΩÊó∂ÔºåÊâçÊòæÁ§∫ÈÅÆÁΩ©Â±Ç ‚òÖ‚òÖ‚òÖ
          if (!isAuto) {
            loadingOverlay.classList.add("visible");
          } else {
            console.log("Ê≠£Âú®ÂêéÂè∞ÊâßË°åÊµÅÂºèÂ§á‰ªΩ..."); // ÂêéÂè∞Â§á‰ªΩ‰ªÖÊâìÂç∞Êó•Âøó
          }

          // ‚òÖ‚òÖ‚òÖ ‰øÆÊîπ 1: Èôç‰ΩéÂàÜÁâáÂ§ßÂ∞èÂà∞ 15MB (ÊµèËßàÂô®‰∏ä‰º†Êõ¥Á®≥ÂÆö) ‚òÖ‚òÖ‚òÖ
          const CHUNK_SIZE = 15 * 1024 * 1024;

          // ‚òÖ‚òÖ‚òÖ ËæÖÂä©ÂáΩÊï∞: Âª∂Êó∂ (Èò≤Ê≠¢Ëß¶ÂèëÈÄüÁéáÈôêÂà∂) ‚òÖ‚òÖ‚òÖ
          const sleep = (ms) =>
            new Promise((resolve) => setTimeout(resolve, ms));

          // ‚òÖ‚òÖ‚òÖ ËæÖÂä©ÂáΩÊï∞: Â∏¶ÈáçËØïÁöÑ‰∏ä‰º†Âô® ‚òÖ‚òÖ‚òÖ
          const uploadWithRetry = async (path, content, retries = 3) => {
            for (let i = 0; i < retries; i++) {
              try {
                await uploadSingleFile(
                  githubUsername,
                  githubRepo,
                  path,
                  githubToken,
                  content,
                  true,
                );
                return; // ÊàêÂäüÂàôÈÄÄÂá∫
              } catch (error) {
                console.warn(`‰∏ä‰º† ${path} Â§±Ë¥• (Á¨¨ ${i + 1} Ê¨°ÈáçËØï):`, error);
                if (i === retries - 1) throw error; // ÊúÄÂêé‰∏ÄÊ¨°ËøòÂ§±Ë¥•ÔºåÂàôÊäõÂá∫ÂºÇÂ∏∏
                await sleep(2000); // Â§±Ë¥•ÂêéÁ≠âÂæÖ2ÁßíÂÜçËØï
              }
            }
          };

          try {
            // 1. ÂáÜÂ§á‰ªªÂä°ÂàóË°®
            const tablesToExport = db.tables.map((t) => t.name);
            const singleObjects = [
              "apiConfig",
              "globalSettings",
              "musicLibrary",
              "qzoneSettings",
            ];

            const allTasks = [
              ...tablesToExport.map((name) => ({ type: "table", name })),
              ...singleObjects.map((name) => ({ type: "object", name })),
            ];

            const totalTasks = allTasks.length;

            // 2. ÈÅçÂéÜÊâßË°å
            for (let i = 0; i < totalTasks; i++) {
              const task = allTasks[i];

              let data = null;
              if (task.type === "table") {
                // ÂØπ‰∫éÂ§ßË°®ÔºåËøôÈáåËØªÂèñÂèØËÉΩ‰ºöËä±‰∏ÄÁÇπÊó∂Èó¥ÔºåUIÊõ¥Êñ∞‰∏Ä‰∏ã
                loadingText.textContent = `[${i + 1}/${totalTasks}] ËØªÂèñÊú¨Âú∞Êï∞ÊçÆ: ${task.name}...`;
                // ÁªôUI‰∏ÄÁÇπÊ∏≤ÊüìÊó∂Èó¥
                await sleep(50);
                data = await db[task.name].toArray();
              } else {
                data = await db[task.name].get("main");
                // ÂÆâÂÖ®ËøáÊª§
                if (data && task.name === "apiConfig") {
                  data.apiKey = "";
                  data.githubToken = "";
                  data.minimaxApiKey = "";
                }
              }

              if (!data) continue;

              loadingText.textContent = `[${i + 1}/${totalTasks}] Ê≠£Âú®ÁºñÁ†Å: ${task.name}...`;
              await sleep(20);

              // Â∫èÂàóÂåñÂπ∂ËΩ¨Base64
              const jsonContent = JSON.stringify(data);
              const contentBase64 = btoa(
                unescape(encodeURIComponent(jsonContent)),
              );

              const fileName = `${basePath}_${task.name}.json`;
              const totalSize = contentBase64.length;

              // 3. ‰∏ä‰º†ÈÄªËæë
              if (totalSize > CHUNK_SIZE) {
                const totalChunks = Math.ceil(totalSize / CHUNK_SIZE);

                for (let c = 0; c < totalChunks; c++) {
                  loadingText.textContent = `[${i + 1}/${totalTasks}] ‰∏ä‰º† ${
                    task.name
                  } ÂàÜÁâá (${c + 1}/${totalChunks})...`;

                  const start = c * CHUNK_SIZE;
                  const end = Math.min(start + CHUNK_SIZE, totalSize);
                  const chunkContent = contentBase64.substring(start, end);
                  const partName = `${fileName}.${String(c + 1).padStart(3, "0")}`;

                  // ‰ΩøÁî®ÈáçËØïÊú∫Âà∂‰∏ä‰º†
                  await uploadWithRetry(partName, chunkContent);

                  // ‚òÖ‚òÖ‚òÖ ÊØèÊ¨°‰∏ä‰º†ÂÆå‰∏Ä‰∏™ÂàÜÁâáÔºå‰ºëÊÅØ 1 Áßí ‚òÖ‚òÖ‚òÖ
                  await sleep(1000);
                }

                // ‰∏ä‰º†Á¥¢ÂºïÊñá‰ª∂
                const metaInfo = {
                  split: true,
                  totalChunks: totalChunks,
                  originalSize: totalSize,
                };
                const metaBase64 = btoa(JSON.stringify(metaInfo));
                await uploadWithRetry(`${fileName}.meta`, metaBase64);
              } else {
                loadingText.textContent = `[${i + 1}/${totalTasks}] Ê≠£Âú®‰∏ä‰º†: ${task.name}...`;
                await uploadWithRetry(fileName, contentBase64);
                await sleep(500); // Â∞èÊñá‰ª∂‰πüÁ®çÂæÆ‰ºëÊÅØ‰∏Ä‰∏ã
              }
            }

            // 4. ‰∏ä‰º†ÊÄªÁ¥¢Âºï
            const masterMeta = {
              type: "stream_backup_v2",
              timestamp: Date.now(),
              tables: tablesToExport,
              configs: singleObjects,
            };
            const masterMetaBase64 = btoa(
              unescape(encodeURIComponent(JSON.stringify(masterMeta))),
            );
            await uploadWithRetry(
              `${basePath}_master_meta.json`,
              masterMetaBase64,
            );

            // ‚òÖ‚òÖ‚òÖ 4. ÊàêÂäüÂêéÁöÑÂ§ÑÁêÜ ‚òÖ‚òÖ‚òÖ
            if (isAuto) {
              // Â¶ÇÊûúÊòØËá™Âä®Â§á‰ªΩÔºå‰ΩøÁî®È°∂ÈÉ®ÈÄöÁü•Êù°Ôºà‰∏çÊâìÊñ≠Áî®Êà∑Ôºâ
              showNotification(
                state.activeChatId || "system",
                "GitHub Ëá™Âä®Â§á‰ªΩÂ∑≤ÂÆåÊàê ‚úÖ",
              );
              console.log("GitHub Ëá™Âä®Â§á‰ªΩÂ∑≤ÂÆåÊàê");
            } else {
              // Â¶ÇÊûúÊòØÊâãÂä®ÔºåÂºπÁ™óÊèêÁ§∫
              await showCustomAlert(
                "‰∏ä‰º†ÂÆåÊàê",
                `ÊâÄÊúâÊï∞ÊçÆÂ∑≤ÊµÅÂºè‰∏ä‰º†ÊàêÂäüÔºÅ\nÁΩëÁªúÊ≥¢Âä®Â∑≤Ëá™Âä®Â§ÑÁêÜ„ÄÇ`,
              );
            }
          } catch (error) {
            console.error("ÊµÅÂºè‰∏ä‰º†Â§±Ë¥•:", error);
            // ‚òÖ‚òÖ‚òÖ 5. Â§±Ë¥•Â§ÑÁêÜ ‚òÖ‚òÖ‚òÖ
            if (!isAuto) {
              await showCustomAlert(
                "‰∏ä‰º†‰∏≠Êñ≠",
                `Â§öÊ¨°ÈáçËØïÂêé‰ªçÁÑ∂Â§±Ë¥•„ÄÇ\nÈîôËØØ‰ø°ÊÅØ: ${error.message}\nËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊòØÂê¶Á®≥ÂÆö„ÄÇ`,
              );
            } else {
              showNotification(
                state.activeChatId || "system",
                "GitHub Ëá™Âä®Â§á‰ªΩÂ§±Ë¥• ‚ùå",
              );
            }
          } finally {
            // Êó†ËÆ∫Â¶Ç‰ΩïÈÉΩË¶ÅÂ∞ùËØïÁßªÈô§ÔºåÈò≤Ê≠¢ÊâãÂä®Ê®°ÂºèÂç°‰Ωè
            loadingOverlay.classList.remove("visible");
          }
        }

        /**
         * GitÊµÅÂºèÂØºÂÖ• (‰øÆÂ§çÁâàÔºöÊîØÊåÅÂàÜË°®‰∏ãËΩΩ + Ëá™Âä®ÂêàÂπ∂ÂàÜÁâá)
         */
        async function restoreBackupFromGitHubStream() {
          let { githubToken, githubUsername, githubRepo, githubPath } =
            state.apiConfig;

          if (!githubToken || !githubUsername || !githubRepo) {
            alert("ËØ∑ÂÖàÂú® API ËÆæÁΩÆ‰∏≠Â°´ÂÜô GitHub ÈÖçÁΩÆÔºÅ");
            return;
          }

          githubToken = githubToken.trim();
          githubUsername = githubUsername.trim();
          githubRepo = githubRepo
            .trim()
            .replace(/\/$/, "")
            .split("/")
            .pop()
            .replace(".git", "");
          let basePath = (githubPath || "ephone_backup").trim();
          if (basePath.endsWith(".json")) {
            basePath = basePath.replace(".json", "");
          }

          const confirmed = await showCustomConfirm(
            "‚ö†Ô∏è Á°ÆËÆ§ÊµÅÂºèÊÅ¢Â§ç",
            `Â∞Ü‰ªé GitHub ‰æùÊ¨°‰∏ãËΩΩ‰ª• "${basePath}_" ÂºÄÂ§¥ÁöÑÊñá‰ª∂Âπ∂Ë¶ÜÁõñÂΩìÂâçÊï∞ÊçÆ„ÄÇ\n\nÊ≠§Êìç‰Ωú‰ºö„ÄêÊ∏ÖÁ©∫„ÄëÂΩìÂâçÊâÄÊúâÊï∞ÊçÆ‰∏î‰∏çÂèØÊí§ÈîÄÔºÅ\nÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü`,
            { confirmButtonClass: "btn-danger" },
          );
          if (!confirmed) return;

          const loadingOverlay = document.getElementById("generation-overlay");
          const loadingText = loadingOverlay.querySelector("p");
          loadingOverlay.classList.add("visible");

          try {
            // 1. ÂÆö‰πâÈúÄË¶ÅÊÅ¢Â§çÁöÑË°®ÂêçÂíåÈÖçÁΩÆ
            const tablesToImport = db.tables.map((t) => t.name);
            const singleObjects = [
              "apiConfig",
              "globalSettings",
              "musicLibrary",
              "qzoneSettings",
            ];

            // ÂêàÂπ∂‰ªªÂä°ÂàóË°®
            const allTasks = [
              ...tablesToImport.map((name) => ({ type: "table", name })),
              ...singleObjects.map((name) => ({ type: "object", name })),
            ];

            const totalTasks = allTasks.length;
            let completedTasks = 0;
            let successCount = 0;

            // Ê∏ÖÂ∫ì
            loadingText.textContent = "Ê≠£Âú®Ê∏ÖÁ©∫ÂΩìÂâçÊï∞ÊçÆÂ∫ì...";
            for (const table of db.tables) {
              await table.clear();
            }

            // --- Ê†∏ÂøÉËæÖÂä©ÂáΩÊï∞Ôºö‰∏ãËΩΩÂπ∂ÂêàÂπ∂ (ÂåÖÂê´ÂàÜÁâáÈÄªËæë) ---
            const downloadAndMerge = async (taskName, taskType) => {
              const fileName = `${basePath}_${taskName}.json`;
              // ÊûÑÈÄ† meta Êñá‰ª∂Âú∞ÂùÄ
              const metaUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/contents/${fileName}.meta`;

              let finalBase64 = "";
              let isSplit = false;
              let splitInfo = null;

              // A. Â∞ùËØïËé∑Âèñ .meta Êñá‰ª∂ÔºåÂà§Êñ≠ÊòØÂê¶ÂàÜÁâá
              try {
                const metaRes = await fetch(metaUrl, {
                  headers: { Authorization: `token ${githubToken}` },
                });
                if (metaRes.ok) {
                  const metaJson = await metaRes.json();
                  // Ëß£Á†Å meta Êñá‰ª∂ÂÜÖÂÆπ
                  const metaStr = atob(metaJson.content.replace(/\s/g, ""));
                  splitInfo = JSON.parse(metaStr);
                  isSplit = true;
                }
              } catch (e) {
                // Ê≤°ÊâæÂà∞ meta Êñá‰ª∂ÔºåËØ¥ÊòéÊòØÂçïÊñá‰ª∂ÔºåÁªßÁª≠Ëµ∞
              }

              if (isSplit && splitInfo) {
                // === ÂàÜÁâáÊ®°Âºè ===
                console.log(
                  `Ê£ÄÊµãÂà∞ ${taskName} ‰∏∫ÂàÜÁâáÊñá‰ª∂ÔºåÂÖ± ${splitInfo.totalChunks} Áâá`,
                );
                loadingText.textContent = `Ê≠£Âú®‰∏ãËΩΩ ${taskName} (ÂàÜÁâá ${splitInfo.totalChunks} ‰∏™)...`;

                for (let i = 1; i <= splitInfo.totalChunks; i++) {
                  // ÊûÑÈÄ†ÂàÜÁâáÊñá‰ª∂ÂêçÔºå‰æãÂ¶Ç .001, .002
                  const partName = `${fileName}.${String(i).padStart(3, "0")}`;
                  const partUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/contents/${partName}`;

                  const partRes = await fetch(partUrl, {
                    headers: { Authorization: `token ${githubToken}` },
                  });
                  if (!partRes.ok) throw new Error(`ÂàÜÁâá ${partName} ‰∏ãËΩΩÂ§±Ë¥•`);

                  const partJson = await partRes.json();

                  // Â§ÑÁêÜÂÜÖÂÆπÔºàÂÖºÂÆπÂ§ßÊñá‰ª∂ËøîÂõû sha ÁöÑÊÉÖÂÜµÔºâ
                  if (partJson.content) {
                    finalBase64 += partJson.content.replace(/\s/g, "");
                  } else if (partJson.sha) {
                    // Â¶ÇÊûúÂàÜÁâáÊú¨Ë∫´‰πüÂæàÂ§ßÔºåGitHubÂèØËÉΩÂè™ËøîÂõûshaÔºåÈúÄË¶ÅÁî®Blob API
                    const blobUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/git/blobs/${partJson.sha}`;
                    const blobRes = await fetch(blobUrl, {
                      headers: { Authorization: `token ${githubToken}` },
                    });
                    const blobJson = await blobRes.json();
                    finalBase64 += blobJson.content.replace(/\s/g, "");
                  }
                }
              } else {
                // === ÂçïÊñá‰ª∂Ê®°Âºè ===
                const fileUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/contents/${fileName}`;
                const res = await fetch(fileUrl, {
                  headers: { Authorization: `token ${githubToken}` },
                });

                if (res.status === 404) return null; // Êñá‰ª∂‰∏çÂ≠òÂú®ÔºåË∑≥Ëøá
                if (!res.ok) throw new Error(`Êñá‰ª∂ ${fileName} ‰∏ãËΩΩÂ§±Ë¥•`);

                const json = await res.json();

                if (json.content) {
                  finalBase64 = json.content.replace(/\s/g, "");
                } else if (json.sha) {
                  const blobUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/git/blobs/${json.sha}`;
                  const blobRes = await fetch(blobUrl, {
                    headers: { Authorization: `token ${githubToken}` },
                  });
                  const blobJson = await blobRes.json();
                  finalBase64 = blobJson.content.replace(/\s/g, "");
                }
              }

              // B. Ëß£Á†Å Base64 -> UTF8 -> JSON
              try {
                // atob Ëß£Á†Å Base64
                const binaryString = atob(finalBase64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }
                // TextDecoder Â§ÑÁêÜ‰∏≠Êñá‰π±Á†Å
                const decoder = new TextDecoder("utf-8");
                const dataJson = JSON.parse(decoder.decode(bytes));
                return dataJson;
              } catch (parseError) {
                console.error(`Ëß£Êûê ${taskName} Êï∞ÊçÆÂ§±Ë¥•`, parseError);
                throw new Error(`Ëß£Êûê ${taskName} Â§±Ë¥•ÔºåÊï∞ÊçÆÂèØËÉΩÊçüÂùè`);
              }
            };

            // 2. Âæ™ÁéØÂ§ÑÁêÜÊâÄÊúâ‰ªªÂä°
            for (let i = 0; i < totalTasks; i++) {
              const task = allTasks[i];
              loadingText.textContent = `[${completedTasks + 1}/${totalTasks}] Ê≠£Âú®ÊÅ¢Â§ç: ${task.name}...`;

              try {
                const data = await downloadAndMerge(task.name, task.type);

                if (data) {
                  if (task.type === "object") {
                    // ÊÅ¢Â§çÂçïÂØπË±°ÈÖçÁΩÆ
                    if (task.name === "apiConfig") {
                      // ÊÅ¢Â§çÊó∂ÔºåÂ¶ÇÊûúÂ§á‰ªΩÈáåÊ≤°ÊúâKeyÔºå‰øùÁïôÂΩìÂâçÂÜÖÂ≠òÈáåÁöÑKey
                      if (!data.apiKey) data.apiKey = state.apiConfig.apiKey;
                      if (!data.githubToken)
                        data.githubToken = state.apiConfig.githubToken;
                    }
                    await db[task.name].put(data);
                  } else {
                    // ÊÅ¢Â§çÊï∞ÁªÑË°®Êï∞ÊçÆ
                    if (Array.isArray(data) && data.length > 0) {
                      await db[task.name].bulkPut(data);
                    }
                  }
                  successCount++;
                }
              } catch (err) {
                console.warn(`ÊÅ¢Â§ç ${task.name} Êó∂Âá∫ÈîôÔºåË∑≥Ëøá:`, err);
              }
              completedTasks++;
            }

            await showCustomAlert(
              "ÊÅ¢Â§çÂÆåÊàê",
              `ÊµÅÂºèÊÅ¢Â§çÁªìÊùüÔºÅ\nÊàêÂäüÊÅ¢Â§ç‰∫Ü ${successCount} ‰∏™Êï∞ÊçÆÊ®°Âùó„ÄÇ\nÂ∫îÁî®Âç≥Â∞ÜÂà∑Êñ∞„ÄÇ`,
            );
            setTimeout(() => window.location.reload(), 1500);
          } catch (error) {
            console.error("ÊµÅÂºèÊÅ¢Â§çÂ§±Ë¥•:", error);
            await showCustomAlert("ÊÅ¢Â§çÂ§±Ë¥•", `ÂèëÁîüÈîôËØØ: ${error.message}`);
          } finally {
            loadingOverlay.classList.remove("visible");
          }
        }

        /**
         * GitÊµÅÂºèÂØºÂÖ• (ÂàÜË°®‰∏ãËΩΩÔºåËäÇÁúÅÂÜÖÂ≠ò)
         */
        async function restoreBackupFromGitHubStream() {
          let { githubToken, githubUsername, githubRepo, githubPath } =
            state.apiConfig;

          if (!githubToken || !githubUsername || !githubRepo) {
            alert("ËØ∑ÂÖàÂú® API ËÆæÁΩÆ‰∏≠Â°´ÂÜô GitHub ÈÖçÁΩÆÔºÅ");
            return;
          }

          // Êï¥ÁêÜË∑ØÂæÑ
          githubToken = githubToken.trim();
          githubUsername = githubUsername.trim();
          githubRepo = githubRepo
            .trim()
            .replace(/\/$/, "")
            .split("/")
            .pop()
            .replace(".git", "");
          let basePath = (githubPath || "ephone_backup").trim();
          if (basePath.endsWith(".json")) {
            basePath = basePath.replace(".json", "");
          }

          const confirmed = await showCustomConfirm(
            "‚ö†Ô∏è Á°ÆËÆ§ÊµÅÂºèÊÅ¢Â§ç",
            `Â∞Ü‰ªé GitHub ‰æùÊ¨°‰∏ãËΩΩ‰ª• "${basePath}_" ÂºÄÂ§¥ÁöÑÊñá‰ª∂Âπ∂Ë¶ÜÁõñÂΩìÂâçÊï∞ÊçÆ„ÄÇ\n\nÊ≠§Êìç‰Ωú‰ºö„ÄêÊ∏ÖÁ©∫„ÄëÂΩìÂâçÊâÄÊúâÊï∞ÊçÆ‰∏î‰∏çÂèØÊí§ÈîÄÔºÅ\nÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü`,
            { confirmButtonClass: "btn-danger" },
          );
          if (!confirmed) return;

          const loadingOverlay = document.getElementById("generation-overlay");
          const loadingText = loadingOverlay.querySelector("p");
          loadingOverlay.classList.add("visible");

          try {
            // 1. ÂÆö‰πâÈúÄË¶ÅÊÅ¢Â§çÁöÑË°®ÂêçÂíåÈÖçÁΩÆ (‰∏é‰∏ä‰º†Êó∂ÂØπÂ∫î)
            // Âç≥‰Ωø‰∫ëÁ´ØÊ≤°ÊúâÊüê‰∫õË°®ÔºåÂ∞ùËØï‰∏ãËΩΩ404‰πü‰ºöË¢´ÂøΩÁï•Ôºå‰øùËØÅÂÅ•Â£ÆÊÄß
            const tablesToImport = db.tables.map((t) => t.name);
            const singleObjects = [
              "apiConfig",
              "globalSettings",
              "musicLibrary",
              "qzoneSettings",
            ];

            const totalTasks = tablesToImport.length + singleObjects.length;
            let completedTasks = 0;
            let successCount = 0;

            // ÂÖàÊ∏ÖÁ©∫Êï∞ÊçÆÂ∫ì (‰∏∫‰∫Ü‰øùËØÅÊï∞ÊçÆÁ∫ØÂáÄ)
            loadingText.textContent = "Ê≠£Âú®Ê∏ÖÁ©∫ÂΩìÂâçÊï∞ÊçÆÂ∫ì...";
            for (const table of db.tables) {
              await table.clear();
            }

            // 2. ËæÖÂä©‰∏ãËΩΩÂáΩÊï∞
            const downloadAndImport = async (
              fileName,
              targetStore,
              isSingleObject = false,
            ) => {
              const apiUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/contents/${fileName}`;
              try {
                const res = await fetch(apiUrl, {
                  headers: { Authorization: `token ${githubToken}` },
                });

                if (res.status === 404) {
                  console.log(`Ë∑≥Ëøá: ${fileName} ‰∏çÂ≠òÂú®`);
                  return false;
                }
                if (!res.ok) throw new Error(`HTTP ${res.status}`);

                const json = await res.json();

                // Â§ÑÁêÜÂ§ßÊñá‰ª∂ Blob (Â¶ÇÊûúÊòØÂ§ßÊñá‰ª∂ github api ‰ºöËøîÂõû sha Ê≤° content)
                let finalContentStr = "";
                if (json.content) {
                  finalContentStr = json.content.replace(/\s/g, "");
                } else if (json.sha) {
                  // Blob API for large files
                  const blobUrl = `https://api.github.com/repos/${githubUsername}/${githubRepo}/git/blobs/${json.sha}`;
                  const blobRes = await fetch(blobUrl, {
                    headers: { Authorization: `token ${githubToken}` },
                  });
                  const blobJson = await blobRes.json();
                  finalContentStr = blobJson.content.replace(/\s/g, "");
                }

                // Ëß£Á†Å
                const binaryString = atob(finalContentStr);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }
                const decoder = new TextDecoder("utf-8");
                const dataJson = JSON.parse(decoder.decode(bytes));

                // ÂÜôÂÖ•Êï∞ÊçÆÂ∫ì
                if (isSingleObject) {
                  // ÂØπ‰∫éÈÖçÁΩÆÂØπË±°ÔºåÂ¶ÇÊûúÊòØ apiConfigÔºå‰øùÁïôÂΩìÂâçÁöÑ Key Âà´Ë¢´Á©∫ÂÄºË¶ÜÁõñ
                  if (targetStore === "apiConfig") {
                    // ÊÅ¢Â§çÊó∂ÔºåÂ¶ÇÊûúÂ§á‰ªΩÈáåÊòØÁ©∫ÁöÑÔºåÂ∞±‰øùÁïôÂΩìÂâçÂÜÖÂ≠òÈáåÁöÑKey
                    if (!dataJson.apiKey)
                      dataJson.apiKey = state.apiConfig.apiKey;
                    if (!dataJson.githubToken)
                      dataJson.githubToken = state.apiConfig.githubToken;
                  }
                  await db[targetStore].put(dataJson);
                } else {
                  // Êï∞ÁªÑÊï∞ÊçÆ
                  if (Array.isArray(dataJson) && dataJson.length > 0) {
                    await db[targetStore].bulkPut(dataJson);
                  }
                }
                return true;
              } catch (e) {
                console.warn(`‰∏ãËΩΩ/Import ${fileName} Â§±Ë¥•:`, e);
                return false;
              }
            };

            // 3. Âæ™ÁéØÊÅ¢Â§çË°®
            for (const tableName of tablesToImport) {
              loadingText.textContent = `[${completedTasks + 1}/${totalTasks}] Ê≠£Âú®‰∏ãËΩΩÂπ∂ÂØºÂÖ•: ${tableName}...`;
              const fileName = `${basePath}_${tableName}.json`;
              if (await downloadAndImport(fileName, tableName, false)) {
                successCount++;
              }
              completedTasks++;
            }

            // 4. Âæ™ÁéØÊÅ¢Â§çÈÖçÁΩÆ
            for (const configName of singleObjects) {
              loadingText.textContent = `[${completedTasks + 1}/${totalTasks}] Ê≠£Âú®‰∏ãËΩΩÂπ∂ÂØºÂÖ•ÈÖçÁΩÆ: ${configName}...`;
              const fileName = `${basePath}_${configName}.json`;
              if (await downloadAndImport(fileName, configName, true)) {
                successCount++;
              }
              completedTasks++;
            }

            await showCustomAlert(
              "ÊÅ¢Â§çÂÆåÊàê",
              `ÊµÅÂºèÊÅ¢Â§çÁªìÊùüÔºÅ\nÊàêÂäüÊÅ¢Â§ç‰∫Ü ${successCount} ‰∏™Êï∞ÊçÆÊ®°Âùó„ÄÇ\nÂ∫îÁî®Âç≥Â∞ÜÂà∑Êñ∞„ÄÇ`,
            );
            setTimeout(() => window.location.reload(), 1500);
          } catch (error) {
            console.error("ÊµÅÂºèÊÅ¢Â§çÂ§±Ë¥•:", error);
            await showCustomAlert("ÊÅ¢Â§çÂ§±Ë¥•", `ÂèëÁîüÈîôËØØ: ${error.message}`);
          } finally {
            loadingOverlay.classList.remove("visible");
          }
        }
        // ---------------- [‰øÆÊîπÂºÄÂßã] Êñ∞Â¢ûÂäüËÉΩÈÄªËæë ----------------

        // 1. ÂàùÂßãÂåñÊº´Ê∏∏Â≠óÂè∑Ë∞ÉÊï¥
        let currentAuroraFontSize = 16;
        function initAuroraFontControl() {
          const upBtn = document.getElementById("aurora-font-up");
          const downBtn = document.getElementById("aurora-font-down");
          const textViewer = document.getElementById("aurora-text-viewer");
          const subDisplay = document.getElementById(
            "aurora-custom-subtitle-display",
          );

          // Ë∞ÉÊï¥Â≠óÂè∑ÁöÑÈÄöÁî®ÂáΩÊï∞
          const changeFontSize = (delta) => {
            currentAuroraFontSize = Math.max(
              10,
              Math.min(40, currentAuroraFontSize + delta),
            ); // ÈôêÂà∂Âú® 10px - 40px

            // Â∫îÁî®Âà∞Â∞èËØ¥ÊñáÊú¨
            if (textViewer)
              textViewer.style.fontSize = `${currentAuroraFontSize}px`;

            // Â∫îÁî®Âà∞Ëá™ÂÆö‰πâÊ®°ÂºèÂ≠óÂπï
            if (subDisplay)
              subDisplay.style.fontSize = `${currentAuroraFontSize}px`;
          };

          if (upBtn)
            upBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              changeFontSize(2);
            });
          if (downBtn)
            downBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              changeFontSize(-2);
            });
        }

        // 2. ÂàùÂßãÂåñÊâãÊú∫Á´ØËß¶Êë∏Áº©Êîæ
        function initAuroraResize() {
          const handle = document.getElementById("aurora-resize-handle");
          const overlay = document.getElementById("aurora-player-overlay");

          if (!handle || !overlay) return;

          let startX, startY, startWidth, startHeight;

          const onTouchStart = (e) => {
            e.preventDefault(); // Èò≤Ê≠¢ÊªöÂä®
            e.stopPropagation();
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;
            startWidth = parseInt(
              document.defaultView.getComputedStyle(overlay).width,
              10,
            );
            startHeight = parseInt(
              document.defaultView.getComputedStyle(overlay).height,
              10,
            );

            document.addEventListener("touchmove", onTouchMove, {
              passive: false,
            });
            document.addEventListener("touchend", onTouchEnd);
          };

          const onTouchMove = (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const newWidth = startWidth + (touch.clientX - startX);
            const newHeight = startHeight + (touch.clientY - startY);

            // ËÆæÁΩÆÊúÄÂ∞èÂ∞∫ÂØ∏ÈôêÂà∂
            if (newWidth > 200) overlay.style.width = `${newWidth}px`;
            if (newHeight > 150) overlay.style.height = `${newHeight}px`;
          };

          const onTouchEnd = () => {
            document.removeEventListener("touchmove", onTouchMove);
            document.removeEventListener("touchend", onTouchEnd);
          };

          handle.addEventListener("touchstart", onTouchStart, {
            passive: false,
          });

          // ‰∏∫‰∫ÜÂÖºÂÆπÁîµËÑëÈº†Ê†áÊãñÊãΩËØ•ËßíËêΩ
          handle.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            startX = e.clientX;
            startY = e.clientY;
            startWidth = parseInt(
              document.defaultView.getComputedStyle(overlay).width,
              10,
            );
            startHeight = parseInt(
              document.defaultView.getComputedStyle(overlay).height,
              10,
            );
            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
          });

          const onMouseMove = (e) => {
            const newWidth = startWidth + (e.clientX - startX);
            const newHeight = startHeight + (e.clientY - startY);
            if (newWidth > 200) overlay.style.width = `${newWidth}px`;
            if (newHeight > 150) overlay.style.height = `${newHeight}px`;
          };

          const onMouseUp = () => {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          };
        }
        /**
         * ÂÖ®Â±ÄÊï∞ÊçÆÂàùÂßãÂåñÔºàÊÅ¢Â§çÂá∫ÂéÇËÆæÁΩÆÔºâ
         */
        async function handleFactoryReset() {
          // 1. Á¨¨‰∏ÄÈáçË≠¶Âëä
          const confirmed = await showCustomConfirm(
            "‚ö† ‰∏•ÈáçË≠¶Âëä",
            "Ê≠§Êìç‰ΩúÂ∞Ü„ÄêÂΩªÂ∫ïÊ∏ÖÁ©∫„ÄëÊâÄÊúâÊï∞ÊçÆÔºÅÂåÖÊã¨Ôºö\n- ÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩï\n- ÊâÄÊúâËÆæÁΩÆ‰∏éAPI Key\n- ÊâÄÊúâÂõæÁâá„ÄÅ‰∏ñÁïå‰π¶„ÄÅË°®ÊÉÖÂåÖ\n\nÊï∞ÊçÆ‰∏ÄÊó¶Âà†Èô§„ÄêÊó†Ê≥ïÊÅ¢Â§ç„Äë„ÄÇÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü",
            { confirmButtonClass: "btn-danger" },
          );

          if (!confirmed) return;

          // 2. Á¨¨‰∫åÈáçË≠¶Âëä (‰ΩøÁî®ÂéüÁîü confirm Èò≤Ê≠¢ËØØËß¶)
          if (confirm("ÊúÄÂêé‰∏ÄÊ¨°Á°ÆËÆ§ÔºöÁúüÁöÑË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÊï∞ÊçÆÂπ∂ÈáçÁΩÆÂ∫îÁî®ÂêóÔºü")) {
            try {
              // ÊòæÁ§∫Âä†ËΩΩÈÅÆÁΩ©
              const loadingOverlay =
                document.getElementById("generation-overlay");
              if (loadingOverlay) {
                loadingOverlay.querySelector("p").textContent =
                  "Ê≠£Âú®Á≤âÁ¢éÊï∞ÊçÆ...";
                loadingOverlay.classList.add("visible");
              }

              // A. Ê∏ÖÁ©∫ IndexedDB Êï∞ÊçÆÂ∫ìÁöÑÊâÄÊúâË°®
              await db.transaction("rw", db.tables, async () => {
                for (const table of db.tables) {
                  await table.clear();
                }
              });

              // B. Ê∏ÖÁ©∫ LocalStorage (ÂåÖÂê´‰∏ªÈ¢ò„ÄÅÈÉ®ÂàÜÂºÄÂÖ≥ËÆæÁΩÆÁ≠â)
              localStorage.clear();

              // C. ÊàêÂäüÊèêÁ§∫Âπ∂Âà∑Êñ∞
              alert("Êï∞ÊçÆÂ∑≤ÂÖ®ÈÉ®ÂàùÂßãÂåñÔºåÂ∫îÁî®Â∞ÜÈáçÂêØ„ÄÇ");
              window.location.reload();
            } catch (error) {
              console.error(error);
              alert("ÂàùÂßãÂåñÂ§±Ë¥•: " + error.message);
              window.location.reload(); // Âç≥‰ΩøÂ§±Ë¥•‰πüÂ∞ùËØïÂà∑Êñ∞
            }
          }
        }
        /**
         * „ÄêÊñ∞Â¢û„ÄëÂÖ®ËÉΩÊï∞ÊçÆ‰øÆÂ§çÂáΩÊï∞
         * Êâ´ÊèèÊâÄÊúâÊï∞ÊçÆÂ∫ìË°®ÔºåË°•ÂÖ®Áº∫Â§±Â≠óÊÆµÔºå‰øÆÂ§çÈîôËØØÁªìÊûÑÔºåÈò≤Ê≠¢ÁïåÈù¢ÁôΩÂ±è
         */
        async function repairAllData() {
          const confirmed = await showCustomConfirm(
            "Êï∞ÊçÆ‰øÆÂ§ç",
            "Ê≠§ÂäüËÉΩÂ∞ÜÊâ´ÊèèÊâÄÊúâÊï∞ÊçÆÔºåË°•ÂÖ®Áº∫Â§±ÁöÑÂ±ûÊÄßÂπ∂‰øÆÂ§çÈîôËØØÁªìÊûÑÔºà‰∏ç‰ºöÂà†Èô§ËÅäÂ§©ËÆ∞ÂΩïÔºâ„ÄÇ\n\nÂ¶ÇÊûú‰Ω†ÁöÑÁïåÈù¢Âá∫Áé∞ÁôΩÂ±è„ÄÅÂç°È°øÊàñÊä•ÈîôÔºåËØ∑Â∞ùËØïÊ≠§Êìç‰Ωú„ÄÇ\n\nÁ°ÆÂÆöË¶ÅÂºÄÂßã‰øÆÂ§çÂêóÔºü",
          );

          if (!confirmed) return;

          await showCustomAlert("Please wait...", "Ê≠£Âú®Ê∑±Â∫¶Êâ´ÊèèÂπ∂‰øÆÂ§çÊï∞ÊçÆÁªìÊûÑ...");

          try {
            let fixCount = 0;

            // 1. ‰øÆÂ§çËÅäÂ§©Êï∞ÊçÆ (Chats)
            const allChats = await db.chats.toArray();
            for (const chat of allChats) {
              let needSave = false;

              // ‰øÆÂ§çÂü∫Á°ÄÁªìÊûÑ
              if (!chat.history || !Array.isArray(chat.history)) {
                chat.history = [];
                needSave = true;
              }
              if (!chat.settings) {
                chat.settings = {};
                needSave = true;
              }
              if (!chat.status) {
                chat.status = {
                  text: "Online",
                  lastUpdate: Date.now(),
                  isBusy: false,
                };
                needSave = true;
              }

              // ‰øÆÂ§çÁæ§ËÅäÊàêÂëòÁªìÊûÑ
              if (chat.isGroup) {
                if (!chat.members || !Array.isArray(chat.members)) {
                  chat.members = [];
                  needSave = true;
                }
                chat.members.forEach((m) => {
                  if (!m.originalName && m.name) {
                    m.originalName = m.name;
                    needSave = true;
                  } // ‰øÆÂ§çÊóßÁâàÂêçÂ≠ó
                  if (!m.groupNickname) {
                    m.groupNickname = m.originalName || "Êú™Áü•ÊàêÂëò";
                    needSave = true;
                  }
                });
              }

              // ‰øÆÂ§çÂçïËÅäËÆæÁΩÆ
              if (!chat.isGroup) {
                // ‰øÆÂ§çÂÖ≥Á≥ªÁä∂ÊÄÅ
                if (!chat.relationship) {
                  chat.relationship = { status: "friend" };
                  needSave = true;
                }

                // ‰øÆÂ§çÊâãÊú∫Êï∞ÊçÆÁªìÊûÑ (ÊúÄÂÆπÊòìÂØºËá¥Êä•ÈîôÁöÑÈÉ®ÂàÜ)
                if (!chat.characterPhoneData) {
                  chat.characterPhoneData = {};
                  needSave = true;
                }

                const phone = chat.characterPhoneData;
                const phoneDefaults = {
                  chats: {},
                  shoppingCart: [],
                  memos: [],
                  browserHistory: [],
                  photoAlbum: [],
                  bank: { balance: 0, transactions: [] },
                  trajectory: [],
                  appUsage: [],
                  diary: [],
                  widgets: {},
                };

                for (const key in phoneDefaults) {
                  if (!phone[key]) {
                    phone[key] = phoneDefaults[key];
                    needSave = true;
                  }
                }

                // ‰øÆÂ§çÈì∂Ë°å‰ΩôÈ¢ù‰∏∫NaNÁöÑÊÉÖÂÜµ
                if (phone.bank && typeof phone.bank.balance !== "number") {
                  phone.bank.balance = 0;
                  needSave = true;
                }
              }

              // ‰øÆÂ§çËÆæÁΩÆ‰∏≠ÁöÑÁº∫Â§±È°π
              if (!chat.settings.streak) {
                chat.settings.streak = { enabled: false, currentDays: 0 };
                needSave = true;
              }
              if (!chat.settings.summary) {
                chat.settings.summary = {
                  enabled: false,
                  mode: "auto",
                  count: 20,
                  lastSummaryIndex: -1,
                };
                needSave = true;
              }

              if (needSave) {
                await db.chats.put(chat);
                fixCount++;
              }
            }

            // 2. ‰øÆÂ§çÂÖ®Â±ÄËÆæÁΩÆ (Global Settings)
            let globalSettings = await db.globalSettings.get("main");
            if (!globalSettings) {
              globalSettings = { id: "main" }; // Â¶ÇÊûúÂÆåÂÖ®‰∏¢Â§±ÔºåÈáçÂª∫
            }

            let globalNeedSave = false;
            if (!globalSettings.appIcons) {
              globalSettings.appIcons = {};
              globalNeedSave = true;
            }
            if (!globalSettings.appLabels) {
              globalSettings.appLabels = {};
              globalNeedSave = true;
            }
            if (
              !globalSettings.quickReplies ||
              !Array.isArray(globalSettings.quickReplies)
            ) {
              globalSettings.quickReplies = [];
              globalNeedSave = true;
            }
            // ‰øÆÂ§ç‰ΩôÈ¢ùNaN
            if (
              typeof globalSettings.userBalance !== "number" ||
              isNaN(globalSettings.userBalance)
            ) {
              globalSettings.userBalance = 0;
              globalNeedSave = true;
            }

            if (globalNeedSave) {
              await db.globalSettings.put(globalSettings);
              fixCount++;
            }

            // 3. ‰øÆÂ§çÂä®ÊÄÅËÆæÁΩÆ (Qzone Settings)
            let qzoneSettings = await db.qzoneSettings.get("main");
            if (!qzoneSettings) {
              await db.qzoneSettings.put({
                id: "main",
                nickname: "Me",
                avatar: "https://files.catbox.moe/q6z5fc.jpeg",
              });
              fixCount++;
            }

            await showCustomAlert(
              "‰øÆÂ§çÂÆåÊàê",
              `Â∑≤Ê£ÄÊü•ÊâÄÊúâÊï∞ÊçÆÔºåÂÖ±‰øÆÂ§ç‰∫Ü ${fixCount} Â§ÑÊΩúÂú®ÈóÆÈ¢ò„ÄÇ\n\nÈ°µÈù¢Âç≥Â∞ÜÂà∑Êñ∞‰ª•Â∫îÁî®Êõ¥Êîπ„ÄÇ`,
            );

            setTimeout(() => {
              window.location.reload();
            }, 2000);
          } catch (error) {
            console.error("‰øÆÂ§çËøáÁ®ã‰∏≠Âá∫Èîô:", error);
            alert(`‰øÆÂ§çÂ§±Ë¥•: ${error.message}\nËØ∑Êà™ÂõæÊéßÂà∂Âè∞Êä•ÈîôÁªôÂºÄÂèëËÄÖ„ÄÇ`);
          }
        }

        // 1. ÈÄöÁî®Â§ÑÁêÜÂáΩÊï∞ÔºöÁÇπÂáª‰∏ä‰º†ÊåâÈíÆÊó∂Ëß¶Âèë
        async function handleCoupleImageSelect(previewImgId, fileInputId) {
          const choice = await showChoiceModal("ÈÄâÊã©ÂõæÁâáÊù•Ê∫ê", [
            { text: "üìÅ Upload from local", value: "local" },
            { text: "üåê Use URL", value: "url" },
          ]);

          if (!choice) return;

          if (choice === "local") {
            // Ëß¶ÂèëÊú¨Âú∞Êñá‰ª∂ÈÄâÊã©
            document.getElementById(fileInputId).click();
          } else if (choice === "url") {
            // ÂºπÂá∫ËæìÂÖ•Ê°ÜËé∑ÂèñURL
            const url = await showCustomPrompt(
              "ËæìÂÖ•ÂõæÁâáÈìæÊé•",
              "ËØ∑Á≤òË¥¥‰ª• http ÂºÄÂ§¥ÁöÑÂõæÁâáÂú∞ÂùÄ",
              "",
              "url",
            );
            if (url && url.trim()) {
              document.getElementById(previewImgId).src = url.trim();
            }
          }
        }

        // 2. ÁªëÂÆö‰∏§‰∏™‰∏ä‰º†ÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂ (‰ΩøÁî®‰∏äÈù¢ÂÆö‰πâÁöÑÊñ∞ID)
        document
          .getElementById("upload-couple-my-btn")
          .addEventListener("click", () => {
            handleCoupleImageSelect(
              "new-couple-my-avatar-preview",
              "new-couple-my-avatar-input",
            );
          });

        document
          .getElementById("upload-couple-char-btn")
          .addEventListener("click", () => {
            handleCoupleImageSelect(
              "new-couple-char-avatar-preview",
              "new-couple-char-avatar-input",
            );
          });

        // 3. ÁªëÂÆöÊú¨Âú∞Êñá‰ª∂ÈÄâÊã©ÂêéÁöÑÈ¢ÑËßà (Â§çÁî®‰πãÂâçÁöÑÈÄªËæëÔºå‰øùÊåÅ‰∏çÂèò)
        // ËøôÈáåÁöÑ setupFileUpload ÊòØ‰Ω†‰ª£Á†ÅÈáåÂ∑≤ÊúâÁöÑËæÖÂä©ÂáΩÊï∞
        setupFileUpload("new-couple-my-avatar-input", (base64) => {
          document.getElementById("new-couple-my-avatar-preview").src = base64;
        });
        setupFileUpload("new-couple-char-avatar-input", (base64) => {
          document.getElementById("new-couple-char-avatar-preview").src =
            base64;
        });
        // ==========================================
        // ‚òÖ‚òÖ‚òÖ Êñ∞Â¢ûÂäüËÉΩÔºöÂÖ®Â±ÄË∑Ø‰∫∫Â§¥ÂÉèÂ∫ìÈÄªËæë ‚òÖ‚òÖ‚òÖ
        // ==========================================

        // 1. ÊâìÂºÄÁÆ°ÁêÜÁïåÈù¢
        async function openPasserbyManager() {
          await renderPasserbyGrid();
          document
            .getElementById("passerby-avatar-manager-modal")
            .classList.add("visible");
        }

        // 2. Ê∏≤ÊüìÁΩëÊ†º
        async function renderPasserbyGrid() {
          const grid = document.getElementById("passerby-avatar-grid");
          const countSpan = document.getElementById("passerby-count");
          grid.innerHTML = "";

          // ‰ªéÊï∞ÊçÆÂ∫ìËé∑ÂèñÊâÄÊúâ
          const avatars = await db.passerbyAvatars.toArray();
          countSpan.textContent = avatars.length;

          // Êõ¥Êñ∞ÂÖ®Â±ÄÁºìÂ≠ò (ÈáçË¶Å)
          window.state.passerbyAvatars = avatars;

          if (avatars.length === 0) {
            grid.innerHTML =
              '<p style="grid-column:1/-1; text-align:center; color:#999;">ÂõæÂ∫ì‰∏∫Á©∫ÔºåÂø´ÂéªÊ∑ªÂä†‰∏Ä‰∫õÂêßÔºÅ</p>';
            return;
          }

          avatars.forEach((item) => {
            const div = document.createElement("div");
            div.className = "sticker-item"; // Â§çÁî®Áé∞ÊúâÁöÑË¥¥Á∫∏Ê†∑Âºè
            div.style.backgroundImage = `url(${item.url})`;
            div.style.borderRadius = "8px";
            div.style.aspectRatio = "1/1";

            // Âà†Èô§ÊåâÈíÆ
            const delBtn = document.createElement("div");
            delBtn.className = "delete-btn";
            delBtn.innerHTML = "√ó";
            delBtn.style.display = "block";
            delBtn.onclick = async (e) => {
              e.stopPropagation();
              if (confirm("Á°ÆÂÆöÂà†Èô§ËøôÂº†Â§¥ÂÉèÂêóÔºü")) {
                await db.passerbyAvatars.delete(item.id);
                renderPasserbyGrid();
              }
            };

            div.appendChild(delBtn);
            grid.appendChild(div);
          });
        }

        // 3. Â§ÑÁêÜÊ∑ªÂä†Â§¥ÂÉè (ÊîØÊåÅÊú¨Âú∞Â§öÈÄâ Âíå URL)
        async function handleAddPasserbyAvatar() {
          const choice = await showChoiceModal("Ê∑ªÂä†ÊñπÂºè", [
            { text: "üìÅ Êú¨Âú∞‰∏ä‰º† (ÊîØÊåÅÂ§öÈÄâ)", value: "local" },
            { text: "üåê ÁΩëÁªúÂõæÁâáURL", value: "url" },
          ]);

          if (!choice) return;

          if (choice === "local") {
            document.getElementById("passerby-upload-input").click();
          } else if (choice === "url") {
            const url = await showCustomPrompt("ËæìÂÖ•URL", "ËØ∑ËæìÂÖ•ÂõæÁâáÈìæÊé•");
            if (url && url.trim()) {
              await db.passerbyAvatars.add({ url: url.trim() });
              alert("Ê∑ªÂä†ÊàêÂäü");
              // Â¶ÇÊûúÁÆ°ÁêÜÁïåÈù¢ÂºÄÁùÄÔºåÂ∞±Âà∑Êñ∞ÂÆÉ
              if (
                document
                  .getElementById("passerby-avatar-manager-modal")
                  .classList.contains("visible")
              ) {
                renderPasserbyGrid();
              }
            }
          }
        }

        // 4. Â§ÑÁêÜÊú¨Âú∞Êñá‰ª∂ÈÄâÊã©
        async function handlePasserbyFileChange(event) {
          const files = event.target.files;
          if (!files.length) return;

          // ÊòæÁ§∫Âä†ËΩΩÊèêÁ§∫
          const btn = document.getElementById("add-passerby-avatar-btn");
          const originalText = btn.textContent;
          btn.textContent = "Â§ÑÁêÜ‰∏≠...";

          const newItems = [];
          for (const file of files) {
            // Â§çÁî®‰Ω†ÁöÑÂõæÁâáÂéãÁº©ÂáΩÊï∞ handleImageUploadAndCompress
            try {
              const base64 = await handleImageUploadAndCompress(file);
              newItems.push({ url: base64 });
            } catch (e) {
              console.error("ÂõæÁâáÂ§ÑÁêÜÂ§±Ë¥•", e);
            }
          }

          if (newItems.length > 0) {
            await db.passerbyAvatars.bulkAdd(newItems);
            alert(`ÊàêÂäüÊ∑ªÂä† ${newItems.length} Âº†Â§¥ÂÉèÔºÅ`);
            // Âà∑Êñ∞ÁºìÂ≠ò
            window.state.passerbyAvatars = await db.passerbyAvatars.toArray();
            // Â¶ÇÊûúÁÆ°ÁêÜÁïåÈù¢ÂºÄÁùÄÔºåÂà∑Êñ∞
            if (
              document
                .getElementById("passerby-avatar-manager-modal")
                .classList.contains("visible")
            ) {
              renderPasserbyGrid();
            }
          }

          btn.textContent = originalText;
          event.target.value = null; // Ê∏ÖÁ©∫
        }

        // 5. „ÄêÊ†∏ÂøÉÂ∑•ÂÖ∑ÂáΩÊï∞„ÄëÊ†πÊçÆÂêçÂ≠óËé∑ÂèñÂ§¥ÂÉè
        // Â¶ÇÊûúÂêçÂ≠óÁõ∏ÂêåÔºåÂ∞ΩÈáèËøîÂõûÁõ∏ÂêåÁöÑÂ§¥ÂÉèÔºà‰º™ÈöèÊú∫ÔºâÔºõÂ¶ÇÊûúÊ≤°ÊúâÂ∫ìÔºåËøîÂõûÈªòËÆ§„ÄÇ
        window.getAvatarForName = function (name) {
          const lib = window.state.passerbyAvatars || [];
          if (lib.length === 0)
            return "https://i.postimg.cc/PxZrFFFL/o-o-1.jpg"; // ÈªòËÆ§Â§¥ÂÉè

          // ÁÆÄÂçïÁöÑÂìàÂ∏åÁÆóÊ≥ïÔºåÂ∞ÜÂêçÂ≠óËΩ¨‰∏∫Êï∞Â≠ó
          let hash = 0;
          for (let i = 0; i < name.length; i++) {
            hash = name.charCodeAt(i) + ((hash << 5) - hash);
          }

          // ÂèñÁªùÂØπÂÄºÂπ∂ÂèñÊ®°
          const index = Math.abs(hash) % lib.length;
          return lib[index].url;
        };
        /**
         * Áªü‰∏ÄÁöÑ Pollinations ÁîüÂõæÂáΩÊï∞ (‰ªé Taobao, Date, XHS ÊèêÂèñÂπ∂ÂêàÂπ∂)
         * ‰ºòÂÖà‰ΩøÁî® API KeyÔºåÊîØÊåÅÊó†ÈôêÈáçËØïÊú∫Âà∂
         * @param {string} prompt - Ëã±ÊñáÊèêÁ§∫ËØç
         * @param {object} options - ÈÖçÁΩÆÈ°π { width, height, model, seed, nologo }
         * @returns {Promise<string>} - ËøîÂõûÂõæÁâáÂú∞ÂùÄ (Blob URL Êàñ ÂÖ¨ÁΩë URL)
         */
        window.generatePollinationsImage = async function (
          prompt,
          options = {},
        ) {
          const {
            width = 1024,
            height = 1024,
            model = "flux",
            seed = Math.floor(Math.random() * 100000),
            nologo = false,
          } = options;

          console.log(
            `[Global Image Gen] Prompt: ${prompt}, Options:`,
            options,
          );

          while (true) {
            try {
              const encodedPrompt = encodeURIComponent(prompt);
              // Â∞ùËØïËé∑ÂèñÂÖ®Â±Ä stateÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®Âàô‰∏∫ null
              const currentApiConfig =
                window.state && window.state.apiConfig
                  ? window.state.apiConfig
                  : null;
              const pollApiKey = currentApiConfig
                ? currentApiConfig.pollinationsApiKey
                : null;

              // ÊûÑÂª∫Âü∫Á°ÄÂèÇÊï∞
              let queryParams = `width=${width}&height=${height}&seed=${seed}&model=${model}`;
              if (nologo) queryParams += "&nologo=true";

              // 1. === Êúâ API Key ÁöÑÊÉÖÂÜµ ===
              if (pollApiKey) {
                const primaryUrl = `https://gen.pollinations.ai/image/${encodedPrompt}?${queryParams}&key=${pollApiKey}`;
                console.log(
                  `[Global Image Gen] ‰ΩøÁî® API Key ËØ∑Ê±Ç: ${primaryUrl}`,
                );

                const response = await fetch(primaryUrl, { method: "GET" });

                if (!response.ok) {
                  throw new Error(`API Key ËØ∑Ê±ÇÂ§±Ë¥•: ${response.status}`);
                }

                const blob = await response.blob();
                // Â∞Ü Blob ËΩ¨‰∏∫ Base64 ‰ª•‰æøÂ≠òÂÇ®ÂíåÊåÅ‰πÖÂåñÂä†ËΩΩ (Ëß£ÂÜ≥ blob:null Êä•ÈîôÈóÆÈ¢ò)
                return await new Promise((resolve, reject) => {
                  const reader = new FileReader();
                  reader.onloadend = () => resolve(reader.result);
                  reader.onerror = reject;
                  reader.readAsDataURL(blob);
                });
              }

              // 2. === None API Key (ÂÖ¨ÂºÄÊé•Âè£) ÁöÑÊÉÖÂÜµ ===
              // ÂÆö‰πâÂä†ËΩΩÂô®
              const loadImage = (url) =>
                new Promise((resolve, reject) => {
                  const img = new Image();
                  img.src = url;
                  img.onload = () => resolve(url);
                  img.onerror = () => reject(new Error(`ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•: ${url}`));
                });

              // ‰ºòÂÖàÂ∞ùËØï gen.pollinations.ai
              const primaryUrl = `https://gen.pollinations.ai/image/${encodedPrompt}?${queryParams}`;

              return await loadImage(primaryUrl).catch(async () => {
                console.warn(`[Global Image Gen] ‰∏ªÊé•Âè£Â§±Ë¥•ÔºåÂ∞ùËØïÂ§áÁî®Êé•Âè£...`);
                // Â§áÁî®Êé•Âè£ pollinations.ai/p/
                const fallbackUrl = `https://pollinations.ai/p/${encodedPrompt}?${queryParams}`;
                return await loadImage(fallbackUrl);
              });
            } catch (error) {
              console.error(
                `[Global Image Gen] ÁîüÊàêÂ§±Ë¥•Ôºå5ÁßíÂêéËá™Âä®ÈáçËØï... ÈîôËØØ: ${error.message}`,
              );
              await new Promise((resolve) => setTimeout(resolve, 5000));
            }
          }
        };
        /* ==================================================
   „ÄêÂÖ®Â±è‰∏âÂáªËß¶ÂèëÁâà„ÄëÊ°åÈù¢ÊãñÊãΩÁ≥ªÁªü
   Ëß¶ÂèëÊñπÂºèÔºöÂú®‰∏ªÂ±èÂπï‰ªªÊÑè‰ΩçÁΩÆÔºàÈùûÂºπÁ™ó/ÈùûËÆæÁΩÆÈ°µÔºâËøûÁª≠ÁÇπÂáª 3 Ê¨°
   ‰øÆÂ§çÂÜÖÂÆπÔºöÂåÖÂê´ÂØπÁ¨¨‰∫åÈ°µÁªÑ‰ª∂‰ΩçÁΩÆÁöÑÈÄªËæëÂÖºÂÆπ
   ================================================== */
        function initDesktopManager() {
          const homeScreen = document.getElementById("home-screen");
          const doneBtn = document.getElementById("desktop-edit-done-btn");
          const sliderContainer = document.querySelector(".home-screen-slider");

          // ÂàõÂª∫‚ÄúÈáçÁΩÆÂ∏ÉÂ±Ä‚ÄùÊåâÈíÆ
          let resetBtn = document.getElementById("desktop-reset-layout-btn");
          if (!resetBtn) {
            resetBtn = document.createElement("div");
            resetBtn.id = "desktop-reset-layout-btn";
            resetBtn.textContent = "ÈáçÁΩÆÂ∏ÉÂ±Ä";
            resetBtn.style.cssText = `
            position: absolute;
            top: 50px;
            right: 80px; 
            background: rgba(255, 59, 48, 0.9);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000;
            cursor: pointer;
            backdrop-filter: blur(10px);
            display: none; 
        `;
            homeScreen.appendChild(resetBtn);
          }

          // ÂÆö‰πâÊâÄÊúâÂèØÊãñÊãΩÁöÑÁõÆÊ†á
          const selector =
            ".home-page .desktop-app-icon, .home-page .custom-widget-container, #new-custom-widget, #profile-widget, #desktop-widget-column, #center-avatar-wrapper, .draggable-group, #glass-music-widget";

          let isEditMode = false;
          let dragItem = null;
          let originalParent = null;
          let shiftX = 0;
          let shiftY = 0;

          // --- ÂàùÂßãÂåñID ---
          const assignStableIds = () => {
            document.querySelectorAll(selector).forEach((el, index) => {
              if (!el.id) {
                const label = el.querySelector(".label");
                const innerImg = el.querySelector("img[id^='icon-img-']");
                if (innerImg && innerImg.id) {
                  el.id = "wrapper_" + innerImg.id;
                } else if (label) {
                  el.id = "auto_pos_" + label.innerText.trim();
                } else {
                  el.id = "auto_pos_idx_" + index;
                }
              }
            });
          };
          assignStableIds();

          // Âª∂ËøüÊÅ¢Â§çÂ∏ÉÂ±ÄÔºåÂπ∂Â∫îÁî®CSSÂ±Ö‰∏≠‰øÆÂ§ç
          setTimeout(() => {
            restoreLayout();
            // Âº∫Âà∂Âà∑Êñ∞‰∏ÄÊ¨°Á¨¨‰∫åÈ°µÁªÑ‰ª∂ÁöÑ‰ΩçÁΩÆÔºåÁ°Æ‰øùCSSÁîüÊïà
            const centerWidget = document.getElementById(
              "center-avatar-wrapper",
            );
            if (centerWidget && centerWidget.style.position !== "absolute") {
              // Â¶ÇÊûúÊ≤°ÊúâË¢´ÊãñÊãΩËøáÔºàÊ≤°Êúâ‰øùÂ≠òÁªùÂØπÂÆö‰ΩçÔºâÔºåÂàôÊ∏ÖÈô§ÂÜÖËÅîÊ†∑ÂºèÔºåËÆ©CSSÁöÑÂ±Ö‰∏≠ÁîüÊïà
              centerWidget.style.left = "";
              centerWidget.style.top = "";
              centerWidget.style.transform = "";
            }
          }, 200);

          // ============================================================
          // ‚òÖ‚òÖ‚òÖ „ÄêÈáçÁÇπ‰øÆÊîπ„ÄëÂÖ®Â±è‰∏âÂáªÈÄªËæë ‚òÖ‚òÖ‚òÖ
          // ============================================================
          let clickCount = 0;
          let clickTimer = null;

          // Êàë‰ª¨ÊääÁõëÂê¨Âô®ÁªëÂú® homeScreen ‰∏äÔºåË¶ÜÁõñÊï¥‰∏™Ê°åÈù¢Âå∫Âüü
          homeScreen.addEventListener(
            "click",
            (e) => {
              // 1. Â¶ÇÊûúÂ∑≤ÁªèÂú®ÁºñËæëÊ®°ÂºèÔºå‰∏çÂ§ÑÁêÜ
              // 2. Â¶ÇÊûúÁÇπÂáªÁöÑÊòØ‚ÄúÂÆåÊàê‚ÄùÊàñ‚ÄúÈáçÁΩÆ‚ÄùÊåâÈíÆÔºå‰∏çÂ§ÑÁêÜ
              if (
                isEditMode ||
                e.target.id === "desktop-edit-done-btn" ||
                e.target.id === "desktop-reset-layout-btn"
              )
                return;

              // 3. ËÆ°Êï∞
              clickCount++;

              // Á¨¨‰∏ÄÊ¨°ÁÇπÂáªÂºÄÂêØËÆ°Êó∂Âô®
              if (clickCount === 1) {
                clickTimer = setTimeout(() => {
                  clickCount = 0; // 500ms ÂÜÖÊ≤°ÁÇπÂ§ü3Ê¨°ÔºåÂΩíÈõ∂
                }, 500);
              }

              // ËææÂà∞3Ê¨°
              if (clickCount >= 3) {
                clearTimeout(clickTimer);
                clickCount = 0;

                // ÈúáÂä®ÂèçÈ¶à
                if (navigator.vibrate) navigator.vibrate([50, 50, 50]);

                // ÈòªÊ≠¢ËøôÊ¨°ÁÇπÂáªÂèØËÉΩÂºïÂèëÁöÑ APP ÊâìÂºÄÁ≠âË°å‰∏∫
                e.preventDefault();
                e.stopPropagation();

                enterEditMode();
              }
            },
            true,
          ); // ‰ΩøÁî®ÊçïËé∑Èò∂ÊÆµ (true)ÔºåÁ°Æ‰øùÊØî APP ÂõæÊ†áÁöÑÁÇπÂáª‰∫ã‰ª∂ÂÖàËß¶Âèë

          // ============================================================

          // --- ÊãñÊãΩÈÄªËæë ---
          // ËøôÈáåÂéªÊéâ‰∫ÜÂéüÊù•ÁöÑÈïøÊåâËÆ°Êó∂Âô®ÔºåÂè™‰øùÁïôÊãñÊãΩ
          const handleInputDown = (e) => {
            if (!isEditMode) return; // Âè™ÊúâÁºñËæëÊ®°Âºè‰∏ãÊâçÂÖÅËÆ∏ÊãñÊãΩ

            if (
              e.target.id === "desktop-edit-done-btn" ||
              e.target.id === "desktop-reset-layout-btn"
            )
              return;

            let target = e.target.closest(selector);
            if (target && target.parentElement.closest(selector)) {
              target = target.parentElement.closest(selector);
            }

            if (target) {
              prepareDrag(e, target);
            }
          };

          sliderContainer.addEventListener("mousedown", handleInputDown);
          sliderContainer.addEventListener("touchstart", handleInputDown, {
            passive: false,
          });

          // --- ÂáÜÂ§áÊãñÊãΩ ---
          function prepareDrag(e, item) {
            e.preventDefault();
            dragItem = item;
            const rect = dragItem.getBoundingClientRect();
            originalParent = dragItem.parentNode;

            // ‰øÆÂ§çÔºöÊãñÊãΩÊó∂Â¶ÇÊûúÊòØÂ±Ö‰∏≠ÁöÑÁªÑ‰ª∂ÔºåÂÖàËÆ°ÁÆóÂá∫ÂÆÉÂΩìÂâçÁöÑÂÆûÈôÖÂÉèÁ¥†‰ΩçÁΩÆÔºåËΩ¨‰∏∫ absolute left/top
            // Âê¶Âàô‰∏ÄÊãñÂä®Ôºåtransform: translate(-50%, -50%) ‰ºöÂØºËá¥ÂùêÊ†áÁ™ÅÂèò
            if (dragItem.id === "center-avatar-wrapper") {
              dragItem.style.transform = "none"; // ÊöÇÊó∂ÁßªÈô§ CSS Â±Ö‰∏≠ÂèòÊç¢
              dragItem.style.left = rect.left + "px"; // Âõ∫ÂåñÂΩìÂâçËßÜËßâ‰ΩçÁΩÆ
              dragItem.style.top = rect.top + "px";
            }

            const parentStyle = window.getComputedStyle(originalParent);
            if (parentStyle.position === "static") {
              originalParent.style.position = "relative";
            }

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            shiftX = clientX - rect.left;
            shiftY = clientY - rect.top;

            document.body.appendChild(dragItem);
            dragItem.classList.add("is-dragging-active");

            dragItem.style.position = "fixed";
            dragItem.style.zIndex = "99999";
            dragItem.style.width = rect.width + "px";
            dragItem.style.height = rect.height + "px";
            dragItem.style.left = rect.left + "px";
            dragItem.style.top = rect.top + "px";
            dragItem.style.margin = "0"; // Ê∏ÖÈô§ margin
            dragItem.style.transform = "none"; // Ê∏ÖÈô§ transform

            document.addEventListener("mousemove", onDragMove);
            document.addEventListener("touchmove", onDragMove, {
              passive: false,
            });
            document.addEventListener("mouseup", onDragEnd);
            document.addEventListener("touchend", onDragEnd);
          }

          // --- ÊãñÊãΩÁßªÂä® ---
          function onDragMove(e) {
            if (!dragItem) return;
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            dragItem.style.left = clientX - shiftX + "px";
            dragItem.style.top = clientY - shiftY + "px";
          }

          // --- ÊãñÊãΩÁªìÊùü ---
          function onDragEnd() {
            if (dragItem && originalParent) {
              dragItem.classList.remove("is-dragging-active");
              const rect = dragItem.getBoundingClientRect();
              const parentRect = originalParent.getBoundingClientRect();
              const parentStyle = window.getComputedStyle(originalParent);
              const borderLeft = parseFloat(parentStyle.borderLeftWidth) || 0;
              const borderTop = parseFloat(parentStyle.borderTopWidth) || 0;

              const relativeLeft =
                rect.left -
                parentRect.left -
                borderLeft +
                originalParent.scrollLeft;
              const relativeTop =
                rect.top -
                parentRect.top -
                borderTop +
                originalParent.scrollTop;

              originalParent.appendChild(dragItem);

              dragItem.style.position = "absolute";
              dragItem.style.zIndex = "";
              dragItem.style.left = relativeLeft + "px";
              dragItem.style.top = relativeTop + "px";
              dragItem.style.width = rect.width + "px";
              dragItem.style.height = rect.height + "px";
              dragItem.style.margin = "0"; // Á°Æ‰øùÊîæÂõûÂêé‰πüÊ≤°Êúâmargin
              dragItem.style.transform = "none"; // Á°Æ‰øùÊîæÂõûÂêéÊ≤°Êúâtransform

              // ÁâπÊÆäÂ§ÑÁêÜÔºöÂ¶ÇÊûúÊòØÂ±Ö‰∏≠ÁªÑ‰ª∂ÔºåË¢´ÊãñÂä®ÂêéÔºåÂÆÉÂ∞±ÂèòÊàê‰∫ÜÊôÆÈÄöÁªùÂØπÂÆö‰ΩçÁªÑ‰ª∂
              // ‰∏çÈúÄË¶ÅÈ¢ùÂ§ñÊìç‰ΩúÔºå‰∏äÈù¢ÁöÑ left/top Â∑≤ÁªèÂõ∫Âåñ‰∫ÜÂÆÉÁöÑ‰ΩçÁΩÆ

              if (
                originalParent.clientHeight < 50 &&
                originalParent.id !== "phone-screen"
              ) {
                originalParent.style.minHeight = "100px";
              }

              dragItem = null;
              originalParent = null;
            }

            document.removeEventListener("mousemove", onDragMove);
            document.removeEventListener("touchmove", onDragMove);
            document.removeEventListener("mouseup", onDragEnd);
            document.removeEventListener("touchend", onDragEnd);
          }

          function enterEditMode() {
            isEditMode = true;
            homeScreen.classList.add("editing-mode");
            doneBtn.style.display = "block";
            const resetBtn = document.getElementById(
              "desktop-reset-layout-btn",
            );
            if (resetBtn) resetBtn.style.display = "block";
            document.addEventListener("click", blockClickInEditMode, true);
          }

          doneBtn.addEventListener("click", () => {
            isEditMode = false;
            homeScreen.classList.remove("editing-mode");
            doneBtn.style.display = "none";
            const resetBtn = document.getElementById(
              "desktop-reset-layout-btn",
            );
            if (resetBtn) resetBtn.style.display = "none";
            document.removeEventListener("click", blockClickInEditMode, true);
            saveLayout();
          });

          resetBtn.addEventListener("click", async () => {
            if (confirm("Á°ÆÂÆöË¶ÅÈáçÁΩÆÊâÄÊúâÂ∏ÉÂ±ÄÂêóÔºüÈ°µÈù¢Â∞ÜÂà∑Êñ∞„ÄÇ")) {
              if (window.state && window.state.globalSettings) {
                window.state.globalSettings.desktopLayoutV2 = null;
                await window.db.globalSettings.put(window.state.globalSettings);
                location.reload();
              }
            }
          });

          function blockClickInEditMode(e) {
            if (
              e.target.id === "desktop-edit-done-btn" ||
              e.target.id === "desktop-reset-layout-btn"
            )
              return;
            if (isEditMode) {
              e.stopPropagation();
              e.preventDefault();
            }
          }

          // --- ‰øùÂ≠òÂ∏ÉÂ±Ä ---
          async function saveLayout() {
            if (!window.db || !window.state) return;
            assignStableIds();
            const layoutData = {};
            const items = document.querySelectorAll(selector);
            items.forEach((item) => {
              // Ê£ÄÊü•ÔºöÂè™ÊúâÂΩìÂÖÉÁ¥†Ë¢´ÊòéÁ°ÆËÆæ‰∏∫ absolute Êó∂Êâç‰øùÂ≠ò‰ΩçÁΩÆ
              // ËøôÂèØ‰ª•ÂÖºÂÆπÁ¨¨‰∏ÄÊ≠•CSSÈáåÂÜôÁöÑÂàùÂßãÂ±Ö‰∏≠Áä∂ÊÄÅÔºàÊ≤°Êúâabsolute left/topÔºâ
              if (
                item.id &&
                item.style.position === "absolute" &&
                item.style.left
              ) {
                layoutData[item.id] = {
                  left: item.style.left,
                  top: item.style.top,
                  width: item.style.width,
                  height: item.style.height,
                  parentId: item.parentNode.id || null,
                };
              }
            });
            window.state.globalSettings.desktopLayoutV2 = layoutData;
            await window.db.globalSettings.put(window.state.globalSettings);
          }

          // --- ÊÅ¢Â§çÂ∏ÉÂ±Ä ---
          async function restoreLayout() {
            if (!window.db || !window.state || !window.state.globalSettings) {
              setTimeout(restoreLayout, 500);
              return;
            }
            const layoutData = window.state.globalSettings.desktopLayoutV2;
            if (layoutData) {
              assignStableIds();
              for (const [id, pos] of Object.entries(layoutData)) {
                const el = document.getElementById(id);
                if (el) {
                  el.style.position = "absolute";
                  el.style.left = pos.left;
                  el.style.top = pos.top;
                  el.style.width = pos.width;
                  el.style.height = pos.height;
                  el.style.margin = "0";
                  // Â¶ÇÊûúËØªÂèñÂà∞‰∫ÜËá™ÂÆö‰πâ‰ΩçÁΩÆÔºåÂ∞±ÂøÖÈ°ªÁßªÈô§ CSS ÈáåÁöÑ transform Â±Ö‰∏≠
                  el.style.transform = "none";
                  el.style.bottom = "auto";
                  el.style.right = "auto";

                  const parent = el.parentNode;
                  if (parent) {
                    const parentStyle = window.getComputedStyle(parent);
                    if (parentStyle.position === "static") {
                      parent.style.position = "relative";
                    }
                    if (
                      parent.clientHeight < 50 &&
                      parent.id !== "phone-screen"
                    ) {
                      parent.style.minHeight = "100px";
                    }
                  }
                }
              }
            }
          }
        }

        function captureVideoFrame(videoElement) {
          if (!videoElement || videoElement.paused || videoElement.ended)
            return null;
          try {
            const canvas = document.createElement("canvas");
            // ÈôêÂà∂‰∏Ä‰∏ãÂ∞∫ÂØ∏ÔºåÈò≤Ê≠¢tokenÊ∂àËÄóËøáÂ§ßÊàñ‰º†ËæìËøáÊÖ¢ÔºåÂÆΩËÆæÁΩÆ‰∏∫ 512px Â∑¶Âè≥Ë∂≥Â§ü‰∫Ü
            const scale = 512 / videoElement.videoWidth;
            canvas.width = 512;
            canvas.height = videoElement.videoHeight * scale;

            const ctx = canvas.getContext("2d");
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            // ËøîÂõû jpeg Ê†ºÂºèÔºåË¥®Èáè 0.6
            return canvas.toDataURL("image/jpeg", 0.6);
          } catch (e) {
            console.error("Êà™ÂõæÂ§±Ë¥•:", e);
            return null;
          }
        }

        // 4. ÂàùÂßãÂåñÂáΩÊï∞ init()
        // ===================================================================
        async function init() {
          // ‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº ‰øÆÊîπÔºöÊ≥®ÂÜåÁúüÊ≠£ÁöÑ sw.js Êñá‰ª∂ ‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
          if ("serviceWorker" in navigator) {
            try {
              // Ëøô‰∏ÄË°åÂèò‰∫ÜÔºöÁõ¥Êé•Âä†ËΩΩÊ†πÁõÆÂΩïÁöÑ sw.js
              const registration =
                await navigator.serviceWorker.register("sw.js");
              console.log(
                "ServiceWorker Ê≥®ÂÜåÊàêÂäü (File Mode), Scope:",
                registration.scope,
              );

              // Á≠âÂæÖÊøÄÊ¥ª
              await navigator.serviceWorker.ready;
            } catch (error) {
              console.error("ServiceWorker Ê≥®ÂÜåÂ§±Ë¥•:", error);
              // ÊèêÁ§∫Áî®Êà∑ÂèØËÉΩÁöÑÂéüÂõ†
              console.warn(
                "ÊèêÁ§∫ÔºöËØ∑Á°Æ‰øù sw.js Êñá‰ª∂‰Ωç‰∫éÁΩëÁ´ôÊ†πÁõÆÂΩïÔºå‰∏îÈÄöËøá HTTPS Êàñ localhost ËÆøÈóÆ„ÄÇ",
              );
            }
          }
          // ‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤ ‰øÆÊîπÁªìÊùü ‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

          const savedTheme = localStorage.getItem("ephone-theme") || "light"; // ÈªòËÆ§‰∏∫Êó•Èó¥Ê®°Âºè
          applyTheme(savedTheme);

          const customBubbleStyleTag = document.createElement("style");
          customBubbleStyleTag.id = "custom-bubble-style";
          document.head.appendChild(customBubbleStyleTag);

          const previewBubbleStyleTag = document.createElement("style");
          previewBubbleStyleTag.id = "preview-bubble-style";
          document.head.appendChild(previewBubbleStyleTag);

          applyScopedCss("", "#chat-messages", "custom-bubble-style"); // Ê∏ÖÈô§ÁúüÂÆûËÅäÂ§©ÁïåÈù¢ÁöÑËá™ÂÆö‰πâÊ†∑Âºè
          applyScopedCss("", "#settings-preview-area", "preview-bubble-style"); // Ê∏ÖÈô§È¢ÑËßàÂå∫ÁöÑËá™ÂÆö‰πâÊ†∑Âºè

          window.showScreen = showScreen;
          window.openLoversSpaceFromCard = openLoversSpaceFromCard;
          window.renderChatListProxy = renderChatList;
          window.renderApiSettingsProxy = renderApiSettings;
          window.renderWallpaperScreenProxy = renderWallpaperScreen;
          window.renderWorldBookScreenProxy = renderWorldBookScreen;
          const keepAliveUnlocker = () => {
            const player = document.getElementById("strong-keep-alive-player");
            if (player) {
              player.volume = 0; // Á°Æ‰øùÈùôÈü≥
              player
                .play()
                .then(() => {
                  console.log("üî• Âº∫Âäõ‰øùÊ¥ªÊ®°ÂºèÂ∑≤ÊøÄÊ¥ªÔºöÈùôÈü≥Èü≥È¢ëÊ≠£Âú®Âæ™ÁéØÊí≠Êîæ");
                })
                .catch((e) => {
                  console.warn("‰øùÊ¥ªÂêØÂä®Â§±Ë¥• (ÈúÄÁî®Êà∑‰∫§‰∫í):", e);
                });
            }
            document.removeEventListener("click", keepAliveUnlocker);
            document.removeEventListener("touchstart", keepAliveUnlocker);
          };

          document.addEventListener("click", keepAliveUnlocker);
          document.addEventListener("touchstart", keepAliveUnlocker);

          await loadAllDataFromDB();
          // Ê∑ªÂä†ÂêØÂä®Êó∂Âä†ËΩΩCSSÁöÑÈÄªËæë
          // ‰ºòÂÖàÂ∫îÁî®‰øùÂ≠òÂú® activeCustomCss ÈáåÁöÑ‰ª£Á†Å
          if (state.globalSettings.activeCustomCss) {
            applyThemeCss(state.globalSettings.activeCustomCss);
          }
          // Â¶ÇÊûúÊ≤°ÊúâËá™ÂÆö‰πâCSSÔºåÂÜçÂ∞ùËØïÂ∫îÁî®‰∏äÊ¨°ÈÄâ‰∏≠ÁöÑ‰∏ªÈ¢ò
          else if (state.globalSettings.activeThemeId) {
            const activeTheme = await db.themes.get(
              state.globalSettings.activeThemeId,
            );
            if (activeTheme) {
              console.log(`Ê≠£Âú®Â∫îÁî®Â∑≤‰øùÂ≠òÁöÑ‰∏ªÈ¢ò: "${activeTheme.name}"`);
              applyThemeCss(activeTheme.css);
            }
          }

          if (
            typeof state.globalSettings.notificationSoundUrl === "undefined"
          ) {
            state.globalSettings.notificationSoundUrl =
              "https://files.catbox.moe/k369mf.mp3";
          }

          renderHomeScreenProfileFrame(); // ÂàùÂßãÂåñÊó∂Ê∏≤Êüì‰∏ªÈ°µÂ§¥ÂÉèÊ°Ü

          applyHomeIconWidgetTextColor(
            state.globalSettings.homeIconWidgetTextColor,
          );
          await loadAllFontPresetsOnStartup();
          await migrateDefaultLudoQuestions();
          await addDefaultDarkModeThemeIfNeeded();
          applyWidgetData();

          if (state.globalSettings.homeIconWidgetTextColor) {
            applyHomeIconWidgetTextColor(
              state.globalSettings.homeIconWidgetTextColor,
            );
          }

          // 2. Â∫îÁî®Â∑≤‰øùÂ≠òÁöÑ‚ÄúÂéªÈô§Èò¥ÂΩ±‚ÄùËÆæÁΩÆ
          document
            .getElementById("phone-screen")
            .classList.toggle(
              "no-home-font-shadow",
              !!state.globalSettings.removeHomeFontShadow,
            );

          // ÂàùÂßãÂåñÊú™ËØªÂä®ÊÄÅËÆ°Êï∞
          const storedCount =
            parseInt(localStorage.getItem("unreadPostsCount")) || 0;
          updateUnreadIndicator(storedCount);

          if (state.globalSettings && state.globalSettings.fontUrl) {
            applyCustomFont(state.globalSettings.fontUrl);
          }

          // ÂàùÂßãÂåñÊó∂ÔºåËá™Âä®Âä†ËΩΩÂπ∂Â∫îÁî®Â∑≤‰øùÂ≠òÁöÑ‰∏ªÈ¢ò
          if (state.globalSettings.activeThemeId) {
            const activeTheme = await db.themes.get(
              state.globalSettings.activeThemeId,
            );
            if (activeTheme) {
              console.log(`Ê≠£Âú®Â∫îÁî®Â∑≤‰øùÂ≠òÁöÑ‰∏ªÈ¢ò: "${activeTheme.name}"`);
              applyThemeCss(activeTheme.css);
            }
          }

          updateClock();
          setInterval(updateClock, 1000 * 30);
          applyGlobalWallpaper();
          initBatteryManager();

          applyAppIcons();
          applyAppLabels();

          initDraggableLyricsBar(); // ÂàùÂßãÂåñÊÇ¨ÊµÆÊ≠åËØçÊ†èÁöÑÊãñÂä®ÂäüËÉΩ

          // ==========================================================
          // --- ÂêÑÁßç‰∫ã‰ª∂ÁõëÂê¨Âô® ---
          // ==========================================================

          // ‚ÄúÊü•ËßíËâ≤ÊâãÊú∫‚ÄùÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨Âô®

          // 1. ÁªëÂÆö‰∏ªÂ±èÂπï‰∏äÁöÑ‚ÄúÊü•ÊâãÊú∫‚ÄùAPPÂõæÊ†á
          document
            .getElementById("check-phone-btn")
            .addEventListener("click", openCharacterSelectionScreen);

          // 2. ËßíËâ≤ÈÄâÊã©ÂàóË°®ÁöÑÁÇπÂáª‰∫ã‰ª∂ (‰∫ã‰ª∂ÂßîÊâò)
          document
            .getElementById("character-selection-list")
            .addEventListener("click", (e) => {
              const item = e.target.closest(".character-select-item");
              if (item && item.dataset.chatId) {
                openCharacterPhone(item.dataset.chatId);
              }
            });

          // 3. ËßíËâ≤ÊâãÊú∫È°∂ÈÉ®ÁöÑ‚ÄúÂà∑Êñ∞‚ÄùÂíå‚ÄúÊ∏ÖÁ©∫‚ÄùÊåâÈíÆ
          document
            .getElementById("generate-character-data-btn")
            .addEventListener("click", generateCharacterPhoneData);
          document
            .getElementById("clear-character-data-btn")
            .addEventListener("click", clearCharacterPhoneData);

          document
            .getElementById("character-phone-container")
            .addEventListener("click", (e) => {
              const backBtn = e.target.closest(".back-btn");
              const actionBtn = e.target.closest(".action-btn");

              // 1. Â§ÑÁêÜËøîÂõûÊåâÈíÆ
              if (backBtn) {
                if (backBtn.dataset.targetPage) {
                  showCharacterPhonePage(backBtn.dataset.targetPage);
                } else if (backBtn.dataset.targetScreen) {
                  showScreen(backBtn.dataset.targetScreen);
                }
                return;
              }

              // 2. Â§ÑÁêÜÊâÄÊúâÊìç‰ΩúÊåâÈíÆÔºàÁîüÊàê + Âà†Èô§Ôºâ
              if (actionBtn) {
                switch (actionBtn.id) {
                  // --- ÂçïÁã¨ÁîüÊàêÊåâÈíÆ ---
                  case "generate-chat-message-btn":
                    openChatGenerationModal();
                    break;
                  case "generate-cart-item-btn":
                    generateCharacterPhoneDataSegment("shoppingCart");
                    break;
                  case "generate-memo-btn":
                    generateCharacterPhoneDataSegment("memos");
                    break;
                  case "generate-browser-history-btn":
                    generateCharacterPhoneDataSegment("browserHistory");
                    break;
                  case "generate-album-photo-btn":
                    generateCharacterPhoneDataSegment("photoAlbum");
                    break;
                  case "generate-bank-transaction-btn":
                    generateCharacterPhoneDataSegment("bank");
                    break;
                  case "generate-trajectory-btn":
                    generateCharacterPhoneDataSegment("trajectory");
                    break;
                  case "generate-app-usage-btn":
                    generateCharacterPhoneDataSegment("appUsage");
                    break;
                  case "generate-diary-entry-btn":
                    generateCharacterPhoneDataSegment("diary");
                    break;

                  // --- ‚òÖ‚òÖ‚òÖ ËøôÂ∞±ÊòØÊàë‰ª¨Êñ∞Â¢ûÁöÑÂÖ®ÈÉ®Âà†Èô§ÊåâÈíÆÁöÑÈÄªËæë ‚òÖ‚òÖ‚òÖ ---
                  case "clear-npc-chats-btn":
                    handleClearCharacterDataSegment("chats");
                    break;
                  case "clear-cart-items-btn":
                    handleClearCharacterDataSegment("shoppingCart");
                    break;
                  case "clear-memos-btn":
                    handleClearCharacterDataSegment("memos");
                    break;
                  case "clear-browser-history-btn":
                    handleClearCharacterDataSegment("browserHistory");
                    break;
                  case "clear-album-photos-btn":
                    handleClearCharacterDataSegment("photoAlbum");
                    break;
                  case "clear-bank-transactions-btn":
                    handleClearCharacterDataSegment("bank.transactions");
                    break;
                  case "clear-trajectory-btn":
                    handleClearCharacterDataSegment("trajectory");
                    break;
                  case "clear-app-usage-btn":
                    handleClearCharacterDataSegment("appUsage");
                    break;
                  case "clear-diary-entries-btn":
                    handleClearCharacterDataSegment("diary");
                    break;
                }
              }
            });

          // ‰∏ªÂ±èÂπïÈ¢ÑËÆæÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("home-preset-selector")
            .addEventListener("change", handleHomePresetSelection);
          document
            .getElementById("apply-home-preset-btn")
            .addEventListener("click", applySelectedHomeScreenPreset);

          document
            .getElementById("save-home-preset-btn")
            .addEventListener("click", saveCurrentHomeScreenAsPreset);
          document
            .getElementById("update-home-preset-btn")
            .addEventListener("click", updateSelectedHomeScreenPreset); // <-- Êñ∞Â¢ûËøô‰∏ÄË°å
          document
            .getElementById("rename-home-preset-btn")
            .addEventListener("click", renameSelectedHomeScreenPreset);
          document
            .getElementById("delete-home-preset-btn")
            .addEventListener("click", deleteSelectedHomeScreenPreset);
          document
            .getElementById("export-home-preset-btn")
            .addEventListener("click", exportHomeScreenPreset);
          document
            .getElementById("import-home-preset-btn")
            .addEventListener("click", () =>
              document.getElementById("import-home-preset-input").click(),
            );
          document
            .getElementById("import-home-preset-input")
            .addEventListener("change", (e) => {
              importHomeScreenPreset(e.target.files[0]);
              e.target.value = null;
            });

          document
            .getElementById("theme-toggle-switch")
            .addEventListener("change", toggleTheme);
          // ËÅäÂ§©ËÆ∞ÂΩïÊêúÁ¥¢ÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("search-chat-btn")
            .addEventListener("click", openChatSearchScreen);

          document
            .getElementById("search-back-btn")
            .addEventListener("click", () => {
              // ËøîÂõûÊó∂ÔºåÈáçÊñ∞ÊâìÂºÄËÅäÂ§©ËÆæÁΩÆÂºπÁ™ó
              showScreen("chat-interface-screen");
              document.getElementById("chat-settings-btn").click();
            });

          document
            .getElementById("perform-search-btn")
            .addEventListener("click", performChatSearch);

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÊù•Â§ÑÁêÜÊâÄÊúâÊêúÁ¥¢ÁªìÊûúÁöÑÁÇπÂáª
          document
            .getElementById("chat-search-results-list")
            .addEventListener("click", (e) => {
              const item = e.target.closest(".search-result-item");
              if (item && item.dataset.timestamp) {
                jumpToMessage(parseInt(item.dataset.timestamp));
              }
            });

          document
            .getElementById("create-weibo-post-btn")
            .addEventListener("click", openWeiboPublisherClean);

          document
            .getElementById("delete-expired-songs-btn")
            .addEventListener("click", deleteExpiredSearchedSongs);

          // ËßíËâ≤Ë°®ÊÉÖÂåÖÁÆ°ÁêÜÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("chat-settings-modal")
            .addEventListener("click", (e) => {
              if (e.target.id === "manage-char-stickers-btn") {
                document
                  .getElementById("chat-settings-modal")
                  .classList.remove("visible");
                openCharStickerManager();
              }
            });

          document
            .getElementById("back-from-sticker-manager")
            .addEventListener("click", () => {
              showScreen("chat-interface-screen");
              document.getElementById("chat-settings-btn").click();
            });

          const stickerTabExclusive = document.getElementById(
            "sticker-tab-exclusive",
          );
          const stickerTabCommon =
            document.getElementById("sticker-tab-common");
          const stickerContentExclusive = document.getElementById(
            "sticker-content-exclusive",
          );
          const stickerContentCommon = document.getElementById(
            "sticker-content-common",
          );

          stickerTabExclusive.addEventListener("click", () => {
            stickerTabExclusive.classList.add("active");
            stickerTabCommon.classList.remove("active");
            stickerContentExclusive.classList.add("active");
            stickerContentCommon.classList.remove("active");
            // ÂàáÊç¢Êó∂Â¶ÇÊûúÂ§Ñ‰∫éÈÄâÊã©Ê®°ÂºèÔºåÈúÄË¶ÅÈáçÊñ∞Ê∏≤Êüì
            if (isCharStickerSelectionMode) renderCharStickers("exclusive");
          });

          stickerTabCommon.addEventListener("click", () => {
            stickerTabCommon.classList.add("active");
            stickerTabExclusive.classList.remove("active");
            stickerContentCommon.classList.add("active");
            stickerContentExclusive.classList.remove("active");
            // ÂàáÊç¢Êó∂Â¶ÇÊûúÂ§Ñ‰∫éÈÄâÊã©Ê®°ÂºèÔºåÈúÄË¶ÅÈáçÊñ∞Ê∏≤Êüì
            if (isCharStickerSelectionMode) renderCharStickers("common");
          });

          // ÁªëÂÆöÂêÑÁßçÊ∑ªÂä†/‰∏ä‰º†ÊåâÈíÆ
          document
            .getElementById("add-exclusive-sticker-btn")
            .addEventListener("click", () => bulkAddCharStickers("exclusive"));
          document
            .getElementById("upload-exclusive-sticker-btn")
            .addEventListener("click", () =>
              uploadCharStickersLocal("exclusive"),
            );
          document
            .getElementById("add-common-sticker-btn")
            .addEventListener("click", () => bulkAddCharStickers("common"));
          document
            .getElementById("upload-common-sticker-btn")
            .addEventListener("click", () => uploadCharStickersLocal("common"));

          // ÂøÉÂ£∞ÂéÜÂè≤ËÆ∞ÂΩïÂà†Èô§ÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("clear-all-history-btn")
            .addEventListener("click", clearAllInnerVoiceHistory);

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÂ§ÑÁêÜÂçïÊù°Âà†Èô§
          document
            .getElementById("inner-voice-history-list")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("history-item-delete-btn")) {
                const timestamp = parseInt(e.target.dataset.timestamp);
                if (!isNaN(timestamp)) {
                  deleteSingleInnerVoice(timestamp);
                }
              }
            });

        document
  .getElementById("import-character-card-btn")
  .addEventListener("click", () => {
    document.getElementById("character-card-input").click();
  });


          // ‰∏∫Ëá™ÂÆö‰πâÊ®°ÊÄÅÊ°ÜÊ∑ªÂä†ÁÇπÂáªÂ§çÂà∂ËÆæÂ§áÁ†ÅÁöÑÂäüËÉΩ
          document
            .getElementById("custom-modal-body")
            .addEventListener("click", (e) => {
              const codeElement = e.target.closest("#device-code-to-copy");
              if (codeElement) {
                const deviceCode = codeElement.textContent;
                const feedbackEl = document.getElementById(
                  "copy-device-code-feedback",
                );
                navigator.clipboard
                  .writeText(deviceCode)
                  .then(() => {
                    if (feedbackEl) feedbackEl.textContent = "ËÆæÂ§áÁ†ÅÂ∑≤Â§çÂà∂ÔºÅ";
                    setTimeout(() => {
                      if (feedbackEl) feedbackEl.textContent = "";
                    }, 2000);
                  })
                  .catch((err) => {
                    if (feedbackEl)
                      feedbackEl.textContent = "Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®Â§çÂà∂„ÄÇ";
                  });
              }
            });

          document
            .getElementById("character-card-input")
            .addEventListener("change", (event) => {
              const file = event.target.files[0];
              if (file) {
                // ÂΩìÁî®Êà∑ÈÄâÊã©‰∫ÜÊñá‰ª∂ÂêéÔºåË∞ÉÁî®Êàë‰ª¨ÁöÑÊÄªÂ§ÑÁêÜÂáΩÊï∞
                handleCharacterImport(file);
              }
              // Ê∏ÖÁ©∫ÈÄâÊã©ÔºåËøôÊ†∑Áî®Êà∑‰∏ãÊ¨°ËøòËÉΩÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
              event.target.value = null;
            });

          document
            .getElementById("phone-screen")
            .addEventListener("click", unlockAudioContext, { once: true });

          document
            .getElementById("custom-modal-cancel")
            .addEventListener("click", hideCustomModal);
          document
            .getElementById("custom-modal-overlay")
            .addEventListener("click", (e) => {
              if (e.target === modalOverlay) hideCustomModal();
            });
          document
            .getElementById("clear-orphaned-data-btn")
            .addEventListener("click", clearOrphanedData);
          const repairBtn = document.getElementById("repair-data-btn");
          if (repairBtn) {
            repairBtn.addEventListener("click", repairAllData);
          }

          const factoryResetBtn = document.getElementById("factory-reset-btn");
          if (factoryResetBtn) {
            factoryResetBtn.addEventListener("click", handleFactoryReset);
          }
          document
            .getElementById("export-data-btn")
            .addEventListener("click", exportBackup);
          document
            .getElementById("import-btn")
            .addEventListener("click", () =>
              document.getElementById("import-data-input").click(),
            );
          document
            .getElementById("import-data-input")
            .addEventListener("change", (e) => importBackup(e.target.files[0]));
          document
            .getElementById("back-to-list-btn")
            .addEventListener("click", () => {
              stopPetDecayTimer();

              applyScopedCss("", "#chat-messages", "custom-bubble-style"); // Ê∏ÖÈô§ÁúüÂÆûËÅäÂ§©ÁïåÈù¢ÁöÑËá™ÂÆö‰πâÊ†∑Âºè
              applyScopedCss(
                "",
                "#settings-preview-area",
                "preview-bubble-style",
              ); // Ê∏ÖÈô§È¢ÑËßàÂå∫ÁöÑËá™ÂÆö‰πâÊ†∑Âºè

              exitSelectionMode();
              state.activeChatId = null;
              // „ÄêÂøÉÂ£∞ÂäüËÉΩ„ÄëËøîÂõûÂàóË°®Êó∂ÔºåÈöêËóèÂøÉÂΩ¢ÊåâÈíÆ
              document.getElementById("char-heart-btn").style.display = "none";
              showScreen("chat-list-screen");
            });

          // ‰∏∫Ê≠åÊõ≤Â∞ÅÈù¢/Ê≠åËØçÂå∫ÂüüÁªëÂÆöÁÇπÂáªÂàáÊç¢‰∫ã‰ª∂
          document
            .getElementById("music-display-area")
            .addEventListener("click", () => {
              const displayArea = document.getElementById("music-display-area");
              // Áõ¥Êé•ÂàáÊç¢ .show-lyrics Ëøô‰∏™Á±ªÔºåCSS‰ºöËá™Âä®Â§ÑÁêÜÊòæÁ§∫/ÈöêËóè
              displayArea.classList.toggle("show-lyrics");
            });

          document
            .getElementById("add-chat-btn")
            .addEventListener("click", async () => {
              const name = await showCustomPrompt(
                "Create a new chat",
                "Please enter their name.",
              );
              if (name && name.trim()) {
                const newChatId = "chat_" + Date.now();

                const newChat = {
                  id: newChatId,
                  name: name.trim(),
                  isGroup: false,
                  isPinned: false,
                  npcLibrary: [], // ËßíËâ≤‰∏ìÂ±ûNPCÂ∫ì
                  relationship: {
                    status: "friend",
                    blockedTimestamp: null,
                    applicationReason: "",
                  },
                  status: {
                    text: "Online",
                    lastUpdate: Date.now(),
                    isBusy: false,
                  },
                  settings: {
                    aiPersona: "‰Ω†ÊòØË∞ÅÂëÄ„ÄÇ",
                    myPersona: "ÊàëÊòØË∞ÅÂëÄ„ÄÇ",
                    maxMemory: 10,
                    aiAvatar: defaultAvatar,
                    myAvatar: defaultAvatar,
                    background: "",
                    theme: "default",
                    fontSize: 13,
                    customCss: "",
                    linkedWorldBookIds: [],
                    aiAvatarLibrary: [],
                    stickerLibrary: [], // ‰∏ìÂ±ûË°®ÊÉÖÂ∫ì
                    // === ‰ª•‰∏ãÊòØÊú¨Ê¨°‰øÆÂ§çÊñ∞Â¢ûÁöÑÂàùÂßãÂåñÂ±ûÊÄß ===
                    linkedMemories: [], // „Äê‰øÆÂ§çÊ†∏ÂøÉ„ÄëÂàùÂßãÂåñËÆ∞ÂøÜ‰∫íÈÄöÊï∞ÁªÑ
                    offlineMode: {
                      enabled: false,
                      prompt: "",
                      style: "",
                      wordCount: 300,
                      presets: [],
                    }, // ÂàùÂßãÂåñÁ∫ø‰∏ãÊ®°Âºè
                    timePerceptionEnabled: true, // ÂàùÂßãÂåñÊó∂Èó¥ÊÑüÁü•
                    customTime: "", // ÂàùÂßãÂåñËá™ÂÆö‰πâÊó∂Èó¥
                    isCoupleAvatar: false, // ÂàùÂßãÂåñÊÉÖ‰æ£Â§¥ÂÉèÂºÄÂÖ≥
                    coupleAvatarDescription: "", // ÂàùÂßãÂåñÊÉÖ‰æ£Â§¥ÂÉèÊèèËø∞
                    weiboProfession: "", // ÂàùÂßãÂåñÂæÆÂçöËÅå‰∏ö
                    weiboInstruction: "", // ÂàùÂßãÂåñÂæÆÂçöÊåá‰ª§
                  },
                  history: [],
                  musicData: { totalTime: 0 },
                  // ÊâãÊú∫Êï∞ÊçÆ‰πü‰øùÊåÅÂÆåÊï¥
                  characterPhoneData: {
                    lastGenerated: null,
                    chats: {},
                    shoppingCart: [],
                    memos: [],
                    browserHistory: [],
                    photoAlbum: [],
                    bank: { balance: 0, transactions: [] },
                    trajectory: [],
                    appUsage: [],
                    diary: [],
                  },
                  houseData: null,
                };

                state.chats[newChatId] = newChat;
                await db.chats.put(newChat);
                renderChatList();
              }
            });

          // ÂàõÂª∫Áæ§ËÅäÊåâÈíÆÁé∞Âú®ÊâìÂºÄËÅîÁ≥ª‰∫∫ÈÄâÊã©Âô®
          document
            .getElementById("add-group-chat-btn")
            .addEventListener("click", openContactPickerForGroupCreate);

          document
            .getElementById("transfer-cancel-btn")
            .addEventListener("click", () =>
              document
                .getElementById("transfer-modal")
                .classList.remove("visible"),
            );
          document
            .getElementById("transfer-confirm-btn")
            .addEventListener("click", sendUserTransfer);
          document
            .getElementById("listen-together-btn")
            .addEventListener("click", handleListenTogetherClick);
          document
            .getElementById("music-exit-btn")
            .addEventListener("click", () => endListenTogetherSession(true));
          document
            .getElementById("music-return-btn")
            .addEventListener("click", returnToChat);
          document
            .getElementById("music-play-pause-btn")
            .addEventListener("click", togglePlayPause);
          document
            .getElementById("music-next-btn")
            .addEventListener("click", playNext);
          document
            .getElementById("music-prev-btn")
            .addEventListener("click", playPrev);
          document
            .getElementById("music-mode-btn")
            .addEventListener("click", changePlayMode);
          document
            .getElementById("music-playlist-btn")
            .addEventListener("click", () => {
              updatePlaylistUI();
              document
                .getElementById("music-playlist-panel")
                .classList.add("visible");
            });
          document
            .getElementById("close-playlist-btn")
            .addEventListener("click", () =>
              document
                .getElementById("music-playlist-panel")
                .classList.remove("visible"),
            );
          document
            .getElementById("add-song-url-btn")
            .addEventListener("click", addSongFromURL);
          document
            .getElementById("add-song-local-btn")
            .addEventListener("click", () =>
              document.getElementById("local-song-upload-input").click(),
            );
          document
            .getElementById("local-song-upload-input")
            .addEventListener("change", addSongFromLocal);
          // BGMÊêúÁ¥¢ÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("add-song-search-btn")
            .addEventListener("click", addSongFromSearch);

          document
            .getElementById("cancel-music-search-btn")
            .addEventListener("click", () => {
              document
                .getElementById("music-search-results-modal")
                .classList.remove("visible");
            });

          document
            .getElementById("search-results-list")
            .addEventListener("click", (e) => {
              const item = e.target.closest(".search-result-item");
              if (item && item.dataset.songJson) {
                const songData = JSON.parse(item.dataset.songJson);
                handleSearchResultClick(songData);
              }
            });

          // Êí≠ÊîæÁªìÊùüÁõëÂê¨Âô®Ôºà‰øùÊ¥ªÈü≥È¢ëÂº∫Âà∂Ê≠ªÂæ™ÁéØÔºâ
          audioPlayer.addEventListener("ended", () => {
            const currentTrack =
              state.musicState.playlist[state.musicState.currentIndex];

            // Â¶ÇÊûúÊòØ‰øùÊ¥ªÈü≥È¢ëÔºåÂº∫Âà∂ÈáçÊí≠ÔºåÊó†ËßÜ‰ªª‰ΩïÊ®°Âºè
            if (currentTrack && currentTrack.isKeepAlive) {
              console.log("‰øùÊ¥ªÈü≥È¢ëÂæ™ÁéØ‰∏≠...");
              audioPlayer.currentTime = 0;
              audioPlayer.play().catch((e) => console.error("ÈáçÊí≠Â§±Ë¥•:", e));
            } else {
              // Ê≠£Â∏∏Ê≠åÊõ≤Ëµ∞Ê≠£Â∏∏ÈÄªËæë
              playNext();
            }
          });

          // 20ÂàÜÈíüÂº∫Âà∂Âæ™ÁéØÁõëÂê¨Âô®
          audioPlayer.addEventListener("timeupdate", () => {
            const currentTrack =
              state.musicState.playlist[state.musicState.currentIndex];

            // Ê£ÄÊü•Ôºö1.ÊòØÂê¶Â≠òÂú®ÂΩìÂâçÊ≠åÊõ≤ 2.ÊòØÂê¶ÊòØ‰øùÊ¥ªÈü≥È¢ë 3.ÊòØÂê¶Ë∂ÖËøá20ÂàÜÈíü(1200Áßí)
            if (
              currentTrack &&
              currentTrack.isKeepAlive &&
              audioPlayer.currentTime > 600
            ) {
              console.log("‰øùÊ¥ªÈü≥È¢ëÂ∑≤Êí≠Êîæ20ÂàÜÈíüÔºåÊâßË°åÂæ™ÁéØ...");
              // Âº∫Âà∂ÊãâÂõû 0 Áßí
              audioPlayer.currentTime = 0;
              // Á°Æ‰øùÁªßÁª≠Êí≠Êîæ
              if (audioPlayer.paused) {
                audioPlayer
                  .play()
                  .catch((e) => console.error("Âæ™ÁéØÈáçÊí≠Â§±Ë¥•:", e));
              }
            }
          });

          const chatInput = document.getElementById("chat-input");

          document
            .getElementById("send-btn")
            .addEventListener("click", async () => {
              const content = chatInput.value.trim();
              if (!content || !state.activeChatId) return;

              const chat = state.chats[state.activeChatId];

              // ÊóÅÁôΩÊã¶Êà™ÈÄªËæë
              // Ê£ÄÊü•ÊòØÂê¶‰ª• <ÊóÅÁôΩ> ÂºÄÂ§¥
              if (content.startsWith("<ÊóÅÁôΩ>")) {
                // ÊèêÂèñÊóÅÁôΩÂÜÖÂÆπ
                const narrativeContent = content.replace(/^<ÊóÅÁôΩ>/, "").trim();

                if (narrativeContent) {
                  const msg = {
                    role: "system", // ËÆæÁΩÆ‰∏∫ system ËßíËâ≤Ôºå‰∏çÂ±û‰∫éÁî®Êà∑
                    type: "narrative", // ËÆæÁΩÆ‰∏ìÈó®ÁöÑÁ±ªÂûã
                    content: narrativeContent,
                    timestamp: Date.now(),
                  };

                  chat.history.push(msg);
                  await db.chats.put(chat);
                  appendMessage(msg, chat);

                  // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
                  chatInput.value = "";
                  chatInput.style.height = "auto";
                  chatInput.focus();

                  return; // Êã¶Êà™ÊàêÂäüÔºå‰∏çÂÜçÊâßË°åÂêéÁª≠ÁöÑÊôÆÈÄöÂèëÈÄÅÈÄªËæë
                }
              }

              try {
                const command = JSON.parse(content);
                // Ê£ÄÊü•ÔºöËøôÊòØÂê¶ÊòØ‰∏Ä‰∏™ËÆ©ËßíËâ≤ÂèëÂæÆÂçöÁöÑÊåá‰ª§Ôºü
                if (command && command.type === "weibo_post") {
                  const chat = state.chats[state.activeChatId];
                  if (chat.isGroup) {
                    alert("‰∏çËÉΩÂú®Áæ§ËÅä‰∏≠‰∏∫Âçï‰∏™ËßíËâ≤ÂèëÂ∏ÉÂæÆÂçö„ÄÇ");
                    return;
                  }

                  // ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÂæÆÂçöÂ∏ñÂ≠êÂØπË±°
                  const newPost = {
                    authorId: chat.id, // ÂÖ≥ÈîÆÔºÅ‰ΩúËÄÖIDÊòØÂΩìÂâçËßíËâ≤ÁöÑIDÔºåËÄå‰∏çÊòØ'user'
                    authorType: "char",
                    authorNickname: chat.name,
                    authorAvatar: chat.settings.aiAvatar || defaultAvatar,
                    content: command.content || "",
                    timestamp: Date.now(),
                    likes: [],
                    comments: [],
                    baseLikesCount: command.baseLikesCount || 0,
                    baseCommentsCount: command.baseCommentsCount || 0,
                  };

                  // Â¶ÇÊûúJSONÈáåÊúâË∑Ø‰∫∫ËØÑËÆ∫ÔºåÂ∞±Ëß£ÊûêÂπ∂Ê∑ªÂä†
                  if (
                    command.comments &&
                    typeof command.comments === "string"
                  ) {
                    newPost.comments = command.comments
                      .split("\n")
                      .map((c) => {
                        const parts = c.split(/[:Ôºö]/);
                        const commenter = parts.shift() || "Ë∑Ø‰∫∫";
                        const commentText = parts.join(":").trim();
                        return {
                          commentId: "comment_" + Date.now() + Math.random(),
                          authorNickname: commenter,
                          commentText: commentText,
                        };
                      })
                      .filter((c) => c.commentText);
                  }

                  await db.weiboPosts.add(newPost);

                  // Âà∑Êñ∞‚ÄúÂÖ≥Ê≥®ÁöÑ‰∫∫‚ÄùÂàóË°®ÔºåÊñ∞ÂæÆÂçöÂ∞±‰ºöÂá∫Áé∞‰∫ÜÔºÅ
                  await renderFollowingWeiboFeed();

                  await showCustomAlert(
                    "Êìç‰ΩúÊàêÂäü",
                    `Â∑≤‰∏∫ ‚Äú${chat.name}‚Äù ÂèëÂ∏É‰∫Ü‰∏ÄÊù°Êñ∞ÂæÆÂçöÔºÅ`,
                  );

                  chatInput.value = ""; // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
                  return; // ÁªìÊùüÂáΩÊï∞Ôºå‰∏çÂÜçÊâßË°åÂêéÈù¢ÁöÑ‰ª£Á†Å
                }
              } catch (e) {
                // Â¶ÇÊûúËß£ÊûêJSONÂ§±Ë¥•ÔºåËØ¥ÊòéÂÆÉ‰∏çÊòØÊåá‰ª§ÔºåÂè™ÊòØÊôÆÈÄöÊñáÊú¨ÔºåÂ∞±ËÆ©‰ª£Á†ÅÁªßÁª≠ÂæÄ‰∏ãËµ∞
              }

              // 1. Â¶ÇÊûúÊòØÁæ§ËÅäÔºåÂπ∂‰∏î‰Ω†Ë¢´Á¶ÅË®Ä‰∫Ü
              if (chat && chat.isGroup && chat.settings.isUserMuted) {
                alert("‰Ω†Â∑≤Ë¢´Á¶ÅË®ÄÔºåÊó†Ê≥ïÂèëË®ÄÔºÅ");
                return; // ÈòªÊ≠¢ÂèëÈÄÅ
              }

              const msg = {
                role: "user",
                content,
                timestamp: Date.now(),
              };

              // Ê£ÄÊü•ÂΩìÂâçÊòØÂê¶Â§Ñ‰∫éÂºïÁî®ÂõûÂ§çÊ®°Âºè
              if (currentReplyContext) {
                msg.quote = currentReplyContext; // Â∞ÜÂºïÁî®‰ø°ÊÅØÈôÑÂä†Âà∞Ê∂àÊÅØÂØπË±°‰∏ä
              }

              chat.history.push(msg);
              await incrementMessageCount(state.activeChatId);
              await db.chats.put(chat);
              appendMessage(msg, chat);
              renderChatList();
              chatInput.value = "";
              chatInput.style.height = "auto";
              chatInput.focus();

              cancelReplyMode();
            });
          document
            .getElementById("wait-reply-btn")
            .addEventListener("click", triggerAiResponse);
          document
            .getElementById("advance-plot-btn")
            .addEventListener("click", advancePlot);
          document
            .getElementById("impersonate-user-btn")
            .addEventListener("click", impersonateUser);
          document
            .getElementById("poke-pat-btn")
            .addEventListener("click", openPokeModal);
          document
            .getElementById("do-poke-btn")
            .addEventListener("click", () => sendPokeAction("poke"));
          document
            .getElementById("do-pat-btn")
            .addEventListener("click", () => sendPokeAction("pat"));
          document
            .getElementById("cancel-poke-btn")
            .addEventListener("click", () =>
              document.getElementById("poke-choice-modal").classList.remove("visible")
            );

          // ‚òÖ Persona Manager color picker ‚òÖ
          document.getElementById('pm-editor-color-picker')?.addEventListener('click', e => {
            const dot = e.target.closest('.pm-color-dot');
            if (!dot) return;
            document.querySelectorAll('#pm-editor-color-picker .pm-color-dot').forEach(d => d.classList.remove('selected'));
            dot.classList.add('selected');
            document.getElementById('pm-editor-color').value = dot.dataset.color;
          });

          chatInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              document.getElementById("send-btn").click();
            }
          });
          chatInput.addEventListener("input", () => {
            chatInput.style.height = "auto";
            chatInput.style.height = chatInput.scrollHeight + "px";
          });

          document
            .getElementById("wallpaper-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res, rej) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.onerror = () => rej(reader.error);
                  reader.readAsDataURL(file);
                });
                newWallpaperBase64 = dataUrl;
                renderWallpaperScreen();
              }
            });

          document
            .getElementById("save-wallpaper-btn")
            .addEventListener("click", async () => {
              let changesMade = false;

              // ‰øùÂ≠òÂ£ÅÁ∫∏
              if (newWallpaperBase64) {
                state.globalSettings.wallpaper = newWallpaperBase64;
                changesMade = true;
              }

              // ‰øùÂ≠òÈîÅÂ±èÂ£ÅÁ∫∏
              if (newLockscreenWallpaperBase64) {
                state.globalSettings.lockscreenWallpaper =
                  newLockscreenWallpaperBase64;
                changesMade = true;
              }

              // ‰øùÂ≠òÂÖ®Â±ÄËÅäÂ§©ËÉåÊôØ
              if (newGlobalBgBase64 === "REMOVED") {
                state.globalSettings.globalChatBackground = "";
                changesMade = true;
              } else if (newGlobalBgBase64) {
                state.globalSettings.globalChatBackground = newGlobalBgBase64;
                changesMade = true;
              }

              // Êàë‰ª¨Â∞ÜCSS‰ª£Á†Å‰øùÂ≠òÂà∞‰∏Ä‰∏™Êñ∞Â±ûÊÄß activeCustomCss ‰∏≠
              state.globalSettings.activeCustomCss =
                document.getElementById("theme-css-editor").value;
              // ÂêåÊó∂Ôºå‰øùÂ≠òÂΩìÂâçÈÄâÊã©ÁöÑ„Äê‰∏ªÈ¢òID„ÄëÔºåÂ¶ÇÊûúÁî®Êà∑Ê≤°ÈÄâÔºåÂ∞±‰øùÂ≠ònull
              const activeThemeSelector =
                document.getElementById("theme-selector");
              state.globalSettings.activeThemeId = activeThemeSelector.value
                ? parseInt(activeThemeSelector.value)
                : null;
              changesMade = true; // Âè™Ë¶ÅÁÇπÂáª‰øùÂ≠òÔºåÂ∞±ËÆ§‰∏∫CSSÊúâÂèòÂä®

              // ‰øùÂ≠òÂØÜÁ†Å
              const newPassword =
                document.getElementById("password-set-input").value;
              state.globalSettings.password = newPassword;

              // ‰øùÂ≠òÈìÉÂ£∞ÂíåÊèêÁ§∫Èü≥
              state.globalSettings.ringtoneUrl = document
                .getElementById("ringtone-url-input")
                .value.trim();
              state.globalSettings.notificationSoundUrl = document
                .getElementById("notification-sound-url-input")
                .value.trim();

              // ‰øùÂ≠òÈîÅÂ±èÂíåÁä∂ÊÄÅÊ†èÂºÄÂÖ≥Áä∂ÊÄÅ
              const isLockEnabled = document.getElementById(
                "enable-lock-screen-toggle",
              ).checked;
              state.globalSettings.enableLockScreen = isLockEnabled;
              localStorage.setItem("lockScreenEnabled", isLockEnabled);

              // ‰øùÂ≠ò‰∏ªÂ±èÂπïÂ≠ó‰ΩìÈ¢úËâ≤ (Áé∞Âú®Êàë‰ª¨ÂèØ‰ª•‰ªé‰ªªÊÑè‰∏Ä‰∏™ËæìÂÖ•Ê°ÜÂèñÂÄºÔºåÂõ†‰∏∫ÂÆÉ‰ª¨ÊòØÂêåÊ≠•ÁöÑ)
              // ËøôÈáå‰ºòÂÖàÂèñÊñáÊú¨Ê°ÜÁöÑÂÄºÔºåÂõ†‰∏∫ÂÆÉÊõ¥Áõ¥ËßÇ
              const colorInputVal = document.getElementById(
                "home-icon-widget-text-color-input",
              ).value;
              // ÂÅö‰∏™ÊúÄÂêéÊ†°È™åÔºåÂ¶ÇÊûúÊñáÊú¨Ê°ÜÈáåÁöÑ‰∏çÂØπÔºåÂ∞±Áî®ÈÄâËâ≤ÁõòÁöÑ
              const hexRegex = /^#([0-9A-F]{3}){1,2}$/i;
              if (hexRegex.test(colorInputVal)) {
                state.globalSettings.homeIconWidgetTextColor = colorInputVal;
              } else {
                state.globalSettings.homeIconWidgetTextColor =
                  document.getElementById(
                    "home-icon-widget-text-color-picker",
                  ).value;
              }
              state.globalSettings.removeHomeFontShadow =
                document.getElementById(
                  "remove-home-font-shadow-toggle",
                ).checked;

              // ‰øùÂ≠òAppÂêçÁß∞
              saveAppLabels();

              // Â∞ÜÊâÄÊúâËÆæÁΩÆ‰∏ÄÊ¨°ÊÄßÂÜôÂÖ•Êï∞ÊçÆÂ∫ì
              await db.globalSettings.put(state.globalSettings);

              // Â∫îÁî®ÊâÄÊúâÊõ¥Êîπ
              if (changesMade) {
                applyGlobalWallpaper();
                applyLockscreenWallpaper();
                applyThemeCss(state.globalSettings.activeCustomCss); // Â∫îÁî®ÂàöÂàö‰øùÂ≠òÁöÑCSS
                newWallpaperBase64 = null;
                newLockscreenWallpaperBase64 = null;
                newGlobalBgBase64 = null;
              }
              applyAppIcons();
              applyAppLabels();

              alert("ÊâÄÊúâÂ§ñËßÇËÆæÁΩÆÂ∑≤‰øùÂ≠òÂπ∂Â∫îÁî®ÔºÅ");
              showScreen("home-screen");
            });

          document
            .getElementById("save-api-settings-btn")
            .addEventListener("click", async () => {
              const proxyUrl = document
                .getElementById("proxy-url")
                .value.trim();
              const apiKey = document.getElementById("api-key").value.trim();
              const isBlocked = BLOCKED_API_SITES.some((blockedDomain) =>
                proxyUrl.includes(blockedDomain),
              );

              if (isBlocked) {
                alert("ÈîôËØØÔºöËØ• API Á´ôÁÇπÂ∑≤Ë¢´Á¶ÅÁî®ÔºåÊó†Ê≥ï‰ΩøÁî®„ÄÇ");
                return; // ÈòªÊ≠¢‰øùÂ≠ò
              }

              state.apiConfig.proxyUrl = document
                .getElementById("proxy-url")
                .value.trim();
              state.apiConfig.apiKey = document
                .getElementById("api-key")
                .value.trim();
              state.apiConfig.model =
                document.getElementById("model-select").value;
              state.apiConfig.temperature = parseFloat(
                document.getElementById("temperature-slider").value,
              );
              // ‰øùÂ≠ò Minimax ËÆæÁΩÆ
              state.apiConfig.minimaxGroupId = document
                .getElementById("minimax-group-id")
                .value.trim();
              state.apiConfig.minimaxApiKey = document
                .getElementById("minimax-api-key")
                .value.trim();
              state.apiConfig.minimaxProvider = document.getElementById(
                "minimax-provider-select",
              ).value;
              state.apiConfig.minimaxSpeechModel = document.getElementById(
                "minimax-speech-model-select",
              ).value;
              // --- ‰øùÂ≠ò GitHub Â§á‰ªΩËÆæÁΩÆ ---
              state.apiConfig.githubToken = document
                .getElementById("github-token")
                .value.trim();
              state.apiConfig.githubUsername = document
                .getElementById("github-username")
                .value.trim();
              state.apiConfig.githubRepo = document
                .getElementById("github-repo")
                .value.trim();
              state.apiConfig.githubPath =
                document.getElementById("github-path").value.trim() ||
                "ephone_backup.json";
              state.apiConfig.githubAutoBackup = document.getElementById(
                "github-auto-backup-switch",
              ).checked;
              // ‚òÖ‚òÖ‚òÖ Êñ∞Â¢ûÔºö‰øùÂ≠òÊ®°ÂºèÂíåÊó∂Èó¥ ‚òÖ‚òÖ‚òÖ
              state.apiConfig.githubBackupMode =
                document.getElementById("github-backup-mode").value;
              state.apiConfig.githubBackupInterval =
                parseInt(
                  document.getElementById("github-backup-interval").value,
                ) || 30;
              state.apiConfig.pollinationsApiKey = document
                .getElementById("pollinations-api-key")
                .value.trim();

              // Save API CORS proxy
              const _apiProxySelect = document.getElementById("api-cors-proxy").value;
              const _apiProxyFinal = _apiProxySelect === "custom"
                ? (document.getElementById("api-custom-proxy-url").value.trim() || "")
                : _apiProxySelect;
              localStorage.setItem("api-cors-proxy", _apiProxyFinal);

              // Â¶ÇÊûúÂºÄÂêØ‰∫ÜËá™Âä®Â§á‰ªΩÔºåÁ´ãÂç≥ÈáçÂêØÂÆöÊó∂Âô®
              handleAutoBackupTimer();
              await db.apiConfig.put(state.apiConfig);
              state.globalSettings.enableSystemNotifications =
                document.getElementById("system-notification-switch").checked;
              console.log(
                "‰øùÂ≠òÁ≥ªÁªüÈÄöÁü•ÂºÄÂÖ≥Áä∂ÊÄÅ:",
                state.globalSettings.enableSystemNotifications,
              );
              state.globalSettings.imageCompressionQuality = parseFloat(
                document.getElementById("image-quality-slider").value,
              );
              state.globalSettings.enableSystemNotifications =
                document.getElementById("system-notification-switch").checked;
              const backgroundSwitch = document.getElementById(
                "background-activity-switch",
              );
              const intervalInput = document.getElementById(
                "background-interval-input",
              );
              const newEnableState = backgroundSwitch.checked;
              const oldEnableState =
                state.globalSettings.enableBackgroundActivity || false;

              // Âè™ÊúâÂú®Áî®Êà∑‚Äú‰ªéÂÖ≥Âà∞ÂºÄ‚ÄùÊó∂ÔºåÊâçÂºπÂá∫Ë≠¶Âëä
              if (newEnableState && !oldEnableState) {
                const userConfirmed = confirm(
                  "„ÄêÈ´òË¥πÁî®Ë≠¶Âëä„Äë\n\n" +
                    "ÊÇ®Ê≠£Âú®ÂêØÁî®‚ÄúÂêéÂè∞ËßíËâ≤Ê¥ªÂä®‚ÄùÂäüËÉΩ„ÄÇ\n\n" +
                    "Ëøô‰ºö‰ΩøÊÇ®ÁöÑAIËßíËâ≤‰ª¨Âú®ÊÇ®‰∏çÂíå‰ªñ‰ª¨ËÅäÂ§©Êó∂Ôºå‰πüËÉΩ‚ÄúÁã¨Á´ãÊÄùËÄÉ‚ÄùÂπ∂‰∏ªÂä®ÁªôÊÇ®ÂèëÊ∂àÊÅØÊàñËøõË°åÁ§æ‰∫§‰∫íÂä®ÔºåÊûÅÂ§ßÂú∞Â¢ûÂº∫Ê≤âÊµ∏ÊÑü„ÄÇ\n\n" +
                    "‰ΩÜËØ∑Ê≥®ÊÑèÔºö\n" +
                    "Ëøô‰ºö„ÄêÂú®ÂêéÂè∞Ëá™Âä®„ÄÅÂÆöÊúüÂú∞Ë∞ÉÁî®API„ÄëÔºåÂç≥‰ΩøÊÇ®‰∏çËøõË°å‰ªª‰ΩïÊìç‰Ωú„ÄÇÊ†πÊçÆÊÇ®ÁöÑËßíËâ≤Êï∞ÈáèÂíåÊ£ÄÊµãÈó¥ÈöîÔºåËøôÂèØËÉΩ‰ºöÂØºËá¥ÊÇ®ÁöÑAPIË¥πÁî®ÊòæËëóÂ¢ûÂä†„ÄÇ\n\n" +
                    "ÊÇ®Á°ÆÂÆöË¶ÅÂºÄÂêØÂêóÔºü",
                );

                if (!userConfirmed) {
                  backgroundSwitch.checked = false; // Áî®Êà∑ÂèñÊ∂àÔºåÊääÂºÄÂÖ≥Êã®ÂõûÂéª
                  return; // ÈòªÊ≠¢ÂêéÁª≠ÈÄªËæë
                }
              }

              state.globalSettings.enableBackgroundActivity = newEnableState;
              state.globalSettings.backgroundActivityInterval =
                parseInt(intervalInput.value) || 60;
              state.globalSettings.blockCooldownHours =
                parseFloat(
                  document.getElementById("block-cooldown-input").value,
                ) || 1;
              await db.globalSettings.put(state.globalSettings);

              // Âä®ÊÄÅÂêØÂä®ÊàñÂÅúÊ≠¢Ê®°ÊãüÂô®
              stopBackgroundSimulation();
              if (state.globalSettings.enableBackgroundActivity) {
                startBackgroundSimulation();
                console.log(
                  `ÂêéÂè∞Ê¥ªÂä®Ê®°ÊãüÂ∑≤ÂêØÂä®ÔºåÈó¥Èöî: ${state.globalSettings.backgroundActivityInterval}Áßí`,
                );
              } else {
                console.log("ÂêéÂè∞Ê¥ªÂä®Ê®°ÊãüÂ∑≤ÂÅúÊ≠¢„ÄÇ");
              }
              const novelaiSwitch = document.getElementById("novelai-switch");
              const novelaiModelInput =
                document.getElementById("novelai-model");
              const novelaiKeyInput =
                document.getElementById("novelai-api-key");

              if (novelaiSwitch) {
                localStorage.setItem("novelai-enabled", novelaiSwitch.checked);
              }
              if (novelaiModelInput) {
                localStorage.setItem("novelai-model", novelaiModelInput.value);
              }
              if (novelaiKeyInput) {
                localStorage.setItem(
                  "novelai-api-key",
                  novelaiKeyInput.value.trim(),
                );
              }
              alert("API settings have been saved!");
            });

          // gemini ÂØÜÈí•ËÅöÁÑ¶ÁöÑÊó∂ÂÄôÊòæÁ§∫ÊòéÊñá
          const ApiKeyInput = document.getElementById("api-key");
          ApiKeyInput.addEventListener("focus", (e) => {
            e.target.setAttribute("type", "text");
          });
          ApiKeyInput.addEventListener("blur", (e) => {
            e.target.setAttribute("type", "password");
          });

          // API CORS proxy dropdown ‚Äî show/hide custom input
          document
            .getElementById("api-cors-proxy")
            .addEventListener("change", (e) => {
              document.getElementById("api-custom-proxy-group").style.display =
                e.target.value === "custom" ? "block" : "none";
            });

          document
            .getElementById("fetch-models-btn")
            .addEventListener("click", async () => {
              const url = document.getElementById("proxy-url").value.trim();
              const key = document.getElementById("api-key").value.trim();
              if (!url || !key) return alert("ËØ∑ÂÖàÂ°´ÂÜôÂèç‰ª£Âú∞ÂùÄÂíåÂØÜÈí•");
              try {
                let isGemini = url === GEMINI_API_URL;
                const response = await fetch(
                  isGemini
                    ? `${GEMINI_API_URL}?key=${getRandomValue(key)}`
                    : `${url}/v1/models`,
                  isGemini
                    ? undefined
                    : { headers: { Authorization: `Bearer ${key}` } },
                );
                if (!response.ok) throw new Error("Êó†Ê≥ïËé∑ÂèñÊ®°ÂûãÂàóË°®");
                const data = await response.json();
                let models = isGemini ? data.models : data.data;
                if (isGemini) {
                  models = models.map((model) => {
                    const parts = model.name.split("/");
                    return {
                      id: parts.length > 1 ? parts[1] : model.name,
                    };
                  });
                }
                // Ëé∑ÂèñÊàë‰ª¨ÁöÑËæÖÂä©‰∏ãÊãâÊ°Ü
                const picker = document.getElementById("fetched-model-list");
                picker.innerHTML =
                  '<option value="">‚ñº ËØ∑ÈÄâÊã©Ê®°Âûã (ÁÇπÂáªËá™Âä®Â°´ÂÖ•‰∏äÊñπ)</option>';

                // Â°´ÂÖÖ‰∏ãÊãâÊ°Ü
                models.forEach((model) => {
                  const option = document.createElement("option");
                  option.value = model.id;
                  option.textContent = model.id;
                  picker.appendChild(option);
                });

                // ÊòæÁ§∫‰∏ãÊãâÊ°Ü
                picker.style.display = "block";

                alert(
                  `ÊàêÂäüÊãâÂèñ ${models.length} ‰∏™Ê®°ÂûãÔºÅ\nËØ∑ÁÇπÂáª‰∏ãÊñπÁöÑ‰∏ãÊãâÊ°ÜÈÄâÊã©ÔºåÈÄâÊã©Âêé‰ºöËá™Âä®Â°´ÂÖ•ËæìÂÖ•Ê°Ü„ÄÇ`,
                );
              } catch (error) {
                alert(`ÊãâÂèñÊ®°ÂûãÂ§±Ë¥•: ${error.message}`);
              }
            });
          document
            .getElementById("fetch-minimax-speech-models-btn")
            .addEventListener("click", fetchMinimaxSpeechModels);

          // NovelAIÁ≥ªÁªüÁöÑJavaScript‰∫ã‰ª∂ÁõëÂê¨Âô®
          document
            .getElementById("novelai-switch")
            .addEventListener("change", (e) => {
              const detailsDiv = document.getElementById("novelai-details");
              detailsDiv.style.display = e.target.checked ? "block" : "none";
            });

          // NovelAI API KeyÊòæÁ§∫/ÈöêËóèÂàáÊç¢
          document
            .getElementById("novelai-key-toggle")
            .addEventListener("click", function () {
              const input = document.getElementById("novelai-api-key");
              if (input.type === "password") {
                input.type = "text";
                this.textContent = "üòå";
              } else {
                input.type = "password";
                this.textContent = "üßê";
              }
            });

          // ÊâìÂºÄNovelAIËÆæÁΩÆÂºπÁ™ó
          document
            .getElementById("novelai-settings-btn")
            .addEventListener("click", () => {
              loadNovelAISettings();
              document.getElementById("novelai-settings-modal").style.display =
                "flex";
            });

          // CORS‰ª£ÁêÜÈÄâÊã©Âô®ÂèòÂåñ‰∫ã‰ª∂
          document
            .getElementById("nai-cors-proxy")
            .addEventListener("change", (e) => {
              const customProxyGroup = document.getElementById(
                "nai-custom-proxy-group",
              );
              if (e.target.value === "custom") {
                customProxyGroup.style.display = "block";
              } else {
                customProxyGroup.style.display = "none";
              }
            });

          // ÂÖ≥Èó≠NovelAIËÆæÁΩÆÂºπÁ™ó
          document
            .getElementById("close-novelai-settings")
            .addEventListener("click", () => {
              document.getElementById("novelai-settings-modal").style.display =
                "none";
            });

          // ‰øùÂ≠òNovelAIËÆæÁΩÆ
          document
            .getElementById("save-nai-settings-btn")
            .addEventListener("click", () => {
              saveNovelAISettings();
              document.getElementById("novelai-settings-modal").style.display =
                "none";
              alert("NovelAIËÆæÁΩÆÂ∑≤‰øùÂ≠òÔºÅ");
            });

          // ÊÅ¢Â§çÈªòËÆ§ËÆæÁΩÆ
          document
            .getElementById("reset-nai-settings-btn")
            .addEventListener("click", () => {
              if (confirm("Á°ÆÂÆöË¶ÅÊÅ¢Â§çÈªòËÆ§ËÆæÁΩÆÂêóÔºü")) {
                resetNovelAISettings();
              }
            });

          // ÊâìÂºÄNovelAIÊµãËØïÂºπÁ™ó
          document
            .getElementById("novelai-test-btn")
            .addEventListener("click", () => {
              const apiKey = document
                .getElementById("novelai-api-key")
                .value.trim();
              if (!apiKey) {
                alert("ËØ∑ÂÖàÂ°´ÂÜôNovelAI API KeyÔºÅ");
                return;
              }
              document.getElementById("novelai-test-modal").style.display =
                "flex";
              document.getElementById("nai-test-result").style.display = "none";
              document.getElementById("nai-test-error").style.display = "none";
            });

          // ÂÖ≥Èó≠NovelAIÊµãËØïÂºπÁ™ó
          document
            .getElementById("close-novelai-test")
            .addEventListener("click", () => {
              document.getElementById("novelai-test-modal").style.display =
                "none";
            });

          document
            .getElementById("close-nai-test-btn")
            .addEventListener("click", () => {
              document.getElementById("novelai-test-modal").style.display =
                "none";
            });

          // NovelAIÁîüÊàêÂõæÂÉèÊåâÈíÆ
          document
            .getElementById("nai-generate-btn")
            .addEventListener("click", async () => {
              await generateNovelAIImage();
            });

          // NovelAI‰∏ãËΩΩÂõæÂÉèÊåâÈíÆ
          document
            .getElementById("nai-download-btn")
            .addEventListener("click", () => {
              const img = document.getElementById("nai-result-image");
              const link = document.createElement("a");
              link.href = img.src;
              link.download = "novelai-generated-" + Date.now() + ".png";
              link.click();
            });

          // ‚îÄ‚îÄ PixAI event listeners ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

          // PixAI API Key visibility toggle
          document
            .getElementById("pixai-key-toggle")
            .addEventListener("click", function () {
              const input = document.getElementById("pixai-api-key");
              if (input.type === "password") {
                input.type = "text";
                this.textContent = "üòå";
              } else {
                input.type = "password";
                this.textContent = "üßê";
              }
            });

          // Open PixAI settings modal
          document
            .getElementById("pixai-settings-btn")
            .addEventListener("click", () => {
              loadPixAISettings();
              document.getElementById("pixai-settings-modal").style.display = "flex";
            });

          // CORS proxy selector for PixAI
          document
            .getElementById("pai-cors-proxy")
            .addEventListener("change", (e) => {
              document.getElementById("pai-custom-proxy-group").style.display =
                e.target.value === "custom" ? "block" : "none";
            });

          // Close PixAI settings modal
          document
            .getElementById("close-pixai-settings")
            .addEventListener("click", () => {
              document.getElementById("pixai-settings-modal").style.display = "none";
            });

          // Save PixAI settings
          document
            .getElementById("save-pixai-settings-btn")
            .addEventListener("click", () => {
              savePixAISettings();
              alert("PixAI settings saved!");
            });

          // Reset PixAI settings
          document
            .getElementById("reset-pixai-settings-btn")
            .addEventListener("click", () => {
              if (confirm("Reset PixAI settings to defaults?")) {
                localStorage.removeItem("pixai-settings");
                loadPixAISettings();
              }
            });

          // Open PixAI test modal
          document
            .getElementById("pixai-test-btn")
            .addEventListener("click", () => {
              const apiKey = document.getElementById("pixai-api-key").value.trim();
              if (!apiKey) {
                alert("Please enter your PixAI API Key first.");
                return;
              }
              document.getElementById("pixai-test-modal").style.display = "flex";
              document.getElementById("pai-test-result").style.display = "none";
              document.getElementById("pai-test-error").style.display = "none";
            });

          // Close PixAI test modal
          document
            .getElementById("close-pixai-test")
            .addEventListener("click", () => {
              document.getElementById("pixai-test-modal").style.display = "none";
            });
          document
            .getElementById("close-pai-test-btn")
            .addEventListener("click", () => {
              document.getElementById("pixai-test-modal").style.display = "none";
            });

          // PixAI generate button (test modal)
          document
            .getElementById("pai-generate-btn")
            .addEventListener("click", async () => {
              await pixaiTestGenerate();
            });

          // PixAI download button
          document
            .getElementById("pai-download-btn")
            .addEventListener("click", () => {
              const img = document.getElementById("pai-result-image");
              const link = document.createElement("a");
              link.href = img.src;
              link.download = "pixai-generated-" + Date.now() + ".png";
              link.click();
            });

          // Restore selected provider + load PixAI key/model on page init
          switchImageGenProvider(localStorage.getItem("image-gen-provider") || "novelai");
          document.getElementById("pixai-api-key").value = localStorage.getItem("pixai-api-key") || "";
          const _savedPixModel = localStorage.getItem("pixai-model");
          if (_savedPixModel) {
            document.getElementById("pixai-model").value = _savedPixModel;
          }

          // ËßíËâ≤‰∏ìÂ±ûNAIÊèêÁ§∫ËØçÂºπÁ™ó‰∫ã‰ª∂ÁõëÂê¨Âô®

          // ÊâìÂºÄËßíËâ≤‰∏ìÂ±ûNAIÊèêÁ§∫ËØçÈÖçÁΩÆÂºπÁ™ó
          document
            .getElementById("character-nai-prompts-btn")
            .addEventListener("click", () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];

              // Âä†ËΩΩÂΩìÂâçËßíËâ≤ÁöÑNAIÊèêÁ§∫ËØçÈÖçÁΩÆ
              const naiSettings = chat.settings.naiSettings || {
                promptSource: "system",
                characterPositivePrompt: "",
                characterNegativePrompt: "",
              };

              // ‰∏•Ê†ºÂä†ËΩΩËßíËâ≤ÈÖçÁΩÆÔºå‰∏ç‰∏éÁ≥ªÁªüÈÖçÁΩÆÊ∑∑Ê∑Ü
              // Â°´‰∫ÜÂ∞±ÊúâÔºåÊ≤°Â°´Â∞±‰∏∫Á©∫ÔºåÁªù‰∏ç‰ΩøÁî®Á≥ªÁªüÈÖçÁΩÆÂ°´ÂÖÖ
              document.getElementById("character-nai-positive").value =
                naiSettings.characterPositivePrompt || "";
              document.getElementById("character-nai-negative").value =
                naiSettings.characterNegativePrompt || "";

              document.getElementById(
                "character-nai-prompts-modal",
              ).style.display = "flex";
            });

          // ÂÖ≥Èó≠ËßíËâ≤‰∏ìÂ±ûNAIÊèêÁ§∫ËØçÂºπÁ™ó
          document
            .getElementById("close-character-nai-prompts")
            .addEventListener("click", () => {
              document.getElementById(
                "character-nai-prompts-modal",
              ).style.display = "none";
            });

          // ‰øùÂ≠òËßíËâ≤‰∏ìÂ±ûNAIÊèêÁ§∫ËØç
          document
            .getElementById("save-character-nai-prompts-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];

              if (!chat.settings.naiSettings) {
                chat.settings.naiSettings = {
                  promptSource: "system",
                };
              }

              chat.settings.naiSettings.characterPositivePrompt = document
                .getElementById("character-nai-positive")
                .value.trim();
              chat.settings.naiSettings.characterNegativePrompt = document
                .getElementById("character-nai-negative")
                .value.trim();

              console.log("üíæ [‰∏ìÂ±ûÂºπÁ™ó] ‰øùÂ≠òËßíËâ≤NAIÊèêÁ§∫ËØç");
              console.log(
                "   characterPositivePrompt:",
                chat.settings.naiSettings.characterPositivePrompt,
              );
              console.log(
                "   characterNegativePrompt:",
                chat.settings.naiSettings.characterNegativePrompt,
              );
              console.log(
                "   promptSource:",
                chat.settings.naiSettings.promptSource,
              );

              // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
              await db.chats.put(chat);

              document.getElementById(
                "character-nai-prompts-modal",
              ).style.display = "none";
              alert("ËßíËâ≤‰∏ìÂ±ûNAIÊèêÁ§∫ËØçÂ∑≤‰øùÂ≠òÔºÅ");
            });

          // Ê∏ÖÁ©∫ËßíËâ≤‰∏ìÂ±ûNAIÊèêÁ§∫ËØçÈÖçÁΩÆ
          document
            .getElementById("reset-character-nai-prompts-btn")
            .addEventListener("click", () => {
              if (confirm("Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÂΩìÂâçËßíËâ≤ÁöÑNAIÊèêÁ§∫ËØçÈÖçÁΩÆÂêóÔºü")) {
                document.getElementById("character-nai-positive").value = "";
                document.getElementById("character-nai-negative").value = "";
              }
            });

          // Áæ§ËÅäËßíËâ≤‰∏ìÂ±ûNAIÊèêÁ§∫ËØçÂºπÁ™ó‰∫ã‰ª∂ÁõëÂê¨Âô®
          document
            .getElementById("group-character-nai-prompts-btn")
            .addEventListener("click", () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];

              // Âä†ËΩΩÂΩìÂâçËßíËâ≤ÁöÑNAIÊèêÁ§∫ËØçÈÖçÁΩÆ
              const naiSettings = chat.settings.naiSettings || {
                promptSource: "system",
                characterPositivePrompt: "",
                characterNegativePrompt: "",
              };

              // ‰∏•Ê†ºÂä†ËΩΩËßíËâ≤ÈÖçÁΩÆÔºå‰∏ç‰∏éÁ≥ªÁªüÈÖçÁΩÆÊ∑∑Ê∑Ü
              // Â°´‰∫ÜÂ∞±ÊúâÔºåÊ≤°Â°´Â∞±‰∏∫Á©∫ÔºåÁªù‰∏ç‰ΩøÁî®Á≥ªÁªüÈÖçÁΩÆÂ°´ÂÖÖ
              document.getElementById("character-nai-positive").value =
                naiSettings.characterPositivePrompt || "";
              document.getElementById("character-nai-negative").value =
                naiSettings.characterNegativePrompt || "";

              document.getElementById(
                "character-nai-prompts-modal",
              ).style.display = "flex";
            });

          document
  .getElementById("import-world-book-btn")
  .addEventListener("click", () => {
    document.getElementById("world-book-import-input").click();
  });


          document
            .getElementById("world-book-import-input")
            .addEventListener("change", (e) => {
              const file = e.target.files[0];
              if (file) {
                // ÂΩìÁî®Êà∑ÈÄâÊã©‰∫ÜÊñá‰ª∂ÂêéÔºåË∞ÉÁî®Êàë‰ª¨ÁöÑÊ†∏ÂøÉÂ§ÑÁêÜÂáΩÊï∞
                handleImportSillyTavernWorldBook(file);
              }
              // ÊØèÊ¨°Áî®ÂÆåÂêéÊ∏ÖÁ©∫ÔºåËøôÊ†∑Áî®Êà∑‰∏ãÊ¨°ËøòËÉΩÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
              e.target.value = null;
            });

          // ÁªëÂÆö‚ÄúÁºñËæëÊ®°Âºè‚ÄùÊåâÈíÆ
          document
            .getElementById("toggle-world-book-edit-mode-btn")
            .addEventListener("click", toggleWorldBookEditMode);

          // Â∞Ü‚ÄúÁÆ°ÁêÜÂàÜÁ±ª‚ÄùÁöÑÂäüËÉΩÁªëÂÆöÂà∞Êñ∞ÊåâÈíÆ‰∏ä
          // ÂéüÊù•ÁöÑ manage-world-book-categories-btn ÊåâÈíÆÁé∞Âú®ÊòØÁºñËæëÊ®°ÂºèÁöÑÂàáÊç¢ÊåâÈíÆ‰∫Ü
          document
            .getElementById("manage-categories-in-edit-mode-btn")
            .addEventListener("click", openCategoryManager);

          // ‰∏∫‰∏ñÁïå‰π¶ÂàóË°®Ê∑ªÂä†Áªü‰∏ÄÁöÑÁÇπÂáª‰∫ã‰ª∂Â§ÑÁêÜÂô®
          document
            .getElementById("world-book-list")
            .addEventListener("click", handleWorldBookListClick);

          // ‰∏∫Â∫ïÈÉ®ÁöÑ‚ÄúÂà†Èô§Â∑≤ÈÄâ‚ÄùÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("world-book-delete-selected-btn")
            .addEventListener("click", handleBulkDeleteWorldBooks);

          document
            .getElementById("add-world-book-btn")
            .addEventListener("click", async () => {
              const name = await showCustomPrompt("Creating the World Book", "Please enter the book name");
              if (name && name.trim()) {
                const newBook = {
                  id: "wb_" + Date.now(),
                  name: name.trim(),
                  content: "",
                };
                await db.worldBooks.add(newBook);
                state.worldBooks.push(newBook);
                renderWorldBookScreen();
                openWorldBookEditor(newBook.id);
              }
            });
          document
            .getElementById("save-world-book-btn")
            .addEventListener("click", async () => {
              if (!editingWorldBookId) return;
              const book = state.worldBooks.find(
                (wb) => wb.id === editingWorldBookId,
              );
              if (book) {
                const newName = document
                  .getElementById("world-book-name-input")
                  .value.trim();
                if (!newName) {
                  alert("Book name cannot be empty!");
                  return;
                }
                book.name = newName;
                book.content = document.getElementById(
                  "world-book-content-input",
                ).value;

                // „ÄêÊ†∏ÂøÉ‰øÆÊîπ„ÄëÂú®ËøôÈáå‰øùÂ≠òÂàÜÁ±ªID
                const categoryId = document.getElementById(
                  "world-book-category-select",
                ).value;
                // Â¶ÇÊûúÈÄâÊã©‰∫Ü‚ÄúÊú™ÂàÜÁ±ª‚ÄùÔºåÂ≠òÂÖ• nullÔºõÂê¶ÂàôÂ≠òÂÖ•Êï∞Â≠óID
                book.categoryId = categoryId ? parseInt(categoryId) : null;

                await db.worldBooks.put(book);
                document.getElementById("world-book-editor-title").textContent =
                  newName;
                editingWorldBookId = null;
                renderWorldBookScreen();
                showScreen("world-book-screen");
              }
            });

          document
            .getElementById("chat-messages")
            .addEventListener("click", async (e) => {
              const voiceBody = e.target.closest(".voice-message-body");
              if (voiceBody) {
                const bubble = voiceBody.closest(".message-bubble");
                if (!bubble) return;

                // Â¶ÇÊûúÊòØÁî®Êà∑Ëá™Â∑±ÁöÑËØ≠Èü≥ÔºåÂè™ÂàáÊç¢ÊñáÂ≠óÊòæÁ§∫Ôºå‰∏çÊí≠Êîæ
                if (bubble.classList.contains("user")) {
                  toggleVoiceTranscript(bubble);
                  return;
                }

                // Â¶ÇÊûúÊòØAIÁöÑËØ≠Èü≥Ê∂àÊÅØ
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                // --- Ê†∏ÂøÉÈÄªËæëÂºÄÂßã ---

                // 1. Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáª‰∫ÜÊ≠£Âú®Êí≠ÊîæÁöÑËØ≠Èü≥Êù°
                if (isTtsPlaying && currentTtsAudioBubble === bubble) {
                  // Â¶ÇÊûúÊòØÔºåÂàôÂÅúÊ≠¢Êí≠ÊîæÂπ∂Êî∂Ëµ∑ÊâÄÊúâÂÖ≥ËÅîÁöÑÊñáÂ≠ó
                  stopMinimaxAudio();
                }
                // 2. Ê£ÄÊü•ÁÇπÂáªÁöÑÊòØÂê¶ÊòØÂ∑≤ÁªèÂ±ïÂºÄ‰∫ÜÊñáÂ≠ó‰ΩÜÊ≤°ÊúâÊí≠ÊîæÁöÑËØ≠Èü≥Êù°
                else if (bubble.dataset.state === "expanded") {
                  // Â¶ÇÊûúÊòØÔºåÂàôÂè™Êî∂Ëµ∑ÊñáÂ≠óÔºå‰∏çÂΩ±ÂìçÂÖ∂‰ªñ
                  toggleVoiceTranscript(bubble);
                }
                // 3. Â¶ÇÊûú‰ª•‰∏äÈÉΩ‰∏çÊòØÔºåËØ¥ÊòéÊòØÊÉ≥ÂºÄÂßãÊí≠ÊîæÊàñÂè™Â±ïÂºÄÊñáÂ≠ó
                else {
                  const clickedTimestamp = parseInt(bubble.dataset.timestamp);
                  const startIndex = chat.history.findIndex(
                    (m) => m.timestamp === clickedTimestamp,
                  );
                  if (startIndex === -1) return;

                  // Êü•ÊâæËøûÁª≠ÁöÑËØ≠Èü≥Ê∂àÊÅØ
                  const messagesToPlay = findConsecutiveAiVoiceMessages(
                    chat.history,
                    startIndex,
                  );
                  if (messagesToPlay.length > 0) {
                    const bubblesToAnimate = messagesToPlay
                      .map((m) =>
                        document.querySelector(
                          `.message-bubble[data-timestamp="${m.timestamp}"]`,
                        ),
                      )
                      .filter(Boolean);

                    // Ê£ÄÊü•ÈÖçÁΩÆÔºåÂÜ≥ÂÆöÊòØÊí≠ÊîæËøòÊòØÂè™ÊòæÁ§∫ÊñáÂ≠ó
                    const groupId = state.apiConfig.minimaxGroupId;
                    const apiKey = state.apiConfig.minimaxApiKey;
                    const voiceId = chat.settings.minimaxVoiceId;

                    if (groupId && apiKey && voiceId) {
                      // „ÄêÊí≠ÊîæÂàÜÊîØ„Äë
                      // ÂÖàÂ±ïÂºÄÊâÄÊúâÊñáÂ≠ó
                      bubblesToAnimate.forEach((b) => {
                        if (b.dataset.state !== "expanded") {
                          toggleVoiceTranscript(b);
                        }
                      });
                      // ÁÑ∂ÂêéË∞ÉÁî®Êí≠ÊîæÂô®
                      const combinedText = messagesToPlay
                        .map((m) => m.content.trim())
                        .join("Ôºå");
                      playMinimaxAudio(combinedText, voiceId, bubblesToAnimate);
                    } else {
                      // „ÄêÂè™ÊòæÁ§∫ÊñáÂ≠óÂàÜÊîØ„Äë
                      // Âè™Â±ïÂºÄÂΩìÂâçÁÇπÂáªÁöÑËøô‰∏Ä‰∏™ËØ≠Èü≥Êù°ÁöÑÊñáÂ≠ó
                      toggleVoiceTranscript(bubble);
                    }
                  }
                }

                return; // Â§ÑÁêÜÂÆåËØ≠Èü≥ÂêéÈÄÄÂá∫
              }

              // --- ‰Ω†ÂéüÊù•ÁöÑÂÖ∂‰ªñÁÇπÂáª‰∫ã‰ª∂ÈÄªËæë ---
              const aiImage = e.target.closest(".ai-generated-image");
              if (aiImage) {
                const description = aiImage.dataset.description;
                if (description) showCustomAlert("ÁÖßÁâáÊèèËø∞", description);
                return;
              }
              const linkCard = e.target.closest(".link-share-card");
              if (
                linkCard &&
                linkCard.closest(".message-bubble.is-link-share")
              ) {
                const timestamp = parseInt(linkCard.dataset.timestamp);
                if (!isNaN(timestamp)) {
                  openBrowser(timestamp);
                }
              }
              const packetCard = e.target.closest(".red-packet-card");
              if (packetCard) {
                const messageBubble = packetCard.closest(".message-bubble");
                if (messageBubble && messageBubble.dataset.timestamp) {
                  const timestamp = parseInt(messageBubble.dataset.timestamp);
                  handlePacketClick(timestamp);
                }
              }
              const pollCard = e.target.closest(".poll-card");
              if (pollCard) {
                const timestamp = parseInt(pollCard.dataset.pollTimestamp);
                if (isNaN(timestamp)) return;
                const optionItem = e.target.closest(".poll-option-item");
                if (optionItem && !pollCard.classList.contains("closed")) {
                  handleUserVote(timestamp, optionItem.dataset.option);
                  return;
                }
                const actionBtn = e.target.closest(".poll-action-btn");
                if (actionBtn) {
                  if (pollCard.classList.contains("closed")) {
                    showPollResults(timestamp);
                  } else {
                    endPoll(timestamp);
                  }
                  return;
                }
                if (pollCard.classList.contains("closed")) {
                  showPollResults(timestamp);
                }
              }
              const card = e.target.closest(".waimai-card");
              if (card) {
                const messageBubble = card.closest(".message-bubble");
                const invitationMsg = state.chats[
                  state.activeChatId
                ].history.find(
                  (m) =>
                    m.timestamp === parseInt(messageBubble.dataset.timestamp),
                );
                if (
                  invitationMsg &&
                  invitationMsg.type === "lovers_space_invitation" &&
                  invitationMsg.status === "pending"
                ) {
                  const choice = e.target.dataset.choice;
                  if (choice) {
                    handleLoversSpaceResponse(invitationMsg.timestamp, choice);
                  }
                }
              }
              const repostCard = e.target.closest(
                ".link-share-card[data-post-id]",
              );
              if (repostCard) {
                const postId = parseInt(repostCard.dataset.postId);
                if (!isNaN(postId)) {
                  openPost(postId);
                }
              }

              // Â§ÑÁêÜÂàÜ‰∫´Âç°ÁâáÁöÑÁÇπÂáª
              const shareCard = e.target.closest(
                ".link-share-card[data-timestamp]",
              );
              if (
                shareCard &&
                shareCard.closest(".message-bubble.is-link-share")
              ) {
                const timestamp = parseInt(shareCard.dataset.timestamp);
                if (!isNaN(timestamp)) {
                  const msg = state.chats[state.activeChatId].history.find(
                    (m) => m.timestamp === timestamp,
                  );
                  if (msg && msg.type === "share_card")
                    openSharedHistoryViewer(timestamp);
                  else if (msg && msg.type === "share_link")
                    openBrowser(timestamp);
                }
              }

              // Â§ÑÁêÜÂ∑≤Êí§ÂõûÊ∂àÊÅØÁöÑÁÇπÂáª
              const placeholder = e.target.closest(
                ".recalled-message-placeholder",
              );
              if (placeholder) {
                const wrapper = placeholder.closest(".message-wrapper");
                const chat = state.chats[state.activeChatId];
                if (chat && wrapper) {
                  const timestamp = parseInt(wrapper.dataset.timestamp);
                  const recalledMsg = chat.history.find(
                    (m) => m.timestamp === timestamp,
                  );
                  if (recalledMsg && recalledMsg.recalledData) {
                    let originalContentText = "";
                    const recalled = recalledMsg.recalledData;
                    if (recalled.originalType === "text") {
                      originalContentText = `ÂéüÊñá: "${recalled.originalContent}"`;
                    } else {
                      originalContentText = `Êí§Âõû‰∫Ü‰∏ÄÊù°[${recalled.originalType}]Á±ªÂûãÁöÑÊ∂àÊÅØ`;
                    }
                    showCustomAlert("Â∑≤Êí§ÂõûÁöÑÊ∂àÊÅØ", originalContentText);
                  }
                }
              }

              const chatCard = e.target.closest(".dating-summary-chat-card");
              if (chatCard && chatCard.dataset.summaryPayload) {
                try {
                  // ËØªÂèñÂπ∂Ëß£ÊûêÂ≠òÂÇ®Âú® data-* Â±ûÊÄß‰∏≠ÁöÑÂç°ÁâáÊï∞ÊçÆ
                  const payloadString = chatCard.dataset.summaryPayload
                    .replace(/&apos;/g, "'")
                    .replace(/"/g, "&quot;");
                  const payload = JSON.parse(payloadString);
                  // Ë∞ÉÁî®Êàë‰ª¨Êñ∞ÂÜôÁöÑÂáΩÊï∞ÔºåÊâìÂºÄËØ¶ÊÉÖÂç°Áâá
                  reopenDatingSummary(payload);
                } catch (error) {
                  console.error("Ëß£ÊûêÂàÜ‰∫´ÁöÑÁ∫¶‰ºöËÆ∞ÂΩïÂ§±Ë¥•:", error);
                  alert("Êó†Ê≥ïÊâìÂºÄËøô‰∏™Á∫¶‰ºöËÆ∞ÂΩï„ÄÇ");
                }
              }
            });

          const chatSettingsModal = document.getElementById(
            "chat-settings-modal",
          );
          const worldBookSelectBox = document.querySelector(
            ".custom-multiselect .select-box",
          );
          const worldBookCheckboxesContainer = document.getElementById(
            "world-book-checkboxes-container",
          );

          function updateWorldBookSelectionDisplay() {
            const checkedBoxes =
              worldBookCheckboxesContainer.querySelectorAll("input:checked");
            const displayText = document.querySelector(
              ".selected-options-text",
            );
            if (checkedBoxes.length === 0) {
              displayText.textContent = "-- ÁÇπÂáªÈÄâÊã© --";
            } else if (checkedBoxes.length > 2) {
              displayText.textContent = `Â∑≤ÈÄâÊã© ${checkedBoxes.length} È°π`;
            } else {
              displayText.textContent = Array.from(checkedBoxes)
                .map((cb) => cb.parentElement.textContent.trim())
                .join(", ");
            }
          }

          worldBookSelectBox.addEventListener("click", (e) => {
            e.stopPropagation();
            worldBookCheckboxesContainer.classList.toggle("visible");
            worldBookSelectBox.classList.toggle("expanded");
          });
          document
            .getElementById("world-book-checkboxes-container")
            .addEventListener("change", updateWorldBookSelectionDisplay);
          window.addEventListener("click", (e) => {
            if (
              !document.querySelector(".custom-multiselect").contains(e.target)
            ) {
              worldBookCheckboxesContainer.classList.remove("visible");
              worldBookSelectBox.classList.remove("expanded");
            }
          });

          document
            .getElementById("chat-settings-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              const isGroup = chat.isGroup;
              document.getElementById("offline-mode-section").style.display =
                isGroup ? "none" : "block";
              document.getElementById("couple-avatar-group").style.display =
                isGroup ? "none" : "block";
              document.getElementById("streak-settings-section").style.display =
                isGroup ? "none" : "block";

              // ËÆ°ÁÆóÊÄªÊ∂àÊÅØÊù°Êï∞Âπ∂Êõ¥Êñ∞ÊòæÁ§∫
              const totalMessages = chat.history.length;
              const countDisplay = document.getElementById(
                "total-message-count-display",
              );
              if (countDisplay) {
                countDisplay.textContent = `${totalMessages} Êù°`;
              }

              // --- ‰øÆÊîπÂºÄÂßãÔºö‰ΩøÁî®Ê∑±Â∫¶ÂàÜÊûêÈÄªËæëÊù•Êõ¥Êñ∞‰∏ªÁïåÈù¢ÁöÑTokenÊòæÁ§∫ ---
              const tokenDisplay = document.getElementById(
                "context-token-count-display",
              );

              const updateTokenDisplay = async () => {
                tokenDisplay.textContent = "ËÆ°ÁÆó‰∏≠...";

                // Â§çÁî®Ê∑±Â∫¶ÂàÜÊûêÁöÑËÆ°ÁÆóÈÄªËæë
                const result = await getTokenDetailedBreakdown(
                  state.activeChatId,
                );

                if (result && result.items) {
                  const totalCount = result.items.reduce(
                    (sum, item) => sum + item.count,
                    0,
                  );
                  tokenDisplay.textContent = totalCount.toLocaleString();
                } else {
                  tokenDisplay.textContent = "0";
                }
              };

              await updateTokenDisplay();

              // 3. „ÄêÂÖ≥ÈîÆ„ÄëÁßªÈô§ÊóßÁöÑÁõëÂê¨Âô®ÔºàÈò≤Ê≠¢ÈáçÂ§çÔºâÔºåÂπ∂Ê∑ªÂä†Êñ∞ÁöÑÁÇπÂáªÁõëÂê¨Âô®
              // ‰ΩøÁî® cloneNode ÊäÄÂ∑ßÂø´ÈÄüÊ∏ÖÈô§ÊóßÁöÑ event listeners
              const newTokenDisplay = tokenDisplay.cloneNode(true);
              tokenDisplay.parentNode.replaceChild(
                newTokenDisplay,
                tokenDisplay,
              );
              newTokenDisplay.addEventListener("click", async () => {
                // Ê≥®ÊÑèÔºöÁé∞Âú®ËøîÂõûÁöÑÊòØ‰∏Ä‰∏™ÂØπË±° { items, outliers }
                const result = await getTokenDetailedBreakdown(
                  state.activeChatId,
                );
                if (!result) return;

                const breakdown = result.items;
                const outliers = result.outliers;

                let total = 0;
                breakdown.forEach((item) => (total += item.count));

                let htmlContent =
                  '<div style="text-align: left; font-size: 13px;">';

                // 1. Ê∏≤ÊüìÊ≠£Â∏∏ÁöÑËøõÂ∫¶Êù° (‰øùÊåÅ‰∏çÂèò)
                const colorMap = {
                  Ê†∏ÂøÉ‰∫∫ËÆæ: "#FF6B6B",
                  WorldBook: "#4ECDC4",
                  Ë°®ÊÉÖÂåÖÂÆö‰πâ: "#FFD93D",
                  "ÈïøÊúüËÆ∞ÂøÜ(ÊÄªÁªì)": "#45B7D1",
                  "Áü≠ÊúüËÆ∞ÂøÜ(Áî®Êà∑)": "#96CEB4",
                  "Áü≠ÊúüËÆ∞ÂøÜ(AI)": "#A8E6CF",
                  Á≥ªÁªüÊ†ºÂºèÊåá‰ª§: "#D4A5A5",
                };

                breakdown.forEach((item) => {
                  if (item.count > 0) {
                    const percent =
                      total > 0 ? Math.round((item.count / total) * 100) : 0;
                    const color = colorMap[item.name] || "#ccc";
                    htmlContent += `
                    <div style="margin-bottom: 6px;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                            <span>${item.name}</span>
                            <span style="color:#888;">${item.count} (${percent}%)</span>
                        </div>
                        <div style="width: 100%; background-color: #f0f0f0; height: 6px; border-radius: 3px; overflow: hidden;">
                            <div style="width: ${percent}%; background-color: ${color}; height: 100%;"></div>
                        </div>
                    </div>
                `;
                  }
                });

                // 2. „ÄêÊñ∞Â¢û„ÄëÊ∏≤ÊüìÂºÇÂ∏∏Â§ßÊ∂àÊÅØÂàóË°®
                if (outliers.length > 0) {
                  htmlContent += `<hr style="opacity:0.2; margin:15px 0 10px 0;">`;
                  htmlContent += `<div style="color: #ff3b30; font-weight: bold; margin-bottom: 8px;">‚ö†Ô∏è ÂèëÁé∞Âç†Áî®ËæÉÂ§ßÁöÑÊ∂àÊÅØ (Top ${outliers.length})</div>`;
                  htmlContent += `<div style="max-height: 150px; overflow-y: auto; background: #f9f9f9; border-radius: 6px; padding: 5px;">`;

                  outliers.forEach((msg) => {
                    const roleTag =
                      msg.role === "user"
                        ? '<span style="color:#007bff">[Me]</span>'
                        : '<span style="color:#28a745">[AI]</span>';
                    // Ê∑ªÂä† onclick Ë∞ÉÁî®Êàë‰ª¨ÂàöÂàöÊö¥Èú≤ÁöÑ window.jumpToMessage
                    htmlContent += `
                    <div onclick="window.jumpToMessage(${msg.timestamp})" 
                         style="display:flex; justify-content:space-between; align-items:center; padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; font-size: 12px;">
                        <div style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                            ${roleTag} ${msg.preview}
                        </div>
                        <div style="color: #666; margin-left: 10px; font-family: monospace;">
                            ${msg.count} Â≠óÁ¨¶ &rarr;
                        </div>
                    </div>
                `;
                  });
                  htmlContent += `</div>`;
                  htmlContent += `<p style="font-size:11px; color:#aaa; margin-top:4px;">ÁÇπÂáªÂç≥ÂèØÂÆö‰ΩçÂπ∂È´ò‰∫ÆËØ•Ê∂àÊÅØÔºåÊÇ®ÂèØ‰ª•ÈÄâÊã©Âà†Èô§ÂÆÉ„ÄÇ</p>`;
                }

                // 3. Â∫ïÈÉ®Ê±áÊÄª
                htmlContent += `<hr style="opacity:0.2; margin:10px 0;">
            <div style="text-align:right; font-weight:bold; font-size:15px;">ÊÄªËÆ°: ${total} Â≠óÁ¨¶</div>
        </div>`;

                await showCustomAlert("Token Ê∑±Â∫¶ÂàÜÊûê", htmlContent);
              });

              // --- Áªü‰∏ÄÊòæÁ§∫/ÈöêËóèÊéß‰ª∂ ---

              const videoCallSettingsGroup = document.getElementById(
                "video-call-settings-group",
              );
              const visualCallSwitch = document.getElementById(
                "visual-video-call-switch",
              );
              const imageUploadsDiv = document.getElementById(
                "video-call-image-uploads",
              );
              // --- Âä†ËΩΩËÅäÂ§©ÊÄªÁªìËÆæÁΩÆ ---
              const summarySettings = chat.settings.summary || {};
              const summaryToggle = document.getElementById("summary-toggle");
              const summaryDetails = document.getElementById(
                "summary-details-container",
              );

              summaryToggle.checked = summarySettings.enabled || false;
              summaryDetails.style.display = summaryToggle.checked
                ? "block"
                : "none";

              document.querySelector(
                `input[name="summary-mode"][value="${summarySettings.mode || "auto"}"]`,
              ).checked = true;
              document.getElementById("summary-count-input").value =
                summarySettings.count || 20;
              document.getElementById("summary-prompt-input").value =
                summarySettings.prompt ||
                "Summarize a dialogue from a third-person perspective, emphasizing objectivity and a lack of emotional commentary. They explicitly instruct against any role-playing or subjective opinions in the summary.";

              // ‰∏∫ÂºÄÂÖ≥Ê∑ªÂä†ÂÆûÊó∂‰∫§‰∫í
              summaryToggle.onchange = () => {
                summaryDetails.style.display = summaryToggle.checked
                  ? "block"
                  : "none";
              };

              if (isGroup) {
                videoCallSettingsGroup.style.display = "none"; // Áæ§ËÅä‰∏çÊîØÊåÅÔºåÈöêËóèÊï¥‰∏™ËÆæÁΩÆÂå∫
              } else {
                videoCallSettingsGroup.style.display = "block"; // ÂçïËÅäÊòæÁ§∫

                // Âä†ËΩΩÂΩìÂâçËÆæÁΩÆ
                visualCallSwitch.checked =
                  chat.settings.visualVideoCallEnabled || false;
                imageUploadsDiv.style.display = visualCallSwitch.checked
                  ? "block"
                  : "none";
                document.getElementById("char-video-image-preview").src =
                  chat.settings.charVideoImage ||
                  "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
                document.getElementById("user-video-image-preview").src =
                  chat.settings.userVideoImage ||
                  "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
                const voiceAccessSwitch = document.getElementById(
                  "video-call-voice-access-switch",
                );
                voiceAccessSwitch.checked =
                  chat.settings.videoCallVoiceAccess || false;

                // ‰∏∫ÂºÄÂÖ≥Ê∑ªÂä†ÂÆûÊó∂‰∫§‰∫í
                visualCallSwitch.onchange = () => {
                  imageUploadsDiv.style.display = visualCallSwitch.checked
                    ? "block"
                    : "none";
                };
              }
              const realCameraSwitch = document.getElementById(
                "user-real-camera-switch",
              );
              if (realCameraSwitch) {
                realCameraSwitch.checked = chat.settings.useRealCamera || false;
              }
              // --- Á∫ø‰∏ãÊ®°ÂºèUIÊ∏≤Êüì ---
              const offlineModeSettings = chat.settings.offlineMode || {
                enabled: false,
                presets: [],
              }; // ÂÆâÂÖ®Ëé∑Âèñ
              const offlineToggle = document.getElementById(
                "offline-mode-toggle",
              );
              const offlineDetails = document.getElementById(
                "offline-mode-details",
              );

              // 1. ËÆæÁΩÆÂºÄÂÖ≥Áä∂ÊÄÅÂπ∂ÁªëÂÆö‰∫ã‰ª∂
              offlineToggle.checked = offlineModeSettings.enabled;
              offlineDetails.style.display = offlineToggle.checked
                ? "block"
                : "none";
              offlineToggle.onchange = () => {
                offlineDetails.style.display = offlineToggle.checked
                  ? "block"
                  : "none";
              };

              // 2. Â°´ÂÖÖËæìÂÖ•Ê°Ü
              document.getElementById("offline-prompt-input").value =
                offlineModeSettings.prompt || "";
              document.getElementById("offline-style-input").value =
                offlineModeSettings.style || "";
              document.getElementById("offline-word-count-input").value =
                offlineModeSettings.wordCount || 300;
              // Âä†ËΩΩÁîüÂõæÂºÄÂÖ≥Áä∂ÊÄÅ
              document.getElementById("offline-novelai-toggle").checked =
                offlineModeSettings.enableNovelAI || false;

              // Load impersonate user settings
              const impersonateSettings = chat.settings.impersonateUser || {};
              document.getElementById("impersonate-prompt-input").value =
                impersonateSettings.prompt || "";
              document.getElementById("impersonate-wordcount-input").value =
                impersonateSettings.wordCount || 150;

              // 3. Ê∏≤ÊüìÈ¢ÑËÆæ‰∏ãÊãâÊ°Ü
              renderOfflinePresetsSelector();

              // ‰∏∫Ê∞îÊ≥°ÂØºÂÖ•/ÂØºÂá∫ÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
              document
                .getElementById("export-bubble-preset-btn")
                .addEventListener("click", exportSelectedBubblePreset);

              document
                .getElementById("import-bubble-preset-btn")
                .addEventListener("click", () => {
                  // ÁÇπÂáª‚ÄúÂØºÂÖ•‚ÄùÊåâÈíÆÊó∂ÔºåËß¶ÂèëÈöêËóèÁöÑÊñá‰ª∂ÈÄâÊã©Ê°Ü
                  document.getElementById("import-bubble-preset-input").click();
                });

              document
                .getElementById("import-bubble-preset-input")
                .addEventListener("change", (e) => {
                  // ÂΩìÁî®Êà∑ÈÄâÊã©‰∫ÜÊñá‰ª∂ÂêéÔºåË∞ÉÁî®ÂØºÂÖ•ÂáΩÊï∞Â§ÑÁêÜ
                  importBubblePreset(e.target.files[0]);
                  e.target.value = null; // ÊØèÊ¨°Áî®ÂÆåÂêéÊ∏ÖÁ©∫ÔºåÊñπ‰æø‰∏ãÊ¨°ÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
                });

              document.getElementById("chat-name-group").style.display =
                "block";
              document.getElementById("minimax-voice-id-group").style.display =
                isGroup ? "none" : "block";
              document.getElementById("my-persona-group").style.display =
                "block";
              document.getElementById("my-avatar-group").style.display =
                "block";
              document.getElementById("my-group-nickname-group").style.display =
                isGroup ? "block" : "none";
              document.getElementById("group-avatar-group").style.display =
                isGroup ? "block" : "none";
              document.getElementById("group-members-group").style.display =
                isGroup ? "block" : "none";
              document.getElementById("ai-persona-group").style.display =
                isGroup ? "none" : "block";
              document.getElementById("ai-avatar-group").style.display = isGroup
                ? "none"
                : "block";

              document.getElementById("npc-library-group").style.display =
                isGroup ? "none" : "block";

              // NAIÂá∫ÂõæËÆæÁΩÆÁöÑÊòæÁ§∫/ÈöêËóèÂíåÂä†ËΩΩ
              const naiCharacterSettingsGroup = document.getElementById(
                "nai-character-settings-group",
              );
              // Ê£ÄÊü•Á≥ªÁªüÊòØÂê¶ÂêØÁî®‰∫ÜNovelAI
              const novelaiEnabled =
                localStorage.getItem("novelai-enabled") === "true";
              if (!isGroup && novelaiEnabled) {
                naiCharacterSettingsGroup.style.display = "block";

                // Âä†ËΩΩËßíËâ≤NAIËÆæÁΩÆ
                const naiSettings = chat.settings.naiSettings || {
                  promptSource: "system",
                  characterPositivePrompt: "",
                  characterNegativePrompt: "",
                };

                console.log("üìñ [Âä†ËΩΩËÆæÁΩÆ] ËßíËâ≤NAIËÆæÁΩÆ:", naiSettings);
                console.log("   promptSource:", naiSettings.promptSource);
                console.log(
                  "   characterPositivePrompt:",
                  naiSettings.characterPositivePrompt,
                );
                console.log(
                  "   characterNegativePrompt:",
                  naiSettings.characterNegativePrompt,
                );

                // ËÆæÁΩÆÊèêÁ§∫ËØçÊù•Ê∫êÈÄâÈ°π
                const promptSourceRadios = document.querySelectorAll(
                  'input[name="nai-prompt-source"]',
                );
                promptSourceRadios.forEach((radio) => {
                  radio.checked = radio.value === naiSettings.promptSource;
                  console.log(
                    `   ËÆæÁΩÆÂçïÈÄâÊåâÈíÆ ${radio.value}: ${radio.checked}`,
                  );
                });
              } else {
                naiCharacterSettingsGroup.style.display = "none";
              }

              // Áæ§ËÅäNAIÂá∫ÂõæËÆæÁΩÆÁöÑÊòæÁ§∫/ÈöêËóèÂíåÂä†ËΩΩ
              const groupNaiSettingsGroup = document.getElementById(
                "group-nai-settings-group",
              );
              if (isGroup && novelaiEnabled) {
                groupNaiSettingsGroup.style.display = "block";

                // Âä†ËΩΩÁæ§ËÅäËßíËâ≤NAIËÆæÁΩÆ
                const groupNaiSettings = chat.settings.naiSettings || {
                  promptSource: "system",
                  characterPositivePrompt: "",
                  characterNegativePrompt: "",
                };

                console.log("üìñ [Âä†ËΩΩËÆæÁΩÆ] Áæ§ËÅäËßíËâ≤NAIËÆæÁΩÆ:", groupNaiSettings);
                console.log("   promptSource:", groupNaiSettings.promptSource);
                console.log(
                  "   characterPositivePrompt:",
                  groupNaiSettings.characterPositivePrompt,
                );
                console.log(
                  "   characterNegativePrompt:",
                  groupNaiSettings.characterNegativePrompt,
                );

                // ËÆæÁΩÆÊèêÁ§∫ËØçÊù•Ê∫êÈÄâÈ°π
                const groupPromptSourceRadios = document.querySelectorAll(
                  'input[name="group-nai-prompt-source"]',
                );
                groupPromptSourceRadios.forEach((radio) => {
                  radio.checked = radio.value === groupNaiSettings.promptSource;
                  console.log(
                    `   ËÆæÁΩÆÂçïÈÄâÊåâÈíÆ ${radio.value}: ${radio.checked}`,
                  );
                });
              } else {
                groupNaiSettingsGroup.style.display = "none";
              }

              // Ê†πÊçÆÊòØÂê¶‰∏∫ÂçïËÅäÊàñÁæ§ËÅäÔºåÊòæÁ§∫Ë°®ÊÉÖÁÆ°ÁêÜÊåâÈíÆ
              const charStickerGroup =
                document.getElementById("char-sticker-group");
              if (charStickerGroup) {
                // Áé∞Âú®Êó†ËÆ∫ÊòØÂçïËÅäËøòÊòØÁæ§ËÅäÔºåËøô‰∏™ÊåâÈíÆÈÉΩ‰ºöÊòæÁ§∫
                charStickerGroup.style.display = "block";
              }

              // Ê†πÊçÆÊòØÂê¶‰∏∫Áæ§ËÅäÔºåÊòæÁ§∫ÊàñÈöêËóèÂæÆÂçöËÆæÁΩÆ
              document.getElementById("weibo-profession-group").style.display =
                isGroup ? "none" : "block";
              document.getElementById("weibo-instruction-group").style.display =
                isGroup ? "none" : "block";
              // Ê†πÊçÆÊòØÂê¶‰∏∫Áæ§ËÅäÔºåÊòæÁ§∫ÊàñÈöêËóè‚ÄúÂ•ΩÂèãÂàÜÁªÑ‚ÄùÂå∫Âüü
              document.getElementById("assign-group-section").style.display =
                isGroup ? "none" : "block";

              // --- Âä†ËΩΩË°®ÂçïÊï∞ÊçÆ ---
              document.getElementById("chat-name-input").value = chat.name;
              const remarkGroup = document.getElementById("chat-remark-group");
              const remarkInput = document.getElementById("chat-remark-input");

              if (chat.isGroup) {
                remarkGroup.style.display = "none"; // Áæ§ËÅä‰∏çÊòæÁ§∫Â§áÊ≥®ËÆæÁΩÆ
              } else {
                remarkGroup.style.display = "block"; // ÂçïËÅäÊòæÁ§∫
                // Â¶ÇÊûúÊ≤°ÊúâsettingsÂØπË±°ÔºåÂàùÂßãÂåñÂÆÉ
                if (!chat.settings) chat.settings = {};
                remarkInput.value = chat.settings.remarkName || "";
              }

              document.getElementById("my-persona").value =
                chat.settings.myPersona;
              // ‚òÖ Use Global Persona toggle ‚òÖ
              const _ugpToggle = document.getElementById('use-global-persona-toggle');
              if (_ugpToggle) {
                _ugpToggle.checked = chat.settings.useGlobalPersona || false;
                onUseGlobalPersonaToggle(_ugpToggle.checked);
              }
              document.getElementById("my-avatar-preview").src =
                chat.settings.myAvatar ||
                (isGroup ? defaultMyGroupAvatar : defaultAvatar);
              document.getElementById("max-memory").value =
                chat.settings.maxMemory;
              const defaultMin = chat.isGroup ? 3 : 2;
              const defaultMax = chat.isGroup ? 8 : 5;
              const savedRange = chat.settings.replyCountRange || {
                min: defaultMin,
                max: defaultMax,
              };

              document.getElementById("min-reply-count-input").value =
                savedRange.min;
              document.getElementById("max-reply-count-input").value =
                savedRange.max;
              // ËÆ∞ÂøÜ‰∫íÈÄöÂäüËÉΩ - UIÊ∏≤ÊüìÈÄªËæë
              const memoryLinkSelectBox = document.querySelector(
                "#memory-link-multiselect .select-box",
              );
              const memoryLinkCheckboxesContainer = document.getElementById(
                "memory-link-checkboxes-container",
              );
              memoryLinkCheckboxesContainer.innerHTML = ""; // Ê∏ÖÁ©∫ÊóßÈÄâÈ°π

              // 1. Ëé∑ÂèñÈô§‰∫ÜÂΩìÂâçËÅäÂ§©‰ª•Â§ñÁöÑÊâÄÊúâËÅäÂ§©
              const otherChats = Object.values(state.chats).filter(
                (c) => c.id !== chat.id,
              );

              // 2. Âä®ÊÄÅÂàõÂª∫Â∏¶Â§¥ÂÉèÁöÑÂ§çÈÄâÊ°Ü
              otherChats.forEach((otherChat) => {
                const existingLink = chat.settings.linkedMemories.find(
                  (link) => link.chatId === otherChat.id,
                );
                const isChecked = existingLink ? "checked" : "";

                // Ê†πÊçÆÊòØÁæ§ËÅäËøòÊòØÂçïËÅäÔºåËé∑ÂèñÊ≠£Á°ÆÁöÑÂ§¥ÂÉèURL
                const avatarUrl = otherChat.isGroup
                  ? otherChat.settings.groupAvatar || defaultGroupAvatar
                  : otherChat.settings.aiAvatar || defaultAvatar;

                const label = document.createElement("label");

                // ÊûÑÂª∫ÂåÖÂê´ <img> Ê†áÁ≠æÁöÑÊñ∞HTMLÁªìÊûÑ
                label.innerHTML = `
			        <input type="checkbox" value="${otherChat.id}" ${isChecked}>
			        <img src="${avatarUrl}" class="avatar-preview">
			        <span>${otherChat.name} ${otherChat.isGroup ? "(Áæ§ËÅä)" : ""}</span>
			    `;
                memoryLinkCheckboxesContainer.appendChild(label);
              });

              // 3. Êõ¥Êñ∞Â∑≤ÈÄâÊï∞ÈáèÁöÑÊòæÁ§∫ÂíåËÆ∞ÂøÜÊù°Êï∞
              function updateMemoryLinkDisplay() {
                const checkedBoxes =
                  memoryLinkCheckboxesContainer.querySelectorAll(
                    "input:checked",
                  );
                const displayText = memoryLinkSelectBox.querySelector(
                  ".selected-options-text",
                );
                if (checkedBoxes.length === 0) {
                  displayText.textContent = "-- ÁÇπÂáªÈÄâÊã© --";
                } else {
                  displayText.textContent = `Â∑≤ÈìæÊé• ${checkedBoxes.length} ‰∏™ËÅäÂ§©`;
                }
              }

              // 4. Âä†ËΩΩËÆ∞ÂøÜÊù°Êï∞ËÆæÁΩÆ
              // Êàë‰ª¨Áé∞Âú®‰ªé‰∏Ä‰∏™Áã¨Á´ãÁöÑËÆæÁΩÆÈ°πÂä†ËΩΩÔºåÁ°Æ‰øùÂÆÉÊÄªËÉΩË¢´Ê≠£Á°ÆËØªÂèñ
              document.getElementById("link-memory-depth-input").value =
                chat.settings.linkMemoryDepth || 5;

              // 5. ÁªëÂÆö‰∫ã‰ª∂
              updateMemoryLinkDisplay(); // ÂàùÂßãÂåñÊòæÁ§∫
              memoryLinkCheckboxesContainer.addEventListener(
                "change",
                updateMemoryLinkDisplay,
              );
              // ‰ΩøÁî®ÂÖãÈöÜËäÇÁÇπÊäÄÂ∑ßÊù•Èò≤Ê≠¢‰∫ã‰ª∂ÈáçÂ§çÁªëÂÆö
              const newSelectBox = memoryLinkSelectBox.cloneNode(true);
              memoryLinkSelectBox.parentNode.replaceChild(
                newSelectBox,
                memoryLinkSelectBox,
              );
              newSelectBox.addEventListener("click", (e) => {
                e.stopPropagation();
                memoryLinkCheckboxesContainer.classList.toggle("visible");
                newSelectBox.classList.toggle("expanded");
              });

              const timeToggle = document.getElementById(
                "time-perception-toggle",
              );
              const customTimeContainer = document.getElementById(
                "custom-time-container",
              );
              const customTimeInput =
                document.getElementById("custom-time-input");

              // Â¶ÇÊûúÊòØÊóßËÅäÂ§©ÔºåÁªô‰∏Ä‰∏™ÈªòËÆ§ÂÄº trueÔºàÂºÄÂêØÔºâ
              const isTimeEnabled = chat.settings.timePerceptionEnabled ?? true;
              timeToggle.checked = isTimeEnabled;
              customTimeInput.value = chat.settings.customTime || "";

              // Ê†πÊçÆÂºÄÂÖ≥Áä∂ÊÄÅÔºåÂÜ≥ÂÆöÊòØÂê¶ÊòæÁ§∫Ëá™ÂÆö‰πâÊó∂Èó¥ËæìÂÖ•Ê°Ü
              customTimeContainer.style.display = isTimeEnabled
                ? "none"
                : "block";

              const bgPreview = document.getElementById("bg-preview");
              const removeBgBtn = document.getElementById("remove-bg-btn");
              if (chat.settings.background) {
                bgPreview.src = chat.settings.background;
                bgPreview.style.display = "block";
                removeBgBtn.style.display = "inline-block";
              } else {
                bgPreview.style.display = "none";
                removeBgBtn.style.display = "none";
              }

              if (isGroup) {
                document.getElementById("my-group-nickname-input").value =
                  chat.settings.myNickname || "";
                document.getElementById("group-avatar-preview").src =
                  chat.settings.groupAvatar || defaultGroupAvatar;
                renderGroupMemberSettings(chat.members);
                // Âä†ËΩΩÁæ§ËÅäÂêéÂè∞Ê¥ªÂä®ËÆæÁΩÆ
                const groupActivityGroup = document.getElementById(
                  "group-background-activity-group",
                );
                const groupActivitySwitch = document.getElementById(
                  "group-background-activity-switch",
                );
                const groupIntervalSettings = document.getElementById(
                  "group-background-interval-settings",
                );
                const groupIntervalInput = document.getElementById(
                  "group-background-interval-input",
                );

                groupActivityGroup.style.display = "block"; // ÊòæÁ§∫ËÆæÁΩÆÂå∫Âüü
                const bgSettings = chat.settings.backgroundActivity || {
                  enabled: false,
                  interval: 120,
                };
                groupActivitySwitch.checked = bgSettings.enabled;
                groupIntervalInput.value = bgSettings.interval;
                groupIntervalSettings.style.display = bgSettings.enabled
                  ? "block"
                  : "none";

                // ‰∏∫ÂºÄÂÖ≥Ê∑ªÂä†ÂÆûÊó∂‰∫§‰∫í
                groupActivitySwitch.onchange = () => {
                  groupIntervalSettings.style.display =
                    groupActivitySwitch.checked ? "block" : "none";
                };
              } else {
                document.getElementById("ai-persona").value =
                  chat.settings.aiPersona;
                // Âä†ËΩΩÂΩìÂâçËßíËâ≤ÁöÑÂæÆÂçöËÅå‰∏öÂíåÊåá‰ª§
                document.getElementById("weibo-profession-input").value =
                  chat.settings.weiboProfession || "";
                document.getElementById("weibo-instruction-input").value =
                  chat.settings.weiboInstruction || "";
                document.getElementById("ai-avatar-preview").src =
                  chat.settings.aiAvatar || defaultAvatar;
                document.getElementById("minimax-voice-id-input").value =
                  chat.settings.minimaxVoiceId || "";
                // Âä†ËΩΩËØ≠Ë®ÄÂ¢ûÂº∫ÂíåËØ≠ÈÄüËÆæÁΩÆ
                const langBoostSelect = document.getElementById(
                  "minimax-language-boost-select",
                );
                const speedSlider = document.getElementById(
                  "minimax-speed-slider",
                );
                const speedValueDisplay = document.getElementById(
                  "minimax-speed-value",
                );

                // Ê†πÊçÆËÅäÂ§©Á±ªÂûãÔºåÂÜ≥ÂÆöÊòØÂê¶ÊòæÁ§∫Ëøô‰∏§‰∏™Êñ∞ËÆæÁΩÆ
                const showMinimaxSpecificSettings = !isGroup;
                document.getElementById(
                  "minimax-language-boost-group",
                ).style.display = showMinimaxSpecificSettings
                  ? "block"
                  : "none";
                document.getElementById("minimax-speed-group").style.display =
                  showMinimaxSpecificSettings ? "block" : "none";

                if (showMinimaxSpecificSettings) {
                  // Âä†ËΩΩ language_boostÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÈªòËÆ§‰∏∫Á©∫ÔºàÂç≥"None"Ôºâ
                  langBoostSelect.value = chat.settings.language_boost || "";

                  // Âä†ËΩΩ speedÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÈªòËÆ§‰∏∫ 1.0
                  const speed = chat.settings.speed ?? 1.0; // ‰ΩøÁî® ?? Á°Æ‰øùÂç≥‰ΩøÂÄº‰∏∫0‰πüËÉΩÊ≠£Á°ÆÂ§ÑÁêÜ
                  speedSlider.value = speed;
                  speedValueDisplay.textContent = parseFloat(speed).toFixed(1);
                }

                // ‰∏∫ËØ≠ÈÄüÊªëÂùóÊ∑ªÂä†ÂÆûÊó∂Êõ¥Êñ∞ÊòæÁ§∫ÂÄºÁöÑ‰∫ã‰ª∂
                speedSlider.oninput = () => {
                  speedValueDisplay.textContent = parseFloat(
                    speedSlider.value,
                  ).toFixed(1);
                };

                const coupleAvatarToggle = document.getElementById(
                  "couple-avatar-toggle",
                );
                const coupleAvatarDescContainer = document.getElementById(
                  "couple-avatar-desc-container",
                );
                const coupleAvatarDescInput = document.getElementById(
                  "couple-avatar-description",
                );

                coupleAvatarToggle.checked =
                  chat.settings.isCoupleAvatar || false;
                coupleAvatarDescInput.value =
                  chat.settings.coupleAvatarDescription || "";

                coupleAvatarDescContainer.style.display =
                  coupleAvatarToggle.checked ? "block" : "none";

                coupleAvatarToggle.onchange = () => {
                  coupleAvatarDescContainer.style.display =
                    coupleAvatarToggle.checked ? "block" : "none";
                };

                document.getElementById(
                  "group-background-activity-group",
                ).style.display = "none";
                // Â¶ÇÊûúÊòØÂçïËÅäÔºåÂ∞±Âä†ËΩΩÂàÜÁªÑÂàóË°®Âà∞‰∏ãÊãâÊ°Ü
                const select = document.getElementById("assign-group-select");
                select.innerHTML = '<option value="">Êú™ÂàÜÁªÑ</option>'; // Ê∏ÖÁ©∫Âπ∂ËÆæÁΩÆÈªòËÆ§ÈÄâÈ°π
                const groups = await db.qzoneGroups.toArray();
                groups.forEach((group) => {
                  const option = document.createElement("option");
                  option.value = group.id;
                  option.textContent = group.name;
                  // Â¶ÇÊûúÂΩìÂâçÂ•ΩÂèãÂ∑≤ÁªèÊúâÂàÜÁªÑÔºåÂ∞±ÈªòËÆ§ÈÄâ‰∏≠ÂÆÉ
                  if (chat.groupId === group.id) {
                    option.selected = true;
                  }
                  select.appendChild(option);
                });
              }

              const worldBookCheckboxesContainer = document.getElementById(
                "world-book-checkboxes-container",
              );
              worldBookCheckboxesContainer.innerHTML = "";
              const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

              // 1. Ëé∑ÂèñÊâÄÊúâÂàÜÁ±ªÂíå‰∏ñÁïå‰π¶
              const categories = await db.worldBookCategories.toArray();
              const books = state.worldBooks;

              // Â¶ÇÊûúÂ≠òÂú®Êú™ÂàÜÁ±ªÁöÑ‰π¶Á±çÔºåÂ∞±ÂàõÂª∫‰∏Ä‰∏™‚ÄúËôöÊãüÂàÜÁ±ª‚Äù
              const hasUncategorized = books.some((book) => !book.categoryId);
              if (hasUncategorized) {
                categories.push({ id: "uncategorized", name: "Êú™ÂàÜÁ±ª" });
              }

              // 2. Â∞Ü‰π¶Á±çÊåâÂàÜÁ±ªIDËøõË°åÂàÜÁªÑ
              const booksByCategoryId = books.reduce((acc, book) => {
                const categoryId = book.categoryId || "uncategorized";
                if (!acc[categoryId]) {
                  acc[categoryId] = [];
                }
                acc[categoryId].push(book);
                return acc;
              }, {});

              // 3. ÈÅçÂéÜÂàÜÁ±ªÔºåÂàõÂª∫Â∏¶ÊäòÂè†ÂäüËÉΩÁöÑÂàóË°®
              categories.forEach((category) => {
                const booksInCategory = booksByCategoryId[category.id] || [];
                if (booksInCategory.length > 0) {
                  const allInCategoryChecked = booksInCategory.every((book) =>
                    linkedIds.has(book.id),
                  );

                  const header = document.createElement("div");
                  header.className = "wb-category-header";
                  header.innerHTML = `
			            <span class="arrow">‚ñº</span>
			            <input type="checkbox" class="wb-category-checkbox" data-category-id="${
                    category.id
                  }" ${allInCategoryChecked ? "checked" : ""}>
			            <span>${category.name}</span>
			        `;

                  const bookContainer = document.createElement("div");
                  bookContainer.className = "wb-book-container";
                  bookContainer.dataset.containerFor = category.id;

                  booksInCategory.forEach((book) => {
                    const isChecked = linkedIds.has(book.id);
                    const label = document.createElement("label");
                    // Áªô‰π¶ÂêçÂåÖ‰∏Ä‰∏™spanÔºåÊñπ‰æøCSSÂÅöÁúÅÁï•Âè∑Â§ÑÁêÜ
                    label.innerHTML = `<input type="checkbox" class="wb-book-checkbox" value="${
                      book.id
                    }" data-parent-category="${category.id}" ${
                      isChecked ? "checked" : ""
                    }> <span class="wb-book-name">${book.name}</span>`;
                    bookContainer.appendChild(label);
                  });

                  // ÈªòËÆ§Â∞ÜÊâÄÊúâÊñá‰ª∂Â§πËÆæÁΩÆ‰∏∫ÊäòÂè†Áä∂ÊÄÅÔºå‰øùÊåÅÁïåÈù¢Êï¥Ê¥Å
                  header.classList.add("collapsed");
                  bookContainer.classList.add("collapsed");

                  worldBookCheckboxesContainer.appendChild(header);
                  worldBookCheckboxesContainer.appendChild(bookContainer);
                }
              });

              updateWorldBookSelectionDisplay(); // Êõ¥Êñ∞È°∂ÈÉ®ÁöÑÂ∑≤ÈÄâÊï∞ÈáèÊòæÁ§∫

              // Âä†ËΩΩÂπ∂Êõ¥Êñ∞ÊâÄÊúâÈ¢ÑËßàÁõ∏ÂÖ≥Êéß‰ª∂
              const themeRadio = document.querySelector(
                `input[name="theme-select"][value="${chat.settings.theme || "default"}"]`,
              );
              if (themeRadio) themeRadio.checked = true;
              const fontSizeSlider =
                document.getElementById("font-size-slider");
              fontSizeSlider.value = chat.settings.fontSize || 13;
              document.getElementById("font-size-value").textContent =
                `${fontSizeSlider.value}px`;
              const customCssInput =
                document.getElementById("custom-css-input");

              // --- Âä†ËΩΩÁÅ´Ëä±ËÆæÁΩÆ ---
              const streakSettings = chat.settings.streak || {
                enabled: false,
                initialDays: 0,
                extinguishThreshold: 1,
              };
              // --- Âä†ËΩΩËá™ÂÆö‰πâÁÅ´Ëä±ÂõæÊ†áÂíåÈ¢úËâ≤ËÆæÁΩÆ ---
              document.getElementById("streak-lit-icon-url").value =
                streakSettings.litIconUrl || "";
              document.getElementById("streak-extinguished-icon-url").value =
                streakSettings.extinguishedIconUrl || "";
              document.getElementById("streak-font-color-picker").value =
                streakSettings.fontColor || "#ff6f00"; // ÈªòËÆ§Ê©ôËâ≤

              const streakToggle = document.getElementById(
                "streak-enabled-toggle",
              );
              const streakDetails = document.getElementById(
                "streak-details-container",
              );
              const initialDaysInput = document.getElementById(
                "streak-initial-days-input",
              );
              const thresholdSelect = document.getElementById(
                "streak-extinguish-threshold-select",
              );

              streakToggle.checked = streakSettings.enabled;
              streakDetails.style.display = streakSettings.enabled
                ? "block"
                : "none";

              const intimacyBtn = document.getElementById(
                "open-intimacy-panel-btn",
              );
              if (intimacyBtn) {
                intimacyBtn.style.display = streakSettings.enabled
                  ? "block"
                  : "none";
              }

              initialDaysInput.value = streakSettings.initialDays || 0;
              thresholdSelect.value = streakSettings.extinguishThreshold || 1;

              // ‰∏∫ÂºÄÂÖ≥Ê∑ªÂä†ÂÆûÊó∂‰∫§‰∫í
              streakToggle.onchange = () => {
                streakDetails.style.display = streakToggle.checked
                  ? "block"
                  : "none";
              };

              customCssInput.value = chat.settings.customCss || "";

              updateSettingsPreview();

              renderBubblePresetSelector();
              document
                .getElementById("bubble-style-preset-select")
                .addEventListener("change", handlePresetSelectChange);
              document
                .getElementById("manage-bubble-presets-btn")
                .addEventListener("click", openBubblePresetManager);
              document
                .getElementById("chat-settings-modal")
                .classList.add("visible");
            });

          function renderGroupMemberSettings(members) {
            const container = document.getElementById("group-members-settings");
            container.innerHTML = "";
            members.forEach((member) => {
              const div = document.createElement("div");
              div.className = "member-editor";
              div.dataset.memberId = member.id;

              // ÊòæÁ§∫ÁöÑÊòØ groupNickname
              div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`;
              div.addEventListener("click", () => openMemberEditor(member.id));
              container.appendChild(div);
            });
          }

          function openMemberEditor(memberId) {
            editingMemberId = memberId;
            const chat = state.chats[state.activeChatId];
            const member = chat.members.find((m) => m.id === memberId);
            if (!member) return;

            if (typeof member.isMuted === "undefined") {
              member.isMuted = false; // ‰∏∫ÊóßÊï∞ÊçÆÂÖºÂÆπ
            }

            document.getElementById("member-name-input").value =
              member.groupNickname;
            document.getElementById("member-persona-input").value =
              member.persona;
            document.getElementById("member-avatar-preview").src =
              member.avatar;

            // ‚òÖ‚òÖ‚òÖ Êàë‰ª¨Âú®ËøôÈáå‰∏∫Êñ∞ÊåâÈíÆÁªëÂÆö‰∫ÜÁÇπÂáª‰∫ã‰ª∂ ‚òÖ‚òÖ‚òÖ
            const changeFrameBtn = document.getElementById(
              "member-editor-change-frame-btn",
            );
            const newChangeFrameBtn = changeFrameBtn.cloneNode(true);
            changeFrameBtn.parentNode.replaceChild(
              newChangeFrameBtn,
              changeFrameBtn,
            );

            newChangeFrameBtn.addEventListener("click", () => {
              // Ë∞ÉÁî®Â§¥ÂÉèÊ°ÜÈÄâÊã©Âô®ÔºåÂπ∂ÂëäËØâÂÆÉÊàë‰ª¨Ê≠£Âú®‰∏∫'member'Á±ªÂûãÁöÑÊàêÂëòÔºà‰πüÂ∞±ÊòØNPCÔºâËÆæÁΩÆÂ§¥ÂÉèÊ°Ü
              openFrameSelectorModal("member", memberId);
            });

            document
              .getElementById("member-settings-modal")
              .classList.add("visible");
          }

          document
            .getElementById("cancel-member-settings-btn")
            .addEventListener("click", () => {
              document
                .getElementById("member-settings-modal")
                .classList.remove("visible");
              editingMemberId = null;
            });
          document
            .getElementById("save-member-settings-btn")
            .addEventListener("click", () => {
              if (!editingMemberId) return;
              const chat = state.chats[state.activeChatId];
              const member = chat.members.find((m) => m.id === editingMemberId);

              const newNickname = document
                .getElementById("member-name-input")
                .value.trim();
              if (!newNickname) {
                alert("Áæ§ÊòµÁß∞‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
                return;
              }
              member.groupNickname = newNickname; // Âè™‰øÆÊîπÁæ§ÊòµÁß∞
              member.persona = document.getElementById(
                "member-persona-input",
              ).value;
              member.avatar = document.getElementById(
                "member-avatar-preview",
              ).src;

              renderGroupMemberSettings(chat.members);
              document
                .getElementById("member-settings-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("reset-theme-btn")
            .addEventListener("click", () => {
              document.getElementById("theme-default").checked = true;
            });
          document
            .getElementById("cancel-chat-settings-btn")
            .addEventListener("click", () => {
              chatSettingsModal.classList.remove("visible");
            });

          document
            .getElementById("save-chat-settings-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              const newName = document
                .getElementById("chat-name-input")
                .value.trim();
              if (!newName) return alert("Â§áÊ≥®Âêç/Áæ§Âêç‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
              chat.name = newName;
              // --- Êñ∞Â¢û‰ª£Á†ÅÂºÄÂßã ---
              if (!chat.isGroup) {
                const newRemark = document
                  .getElementById("chat-remark-input")
                  .value.trim();
                chat.settings.remarkName = newRemark;
              }
              // --- Êñ∞Â¢û‰ª£Á†ÅÁªìÊùü ---

              // ËÆ∞ÂøÜ‰∫íÈÄöÂäüËÉΩ - ‰øùÂ≠òÈÄªËæë
              const linkedMemoryCheckboxes = document.querySelectorAll(
                "#memory-link-checkboxes-container input:checked",
              );
              const memoryDepth =
                parseInt(
                  document.getElementById("link-memory-depth-input").value,
                ) || 5;

              chat.settings.linkMemoryDepth = memoryDepth; // Áã¨Á´ã‰øùÂ≠òËÆ∞ÂøÜÊù°Êï∞ËÆæÁΩÆ

              chat.settings.linkedMemories = Array.from(
                linkedMemoryCheckboxes,
              ).map((checkbox) => ({
                chatId: checkbox.value,
                depth: memoryDepth, // ÂØπÊâÄÊúâÈÄâ‰∏≠ÁöÑÈìæÊé•Â∫îÁî®Áõ∏ÂêåÁöÑÊ∑±Â∫¶
              }));

              const selectedThemeRadio = document.querySelector(
                'input[name="theme-select"]:checked',
              );
              chat.settings.theme = selectedThemeRadio
                ? selectedThemeRadio.value
                : "default";

              chat.settings.fontSize = parseInt(
                document.getElementById("font-size-slider").value,
              );
              chat.settings.customCss = document
                .getElementById("custom-css-input")
                .value.trim();

              chat.settings.myPersona =
                document.getElementById("my-persona").value;
              // ‚òÖ Save useGlobalPersona & sync if enabled ‚òÖ
              const _saveUgpToggle = document.getElementById('use-global-persona-toggle');
              if (_saveUgpToggle) {
                chat.settings.useGlobalPersona = _saveUgpToggle.checked;
                if (chat.settings.useGlobalPersona) {
                  const _ap = state.personaPresets.find(p => p.id === state.globalSettings.activePersonaId);
                  if (_ap) chat.settings.myPersona = _ap.description || '';
                }
              }
              chat.settings.myAvatar =
                document.getElementById("my-avatar-preview").src;
              const checkedBooks = document.querySelectorAll(
                "#world-book-checkboxes-container input.wb-book-checkbox:checked",
              );
              chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(
                (cb) => cb.value,
              );

              if (chat.isGroup) {
                chat.settings.myNickname = document
                  .getElementById("my-group-nickname-input")
                  .value.trim();
                chat.settings.groupAvatar = document.getElementById(
                  "group-avatar-preview",
                ).src;
                // ‰øùÂ≠òÁæ§ËÅäÂêéÂè∞Ê¥ªÂä®ËÆæÁΩÆ
                const groupActivityEnabled = document.getElementById(
                  "group-background-activity-switch",
                ).checked;
                const groupActivityInterval =
                  parseInt(
                    document.getElementById("group-background-interval-input")
                      .value,
                  ) || 120;

                // Á°Æ‰øù lastActivityTimestamp Â≠óÊÆµÂ≠òÂú®
                const lastTimestamp = chat.settings.backgroundActivity
                  ? chat.settings.backgroundActivity.lastActivityTimestamp
                  : 0;

                chat.settings.backgroundActivity = {
                  enabled: groupActivityEnabled,
                  interval: groupActivityInterval,
                  lastActivityTimestamp: lastTimestamp, // ‰øùÁïô‰∏äÊ¨°ÁöÑÊó∂Èó¥Êà≥
                };
              } else {
                chat.settings.aiPersona =
                  document.getElementById("ai-persona").value;
                chat.settings.aiAvatar =
                  document.getElementById("ai-avatar-preview").src;
                chat.settings.minimaxVoiceId = document
                  .getElementById("minimax-voice-id-input")
                  .value.trim();
                const langBoost = document.getElementById(
                  "minimax-language-boost-select",
                ).value;
                chat.settings.language_boost = langBoost ? langBoost : null; // Â¶ÇÊûúÈÄâÊã©"None"(value‰∏∫Á©∫),Âàô‰øùÂ≠ò‰∏∫null
                chat.settings.speed = parseFloat(
                  document.getElementById("minimax-speed-slider").value,
                );

                chat.settings.isCoupleAvatar = document.getElementById(
                  "couple-avatar-toggle",
                ).checked;
                chat.settings.coupleAvatarDescription = document
                  .getElementById("couple-avatar-description")
                  .value.trim();

                // ‰ªéËæìÂÖ•Ê°ÜËØªÂèñÂÄºÂπ∂‰øùÂ≠ò
                chat.settings.weiboProfession = document
                  .getElementById("weibo-profession-input")
                  .value.trim();
                chat.settings.weiboInstruction = document
                  .getElementById("weibo-instruction-input")
                  .value.trim();
                // ‰øùÂ≠òËßÜÈ¢ëÈÄöËØùËÆæÁΩÆ
                chat.settings.visualVideoCallEnabled = document.getElementById(
                  "visual-video-call-switch",
                ).checked;
                chat.settings.charVideoImage = document.getElementById(
                  "char-video-image-preview",
                ).src;
                chat.settings.userVideoImage = document.getElementById(
                  "user-video-image-preview",
                ).src;
                chat.settings.videoCallVoiceAccess = document.getElementById(
                  "video-call-voice-access-switch",
                ).checked;
                chat.settings.useRealCamera = document.getElementById(
                  "user-real-camera-switch",
                ).checked;
                // ‰øùÂ≠òNAIÂá∫ÂõæËÆæÁΩÆ
                const novelaiEnabled =
                  localStorage.getItem("novelai-enabled") === "true";
                if (novelaiEnabled) {
                  if (!chat.settings.naiSettings) {
                    chat.settings.naiSettings = {};
                  }

                  // Ê†πÊçÆÊòØÂê¶‰∏∫Áæ§ËÅäÈÄâÊã©‰∏çÂêåÁöÑradioÊåâÈíÆÁªÑ
                  const isGroup = chat.isGroup;
                  const promptSourceRadio = document.querySelector(
                    isGroup
                      ? 'input[name="group-nai-prompt-source"]:checked'
                      : 'input[name="nai-prompt-source"]:checked',
                  );

                  chat.settings.naiSettings.promptSource = promptSourceRadio
                    ? promptSourceRadio.value
                    : "system";
                  console.log(
                    "üíæ ‰øùÂ≠òNAIËÆæÁΩÆ - promptSource:",
                    chat.settings.naiSettings.promptSource,
                  );
                  console.log(
                    "üíæ ‰øùÂ≠òNAIËÆæÁΩÆ - characterPositivePrompt:",
                    chat.settings.naiSettings.characterPositivePrompt,
                  );
                  console.log(
                    "üíæ ‰øùÂ≠òNAIËÆæÁΩÆ - characterNegativePrompt:",
                    chat.settings.naiSettings.characterNegativePrompt,
                  );
                  // ËßíËâ≤‰∏ìÂ±ûÊèêÁ§∫ËØçÂ∑≤ÁªèÂú®‰∏ìÂ±ûÂºπÁ™ó‰∏≠‰øùÂ≠òÔºåËøôÈáåÂè™‰øùÂ≠òÊù•Ê∫êÈÄâÊã©
                }

                const selectedGroupId = document.getElementById(
                  "assign-group-select",
                ).value;
                chat.groupId = selectedGroupId
                  ? parseInt(selectedGroupId)
                  : null;
              }

              chat.settings.maxMemory =
                parseInt(document.getElementById("max-memory").value) || 10;
              const minReply =
                parseInt(
                  document.getElementById("min-reply-count-input").value,
                ) || 1;
              const maxReply =
                parseInt(
                  document.getElementById("max-reply-count-input").value,
                ) || 5;

              if (minReply > maxReply) {
                alert("ÂõûÂ§çÊù°Êï∞ÔºöÊúÄÂ∞èÂÄº‰∏çËÉΩÂ§ß‰∫éÊúÄÂ§ßÂÄºÔºÅÂ∑≤Ëá™Âä®‰øÆÊ≠£„ÄÇ");
                chat.settings.replyCountRange = {
                  min: maxReply,
                  max: minReply,
                }; // ‰∫§Êç¢
              } else {
                chat.settings.replyCountRange = {
                  min: minReply,
                  max: maxReply,
                };
              }

              chat.settings.timePerceptionEnabled = document.getElementById(
                "time-perception-toggle",
              ).checked;
              chat.settings.customTime =
                document.getElementById("custom-time-input").value;

              // --- ‰øùÂ≠òÁ∫ø‰∏ãÊ®°ÂºèËÆæÁΩÆ ---
              if (!chat.settings.offlineMode) chat.settings.offlineMode = {}; // ÂàùÂßãÂåñ
              chat.settings.offlineMode.enabled = document.getElementById(
                "offline-mode-toggle",
              ).checked;
              chat.settings.offlineMode.prompt = document
                .getElementById("offline-prompt-input")
                .value.trim();
              chat.settings.offlineMode.style = document
                .getElementById("offline-style-input")
                .value.trim();
              chat.settings.offlineMode.wordCount =
                parseInt(
                  document.getElementById("offline-word-count-input").value,
                ) || 300;
              // ‰øùÂ≠òÁîüÂõæÂºÄÂÖ≥Áä∂ÊÄÅ
              chat.settings.offlineMode.enableNovelAI = document.getElementById(
                "offline-novelai-toggle",
              ).checked;

              // presets ÁöÑÊï∞ÊçÆÂú®ÁÆ°ÁêÜÂáΩÊï∞‰∏≠Áõ¥Êé•Êìç‰ΩúÔºåËøôÈáåÊó†ÈúÄ‰øùÂ≠ò

              // --- Save impersonate user settings ---
              if (!chat.settings.impersonateUser) chat.settings.impersonateUser = {};
              chat.settings.impersonateUser.prompt = document
                .getElementById("impersonate-prompt-input")
                .value.trim();
              chat.settings.impersonateUser.wordCount =
                parseInt(document.getElementById("impersonate-wordcount-input").value) || 150;

              // --- ‰øùÂ≠òËÅäÂ§©ÊÄªÁªìËÆæÁΩÆ ---
              if (!chat.settings.summary) chat.settings.summary = {}; // ÂàùÂßãÂåñ
              chat.settings.summary.enabled =
                document.getElementById("summary-toggle").checked;
              chat.settings.summary.mode = document.querySelector(
                'input[name="summary-mode"]:checked',
              ).value;
              chat.settings.summary.count =
                parseInt(
                  document.getElementById("summary-count-input").value,
                ) || 20;
              chat.settings.summary.prompt = document
                .getElementById("summary-prompt-input")
                .value.trim();

              // Âú® 'save-chat-settings-btn' ÁöÑ click ‰∫ã‰ª∂ÁõëÂê¨Âô®ÂÜÖÈÉ®...

              const isStreakEnabled = document.getElementById(
                "streak-enabled-toggle",
              ).checked;
              const newInitialDays =
                parseInt(
                  document.getElementById("streak-initial-days-input").value,
                ) || 0;
              const newThreshold = parseInt(
                document.getElementById("streak-extinguish-threshold-select")
                  .value,
              );

              const oldStreak = chat.settings.streak || {}; // ÂÆâÂÖ®Âú∞Ëé∑ÂèñÊóßËÆæÁΩÆ

              if (isStreakEnabled) {
                // Ê£ÄÊü•ÊòØÂê¶ÊòØÈ¶ñÊ¨°ÂºÄÂêØ
                const isFirstTimeEnabled = !oldStreak.enabled;

                // Âè™ÊúâÂú®È¶ñÊ¨°ÂºÄÂêØÊó∂ÔºåÊâçÁî®‚ÄúÂàùÂßãÂ§©Êï∞‚ÄùË¶ÜÁõñ‚ÄúÂΩìÂâçÂ§©Êï∞‚Äù„ÄÇ
                // Âê¶ÂàôÔºåÂøÖÈ°ª‰øùÁïôÁî®Êà∑Â∑≤ÁªèÁßØÁ¥ØÁöÑ currentDays Âíå lastInteractionDate„ÄÇ
                chat.settings.streak = {
                  enabled: true,
                  currentDays: isFirstTimeEnabled
                    ? newInitialDays
                    : oldStreak.currentDays,
                  lastInteractionDate: isFirstTimeEnabled
                    ? null
                    : oldStreak.lastInteractionDate,
                  initialDays: newInitialDays,
                  extinguishThreshold: newThreshold,
                  litIconUrl: document
                    .getElementById("streak-lit-icon-url")
                    .value.trim(),
                  extinguishedIconUrl: document
                    .getElementById("streak-extinguished-icon-url")
                    .value.trim(),
                  fontColor: document.getElementById("streak-font-color-picker")
                    .value,
                };
              } else {
                // Â¶ÇÊûúÁî®Êà∑ÂÖ≥Èó≠‰∫ÜÂäüËÉΩÔºåÂ∞±ÈáçÁΩÆÊâÄÊúâËÆæÁΩÆ
                chat.settings.streak = {
                  enabled: false,
                  initialDays: 0,
                  currentDays: 0,
                  extinguishThreshold: 1,
                  lastInteractionDate: null,
                  litIconUrl: "",
                  extinguishedIconUrl: "",
                  fontColor: "#ff6f00",
                };
              }

              await db.chats.put(chat);

              applyScopedCss(
                chat.settings.customCss,
                "#chat-messages",
                "custom-bubble-style",
              );

              chatSettingsModal.classList.remove("visible");
              renderChatInterface(state.activeChatId);
              renderChatList();
            });

          document
            .getElementById("clear-chat-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              const confirmed = await showCustomConfirm(
                "Ê∏ÖÁ©∫ËÆ∞ÂΩï",
                "Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫Ê≠§ËÅäÂ§©ÁöÑ„ÄêÊ∂àÊÅØÂíåÂøÉÂ£∞„ÄëÂêóÔºü\nÔºàËÅäÂ§©ÊÄªÁªìÂ∞ÜË¢´‰øùÁïôÔºâ",
                { confirmButtonClass: "btn-danger" },
              );
              if (confirmed) {
                // ‰ΩøÁî® filter ÊñπÊ≥ïÔºåÂè™‰øùÁïôÁ±ªÂûã‰∏∫ 'summary' ÁöÑÊ∂àÊÅØ
                chat.history = chat.history.filter(
                  (msg) => msg.type === "summary",
                );

                // ÂêåÊó∂Ê∏ÖÁ©∫ÂøÉÂ£∞ËÆ∞ÂΩï
                if (chat.innerVoiceHistory) {
                  chat.innerVoiceHistory = [];
                }
                chat.latestInnerVoice = null;

                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                renderChatList();
                chatSettingsModal.classList.remove("visible");

                alert("ËÅäÂ§©Ê∂àÊÅØÂíåÂøÉÂ£∞Â∑≤Ê∏ÖÁ©∫ÔºÅ");
              }
            });

          // ÂØºÂá∫ËÅäÂ§©ËÆ∞ÂΩïÊåâÈíÆ
          document
            .getElementById("export-chat-history-btn")
            .addEventListener("click", exportChatHistory);

          // ‚ÄúÂØºÂÖ•ËÅäÂ§©ËÆ∞ÂΩï‚ÄùËøô‰∏™ÂèØËßÅÁöÑÊåâÈíÆ
          document
            .getElementById("import-chat-history-btn")
            .addEventListener("click", () => {
              // ÁÇπÂáªÂÆÉÊó∂ÔºåÊàë‰ª¨ÂéªËß¶ÂèëÈÇ£‰∏™ÈöêËóèÁöÑÊñá‰ª∂ÈÄâÊã©Ê°Ü
              document.getElementById("import-chat-history-input").click();
            });

          // ÈöêËóèÁöÑÊñá‰ª∂ÈÄâÊã©Ê°Ü
          document
            .getElementById("import-chat-history-input")
            .addEventListener("change", (event) => {
              const file = event.target.files[0];
              if (file) {
                importChatHistory(file);
              }
              // ÊØèÊ¨°ÈÄâÊã©ÂêéÊ∏ÖÁ©∫ÔºåËøôÊ†∑‰∏ãÊ¨°ËøòËÉΩÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
              event.target.value = null;
            });

          const setupFileUpload = (inputId, callback) => {
            document
              .getElementById(inputId)
              .addEventListener("change", async (event) => {
                const file = event.target.files[0];
                if (file) {
                  try {
                    // Ë∞ÉÁî®Êñ∞ÁöÑÈÄöÁî®ÂéãÁº©ÂáΩÊï∞
                    const compressedDataUrl =
                      await handleImageUploadAndCompress(file);
                    callback(compressedDataUrl); // Â∞ÜÂéãÁº©ÂêéÁöÑÁªìÊûú‰º†ÁªôÂõûË∞É
                  } catch (error) {
                    console.error(`Â§ÑÁêÜÊñá‰ª∂ ${file.name} Â§±Ë¥•:`, error);
                    alert(`Â§ÑÁêÜÂõæÁâáÂ§±Ë¥•: ${error.message}`);
                  } finally {
                    event.target.value = null;
                  }
                }
              });
          };

          setupFileUpload(
            "ai-avatar-input",
            (base64) =>
              (document.getElementById("ai-avatar-preview").src = base64),
          );
          setupFileUpload(
            "my-avatar-input",
            (base64) =>
              (document.getElementById("my-avatar-preview").src = base64),
          );
          setupFileUpload(
            "group-avatar-input",
            (base64) =>
              (document.getElementById("group-avatar-preview").src = base64),
          );
          setupFileUpload(
            "member-avatar-input",
            (base64) =>
              (document.getElementById("member-avatar-preview").src = base64),
          );
          setupFileUpload("bg-input", (base64) => {
            if (state.activeChatId) {
              state.chats[state.activeChatId].settings.background = base64;
              const bgPreview = document.getElementById("bg-preview");
              bgPreview.src = base64;
              bgPreview.style.display = "block";
              document.getElementById("remove-bg-btn").style.display =
                "inline-block";
            }
          });
          setupFileUpload(
            "preset-avatar-input",
            (base64) =>
              (document.getElementById("preset-avatar-preview").src = base64),
          );

          setupFileUpload(
            "char-video-image-input",
            (base64) =>
              (document.getElementById("char-video-image-preview").src =
                base64),
          );
          setupFileUpload(
            "user-video-image-input",
            (base64) =>
              (document.getElementById("user-video-image-preview").src =
                base64),
          );

          document
            .getElementById("remove-bg-btn")
            .addEventListener("click", () => {
              if (state.activeChatId) {
                state.chats[state.activeChatId].settings.background = "";
                const bgPreview = document.getElementById("bg-preview");
                bgPreview.src = "";
                bgPreview.style.display = "none";
                document.getElementById("remove-bg-btn").style.display = "none";
              }
            });

          const stickerPanel = document.getElementById("sticker-panel");
          document
            .getElementById("open-sticker-panel-btn")
            .addEventListener("click", () => {
              renderStickerPanel();
              stickerPanel.classList.add("visible");
            });
          document
            .getElementById("close-sticker-panel-btn")
            .addEventListener("click", () =>
              stickerPanel.classList.remove("visible"),
            );

          document
            .getElementById("add-sticker-btn")
            .addEventListener("click", openBulkAddStickersModal);

          document
            .getElementById("upload-sticker-btn")
            .addEventListener("click", () =>
              document.getElementById("sticker-upload-input").click(),
            );

          document
            .getElementById("sticker-upload-input")
            .addEventListener("change", async (event) => {
              const files = event.target.files;
              if (!files.length) return;

              const newStickers = [];
              let canceled = false;

              // ‰ΩøÁî® for...of Âæ™ÁéØÊù•ÈÄê‰∏™Â§ÑÁêÜÈÄâ‰∏≠ÁöÑÊñá‰ª∂
              for (const file of files) {
                if (canceled) break; // Â¶ÇÊûúÁî®Êà∑‰∏≠ÈÄîÂèñÊ∂à‰∫ÜÔºåÂ∞±Ë∑≥Âá∫Âæ™ÁéØ

                // ‰∏∫ÊØè‰∏™Êñá‰ª∂ÁîüÊàê‰∏Ä‰∏™‰∏¥Êó∂ÁöÑÊú¨Âú∞È¢ÑËßàURL
                const previewUrl = URL.createObjectURL(file);

                // ÂºπÂá∫Â∏¶ÂõæÁâáÈ¢ÑËßàÁöÑÂëΩÂêçÊ°Ü
                const name = await showCustomPrompt(
                  `‰∏∫Ë°®ÊÉÖÂëΩÂêç (${newStickers.length + 1}/${files.length})`,
                  "ËØ∑ËæìÂÖ•Ë°®ÊÉÖÂêçÁß∞",
                  file.name.replace(/\.[^/.]+$/, ""), // ÈªòËÆ§‰ΩøÁî®Êñá‰ª∂Âêç‰Ωú‰∏∫ÂêçÂ≠ó
                  "text",
                  // ËøôÊòØ showCustomPrompt ÁöÑ‰∏Ä‰∏™ÈöêËóèÂäüËÉΩÔºåÂèØ‰ª•ÊèíÂÖ•È¢ùÂ§ñÁöÑHTML
                  `<img src="${previewUrl}" style="max-width: 100px; max-height: 100px; margin-bottom: 10px; border-radius: 8px;">`,
                );

                // ÈáäÊîæ‰∏¥Êó∂ÁöÑÈ¢ÑËßàURLÔºåÈÅøÂÖçÂÜÖÂ≠òÊ≥ÑÊºè
                URL.revokeObjectURL(previewUrl);

                if (name && name.trim()) {
                  // Áî®Êà∑Á°ÆËÆ§ÂëΩÂêçÔºåËØªÂèñÊñá‰ª∂ÂÜÖÂÆπÂπ∂ÂáÜÂ§á‰øùÂ≠ò
                  const base64Url = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsDataURL(file);
                  });

                  newStickers.push({
                    id: "sticker_" + (Date.now() + newStickers.length),
                    url: base64Url,
                    name: name.trim(),
                  });
                } else if (name === null) {
                  // Â¶ÇÊûúÁî®Êà∑ÁÇπÂáª‰∫Ü‚ÄúÂèñÊ∂à‚Äù
                  const confirmCancel = await showCustomConfirm(
                    "Á°ÆËÆ§ÂèñÊ∂à",
                    "Á°ÆÂÆöË¶ÅÂèñÊ∂àÂâ©‰ΩôË°®ÊÉÖÁöÑ‰∏ä‰º†ÂêóÔºü",
                  );
                  if (confirmCancel) {
                    canceled = true;
                  }
                } else {
                  alert("Ë°®ÊÉÖÂêç‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
                }
              }

              // Âæ™ÁéØÁªìÊùüÂêéÔºåÂ¶ÇÊûúÊî∂ÈõÜÂà∞‰∫ÜÊñ∞Ë°®ÊÉÖÔºåÂ∞±ÊâπÈáèÊ∑ªÂä†Âà∞Êï∞ÊçÆÂ∫ì
              if (newStickers.length > 0) {
                await db.userStickers.bulkAdd(newStickers);
                state.userStickers.push(...newStickers);
                renderStickerPanel();
                await showCustomAlert(
                  "‰∏ä‰º†ÊàêÂäü",
                  `Â∑≤ÊàêÂäüÊ∑ªÂä† ${newStickers.length} ‰∏™Êñ∞Ë°®ÊÉÖÔºÅ`,
                );
              }

              // Ê∏ÖÁ©∫Êñá‰ª∂ÈÄâÊã©Âô®ÁöÑÂÄºÔºå‰ª•‰æø‰∏ãÊ¨°ËÉΩÈÄâÊã©Áõ∏ÂêåÁöÑÊñá‰ª∂
              event.target.value = null;
            });

          document
            .getElementById("upload-image-btn")
            .addEventListener("click", () =>
              document.getElementById("image-upload-input").click(),
            );
          document
            .getElementById("image-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (!file || !state.activeChatId) return;
              const reader = new FileReader();
              reader.onload = async (e) => {
                const base64Url = e.target.result;
                const chat = state.chats[state.activeChatId];
                const msg = {
                  role: "user",
                  content: [
                    { type: "image_url", image_url: { url: base64Url } },
                  ],
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              };
              reader.readAsDataURL(file);
              event.target.value = null;
            });
          document
            .getElementById("voice-message-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const text = await showCustomPrompt(
                "ÂèëÈÄÅËØ≠Èü≥",
                "ËØ∑ËæìÂÖ•‰Ω†ÊÉ≥ËØ¥ÁöÑÂÜÖÂÆπÔºö",
              );
              if (text && text.trim()) {
                const chat = state.chats[state.activeChatId];
                const msg = {
                  role: "user",
                  type: "voice_message",
                  content: text.trim(),
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              }
            });
          document
            .getElementById("send-photo-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const description = await showCustomPrompt(
                "ÂèëÈÄÅÁÖßÁâá",
                "ËØ∑Áî®ÊñáÂ≠óÊèèËø∞ÊÇ®Ë¶ÅÂèëÈÄÅÁöÑÁÖßÁâáÔºö",
              );
              if (description && description.trim()) {
                const chat = state.chats[state.activeChatId];
                const msg = {
                  role: "user",
                  type: "user_photo",
                  content: description.trim(),
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              }
            });

          // ===== Food Delivery Modal event bindings =====
          const waimaiModal = document.getElementById("waimai-request-modal");

          // Track current mode: "request" = ask char to pay | "order" = user orders FOR char
          let waimaiCurrentMode = "request";

          // Open modal
          document
            .getElementById("send-waimai-request-btn")
            .addEventListener("click", () => {
              waimaiModal.classList.add("visible");
            });

          // Close modal (Cancel)
          document
            .getElementById("waimai-cancel-btn")
            .addEventListener("click", () => {
              waimaiModal.classList.remove("visible");
            });

          // Mode toggle buttons
          document.querySelectorAll(".waimai-mode-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
              waimaiCurrentMode = btn.dataset.mode;

              // Update active state
              document.querySelectorAll(".waimai-mode-btn").forEach((b) =>
                b.classList.remove("active")
              );
              btn.classList.add("active");

              const isOrderMode = waimaiCurrentMode === "order";

              // Toggle Note field visibility
              document.getElementById("waimai-note-group").style.display =
                isOrderMode ? "block" : "none";

              // Toggle wallet balance display
              const balanceDisplay = document.getElementById("waimai-balance-display");
              if (isOrderMode) {
                const bal = state.globalSettings?.userBalance || 0;
                document.getElementById("waimai-balance-value").textContent =
                  `¬•${bal.toFixed(2)}`;
                balanceDisplay.style.display = "flex";
              } else {
                balanceDisplay.style.display = "none";
              }

              // Update labels & button text
              document.getElementById("waimai-modal-title").textContent =
                isOrderMode ? "Order Food for Them" : "Food Delivery";
              document.getElementById("waimai-amount-label").textContent =
                isOrderMode ? "Order Amount (¬•)" : "Amount (¬•)";
              document.getElementById("waimai-confirm-btn").textContent =
                isOrderMode ? "Place Order" : "Send Request";
            });
          });

          // Confirm button
          document
            .getElementById("waimai-confirm-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;

              const productInfoInput = document.getElementById("waimai-product-info");
              const amountInput     = document.getElementById("waimai-amount");
              const quantityInput   = document.getElementById("waimai-quantity");
              const noteInput       = document.getElementById("waimai-note");

              const productInfo = productInfoInput.value.trim();
              const amount      = parseFloat(amountInput.value);
              const quantity    = Math.max(1, parseInt(quantityInput.value) || 1);
              const note        = noteInput.value.trim();

              if (!productInfo) {
                alert("Please enter item info!");
                return;
              }
              if (isNaN(amount) || amount <= 0) {
                alert("Please enter a valid amount!");
                return;
              }

              const chat = state.chats[state.activeChatId];
              const now  = Date.now();
              const myNickname = chat.isGroup
                ? chat.settings.myNickname || "Me"
                : "Me";

              if (waimaiCurrentMode === "order") {
                // ‚îÄ‚îÄ "Order for Them" flow ‚îÄ‚îÄ
                // User is buying food FOR the character using their own wallet balance.

                // ‚îÄ‚îÄ Balance check ‚îÄ‚îÄ
                const userBalance = state.globalSettings?.userBalance || 0;
                if (userBalance < amount) {
                  await showCustomAlert(
                    "Insufficient Balance",
                    `You need ¬•${amount.toFixed(2)} but only have ¬•${userBalance.toFixed(2)} in your wallet. Please top up first!`
                  );
                  return;
                }

                // ‚îÄ‚îÄ Deduct from user wallet and log the transaction ‚îÄ‚îÄ
                await window.updateUserBalanceAndLogTransaction(
                  -amount,
                  `Ordered "${productInfo}" (√ó${quantity}) for ${chat.name}`
                );

                const orderMsg = {
                  role: "user",
                  senderName: myNickname,
                  type: "waimai_order_for_char",
                  productInfo,
                  quantity,
                  amount,
                  note,
                  timestamp: now,
                };

                // Hidden system note so the AI understands what just happened
                const systemNote = {
                  role: "system",
                  content: `[System Notice: ${myNickname} has ordered food for you! ` +
                    `Item: "${productInfo}", Quantity: ${quantity}, ` +
                    `Amount: ¬•${amount.toFixed(2)}` +
                    (note ? `, Note: "${note}"` : "") +
                    `. Please react naturally to receiving this delivery!]`,
                  timestamp: now + 1,
                  isHidden: true,
                };

                chat.history.push(orderMsg);
                chat.history.push(systemNote);
                await db.chats.put(chat);
                appendMessage(orderMsg, chat);
                renderChatList();

                // Let AI react to receiving the order
                triggerAiResponse();

              } else {
                // ‚îÄ‚îÄ "Request Payment" flow (original behaviour + quantity) ‚îÄ‚îÄ
                const msg = {
                  role: "user",
                  senderName: myNickname,
                  type: "waimai_request",
                  productInfo,
                  quantity,
                  amount,
                  status: "pending",
                  countdownEndTime: now + 15 * 60 * 1000,
                  timestamp: now,
                };

                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              }

              // Reset form
              productInfoInput.value = "";
              amountInput.value      = "";
              quantityInput.value    = "1";
              noteInput.value        = "";
              waimaiModal.classList.remove("visible");
            });
          document
            .getElementById("open-persona-library-btn")
            .addEventListener("click", openPersonaLibrary);
          document
            .getElementById("close-persona-library-btn")
            .addEventListener("click", closePersonaLibrary);
          document
            .getElementById("add-persona-preset-btn")
            .addEventListener("click", openPersonaEditorForCreate);
          document
            .getElementById("cancel-persona-editor-btn")
            .addEventListener("click", closePersonaEditor);

          document
            .getElementById("preset-action-edit")
            .addEventListener("click", openPersonaEditorForEdit);
          document
            .getElementById("preset-action-delete")
            .addEventListener("click", deletePersonaPreset);
          document
            .getElementById("preset-action-cancel")
            .addEventListener("click", hidePresetActions);

          document
            .getElementById("selection-cancel-btn")
            .addEventListener("click", exitSelectionMode);

          document
            .getElementById("selection-delete-btn")
            .addEventListener("click", async () => {
              if (selectedMessages.size === 0) return;
              const confirmed = await showCustomConfirm(
                "Âà†Èô§Ê∂àÊÅØ",
                `Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${selectedMessages.size} Êù°Ê∂àÊÅØÂêóÔºüËøôÂ∞ÜÊîπÂèòAIÁöÑËÆ∞ÂøÜ„ÄÇ`,
                { confirmButtonClass: "btn-danger" },
              );
              if (confirmed) {
                const chat = state.chats[state.activeChatId];

                // 1. Âú®Âà†Èô§ÂâçÔºåÊ£ÄÊü•Ë¢´Âà†Èô§ÁöÑÊ∂àÊÅØ‰∏≠ÊòØÂê¶ÂåÖÂê´ÊäïÁ•®
                let deletedPollsInfo = [];
                for (const timestamp of selectedMessages) {
                  const msg = chat.history.find(
                    (m) => m.timestamp === timestamp,
                  );
                  if (msg && msg.type === "poll") {
                    deletedPollsInfo.push(
                      `ÂÖ≥‰∫é‚Äú${msg.question}‚ÄùÁöÑÊäïÁ•®(Êó∂Èó¥Êà≥: ${msg.timestamp})`,
                    );
                  }
                }

                // 2. Êõ¥Êñ∞ÂêéÁ´ØÁöÑÂéÜÂè≤ËÆ∞ÂΩï
                chat.history = chat.history.filter(
                  (msg) => !selectedMessages.has(msg.timestamp),
                );

                // 3. ÊûÑÂª∫Êõ¥ÂÖ∑‰ΩìÁöÑ‚ÄúÈÅóÂøòÊåá‰ª§‚Äù
                let forgetReason = "‰∏Ä‰∫õ‰πãÂâçÁöÑÊ∂àÊÅØÂ∑≤Ë¢´Áî®Êà∑Âà†Èô§„ÄÇ";
                if (deletedPollsInfo.length > 0) {
                  forgetReason += ` ÂÖ∂‰∏≠ÂåÖÊã¨‰ª•‰∏ãÊäïÁ•®Ôºö${deletedPollsInfo.join("Ôºõ")}„ÄÇ`;
                }
                forgetReason +=
                  " ‰Ω†Â∫îËØ•ÂÉèÂÆÉ‰ª¨‰ªéÊú™Â≠òÂú®Ëøá‰∏ÄÊ†∑ÁªßÁª≠ÂØπËØùÔºåÂπ∂Áõ∏Â∫îÂú∞Ë∞ÉÊï¥‰Ω†ÁöÑËÆ∞ÂøÜÂíåË°å‰∏∫Ôºå‰∏çË¶ÅÂÜçÊèêÂèäËøô‰∫õË¢´Âà†Èô§ÁöÑÂÜÖÂÆπ„ÄÇ";

                const forgetInstruction = {
                  role: "system",
                  content: `[Á≥ªÁªüÊèêÁ§∫Ôºö${forgetReason}]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(forgetInstruction);

                // 4. Â∞ÜÂåÖÂê´‚ÄúÈÅóÂøòÊåá‰ª§‚ÄùÁöÑ„ÄÅÊõ¥Êñ∞ÂêéÁöÑchatÂØπË±°Â≠òÂõûÊï∞ÊçÆÂ∫ì
                await db.chats.put(chat);

                // 5. ÊúÄÂêéÊâçÊõ¥Êñ∞UI
                renderChatInterface(state.activeChatId);
                renderChatList();
              }
            });

          document
            .getElementById("reset-font-btn")
            .addEventListener("click", resetToDefaultFont);

          document
            .querySelectorAll("#chat-list-bottom-nav .nav-item")
            .forEach((item) => {
              item.addEventListener("click", () =>
                switchToChatListView(item.dataset.view),
              );
            });
          document
            .getElementById("qzone-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view"),
            );
          document
            .getElementById("qzone-nickname")
            .addEventListener("click", async () => {
              const newNickname = await showCustomPrompt(
                "‰øÆÊîπÊòµÁß∞",
                "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÊòµÁß∞",
                state.qzoneSettings.nickname,
              );
              if (newNickname && newNickname.trim()) {
                state.qzoneSettings.nickname = newNickname.trim();
                await saveQzoneSettings();
                renderQzoneScreen();
              }
            });
          document
            .getElementById("qzone-avatar-container")
            .addEventListener("click", () =>
              document.getElementById("qzone-avatar-input").click(),
            );
          document
            .getElementById("qzone-banner-container")
            .addEventListener("click", () =>
              document.getElementById("qzone-banner-input").click(),
            );
          document
            .getElementById("qzone-avatar-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.readAsDataURL(file);
                });
                state.qzoneSettings.avatar = dataUrl;
                await saveQzoneSettings();
                renderQzoneScreen();
              }
              event.target.value = null;
            });
          document
            .getElementById("qzone-banner-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.readAsDataURL(file);
                });
                state.qzoneSettings.banner = dataUrl;
                await saveQzoneSettings();
                renderQzoneScreen();
              }
              event.target.value = null;
            });

          document
            .getElementById("create-shuoshuo-btn")
            .addEventListener("click", () => openQZonePublisher("shuoshuo"));
          document
            .getElementById("create-post-btn")
            .addEventListener("click", () => openQZonePublisher("complex"));

          document
            .getElementById("open-album-btn")
            .addEventListener("click", async () => {
              await renderAlbumList();
              showScreen("album-screen");
            });
          document
            .getElementById("album-back-btn")
            .addEventListener("click", () => {
              showScreen("chat-list-screen");
              switchToChatListView("qzone-screen");
            });

          document
            .getElementById("album-photos-back-btn")
            .addEventListener("click", () => {
              state.activeAlbumId = null;
              showScreen("album-screen");
            });

          document
            .getElementById("album-upload-photo-btn")
            .addEventListener("click", () =>
              document.getElementById("album-photo-input").click(),
            );

          document
            .getElementById("album-photo-input")
            .addEventListener("change", async (event) => {
              if (!state.activeAlbumId) return;
              const files = event.target.files;
              if (!files.length) return;

              const album = await db.qzoneAlbums.get(state.activeAlbumId);

              for (const file of files) {
                const dataUrl = await new Promise((resolve) => {
                  const reader = new FileReader();
                  reader.onload = () => resolve(reader.result);
                  reader.readAsDataURL(file);
                });
                await db.qzonePhotos.add({
                  albumId: state.activeAlbumId,
                  url: dataUrl,
                  createdAt: Date.now(),
                });
              }

              const photoCount = await db.qzonePhotos
                .where("albumId")
                .equals(state.activeAlbumId)
                .count();
              const updateData = { photoCount };

              if (!album.photoCount || album.coverUrl.includes("placeholder")) {
                const firstPhoto = await db.qzonePhotos
                  .where("albumId")
                  .equals(state.activeAlbumId)
                  .first();
                if (firstPhoto) updateData.coverUrl = firstPhoto.url;
              }

              await db.qzoneAlbums.update(state.activeAlbumId, updateData);
              await renderAlbumPhotosScreen();
              await renderAlbumList();

              event.target.value = null;
              alert("ÁÖßÁâá‰∏ä‰º†ÊàêÂäüÔºÅ");
            });

          document
            .getElementById("photos-grid-page")
            .addEventListener("click", async (e) => {
              const deleteBtn = e.target.closest(".photo-delete-btn");
              const photoThumb = e.target.closest(".photo-thumb");

              if (deleteBtn) {
                e.stopPropagation(); // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°Âà∞ÂõæÁâá‰∏ä
                const photoId = parseInt(deleteBtn.dataset.photoId);
                const confirmed = await showCustomConfirm(
                  "Âà†Èô§ÁÖßÁâá",
                  "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÂº†ÁÖßÁâáÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ",
                  {
                    confirmButtonClass: "btn-danger",
                  },
                );

                if (confirmed) {
                  const deletedPhoto = await db.qzonePhotos.get(photoId);
                  if (!deletedPhoto) return;

                  await db.qzonePhotos.delete(photoId);

                  const album = await db.qzoneAlbums.get(state.activeAlbumId);
                  const photoCount = (album.photoCount || 1) - 1;
                  const updateData = { photoCount };

                  if (album.coverUrl === deletedPhoto.url) {
                    const nextPhoto = await db.qzonePhotos
                      .where("albumId")
                      .equals(state.activeAlbumId)
                      .first();
                    updateData.coverUrl = nextPhoto
                      ? nextPhoto.url
                      : "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
                  }

                  await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                  await renderAlbumPhotosScreen();
                  await renderAlbumList();
                  alert("ÁÖßÁâáÂ∑≤Âà†Èô§„ÄÇ");
                }
              } else if (photoThumb) {
                // ËøôÂ∞±ÊòØÊÅ¢Â§çÁöÑÂõæÁâáÁÇπÂáªÊîæÂ§ßÂäüËÉΩÔºÅ
                openPhotoViewer(photoThumb.src);
              }
            });

          // ÊÅ¢Â§çÂõæÁâáÊü•ÁúãÂô®ÁöÑÊéßÂà∂‰∫ã‰ª∂
          document
            .getElementById("photo-viewer-close-btn")
            .addEventListener("click", closePhotoViewer);
          document
            .getElementById("photo-viewer-next-btn")
            .addEventListener("click", showNextPhoto);
          document
            .getElementById("photo-viewer-prev-btn")
            .addEventListener("click", showPrevPhoto);

          // ÊÅ¢Â§çÈîÆÁõòÂ∑¶Âè≥ÁÆ≠Â§¥ÂíåESCÈîÆÁöÑÂäüËÉΩ
          document.addEventListener("keydown", (e) => {
            if (!photoViewerState.isOpen) return;

            if (e.key === "ArrowRight") {
              showNextPhoto();
            } else if (e.key === "ArrowLeft") {
              showPrevPhoto();
            } else if (e.key === "Escape") {
              closePhotoViewer();
            }
          });

          // --- ‚Üë‚Üë‚Üë Â§çÂà∂Âà∞ËøôÈáåÁªìÊùü ‚Üë‚Üë‚Üë ---

          document
            .getElementById("create-album-btn-page")
            .addEventListener("click", async () => {
              const albumName = await showCustomPrompt(
                "ÂàõÂª∫Êñ∞Áõ∏ÂÜå",
                "ËØ∑ËæìÂÖ•Áõ∏ÂÜåÂêçÁß∞",
              );
              if (albumName && albumName.trim()) {
                const newAlbum = {
                  name: albumName.trim(),
                  coverUrl:
                    "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png",
                  photoCount: 0,
                  createdAt: Date.now(),
                };
                await db.qzoneAlbums.add(newAlbum);
                await renderAlbumList();
                alert(`Albums "${albumName}" ÂàõÂª∫ÊàêÂäüÔºÅ`);
              } else if (albumName !== null) {
                alert("Áõ∏ÂÜåÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫ÔºÅ");
              }
            });

          document
            .getElementById("cancel-create-post-btn")
            .addEventListener("click", () =>
              document
                .getElementById("create-post-modal")
                .classList.remove("visible"),
            );
          document
            .getElementById("post-upload-local-btn")
            .addEventListener("click", () =>
              document.getElementById("post-local-image-input").click(),
            );
          document
            .getElementById("post-local-image-input")
            .addEventListener("change", (event) => {
              const file = event.target.files[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                  document.getElementById("post-image-preview").src =
                    e.target.result;
                  document
                    .getElementById("post-image-preview-container")
                    .classList.add("visible");
                  document.getElementById(
                    "post-image-desc-group",
                  ).style.display = "block";
                };
                reader.readAsDataURL(file);
              }
            });
          document
            .getElementById("post-use-url-btn")
            .addEventListener("click", async () => {
              const url = await showCustomPrompt(
                "ËæìÂÖ•ÂõæÁâáURL",
                "ËØ∑ËæìÂÖ•ÁΩëÁªúÂõæÁâáÁöÑÈìæÊé•",
                "",
                "url",
              );
              if (url) {
                document.getElementById("post-image-preview").src = url;
                document
                  .getElementById("post-image-preview-container")
                  .classList.add("visible");
                document.getElementById("post-image-desc-group").style.display =
                  "block";
              }
            });
          document
            .getElementById("post-remove-image-btn")
            .addEventListener("click", () => resetCreatePostModal());
          const imageModeBtn = document.getElementById("switch-to-image-mode");
          const textImageModeBtn = document.getElementById(
            "switch-to-text-image-mode",
          );
          const imageModeContent =
            document.getElementById("image-mode-content");
          const textImageModeContent = document.getElementById(
            "text-image-mode-content",
          );
          imageModeBtn.addEventListener("click", () => {
            imageModeBtn.classList.add("active");
            textImageModeBtn.classList.remove("active");
            imageModeContent.classList.add("active");
            textImageModeContent.classList.remove("active");
          });
          textImageModeBtn.addEventListener("click", () => {
            textImageModeBtn.classList.add("active");
            imageModeBtn.classList.remove("active");
            textImageModeContent.classList.add("active");
            imageModeContent.classList.remove("active");
          });

          document
            .getElementById("confirm-create-post-btn")
            .addEventListener("click", async () => {
              const modal = document.getElementById("create-post-modal");
              const mode = modal.dataset.mode;

              // Â¶ÇÊûúÂΩìÂâçÊòØ 'forum' (Â∞èÁªÑÂèëÂ∏ñ) Ê®°ÂºèÔºåÂ∞±Ë∞ÉÁî®Êàë‰ª¨ÂàöÂàöÂÜôÁöÑÂèëÂ∏ñÂáΩÊï∞
              if (mode === "forum") {
                await handleCreateForumPost();
                return; // ÊâßË°åÂÆåÂ∞±ÁªìÊùüÔºå‰∏çÂæÄ‰∏ãËµ∞‰∫Ü
              }

              // Â¶ÇÊûúÊòØ 'weibo' Ê®°ÂºèÔºåÂ∞±Ë∞ÉÁî®ÂèëÂæÆÂçöÁöÑÂáΩÊï∞
              if (mode === "weibo") {
                await handlePublishWeibo();
                return;
              }

              // --- ‰∏ãÈù¢ÊòØ‰Ω†ÂéüÊù•Â∑≤ÊúâÁöÑÂèëÂ∏É‚ÄúÂä®ÊÄÅ‚ÄùÁöÑÈÄªËæëÔºåÊàë‰ª¨‰øùÊåÅ‰∏çÂèò ---
              const editingId = parseInt(modal.dataset.editingPostId);
              const areCommentsVisible = document.getElementById(
                "post-comments-toggle",
              ).checked;

              const visibility = document.querySelector(
                'input[name="visibility"]:checked',
              ).value;
              let visibleGroupIds = null;
              if (visibility === "groups") {
                visibleGroupIds = Array.from(
                  document.querySelectorAll(
                    "#post-visibility-groups input:checked",
                  ),
                ).map((cb) => parseInt(cb.value));
                if (visibleGroupIds.length === 0) {
                  alert("ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏Ä‰∏™ÂèØËßÅÁöÑÂàÜÁªÑÔºÅ");
                  return;
                }
              }

              let postData = {};

              if (mode === "edit") {
                const existingPost = await db.qzonePosts.get(editingId);
                if (!existingPost) {
                  alert("ÈîôËØØÔºöÊâæ‰∏çÂà∞Ë¶ÅÁºñËæëÁöÑÂä®ÊÄÅÔºÅ");
                  return;
                }
                postData = {
                  ...existingPost,
                  areCommentsVisible: areCommentsVisible,
                  visibleGroupIds: visibleGroupIds,
                };

                if (postData.type === "shuoshuo") {
                  postData.content = document
                    .getElementById("post-public-text")
                    .value.trim();
                } else {
                  postData.publicText = document
                    .getElementById("post-public-text")
                    .value.trim();
                  if (postData.type === "image_post") {
                    postData.imageUrl =
                      document.getElementById("post-image-preview").src;
                    postData.imageDescription = document
                      .getElementById("post-image-description")
                      .value.trim();
                  } else if (postData.type === "text_image") {
                    postData.hiddenContent = document
                      .getElementById("post-hidden-text")
                      .value.trim();
                  }
                }
                await db.qzonePosts.put(postData);
              } else {
                const basePostData = {
                  timestamp: Date.now(),
                  authorId: "user",
                  areCommentsVisible: areCommentsVisible,
                  visibleGroupIds: visibleGroupIds,
                };

                if (mode === "shuoshuo") {
                  const content = document
                    .getElementById("post-public-text")
                    .value.trim();
                  if (!content) return alert("ËØ¥ËØ¥ÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫Âì¶ÔºÅ");
                  postData = {
                    ...basePostData,
                    type: "shuoshuo",
                    content: content,
                  };
                } else {
                  const publicText = document
                    .getElementById("post-public-text")
                    .value.trim();
                  const isImageModeActive = document
                    .getElementById("image-mode-content")
                    .classList.contains("active");
                  if (isImageModeActive) {
                    const imageUrl =
                      document.getElementById("post-image-preview").src;
                    const imageDescription = document
                      .getElementById("post-image-description")
                      .value.trim();
                    if (
                      !imageUrl ||
                      !(
                        imageUrl.startsWith("http") ||
                        imageUrl.startsWith("data:")
                      )
                    )
                      return alert("ËØ∑ÂÖàÊ∑ªÂä†‰∏ÄÂº†ÂõæÁâáÂÜçÂèëÂ∏ÉÂä®ÊÄÅÂì¶ÔºÅ");
                    if (!imageDescription)
                      return alert(
                        "ËØ∑‰∏∫‰Ω†ÁöÑÂõæÁâáÊ∑ªÂä†‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊèèËø∞ÔºàÂøÖÂ°´ÔºåÁªôAIÁúãÁöÑÔºâÔºÅ",
                      );
                    postData = {
                      ...basePostData,
                      type: "image_post",
                      publicText,
                      imageUrl,
                      imageDescription,
                    };
                  } else {
                    const hiddenText = document
                      .getElementById("post-hidden-text")
                      .value.trim();
                    if (!hiddenText) return alert("ËØ∑ËæìÂÖ•ÊñáÂ≠óÂõæÊèèËø∞ÔºÅ");
                    postData = {
                      ...basePostData,
                      type: "text_image",
                      publicText,
                      hiddenContent: hiddenText,
                    };
                  }
                }
                const newPostId = await db.qzonePosts.add(postData);
                postData.id = newPostId;
              }

              let postSummary =
                postData.content ||
                postData.publicText ||
                postData.imageDescription ||
                postData.hiddenContent ||
                "ÔºàÊó†ÊñáÂ≠óÂÜÖÂÆπÔºâ";
              postSummary =
                postSummary.substring(0, 50) +
                (postSummary.length > 50 ? "..." : "");
              for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (chat.isGroup) continue;
                const historyMessage = {
                  role: "system",
                  content: `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑${editingId ? "ÁºñËæë‰∫Ü" : "ÂèëÂ∏É‰∫Ü"}‰∏ÄÊù°Âä®ÊÄÅ(ID: ${
                    editingId || postData.id
                  })ÔºåÂÜÖÂÆπÊëòË¶ÅÊòØÔºö‚Äú${postSummary}‚Äù„ÄÇ]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(historyMessage);
                await db.chats.put(chat);
              }

              await renderQzonePosts();
              modal.classList.remove("visible");
              delete modal.dataset.editingPostId;
              delete modal.dataset.mode;
              alert(`Âä®ÊÄÅ${editingId ? "ÁºñËæë" : "ÂèëÂ∏É"}ÊàêÂäüÔºÅ`);
            });

          // ‰∏∫ÂÖ®Â±ÄËÅäÂ§©ËÉåÊôØÁöÑ‰∏ä‰º†ÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("global-bg-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.readAsDataURL(file);
                });
                newGlobalBgBase64 = dataUrl; // Â∞ÜÊñ∞ËÉåÊôØÂ≠òÂÖ•‰∏¥Êó∂ÂèòÈáè
                // ÂÆûÊó∂Êõ¥Êñ∞È¢ÑËßà
                const preview = document.getElementById("global-bg-preview");
                preview.style.backgroundImage = `url(${dataUrl})`;
                preview.textContent = "";
              }
            });

          // ‰∏∫ÂÖ®Â±ÄËÅäÂ§©ËÉåÊôØÁöÑÁßªÈô§ÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("remove-global-bg-btn")
            .addEventListener("click", () => {
              newGlobalBgBase64 = "REMOVED"; // Áî®‰∏Ä‰∏™ÁâπÊÆäÊ†áËÆ∞Ë°®Á§∫‚ÄúÁßªÈô§‚Äù
              const preview = document.getElementById("global-bg-preview");
              preview.style.backgroundImage = "none";
              preview.textContent = "Â∑≤ÁßªÈô§";
              alert("ÂÖ®Â±ÄËÉåÊôØÂ∞ÜÂú®ÁÇπÂáª‚Äú‰øùÂ≠ò‚ÄùÂêéË¢´ÁßªÈô§„ÄÇ");
            });

          // ‰∏∫‚Äú‰∏ÄÈîÆÊ∏ÖÁ©∫Âçï‰∫∫ËÉåÊôØ‚ÄùÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("clear-all-single-bgs-btn")
            .addEventListener("click", clearAllSingleChatBackgrounds);

          const postsList = document.getElementById("qzone-posts-list");
          let swipeState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            activeContainer: null,
            swipeDirection: null,
            isClick: true,
          };

          function resetAllSwipes(exceptThisOne = null) {
            document
              .querySelectorAll(".qzone-post-container")
              .forEach((container) => {
                if (container !== exceptThisOne) {
                  container
                    .querySelector(".qzone-post-item")
                    .classList.remove("swiped");
                }
              });
          }

          const handleSwipeStart = (e) => {
            const targetContainer = e.target.closest(".qzone-post-container");
            if (!targetContainer) return;

            resetAllSwipes(targetContainer);
            swipeState.activeContainer = targetContainer;
            swipeState.isDragging = true;
            swipeState.isClick = true;
            swipeState.swipeDirection = null;
            swipeState.startX = e.type.includes("mouse")
              ? e.pageX
              : e.touches[0].pageX;
            swipeState.startY = e.type.includes("mouse")
              ? e.pageY
              : e.touches[0].pageY;
            swipeState.activeContainer.querySelector(
              ".qzone-post-item",
            ).style.transition = "none";
          };

          const handleSwipeMove = (e) => {
            if (!swipeState.isDragging || !swipeState.activeContainer) return;

            const currentX = e.type.includes("mouse")
              ? e.pageX
              : e.touches[0].pageX;
            const currentY = e.type.includes("mouse")
              ? e.pageY
              : e.touches[0].pageY;
            const diffX = currentX - swipeState.startX;
            const diffY = currentY - swipeState.startY;
            const absDiffX = Math.abs(diffX);
            const absDiffY = Math.abs(diffY);
            const clickThreshold = 5;

            if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
              swipeState.isClick = false;
            }

            if (swipeState.swipeDirection === null) {
              if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
                if (absDiffX > absDiffY) {
                  swipeState.swipeDirection = "horizontal";
                } else {
                  swipeState.swipeDirection = "vertical";
                }
              }
            }
            if (swipeState.swipeDirection === "vertical") {
              handleSwipeEnd(e);
              return;
            }
            if (swipeState.swipeDirection === "horizontal") {
              e.preventDefault();
              swipeState.currentX = currentX;
              let translation = diffX;
              if (translation > 0) translation = 0;
              if (translation < -90) translation = -90;
              swipeState.activeContainer.querySelector(
                ".qzone-post-item",
              ).style.transform = `translateX(${translation}px)`;
            }
          };

          const handleSwipeEnd = (e) => {
            if (swipeState.isClick) {
              swipeState.isDragging = false;
              swipeState.activeContainer = null;
              return;
            }
            if (!swipeState.isDragging || !swipeState.activeContainer) return;

            const postItem =
              swipeState.activeContainer.querySelector(".qzone-post-item");
            postItem.style.transition = "transform 0.3s ease";

            const finalX = e.type.includes("touchend")
              ? e.changedTouches[0].pageX
              : e.pageX;
            const diffX = finalX - swipeState.startX;
            const swipeThreshold = -40;

            if (
              swipeState.swipeDirection === "horizontal" &&
              diffX < swipeThreshold
            ) {
              postItem.classList.add("swiped");
              postItem.style.transform = "";
            } else {
              postItem.classList.remove("swiped");
              postItem.style.transform = "";
            }

            swipeState.isDragging = false;
            swipeState.startX = 0;
            swipeState.startY = 0;
            swipeState.currentX = 0;
            swipeState.activeContainer = null;
            swipeState.swipeDirection = null;
            swipeState.isClick = true;
          };

          // --- ÁªëÂÆöÊâÄÊúâÊªëÂä®‰∫ã‰ª∂ ---
          postsList.addEventListener("mousedown", handleSwipeStart);
          document.addEventListener("mousemove", handleSwipeMove);
          document.addEventListener("mouseup", handleSwipeEnd);
          postsList.addEventListener("touchstart", handleSwipeStart, {
            passive: false,
          });
          postsList.addEventListener("touchmove", handleSwipeMove, {
            passive: false,
          });
          postsList.addEventListener("touchend", handleSwipeEnd);

          postsList.addEventListener("click", async (e) => {
            e.stopPropagation();
            const target = e.target;

            const summonBtn = target.closest(".action-icon.summon-npc");
            if (summonBtn) {
              const postId = parseInt(summonBtn.dataset.postId);
              const authorId = summonBtn.dataset.authorId;
              if (!isNaN(postId) && authorId) {
                handleNpcSummonClick(postId, authorId);
              }
              return; // Â§ÑÁêÜÂÆåÂè¨Âî§ÈÄªËæëÂêéÔºåÁõ¥Êé•ÁªìÊùüÔºå‰∏çÊâßË°åÂêéÁª≠ÁöÑÁÇπËµûÁ≠âÂà§Êñ≠
            }

            // Â§ÑÁêÜÁÇπÂáªËØÑËÆ∫Êú¨Ë∫´ÔºàÁî®‰∫éÂõûÂ§çÔºâ
            const commentItem = target.closest(".comment-item");
            // Á°Æ‰øùÁÇπÂáªÁöÑ‰∏çÊòØÂà†Èô§ÊåâÈíÆÊàñËØÑËÆ∫ÈáåÁöÑÂêçÂ≠óÈìæÊé•
            if (
              commentItem &&
              !target.classList.contains("comment-delete-btn") &&
              !target.classList.contains("commenter-name") &&
              !target.classList.contains("reply-target-name")
            ) {
              const postContainer = commentItem.closest(
                ".qzone-post-container",
              );
              if (postContainer) {
                const commenterName = commentItem.dataset.commenterName;
                const myNickname = state.qzoneSettings.nickname;

                // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØËá™Â∑±ÁöÑËØÑËÆ∫ÔºåÂàô‰∏çËøõÂÖ•ÂõûÂ§çÊ®°Âºè
                if (commenterName !== myNickname) {
                  const commentInput =
                    postContainer.querySelector(".comment-input");
                  commentInput.placeholder = `Reply ${commenterName}:`;
                  commentInput.dataset.replyTo = commenterName; // ÊääË¶ÅÂõûÂ§çÁöÑ‰∫∫ÁöÑÂêçÂ≠óÔºå‰∏¥Êó∂Â≠òËµ∑Êù•
                  commentInput.focus(); // Ëá™Âä®ËÅöÁÑ¶Âà∞ËæìÂÖ•Ê°Ü
                }
              }
              return; // Â§ÑÁêÜÂÆåÁÇπÂáªËØÑËÆ∫ÂêéÔºåÂ∞±‰∏çÁî®ÂæÄ‰∏ãÊâßË°å‰∫Ü
            }

            if (target.classList.contains("comment-delete-btn")) {
              const postContainer = target.closest(".qzone-post-container");
              if (!postContainer) return;
              const postId = parseInt(postContainer.dataset.postId);
              const commentIndex = parseInt(target.dataset.commentIndex);
              if (isNaN(postId) || isNaN(commentIndex)) return;
              const post = await db.qzonePosts.get(postId);
              if (!post || !post.comments || !post.comments[commentIndex])
                return;
              const commentText = post.comments[commentIndex].text;
              const confirmed = await showCustomConfirm(
                "Âà†Èô§ËØÑËÆ∫",
                `Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËØÑËÆ∫ÂêóÔºü\n\n‚Äú${commentText.substring(0, 50)}...‚Äù`,
                { confirmButtonClass: "btn-danger" },
              );
              if (confirmed) {
                post.comments.splice(commentIndex, 1);
                await db.qzonePosts.update(postId, { comments: post.comments });
                await renderQzonePosts();
                alert("ËØÑËÆ∫Â∑≤Âà†Èô§„ÄÇ");
              }
              return;
            }

            if (target.classList.contains("post-actions-btn")) {
              const container = target.closest(".qzone-post-container");
              if (container && container.dataset.postId)
                showPostActions(parseInt(container.dataset.postId));
              return;
            }

            if (target.closest(".qzone-post-delete-action")) {
              const container = target.closest(
                ".qzone-post-delete-action",
              ).parentElement;
              if (!container) return;
              const postIdToDelete = parseInt(container.dataset.postId);
              if (isNaN(postIdToDelete)) return;
              const confirmed = await showCustomConfirm(
                "Âà†Èô§Âä®ÊÄÅ",
                "Á°ÆÂÆöË¶ÅÊ∞∏‰πÖÂà†Èô§ËøôÊù°Âä®ÊÄÅÂêóÔºü",
                {
                  confirmButtonClass: "btn-danger",
                },
              );
              if (confirmed) {
                container.style.transition = "all 0.3s ease";
                container.style.transform = "scale(0.8)";
                container.style.opacity = "0";
                setTimeout(async () => {
                  await db.qzonePosts.delete(postIdToDelete);
                  const notificationIdentifier = `(ID: ${postIdToDelete})`;
                  for (const chatId in state.chats) {
                    const chat = state.chats[chatId];
                    const originalHistoryLength = chat.history.length;
                    chat.history = chat.history.filter(
                      (msg) =>
                        !(
                          msg.role === "system" &&
                          msg.content.includes(notificationIdentifier)
                        ),
                    );
                    if (chat.history.length < originalHistoryLength)
                      await db.chats.put(chat);
                  }
                  await renderQzonePosts();
                  alert("Âä®ÊÄÅÂ∑≤Âà†Èô§„ÄÇ");
                }, 300);
              }
              return;
            }

            if (target.tagName === "IMG" && target.dataset.hiddenText) {
              showCustomAlert(
                "ÂõæÁâáÂÜÖÂÆπ",
                target.dataset.hiddenText.replace(/<br>/g, "\n"),
              );
              return;
            }
            const icon = target.closest(".action-icon");
            if (icon) {
              const postContainer = icon.closest(".qzone-post-container");
              if (!postContainer) return;
              const postId = parseInt(postContainer.dataset.postId);
              if (isNaN(postId)) return;
              if (icon.classList.contains("like")) {
                const post = await db.qzonePosts.get(postId);
                if (!post) return;
                if (!post.likes) post.likes = [];
                const userNickname = state.qzoneSettings.nickname;
                const userLikeIndex = post.likes.indexOf(userNickname);
                if (userLikeIndex > -1) {
                  post.likes.splice(userLikeIndex, 1);
                } else {
                  post.likes.push(userNickname);
                  icon.classList.add("animate-like");
                  icon.addEventListener(
                    "animationend",
                    () => icon.classList.remove("animate-like"),
                    { once: true },
                  );
                }
                await db.qzonePosts.update(postId, { likes: post.likes });
              }
              if (icon.classList.contains("favorite")) {
                const existingFavorite = await db.favorites
                  .where({ type: "qzone_post", "content.id": postId })
                  .first();
                if (existingFavorite) {
                  await db.favorites.delete(existingFavorite.id);
                  await showCustomAlert("ÊèêÁ§∫", "Â∑≤ÂèñÊ∂àÊî∂Ëóè");
                } else {
                  const postToSave = await db.qzonePosts.get(postId);
                  if (postToSave) {
                    await db.favorites.add({
                      type: "qzone_post",
                      content: postToSave,
                      timestamp: Date.now(),
                    });
                    await showCustomAlert("ÊèêÁ§∫", "Êî∂ËóèÊàêÂäüÔºÅ");
                  }
                }
              }
              await renderQzonePosts();
              return;
            }

            // Â§ÑÁêÜËØÑËÆ∫ÂèëÈÄÅÈÄªËæë
            const sendBtn = target.closest(".comment-send-btn");
            if (sendBtn) {
              const postContainer = sendBtn.closest(".qzone-post-container");
              if (!postContainer) return;
              const postId = parseInt(postContainer.dataset.postId);
              const commentInput =
                postContainer.querySelector(".comment-input");
              const commentText = commentInput.value.trim();
              if (!commentText) return alert("ËØÑËÆ∫ÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫Âì¶ÔºÅ");
              const post = await db.qzonePosts.get(postId);
              if (!post) return;
              if (!post.comments) post.comments = [];

              // ÂàõÂª∫Êñ∞ÁöÑËØÑËÆ∫ÂØπË±°
              const newComment = {
                commenterName: state.qzoneSettings.nickname,
                text: commentText,
                timestamp: Date.now(),
              };

              // Ê£ÄÊü•ÊòØ‰∏çÊòØÂú®ÂõûÂ§çÊ®°Âºè
              if (commentInput.dataset.replyTo) {
                newComment.replyTo = commentInput.dataset.replyTo; // Â¶ÇÊûúÊòØÔºåÂ∞±ÊääÂõûÂ§çÂØπË±°ÁöÑÂêçÂ≠óÂä†‰∏ä
              }

              post.comments.push(newComment);
              await db.qzonePosts.update(postId, { comments: post.comments });
              for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (!chat.isGroup) {
                  let aiNotification = `[Á≥ªÁªüÊèêÁ§∫Ôºö'${state.qzoneSettings.nickname}' Âú®ID‰∏∫${postId}ÁöÑÂä®ÊÄÅ‰∏ãÂèëË°®‰∫ÜËØÑËÆ∫Ôºö‚Äú${commentText}‚Äù`;
                  if (newComment.replyTo) {
                    aiNotification += ` (ËøôÊòØÂØπ'${newComment.replyTo}'ÁöÑÂõûÂ§ç)`;
                  }
                  aiNotification += `]`;
                  chat.history.push({
                    role: "system",
                    content: aiNotification,
                    timestamp: Date.now(),
                    isHidden: true,
                  });
                  await db.chats.put(chat);
                }
              }

              // ÂèëÈÄÅÂêéÔºåÈáçÁΩÆËæìÂÖ•Ê°ÜÁä∂ÊÄÅ
              commentInput.value = "";
              commentInput.placeholder = "ÂèãÂñÑÁöÑËØÑËÆ∫ÊòØ‰∫§ÊµÅÁöÑËµ∑ÁÇπ";
              delete commentInput.dataset.replyTo; // Ê∏ÖÈô§ÂõûÂ§çÁä∂ÊÄÅ

              await renderQzonePosts();
              return;
            }
          });

          // ÁªëÂÆöÂä®ÊÄÅÈ°µÂíåÊî∂ËóèÈ°µÁöÑËøîÂõûÊåâÈíÆ
          document
            .getElementById("qzone-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view"),
            );
          document
            .getElementById("favorites-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view"),
            );

          // Êî∂ËóèÈ°µÊêúÁ¥¢ÂäüËÉΩ
          const searchInput = document.getElementById("favorites-search-input");
          const searchClearBtn = document.getElementById(
            "favorites-search-clear-btn",
          );

          searchInput.addEventListener("input", () => {
            const searchTerm = searchInput.value.trim().toLowerCase();

            // ÊéßÂà∂Ê∏ÖÈô§ÊåâÈíÆÁöÑÊòæÁ§∫/ÈöêËóè
            searchClearBtn.style.display = searchTerm ? "block" : "none";

            if (!searchTerm) {
              displayFilteredFavorites(allFavoriteItems); // Â¶ÇÊûúÊêúÁ¥¢Ê°Ü‰∏∫Á©∫ÔºåÊòæÁ§∫ÊâÄÊúâ
              return;
            }

            // Á≠õÈÄâÈÄªËæë
            const filteredItems = allFavoriteItems.filter((item) => {
              let contentToSearch = "";
              let authorToSearch = "";

              if (item.type === "qzone_post") {
                const post = item.content;
                contentToSearch +=
                  (post.publicText || "") + " " + (post.content || "");
                if (post.authorId === "user") {
                  authorToSearch = state.qzoneSettings.nickname;
                } else if (state.chats[post.authorId]) {
                  authorToSearch = state.chats[post.authorId].name;
                }
              } else if (item.type === "chat_message") {
                const msg = item.content;
                if (typeof msg.content === "string") {
                  contentToSearch = msg.content;
                }
                const chat = state.chats[item.chatId];
                if (chat) {
                  if (msg.role === "user") {
                    authorToSearch = chat.isGroup
                      ? chat.settings.myNickname || "Me"
                      : "Me";
                  } else {
                    authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                  }
                }
              }

              // ÂêåÊó∂ÊêúÁ¥¢ÂÜÖÂÆπÂíå‰ΩúËÄÖÔºåÂπ∂‰∏î‰∏çÂå∫ÂàÜÂ§ßÂ∞èÂÜô
              return (
                contentToSearch.toLowerCase().includes(searchTerm) ||
                authorToSearch.toLowerCase().includes(searchTerm)
              );
            });

            displayFilteredFavorites(filteredItems);
          });

          // Ê∏ÖÈô§ÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂
          searchClearBtn.addEventListener("click", () => {
            searchInput.value = "";
            searchClearBtn.style.display = "none";
            displayFilteredFavorites(allFavoriteItems);
            searchInput.focus();
          });

          // ‰∏∫ËÅäÂ§©ÁïåÈù¢ÁöÑÊâπÈáèÊî∂ËóèÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          // ‰∏∫ËÅäÂ§©ÁïåÈù¢ÁöÑÊâπÈáèÊî∂ËóèÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂ (Â∑≤‰øÆÊ≠£)
          document
            .getElementById("selection-favorite-btn")
            .addEventListener("click", async () => {
              if (selectedMessages.size === 0) return;
              const chat = state.chats[state.activeChatId];
              if (!chat) return;

              const favoritesToAdd = [];
              const timestampsToFavorite = [...selectedMessages];

              for (const timestamp of timestampsToFavorite) {
                // ‰ΩøÁî®Êñ∞ÁöÑ„ÄÅÈ´òÊïàÁöÑÁ¥¢ÂºïËøõË°åÊü•ËØ¢
                const existing = await db.favorites
                  .where("originalTimestamp")
                  .equals(timestamp)
                  .first();

                if (!existing) {
                  const messageToSave = chat.history.find(
                    (msg) => msg.timestamp === timestamp,
                  );
                  if (messageToSave) {
                    favoritesToAdd.push({
                      type: "chat_message",
                      content: messageToSave,
                      chatId: state.activeChatId,
                      timestamp: Date.now(), // ËøôÊòØÊî∂ËóèÊìç‰ΩúÂèëÁîüÁöÑÊó∂Èó¥
                      originalTimestamp: messageToSave.timestamp, // ‰øùÂ≠òÂéüÂßãÊ∂àÊÅØÁöÑÊó∂Èó¥Êà≥Âà∞Êñ∞Â≠óÊÆµ
                    });
                  }
                }
              }

              if (favoritesToAdd.length > 0) {
                await db.favorites.bulkAdd(favoritesToAdd);
                allFavoriteItems = await db.favorites
                  .orderBy("timestamp")
                  .reverse()
                  .toArray(); // Êõ¥Êñ∞ÂÖ®Â±ÄÊî∂ËóèÁºìÂ≠ò
                await showCustomAlert(
                  "Êî∂ËóèÊàêÂäü",
                  `Â∑≤ÊàêÂäüÊî∂Ëóè ${favoritesToAdd.length} Êù°Ê∂àÊÅØ„ÄÇ`,
                );
              } else {
                await showCustomAlert("ÊèêÁ§∫", "ÈÄâ‰∏≠ÁöÑÊ∂àÊÅØÂùáÂ∑≤Êî∂ËóèËøá„ÄÇ");
              }

              exitSelectionMode();
            });

          // Êî∂ËóèÈ°µÈù¢ÁöÑ"ÁºñËæë"ÊåâÈíÆ‰∫ã‰ª∂ (Â∑≤‰øÆÊ≠£)
          const favoritesEditBtn =
            document.getElementById("favorites-edit-btn");
          const favoritesView = document.getElementById("favorites-view");
          const favoritesActionBar = document.getElementById(
            "favorites-action-bar",
          );
          const mainBottomNav = document.getElementById("chat-list-bottom-nav"); // Ëé∑Âèñ‰∏ªÂØºËà™Ê†è
          const favoritesList = document.getElementById("favorites-list"); // Ëé∑ÂèñÊî∂ËóèÂàóË°®

          favoritesEditBtn.addEventListener("click", () => {
            isFavoritesSelectionMode = !isFavoritesSelectionMode;
            favoritesView.classList.toggle(
              "selection-mode",
              isFavoritesSelectionMode,
            );

            if (isFavoritesSelectionMode) {
              // --- ËøõÂÖ•ÁºñËæëÊ®°Âºè ---
              favoritesEditBtn.textContent = "ÂÆåÊàê";
              favoritesActionBar.style.display = "block"; // ÊòæÁ§∫Âà†Èô§Êìç‰ΩúÊ†è
              mainBottomNav.style.display = "none"; // ‚ñº Êñ∞Â¢ûÔºöÈöêËóè‰∏ªÂØºËà™Ê†è
              favoritesList.style.paddingBottom = "80px"; // ‚ñº Êñ∞Â¢ûÔºöÁªôÂàóË°®Â∫ïÈÉ®Â¢ûÂä†Á©∫Èó¥
            } else {
              // --- ÈÄÄÂá∫ÁºñËæëÊ®°Âºè ---
              favoritesEditBtn.textContent = "ÁºñËæë";
              favoritesActionBar.style.display = "none"; // ÈöêËóèÂà†Èô§Êìç‰ΩúÊ†è
              mainBottomNav.style.display = "flex"; // ‚ñº Êñ∞Â¢ûÔºöÊÅ¢Â§ç‰∏ªÂØºËà™Ê†è
              favoritesList.style.paddingBottom = ""; // ‚ñº Êñ∞Â¢ûÔºöÊÅ¢Â§çÂàóË°®ÈªòËÆ§padding

              // ÈÄÄÂá∫Êó∂Ê∏ÖÁ©∫ÊâÄÊúâÈÄâÊã©
              selectedFavorites.clear();
              document
                .querySelectorAll(".favorite-item-card.selected")
                .forEach((card) => card.classList.remove("selected"));
              document.getElementById(
                "favorites-delete-selected-btn",
              ).textContent = `Delete (0)`;
            }
          });

          // Êî∂ËóèÂàóË°®ÁöÑÁÇπÂáªÈÄâÊã©‰∫ã‰ª∂ (‰∫ã‰ª∂ÂßîÊâò)
          document
            .getElementById("favorites-list")
            .addEventListener("click", (e) => {
              const target = e.target;
              const card = target.closest(".favorite-item-card");

              // Â§ÑÁêÜÊñáÂ≠óÂõæÁÇπÂáªÔºåËøôÊÆµÈÄªËæëË¶ÅÊîæÂú®ÊúÄÂâçÈù¢Ôºå‰øùËØÅ‰ªª‰ΩïÊ®°Âºè‰∏ãÈÉΩÁîüÊïà
              if (target.tagName === "IMG" && target.dataset.hiddenText) {
                const hiddenText = target.dataset.hiddenText;
                showCustomAlert("ÂõæÁâáÂÜÖÂÆπ", hiddenText.replace(/<br>/g, "\n"));
                return; // Â§ÑÁêÜÂÆåÂ∞±ÈÄÄÂá∫Ôºå‰∏çÁªßÁª≠ÊâßË°åÈÄâÊã©ÈÄªËæë
              }

              // Â¶ÇÊûú‰∏çÂú®ÈÄâÊã©Ê®°ÂºèÔºåÂàô‰∏çÊâßË°åÂêéÁª≠ÁöÑÈÄâÊã©Êìç‰Ωú
              if (!isFavoritesSelectionMode) return;

              // --- ‰ª•‰∏ãÊòØÂéüÊúâÁöÑÈÄâÊã©ÈÄªËæëÔºå‰øùÊåÅ‰∏çÂèò ---
              if (!card) return;

              const favId = parseInt(card.dataset.favid);
              if (isNaN(favId)) return;

              // ÂàáÊç¢ÈÄâÊã©Áä∂ÊÄÅ
              if (selectedFavorites.has(favId)) {
                selectedFavorites.delete(favId);
                card.classList.remove("selected");
              } else {
                selectedFavorites.add(favId);
                card.classList.add("selected");
              }

              // Êõ¥Êñ∞Â∫ïÈÉ®Âà†Èô§ÊåâÈíÆÁöÑËÆ°Êï∞
              document.getElementById(
                "favorites-delete-selected-btn",
              ).textContent = `Delete (${selectedFavorites.size})`;
            });

          // Êî∂ËóèÈ°µÈù¢ÊâπÈáèÂà†Èô§ÊåâÈíÆ‰∫ã‰ª∂
          document
            .getElementById("favorites-delete-selected-btn")
            .addEventListener("click", async () => {
              if (selectedFavorites.size === 0) return;

              const confirmed = await showCustomConfirm(
                "Á°ÆËÆ§Âà†Èô§",
                `Á°ÆÂÆöË¶Å‰ªéÊî∂ËóèÂ§π‰∏≠ÁßªÈô§Ëøô ${selectedFavorites.size} Êù°ÂÜÖÂÆπÂêóÔºü`,
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                const idsToDelete = [...selectedFavorites];
                await db.favorites.bulkDelete(idsToDelete);
                await showCustomAlert("Âà†Èô§ÊàêÂäü", "ÈÄâ‰∏≠ÁöÑÊî∂ËóèÂ∑≤Ë¢´ÁßªÈô§„ÄÇ");

                // ‰ªéÂâçÁ´ØÁºìÂ≠ò‰∏≠‰πüÁßªÈô§Ë¢´Âà†Èô§ÁöÑÈ°π
                allFavoriteItems = allFavoriteItems.filter(
                  (item) => !idsToDelete.includes(item.id),
                );

                // ‰ΩøÁî®Êõ¥Êñ∞ÂêéÁöÑÁºìÂ≠òÔºåÁ´ãÂç≥ÈáçÊñ∞Ê∏≤ÊüìÂàóË°®
                displayFilteredFavorites(allFavoriteItems);

                // ÊúÄÂêéÔºåÂÜçÈÄÄÂá∫ÁºñËæëÊ®°Âºè
                favoritesEditBtn.click(); // Ê®°ÊãüÁÇπÂáª"ÂÆåÊàê"ÊåâÈíÆÊù•ÈÄÄÂá∫ÁºñËæëÊ®°Âºè
              }
            });

          if (state.globalSettings.enableBackgroundActivity) {
            startBackgroundSimulation();
            console.log("ÂêéÂè∞Ê¥ªÂä®Ê®°ÊãüÂ∑≤Ëá™Âä®ÂêØÂä®„ÄÇ");
          }

          // 1. ÁõëÂê¨‰∏ªÈ¢òÈÄâÊã©
          document
            .querySelectorAll('input[name="theme-select"]')
            .forEach((radio) => {
              radio.addEventListener("change", updateSettingsPreview);
            });

          // 2. ÁõëÂê¨Â≠ó‰ΩìÂ§ßÂ∞èÊªëÂùó
          const fontSizeSlider = document.getElementById("font-size-slider");
          fontSizeSlider.addEventListener("input", () => {
            // a. ÂÆûÊó∂Êõ¥Êñ∞Êï∞ÂÄºÊòæÁ§∫
            document.getElementById("font-size-value").textContent =
              `${fontSizeSlider.value}px`;
            // b. Êõ¥Êñ∞È¢ÑËßà
            updateSettingsPreview();
          });

          // 3. ÁõëÂê¨Ëá™ÂÆö‰πâCSSËæìÂÖ•Ê°Ü
          const customCssInputForPreview =
            document.getElementById("custom-css-input");
          customCssInputForPreview.addEventListener(
            "input",
            updateSettingsPreview,
          );

          // 4. ÁõëÂê¨ÈáçÁΩÆÊåâÈíÆ
          document
            .getElementById("reset-theme-btn")
            .addEventListener("click", () => {
              document.getElementById("theme-default").checked = true;
              updateSettingsPreview();
            });

          document
            .getElementById("reset-custom-css-btn")
            .addEventListener("click", () => {
              document.getElementById("custom-css-input").value = "";
              updateSettingsPreview();
            });

          document
            .querySelectorAll('input[name="visibility"]')
            .forEach((radio) => {
              radio.addEventListener("change", function () {
                const groupsContainer = document.getElementById(
                  "post-visibility-groups",
                );
                if (this.value === "include" || this.value === "exclude") {
                  groupsContainer.style.display = "block";
                } else {
                  groupsContainer.style.display = "none";
                }
              });
            });

          document
            .getElementById("manage-groups-btn")
            .addEventListener("click", openGroupManager);
          document
            .getElementById("close-group-manager-btn")
            .addEventListener("click", () => {
              document
                .getElementById("group-management-modal")
                .classList.remove("visible");
              // Âà∑Êñ∞ËÅäÂ§©ËÆæÁΩÆÈáåÁöÑÂàÜÁªÑÂàóË°®
              const chatSettingsBtn =
                document.getElementById("chat-settings-btn");
              if (
                document
                  .getElementById("chat-settings-modal")
                  .classList.contains("visible")
              ) {
                chatSettingsBtn.click(); // ÂÜçÊ¨°ÁÇπÂáª‰ª•ÈáçÊñ∞ÊâìÂºÄ
              }
            });

          document
            .getElementById("add-new-group-btn")
            .addEventListener("click", addNewGroup);
          document
            .getElementById("existing-groups-list")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("delete-group-btn")) {
                const groupId = parseInt(e.target.dataset.id);
                deleteGroup(groupId);
              }
            });

          // Ê∂àÊÅØÊìç‰ΩúËèúÂçïÁöÑÊåâÈíÆ‰∫ã‰ª∂
          document
            .getElementById("cancel-message-action-btn")
            .addEventListener("click", hideMessageActions);
          // ‰ΩøÁî®Êñ∞ÁöÑÁºñËæëÂô®ÂÖ•Âè£
          document
            .getElementById("edit-message-btn")
            .addEventListener("click", openAdvancedMessageEditor);
          document
            .getElementById("reroll-nai-btn")
            .addEventListener("click", handleNaiReroll);

          document
            .getElementById("copy-message-btn")
            .addEventListener("click", copyMessageContent);

          document
            .getElementById("recall-message-btn")
            .addEventListener("click", handleRecallClick);

          document
            .getElementById("select-message-btn")
            .addEventListener("click", () => {
              // Âú®ÂÖ≥Èó≠ËèúÂçïÂâçÔºåÂÖàÊçïËé∑Êó∂Èó¥Êà≥
              const timestampToSelect = activeMessageTimestamp;
              hideMessageActions();
              // ‰ΩøÁî®ÊçïËé∑Âà∞ÁöÑÂÄº
              if (timestampToSelect) {
                enterSelectionMode(timestampToSelect);
              }
            });

          // Âä®ÊÄÅÊìç‰ΩúËèúÂçïÁöÑÊåâÈíÆ‰∫ã‰ª∂
          document
            .getElementById("edit-post-btn")
            .addEventListener("click", openPostEditor);
          document
            .getElementById("copy-post-btn")
            .addEventListener("click", copyPostContent);
          document
            .getElementById("cancel-post-action-btn")
            .addEventListener("click", hidePostActions);

          // ËÅîÁ≥ª‰∫∫ÈÄâÊã©Âô®‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("cancel-contact-picker-btn")
            .addEventListener("click", () => {
              showScreen("chat-list-screen");
            });

          document
            .getElementById("contact-picker-list")
            .addEventListener("click", (e) => {
              const item = e.target.closest(".contact-picker-item");
              if (!item) return;

              const contactId = item.dataset.contactId;
              item.classList.toggle("selected");

              if (selectedContacts.has(contactId)) {
                selectedContacts.delete(contactId);
              } else {
                selectedContacts.add(contactId);
              }
              updateContactPickerConfirmButton();
            });

          // ÁªëÂÆö‚ÄúÁÆ°ÁêÜÁæ§ÊàêÂëò‚ÄùÊåâÈíÆ‰∫ã‰ª∂
          document
            .getElementById("manage-members-btn")
            .addEventListener("click", () => {
              // Âú®ÂàáÊç¢Â±èÂπïÂâçÔºåÂÖàÈöêËóèÂΩìÂâçÁöÑËÅäÂ§©ËÆæÁΩÆÂºπÁ™ó
              document
                .getElementById("chat-settings-modal")
                .classList.remove("visible");
              // ÁÑ∂ÂêéÂÜçÊâìÂºÄÊàêÂëòÁÆ°ÁêÜÂ±èÂπï
              openMemberManagementScreen();
            });

          // Áæ§ÊàêÂëòÁÆ°ÁêÜÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("back-from-member-management")
            .addEventListener("click", () => {
              showScreen("chat-interface-screen");
              document.getElementById("chat-settings-btn").click();
            });

          document
            .getElementById("add-existing-contact-btn")
            .addEventListener("click", async () => {
              // ‰ªéÂ•ΩÂèãÂàóË°®Ê∑ªÂä†ÁöÑ‰∫ã‰ª∂
              // ‰∏∫‚ÄúÂÆåÊàê‚ÄùÊåâÈíÆÁªëÂÆö‚ÄúÊãâ‰∫∫ÂÖ•Áæ§‚ÄùÁöÑÈÄªËæë
              const confirmBtn = document.getElementById(
                "confirm-contact-picker-btn",
              );
              // ‰ΩøÁî®ÂÖãÈöÜËäÇÁÇπÊñπÊ≥ïÊ∏ÖÈô§ÊóßÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®ÔºåÈò≤Ê≠¢ÈáçÂ§çÁªëÂÆö
              const newConfirmBtn = confirmBtn.cloneNode(true);
              confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
              newConfirmBtn.addEventListener("click", handleAddMembersToGroup);

              await openContactPickerForAddMember();
            });

          document
            .getElementById("create-new-member-btn")
            .addEventListener("click", createNewMemberInGroup);

          // ËßÜÈ¢ëÈÄöËØùÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨Âô®

          // ÁªëÂÆöÂçïËÅäÂíåÁæ§ËÅäÁöÑÂèëËµ∑ÊåâÈíÆ
          document
            .getElementById("video-call-btn")
            .addEventListener("click", handleInitiateCall);
          document
            .getElementById("group-video-call-btn")
            .addEventListener("click", handleInitiateCall);

          // ÁªëÂÆö‚ÄúÊåÇÊñ≠‚ÄùÊåâÈíÆ
          document
            .getElementById("hang-up-btn")
            .addEventListener("click", endVideoCall);

          // ÁªëÂÆö‚ÄúÂèñÊ∂àÂëºÂè´‚ÄùÊåâÈíÆ
          document
            .getElementById("cancel-call-btn")
            .addEventListener("click", () => {
              videoCallState.isAwaitingResponse = false;
              showScreen("chat-interface-screen");
            });

          // ÁªëÂÆö‚ÄúÂä†ÂÖ•ÈÄöËØù‚ÄùÊåâÈíÆ
          document
            .getElementById("join-call-btn")
            .addEventListener("click", handleUserJoinCall);

          // ÁªëÂÆöÊù•ÁîµËØ∑Ê±ÇÁöÑ‚ÄúÊãíÁªù‚ÄùÊåâÈíÆ
          document
            .getElementById("decline-call-btn")
            .addEventListener("click", async () => {
              stopRingtone();
              hideIncomingCallModal();
              const callerChatId = videoCallState.activeChatId; // ‰ªé‰∏ìÁî®‰ø°ÈÅìËé∑ÂèñÊù•ÁîµËÄÖID
              if (!callerChatId) return;

              const chat = state.chats[callerChatId];
              if (!chat) return;

              // Ê†πÊçÆÊòØÂê¶Áæ§ËÅäÔºåÊâßË°å‰∏çÂêåÁöÑÊãíÁªùÈÄªËæë
              if (videoCallState.isGroupCall) {
                // ÂØπ‰∫éÁæ§ËÅäÔºåÊãíÁªù=ÊóÅËßÇÔºåËøô‰∏™ÈÄªËæë‰∏çÂèò
                videoCallState.isUserParticipating = false;
                const systemNote = {
                  role: "system",
                  content: `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑ÊãíÁªù‰∫ÜÈÄöËØùÈÇÄËØ∑Ôºå‰ΩÜ‰Ω†‰ª¨ÂèØ‰ª•Ëá™Â∑±ÂºÄÂßã„ÄÇËØ∑‰Ω†‰ª¨ÂêÑËá™ÂÜ≥Á≠ñÊòØÂê¶Âä†ÂÖ•„ÄÇ]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(systemNote);
                await db.chats.put(chat);
                await triggerAiResponse();
              } else {
                // ÂØπ‰∫éÂçïËÅäÔºåÊàë‰ª¨‰∏çÂÜçÊâìÊâ∞Áî®Êà∑ÂΩìÂâçÁïåÈù¢ÔºåËÄåÊòØÈùôÈªòÂ§ÑÁêÜ
                const declineMessage = {
                  role: "user",
                  content: "ÊàëÊãíÁªù‰∫Ü‰Ω†ÁöÑËßÜÈ¢ëÈÄöËØùËØ∑Ê±Ç„ÄÇ",
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(declineMessage);
                await db.chats.put(chat);

                // Âè™ÈÄöÁü•Ôºå‰∏çÂàáÊç¢Â±èÂπï
                showNotification(callerChatId, "‰Ω†Â∑≤ÊãíÁªùÈÄöËØùÈÇÄËØ∑„ÄÇ");
                // Âú®ÂêéÂè∞‰∏∫ÂØπÊñπËß¶Âèë‰∏Ä‰∏™ÂìçÂ∫îÔºåËÆ©ÂÆÉÁü•ÈÅìËá™Â∑±Ë¢´ÊãíÁªù‰∫Ü
                // Êàë‰ª¨ÈúÄË¶Å‰∏¥Êó∂ÂàáÊç¢activeChatIdÊù•Ëß¶ÂèëÔºåÁÑ∂ÂêéÂÜçÊç¢ÂõûÊù•
                const originalActiveChatId = state.activeChatId;
                state.activeChatId = callerChatId;
                await triggerAiResponse();
                state.activeChatId = originalActiveChatId;
              }

              // Ê∏ÖÁêÜÁä∂ÊÄÅ
              videoCallState.isAwaitingResponse = false;
              videoCallState.activeChatId = null;
            });

          // ÁªëÂÆöÊù•ÁîµËØ∑Ê±ÇÁöÑ‚ÄúÊé•Âê¨‚ÄùÊåâÈíÆ
          document
            .getElementById("accept-call-btn")
            .addEventListener("click", async () => {
              stopRingtone();
              hideIncomingCallModal();
              const callerChatId = videoCallState.activeChatId;
              if (!callerChatId) return;

              // Âú®Êé•Âê¨Êó∂ÁúüÊ≠£ÊîπÂèòÂÖ®Â±ÄÁä∂ÊÄÅÔºåÂπ∂ÊâìÂºÄÈÄöËØùÁïåÈù¢
              state.activeChatId = callerChatId; // <-- Âú®ËøôÈáåÔºåÊàë‰ª¨ÊâçÊéàÊùÉ‰øÆÊîπÂÖ®Â±ÄÁä∂ÊÄÅÔºÅ

              videoCallState.initiator = "ai";
              videoCallState.isUserParticipating = true;

              if (videoCallState.isGroupCall) {
                const chat = state.chats[videoCallState.activeChatId];
                const requester = chat.members.find(
                  (m) => m.name === videoCallState.callRequester,
                );
                if (requester) {
                  videoCallState.participants = [requester];
                } else {
                  videoCallState.participants = [];
                }
              }

              startVideoCall(); // ÂêØÂä®ÈÄöËØùÁïåÈù¢
            });

          // ÁªëÂÆöÁî®Êà∑Âú®ÈÄöËØù‰∏≠ÂèëË®ÄÁöÑÊåâÈíÆ
          document
            .getElementById("user-speak-btn")
            .addEventListener("click", async () => {
              if (!videoCallState.isActive) return;

              // Âú®ÂºπÂá∫ËæìÂÖ•Ê°ÜÂâçÔºåÂÖàÊâæÂà∞Âπ∂È´ò‰∫ÆÁî®Êà∑Â§¥ÂÉè
              const userAvatar = document.querySelector(
                '.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar',
              );
              if (userAvatar) {
                userAvatar.classList.add("speaking");
              }

              const userInput = await showCustomPrompt(
                "‰Ω†ËØ¥",
                "ËØ∑ËæìÂÖ•‰Ω†ÊÉ≥ËØ¥ÁöÑËØù...",
              );

              // Êó†ËÆ∫Áî®Êà∑ÊòØÂê¶ËæìÂÖ•ÔºåÂè™Ë¶ÅÂÖ≥Èó≠ËæìÂÖ•Ê°ÜÂ∞±ÁßªÈô§È´ò‰∫Æ
              if (userAvatar) {
                userAvatar.classList.remove("speaking");
              }

              if (userInput && userInput.trim()) {
                triggerAiInCallAction(userInput.trim());
              }
            });

          // ÂõûÂøÜÂΩïÁõ∏ÂÖ≥‰∫ã‰ª∂ÁªëÂÆö
          // 1. Â∞Ü‚ÄúÂõûÂøÜ‚ÄùÈ°µÁ≠æÂíåÂÆÉÁöÑËßÜÂõæËøûÊé•Ëµ∑Êù•
          document
            .querySelector('.nav-item[data-view="memories-view"]')
            .addEventListener("click", () => {
              // Âú®ÂàáÊç¢ÂâçÔºåÁ°Æ‰øù"Êî∂Ëóè"È°µÈù¢ÁöÑÁºñËæëÊ®°ÂºèÂ∑≤ÂÖ≥Èó≠
              if (isFavoritesSelectionMode) {
                document.getElementById("favorites-edit-btn").click();
              }
              switchToChatListView("memories-view");
              renderMemoriesScreen(); // ÁÇπÂáªÊó∂Ê∏≤Êüì
            });

          // 2. ÁªëÂÆöÂõûÂøÜÂΩïÁïåÈù¢ÁöÑËøîÂõûÊåâÈíÆ
          document
            .getElementById("memories-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view"),
            );

          // Á∫¶ÂÆö/ÂÄíËÆ°Êó∂ÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("add-countdown-btn")
            .addEventListener("click", () => {
              document
                .getElementById("create-countdown-modal")
                .classList.add("visible");
            });
          document
            .getElementById("cancel-create-countdown-btn")
            .addEventListener("click", () => {
              document
                .getElementById("create-countdown-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("confirm-create-countdown-btn")
            .addEventListener("click", async () => {
              const title = document
                .getElementById("countdown-title-input")
                .value.trim();
              const dateValue = document.getElementById(
                "countdown-date-input",
              ).value;

              if (!title || !dateValue) {
                alert("ËØ∑Â°´ÂÜôÂÆåÊï¥ÁöÑÁ∫¶ÂÆöÊ†áÈ¢òÂíåÊó•ÊúüÔºÅ");
                return;
              }

              const targetDate = new Date(dateValue);
              if (isNaN(targetDate) || targetDate <= new Date()) {
                alert("ËØ∑ËæìÂÖ•‰∏Ä‰∏™ÊúâÊïàÁöÑ„ÄÅÊú™Êù•ÁöÑÊó•ÊúüÔºÅ");
                return;
              }

              const newCountdown = {
                chatId: null, // Áî®Êà∑ÂàõÂª∫ÁöÑÔºå‰∏çÂ±û‰∫é‰ªª‰ΩïÁâπÂÆöAI
                authorName: "Me",
                description: title,
                timestamp: Date.now(),
                type: "countdown",
                targetDate: targetDate.getTime(),
              };

              await db.memories.add(newCountdown);
              document
                .getElementById("create-countdown-modal")
                .classList.remove("visible");
              renderMemoriesScreen();
            });

          // ÊãâÈªëÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("block-chat-btn")
            .addEventListener("click", async () => {
              if (
                !state.activeChatId ||
                state.chats[state.activeChatId].isGroup
              )
                return;

              const chat = state.chats[state.activeChatId];
              const confirmed = await showCustomConfirm(
                "Á°ÆËÆ§ÊãâÈªë",
                `Á°ÆÂÆöË¶ÅÊãâÈªë‚Äú${chat.name}‚ÄùÂêóÔºüÊãâÈªëÂêéÊÇ®Â∞ÜÊó†Ê≥ïÂêëÂÖ∂ÂèëÈÄÅÊ∂àÊÅØÔºåÁõ¥Âà∞ÊÇ®Â∞ÜTaÁßªÂá∫ÈªëÂêçÂçïÔºåÊàñÁ≠âÂæÖTaÈáçÊñ∞Áî≥ËØ∑Â•ΩÂèã„ÄÇ`,
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                chat.relationship.status = "blocked_by_user";
                chat.relationship.blockedTimestamp = Date.now();

                const hiddenMessage = {
                  role: "system",
                  content: `[Á≥ªÁªüÊèêÁ§∫Ôºö‰Ω†ÂàöÂàöË¢´Áî®Êà∑ÊãâÈªë‰∫Ü„ÄÇÂú®ÂØπÊñπËß£Èô§ÊãâÈªë‰πãÂâçÔºå‰Ω†Êó†Ê≥ïÂÜç‰∏ªÂä®ÂèëËµ∑ÂØπËØùÔºå‰πüÊó†Ê≥ïÂõûÂ∫î„ÄÇ]`,
                  timestamp: Date.now() + 1,
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);

                await db.chats.put(chat);

                // ÂÖ≥Èó≠ËÆæÁΩÆÂºπÁ™óÔºåÂπ∂Âà∑Êñ∞ËÅäÂ§©ÁïåÈù¢
                document
                  .getElementById("chat-settings-modal")
                  .classList.remove("visible");
                renderChatInterface(state.activeChatId);
                // Âà∑Êñ∞ËÅäÂ§©ÂàóË°®ÔºåÂèØËÉΩ‰ºöÊúâUIÂèòÂåñ
                renderChatList();
              }
            });

          document
            .getElementById("chat-lock-overlay")
            .addEventListener("click", async (e) => {
              const chat = state.chats[state.activeChatId];
              if (!chat) return;

              if (e.target.id === "force-apply-check-btn") {
                alert(
                  "Ê≠£Âú®ÊâãÂä®Ëß¶ÂèëÂ•ΩÂèãÁî≥ËØ∑ÊµÅÁ®ãÔºåËØ∑Á®çÂêé...\nÂ¶ÇÊûúAPIË∞ÉÁî®ÊàêÂäüÔºåÂ∞ÜÂºπÂá∫ÊèêÁ§∫„ÄÇÂ¶ÇÊûúÂ§±Ë¥•Ôºå‰πü‰ºöÊúâÈîôËØØÊèêÁ§∫„ÄÇÂ¶ÇÊûúÈïøÊó∂Èó¥Êó†ÂèçÂ∫îÔºåËØ¥ÊòéAIÂèØËÉΩÂÜ≥ÂÆöÊöÇÊó∂‰∏çÁî≥ËØ∑„ÄÇ",
                );
                await triggerAiFriendApplication(chat.id);
                renderChatInterface(chat.id);
                return;
              }

              if (e.target.id === "unblock-btn") {
                chat.relationship.status = "friend";
                chat.relationship.blockedTimestamp = null;

                const hiddenMessage = {
                  role: "system",
                  content: `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑ÂàöÂàöËß£Èô§‰∫ÜÂØπ‰Ω†ÁöÑÊãâÈªë„ÄÇÁé∞Âú®‰Ω†‰ª¨ÂèØ‰ª•ÈáçÊñ∞ÂºÄÂßãÂØπËØù‰∫Ü„ÄÇ]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);

                await db.chats.put(chat);
                renderChatInterface(chat.id);
                renderChatList();
                triggerAiResponse(); // „ÄêÂèØÈÄâ‰ΩÜÊé®Ëçê„ÄëËß£Èô§ÂêéËÆ©AI‰∏ªÂä®ËØ¥ÁÇπ‰ªÄ‰πà
              } else if (e.target.id === "accept-friend-btn") {
                chat.relationship.status = "friend";
                chat.relationship.applicationReason = "";

                const hiddenMessage = {
                  role: "system",
                  content: `[Á≥ªÁªüÊèêÁ§∫ÔºöÁî®Êà∑ÂàöÂàöÈÄöËøá‰∫Ü‰Ω†ÁöÑÂ•ΩÂèãÁî≥ËØ∑„ÄÇ‰Ω†‰ª¨Áé∞Âú®ÂèàÂèØ‰ª•Ê≠£Â∏∏ËÅäÂ§©‰∫Ü„ÄÇ]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);

                await db.chats.put(chat);
                renderChatInterface(chat.id);
                renderChatList();
                const msg = {
                  role: "user",
                  content: "ÊàëÈÄöËøá‰∫Ü‰Ω†ÁöÑÂ•ΩÂèãËØ∑Ê±Ç",
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                triggerAiResponse();
              } else if (e.target.id === "reject-friend-btn") {
                chat.relationship.status = "blocked_by_user";
                chat.relationship.blockedTimestamp = Date.now();
                chat.relationship.applicationReason = "";
                await db.chats.put(chat);
                renderChatInterface(chat.id);
              }
              // Â§ÑÁêÜÁî≥ËØ∑Â•ΩÂèãÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂
              else if (e.target.id === "apply-friend-btn") {
                const reason = await showCustomPrompt(
                  "ÂèëÈÄÅÂ•ΩÂèãÁî≥ËØ∑",
                  `ËØ∑ËæìÂÖ•‰Ω†ÊÉ≥ÂØπ‚Äú${chat.name}‚ÄùËØ¥ÁöÑÁî≥ËØ∑ÁêÜÁî±Ôºö`,
                  "Êàë‰ª¨ÂíåÂ•ΩÂêßÔºÅ",
                );
                // Âè™ÊúâÂΩìÁî®Êà∑ËæìÂÖ•‰∫ÜÂÜÖÂÆπÂπ∂ÁÇπÂáª‚ÄúÁ°ÆÂÆö‚ÄùÂêéÊâçÁªßÁª≠
                if (reason !== null) {
                  // Êõ¥Êñ∞ÂÖ≥Á≥ªÁä∂ÊÄÅ‰∏∫‚ÄúÁ≠âÂæÖAIÊâπÂáÜ‚Äù
                  chat.relationship.status = "pending_ai_approval";
                  chat.relationship.applicationReason = reason;
                  await db.chats.put(chat);

                  // Âà∑Êñ∞UIÔºåÊòæÁ§∫‚ÄúÁ≠âÂæÖÈÄöËøá‚ÄùÁöÑÁïåÈù¢
                  renderChatInterface(chat.id);
                  renderChatList();

                  // Ëß¶ÂèëAIÂìçÂ∫îÔºåËÆ©ÂÆÉÂéªÂ§ÑÁêÜËøô‰∏™Â•ΩÂèãÁî≥ËØ∑
                  triggerAiResponse();
                }
              }
            });

          // Á∫¢ÂåÖÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö

          // 1. Â∞ÜÂéüÊúâÁöÑËΩ¨Ë¥¶ÊåâÈíÆ(Ôø•)ÁöÑÁÇπÂáª‰∫ã‰ª∂ÔºåÈáçÂÆöÂêëÂà∞Êñ∞ÁöÑÊÄªÂÖ•Âè£ÂáΩÊï∞
          document
            .getElementById("transfer-btn")
            .addEventListener("click", handlePaymentButtonClick);

          // 2. Á∫¢ÂåÖÊ®°ÊÄÅÊ°ÜÂÜÖÈÉ®ÁöÑÊéßÂà∂ÊåâÈíÆ
          document
            .getElementById("cancel-red-packet-btn")
            .addEventListener("click", () => {
              document
                .getElementById("red-packet-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("send-group-packet-btn")
            .addEventListener("click", sendGroupRedPacket);
          document
            .getElementById("send-direct-packet-btn")
            .addEventListener("click", sendDirectRedPacket);

          // 3. Á∫¢ÂåÖÊ®°ÊÄÅÊ°ÜÁöÑÈ°µÁ≠æÂàáÊç¢ÈÄªËæë
          const rpTabGroup = document.getElementById("rp-tab-group");
          const rpTabDirect = document.getElementById("rp-tab-direct");
          const rpContentGroup = document.getElementById("rp-content-group");
          const rpContentDirect = document.getElementById("rp-content-direct");

          rpTabGroup.addEventListener("click", () => {
            rpTabGroup.classList.add("active");
            rpTabDirect.classList.remove("active");
            rpContentGroup.style.display = "block";
            rpContentDirect.style.display = "none";
          });
          rpTabDirect.addEventListener("click", () => {
            rpTabDirect.classList.add("active");
            rpTabGroup.classList.remove("active");
            rpContentDirect.style.display = "block";
            rpContentGroup.style.display = "none";
          });

          // 4. ÂÆûÊó∂Êõ¥Êñ∞Á∫¢ÂåÖÈáëÈ¢ùÊòæÁ§∫
          document
            .getElementById("rp-group-amount")
            .addEventListener("input", (e) => {
              const amount = parseFloat(e.target.value) || 0;
              document.getElementById("rp-group-total").textContent =
                `¬• ${amount.toFixed(2)}`;
            });
          document
            .getElementById("rp-direct-amount")
            .addEventListener("input", (e) => {
              const amount = parseFloat(e.target.value) || 0;
              document.getElementById("rp-direct-total").textContent =
                `¬• ${amount.toFixed(2)}`;
            });

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÂ§ÑÁêÜÁ∫¢ÂåÖÁÇπÂáªÔºå‰øÆÂ§çÂ§±ÊïàÈóÆÈ¢ò
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 1. ÊâæÂà∞Ë¢´ÁÇπÂáªÁöÑÁ∫¢ÂåÖÂç°Áâá
              const packetCard = e.target.closest(".red-packet-card");
              if (!packetCard) return; // Â¶ÇÊûúÁÇπÂáªÁöÑ‰∏çÊòØÁ∫¢ÂåÖÔºåÂ∞±‰ªÄ‰πà‰πü‰∏çÂÅö

              // 2. ‰ªéÁ∫¢ÂåÖÂç°ÁâáÁöÑÁà∂Á∫ß.message-bubbleËé∑ÂèñÊó∂Èó¥Êà≥
              const messageBubble = packetCard.closest(".message-bubble");
              if (!messageBubble || !messageBubble.dataset.timestamp) return;

              // 3. Ë∞ÉÁî®Êàë‰ª¨Áé∞ÊúâÁöÑÂ§ÑÁêÜÂáΩÊï∞
              const timestamp = parseInt(messageBubble.dataset.timestamp);
              handlePacketClick(timestamp);
            });

          // ÊäïÁ•®ÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨Âô®
          // Âú®ËæìÂÖ•Ê°ÜÂ∑•ÂÖ∑Ê†èÊ∑ªÂä†ÊåâÈíÆ
          document
            .getElementById("send-poll-btn")
            .addEventListener("click", openCreatePollModal);

          // ÊäïÁ•®ÂàõÂª∫Ê®°ÊÄÅÊ°ÜÁöÑÊåâÈíÆ
          document
            .getElementById("add-poll-option-btn")
            .addEventListener("click", addPollOptionInput);
          document
            .getElementById("cancel-create-poll-btn")
            .addEventListener("click", () => {
              document
                .getElementById("create-poll-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("confirm-create-poll-btn")
            .addEventListener("click", sendPoll);

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÂ§ÑÁêÜÊäïÁ•®Âç°ÁâáÂÜÖÁöÑÊâÄÊúâÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              const pollCard = e.target.closest(".poll-card");
              if (!pollCard) return;

              const timestamp = parseInt(pollCard.dataset.pollTimestamp);
              if (isNaN(timestamp)) return;

              // ÁÇπÂáª‰∫ÜÈÄâÈ°π
              const optionItem = e.target.closest(".poll-option-item");
              if (optionItem && !pollCard.classList.contains("closed")) {
                handleUserVote(timestamp, optionItem.dataset.option);
                return;
              }

              // ÁÇπÂáª‰∫ÜÂä®‰ΩúÊåâÈíÆÔºàÁªìÊùüÊäïÁ•®/Êü•ÁúãÁªìÊûúÔºâ
              const actionBtn = e.target.closest(".poll-action-btn");
              if (actionBtn) {
                if (pollCard.classList.contains("closed")) {
                  showPollResults(timestamp);
                } else {
                  endPoll(timestamp);
                }
                return;
              }

              // Â¶ÇÊûúÊòØÂ∑≤ÁªìÊùüÁöÑÊäïÁ•®ÔºåÁÇπÂáªÂç°Áâá‰ªª‰ΩïÂú∞ÊñπÈÉΩÂèØ‰ª•Êü•ÁúãÁªìÊûú
              if (pollCard.classList.contains("closed")) {
                showPollResults(timestamp);
              }
            });

          // AIÂ§¥ÂÉèÂ∫ìÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("manage-ai-avatar-library-btn")
            .addEventListener("click", openAiAvatarLibraryModal);
          document
            .getElementById("add-ai-avatar-btn")
            .addEventListener("click", addAvatarToLibrary);
          document
            .getElementById("close-ai-avatar-library-btn")
            .addEventListener("click", closeAiAvatarLibraryModal);

          document
            .getElementById("icon-settings-grid")
            .addEventListener("click", async (e) => {
              if (e.target.classList.contains("change-icon-btn")) {
                const item = e.target.closest(".icon-setting-item");
                const iconId = item.dataset.iconId;
                if (!iconId) return;

                // 1. ÂºπÂá∫ÈÄâÊã©Ê®°ÊÄÅÊ°Ü
                const choice = await showChoiceModal("Êõ¥Êç¢ÂõæÊ†á", [
                  { text: "üìÅ Upload from local", value: "local" },
                  { text: "üåê Use URL", value: "url" },
                ]);

                let newUrl = null;

                // 2. Ê†πÊçÆÁî®Êà∑ÁöÑÈÄâÊã©ÊâßË°å‰∏çÂêåÊìç‰Ωú
                if (choice === "local") {
                  newUrl = await uploadImageLocally(); // Ë∞ÉÁî®Êàë‰ª¨‰πãÂâçÂÜôÂ•ΩÁöÑÊú¨Âú∞‰∏ä‰º†ËæÖÂä©ÂáΩÊï∞
                } else if (choice === "url") {
                  const currentUrl = state.globalSettings.appIcons[iconId];
                  newUrl = await showCustomPrompt(
                    `Êõ¥Êç¢‚Äú${item.querySelector(".icon-preview").alt}‚ÄùÂõæÊ†á`,
                    "ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂõæÁâáURL",
                    currentUrl,
                    "url",
                  );
                }

                // 3. Â§ÑÁêÜÊúÄÁªàÁªìÊûú
                if (newUrl && newUrl.trim()) {
                  const trimmedUrl = newUrl.trim();
                  // ‰ªÖÂú®ÂÜÖÂ≠ò‰∏≠Êõ¥Êñ∞ÔºåÁ≠âÂæÖÁî®Êà∑ÁÇπÂáª‚Äú‰øùÂ≠ò‚Äù
                  state.globalSettings.appIcons[iconId] = trimmedUrl;
                  // ÂÆûÊó∂Êõ¥Êñ∞ËÆæÁΩÆÈ°µÈù¢ÁöÑÈ¢ÑËßàÂõæ
                  item.querySelector(".icon-preview").src = trimmedUrl;
                } else if (newUrl !== null) {
                  alert("ËØ∑ËæìÂÖ•‰∏Ä‰∏™ÊúâÊïàÁöÑURLÊàñÈÄâÊã©‰∏Ä‰∏™Êñá‰ª∂ÔºÅ");
                }
              }
            });

          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // ‰ΩøÁî® .closest() Âêë‰∏äÊü•ÊâæË¢´ÁÇπÂáªÁöÑÂç°Áâá
              const linkCard = e.target.closest(".link-share-card");
              if (linkCard) {
                const timestamp = parseInt(linkCard.dataset.timestamp);
                if (!isNaN(timestamp)) {
                  openBrowser(timestamp); // Ë∞ÉÁî®Êàë‰ª¨ÁöÑÂáΩÊï∞
                }
              }
            });

          // ÊµèËßàÂô®ËøîÂõûÊåâÈíÆÁöÑ‰∫ã‰ª∂ÁõëÂê¨ÔºåÁ°Æ‰øùÂÆÉÂè™ÁªëÂÆö‰∏ÄÊ¨°
          document
            .getElementById("browser-back-btn")
            .addEventListener("click", () => {
              showScreen("chat-interface-screen");
            });

          // 1. ÁªëÂÆöËæìÂÖ•Ê°Ü‰∏äÊñπ‚ÄúÂàÜ‰∫´ÈìæÊé•‚ÄùÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("share-link-btn")
            .addEventListener("click", openShareLinkModal);

          // 2. ÁªëÂÆöÊ®°ÊÄÅÊ°Ü‰∏≠‚ÄúÂèñÊ∂à‚ÄùÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("cancel-share-link-btn")
            .addEventListener("click", () => {
              document
                .getElementById("share-link-modal")
                .classList.remove("visible");
            });

          // 3. ÁªëÂÆöÊ®°ÊÄÅÊ°Ü‰∏≠‚ÄúÂàÜ‰∫´‚ÄùÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("confirm-share-link-btn")
            .addEventListener("click", sendUserLinkShare);

          document
            .getElementById("theme-toggle-switch")
            .addEventListener("change", toggleTheme);

          // ÁªëÂÆöÊ∂àÊÅØÊìç‰ΩúËèúÂçï‰∏≠ÁöÑ‚ÄúÂºïÁî®‚ÄùÊåâÈíÆ
          document
            .getElementById("quote-message-btn")
            .addEventListener("click", startReplyToMessage);

          // ÁªëÂÆöÂõûÂ§çÈ¢ÑËßàÊ†è‰∏≠ÁöÑ‚ÄúÂèñÊ∂à‚ÄùÊåâÈíÆ
          document
            .getElementById("cancel-reply-btn")
            .addEventListener("click", cancelReplyMode);

          // Âú®‰Ω†ÁöÑ init() ÂáΩÊï∞ÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®Âå∫Âüü...

          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 1. Âêë‰∏äÊü•ÊâæË¢´ÁÇπÂáªÁöÑÂÖÉÁ¥†ÊòØÂê¶Âú®‰∏Ä‰∏™Ê∂àÊÅØÊ∞îÊ≥°ÂÜÖ
              const bubble = e.target.closest(".message-bubble");
              if (!bubble) return; // Â¶ÇÊûú‰∏çÂú®ÔºåÂ∞±ÈÄÄÂá∫

              // 2. Ê∑ªÂä†‰∏•Ê†ºÁöÑÁ≠õÈÄâÊù°‰ª∂
              // ÂøÖÈ°ªÊòØ AI ÁöÑÊ∂àÊÅØ (.ai)
              // ÂøÖÈ°ªÊòØËΩ¨Ë¥¶Á±ªÂûã (.is-transfer)
              // ÂøÖÈ°ªÊòØÊàë‰ª¨Ê†áËÆ∞‰∏∫‚ÄúÂæÖÂ§ÑÁêÜ‚ÄùÁöÑ (data-status="pending")
              if (
                bubble.classList.contains("ai") &&
                bubble.classList.contains("is-transfer") &&
                bubble.dataset.status === "pending"
              ) {
                // 3. Âè™ÊúâÊª°Ë∂≥ÊâÄÊúâÊù°‰ª∂ÔºåÊâçÊâßË°åÂêéÁª≠ÈÄªËæë
                const timestamp = parseInt(bubble.dataset.timestamp);
                if (!isNaN(timestamp)) {
                  showTransferActionModal(timestamp);
                }
              }
            });

          // Âú® init() ÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âå∫ÂüüÊ∑ªÂä†
          document
            .getElementById("transfer-action-accept")
            .addEventListener("click", () =>
              handleUserTransferResponse("accepted"),
            );
          document
            .getElementById("transfer-action-decline")
            .addEventListener("click", () =>
              handleUserTransferResponse("declined"),
            );
          document
            .getElementById("transfer-action-cancel")
            .addEventListener("click", hideTransferActionModal);

          document
            .getElementById("chat-list-title")
            .addEventListener("click", renderCallHistoryScreen);

          // 2. ÁªëÂÆöÈÄöËØùËÆ∞ÂΩïÈ°µÈù¢ÁöÑ‚ÄúËøîÂõû‚ÄùÊåâÈíÆ
          document
            .getElementById("call-history-back-btn")
            .addEventListener("click", () => {
              // ËøîÂõûÂà∞ËÅäÂ§©ÂàóË°®È°µÈù¢ÔºåËÄå‰∏çÊòØËÅäÂ§©ÁïåÈù¢
              showScreen("chat-list-screen");
            });

          // 3. ÁõëÂê¨Âç°ÁâáÁÇπÂáªÁöÑÈÄªËæë‰øùÊåÅ‰∏çÂèò
          document
            .getElementById("call-history-list")
            .addEventListener("click", (e) => {
              const card = e.target.closest(".call-record-card");
              if (card && card.dataset.recordId) {
                showCallTranscript(parseInt(card.dataset.recordId));
              }
            });

          // 4. ÂÖ≥Èó≠ËØ¶ÊÉÖÂºπÁ™óÁöÑÈÄªËæë‰øùÊåÅ‰∏çÂèò
          document
            .getElementById("close-transcript-modal-btn")
            .addEventListener("click", () => {
              document
                .getElementById("call-transcript-modal")
                .classList.remove("visible");
            });

          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 1. Ê£ÄÊü•ÁÇπÂáªÁöÑÊòØÂê¶ÊòØËØ≠Èü≥Êù°
              const voiceBody = e.target.closest(".voice-message-body");
              if (!voiceBody) return;

              // 2. ÊâæÂà∞Áõ∏ÂÖ≥ÁöÑDOMÂÖÉÁ¥†
              const bubble = voiceBody.closest(".message-bubble");
              if (!bubble) return;

              const spinner = voiceBody.querySelector(".loading-spinner");
              const transcriptEl = bubble.querySelector(".voice-transcript");

              // Â¶ÇÊûúÊ≠£Âú®Âä†ËΩΩ‰∏≠ÔºåÂàô‰∏çÂìçÂ∫îÁÇπÂáª
              if (bubble.dataset.state === "loading") {
                return;
              }

              // 3. Â¶ÇÊûúÊñáÂ≠óÂ∑≤ÁªèÂ±ïÂºÄÔºåÂàôÊî∂Ëµ∑
              if (bubble.dataset.state === "expanded") {
                transcriptEl.style.display = "none";
                bubble.dataset.state = "collapsed";
              }
              // 4. Â¶ÇÊûúÊòØÊî∂Ëµ∑Áä∂ÊÄÅÔºåÂàôÂºÄÂßã‚ÄúËΩ¨ÂΩï‚ÄùÊµÅÁ®ã
              else {
                bubble.dataset.state = "loading"; // ËøõÂÖ•Âä†ËΩΩÁä∂ÊÄÅ
                spinner.style.display = "block"; // ÊòæÁ§∫Âä†ËΩΩÂä®Áîª

                // Ê®°Êãü1.5ÁßíÁöÑËØ≠Èü≥ËØÜÂà´ËøáÁ®ã
                setTimeout(() => {
                  // Ê£ÄÊü•Ê≠§Êó∂ÂÖÉÁ¥†ÊòØÂê¶ËøòÂ≠òÂú®ÔºàÂèØËÉΩÁî®Êà∑Â∑≤ÁªèÂàáÊç¢‰∫ÜËÅäÂ§©Ôºâ
                  if (document.body.contains(bubble)) {
                    const voiceText = bubble.dataset.voiceText || "(Unrecognized)";
                    transcriptEl.textContent = voiceText; // Â°´ÂÖÖÊñáÂ≠ó

                    spinner.style.display = "none"; // ÈöêËóèÂä†ËΩΩÂä®Áîª
                    transcriptEl.style.display = "block"; // ÊòæÁ§∫ÊñáÂ≠ó
                    bubble.dataset.state = "expanded"; // ËøõÂÖ•Â±ïÂºÄÁä∂ÊÄÅ
                  }
                }, 500);
              }
            });

          document
            .getElementById("chat-header-status")
            .addEventListener("click", handleEditStatusClick);

          // Âú® init() ÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®Âå∫ÂüüÊ∑ªÂä†
          document
            .getElementById("selection-share-btn")
            .addEventListener("click", () => {
              if (selectedMessages.size > 0) {
                openShareTargetPicker(); // ÊâìÂºÄÊàë‰ª¨Âç≥Â∞ÜÂàõÂª∫ÁöÑÁõÆÊ†áÈÄâÊã©Âô®
              }
            });

          // Âú® init() ÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®Âå∫ÂüüÊ∑ªÂä†
          document
            .getElementById("confirm-share-target-btn")
            .addEventListener("click", async () => {
              const sourceChat = state.chats[state.activeChatId];
              const selectedTargetIds = Array.from(
                document.querySelectorAll(".share-target-checkbox:checked"),
              ).map((cb) => cb.dataset.chatId);

              if (selectedTargetIds.length === 0) {
                alert("ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÂàÜ‰∫´ÁöÑËÅäÂ§©„ÄÇ");
                return;
              }

              // 1. ÊâìÂåÖËÅäÂ§©ËÆ∞ÂΩï
              const sharedHistory = [];
              const sortedTimestamps = [...selectedMessages].sort(
                (a, b) => a - b,
              );
              for (const timestamp of sortedTimestamps) {
                const msg = sourceChat.history.find(
                  (m) => m.timestamp === timestamp,
                );
                if (msg) {
                  sharedHistory.push(msg);
                }
              }

              // 2. ÂàõÂª∫ÂàÜ‰∫´Âç°ÁâáÊ∂àÊÅØÂØπË±°
              const shareCardMessage = {
                role: "user",
                senderName: sourceChat.isGroup
                  ? sourceChat.settings.myNickname || "Me"
                  : "Me",
                type: "share_card",
                timestamp: Date.now(),
                payload: {
                  sourceChatName: sourceChat.name,
                  title: `Êù•Ëá™‚Äú${sourceChat.name}‚ÄùÁöÑËÅäÂ§©ËÆ∞ÂΩï`,
                  sharedHistory: sharedHistory,
                },
              };

              // 3. Âæ™ÁéØÂèëÈÄÅÂà∞ÊâÄÊúâÁõÆÊ†áËÅäÂ§©
              for (const targetId of selectedTargetIds) {
                const targetChat = state.chats[targetId];
                if (targetChat) {
                  targetChat.history.push(shareCardMessage);
                  await db.chats.put(targetChat);
                }
              }

              // 4. Êî∂Â∞æÂ∑•‰Ωú
              document
                .getElementById("share-target-modal")
                .classList.remove("visible");
              exitSelectionMode(); // ÈÄÄÂá∫Â§öÈÄâÊ®°Âºè
              await showCustomAlert(
                "ÂàÜ‰∫´ÊàêÂäü",
                `ËÅäÂ§©ËÆ∞ÂΩïÂ∑≤ÊàêÂäüÂàÜ‰∫´Âà∞ ${selectedTargetIds.length} ‰∏™‰ºöËØù‰∏≠„ÄÇ`,
              );
              renderChatList(); // Âà∑Êñ∞ÂàóË°®ÔºåÂèØËÉΩ‰ºöÊúâÊñ∞Ê∂àÊÅØÊèêÁ§∫
            });

          // ÁªëÂÆöÂèñÊ∂àÊåâÈíÆ
          document
            .getElementById("cancel-share-target-btn")
            .addEventListener("click", () => {
              document
                .getElementById("share-target-modal")
                .classList.remove("visible");
            });

          // Âú® init() ÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®Âå∫ÂüüÊ∑ªÂä†
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // Â§ÑÁêÜÂàÜ‰∫´Âç°ÁâáÁöÑÁÇπÂáª
              const shareCard = e.target.closest(
                ".link-share-card[data-timestamp]",
              );
              if (
                shareCard &&
                shareCard.closest(".message-bubble.is-link-share")
              ) {
                const timestamp = parseInt(shareCard.dataset.timestamp);
                openSharedHistoryViewer(timestamp);
              }
            });

          // ÁªëÂÆöÊü•ÁúãÂô®ÁöÑÂÖ≥Èó≠ÊåâÈíÆ
          document
            .getElementById("close-shared-history-viewer-btn")
            .addEventListener("click", () => {
              document
                .getElementById("shared-history-viewer-modal")
                .classList.remove("visible");
            });

          // ÂàõÂª∫Êñ∞ÂáΩÊï∞Êù•Â§ÑÁêÜÊ∏≤ÊüìÈÄªËæë
          function openSharedHistoryViewer(timestamp) {
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find((m) => m.timestamp === timestamp);
            if (!message || message.type !== "share_card") return;

            const viewerModal = document.getElementById(
              "shared-history-viewer-modal",
            );
            const viewerTitle = document.getElementById(
              "shared-history-viewer-title",
            );
            const viewerContent = document.getElementById(
              "shared-history-viewer-content",
            );

            viewerTitle.textContent = message.payload.title;
            viewerContent.innerHTML = ""; // Ê∏ÖÁ©∫ÊóßÂÜÖÂÆπ

            // Â§çÁî® createMessageElement Êù•Ê∏≤ÊüìÊØè‰∏ÄÊù°Ë¢´ÂàÜ‰∫´ÁöÑÊ∂àÊÅØ
            message.payload.sharedHistory.forEach((sharedMsg) => {
              // Ê≥®ÊÑèÔºöËøôÈáåÊàë‰ª¨‰º†ÂÖ•ÁöÑÊòØ sourceChat ÂØπË±°Ôºå‰ª•Á°Æ‰øùÂ§¥ÂÉè„ÄÅÊòµÁß∞Á≠âÊ≠£Á°Æ
              const sourceChat =
                Object.values(state.chats).find(
                  (c) => c.name === message.payload.sourceChatName,
                ) || chat;
              const bubbleEl = createMessageElement(sharedMsg, sourceChat);
              if (bubbleEl) {
                viewerContent.appendChild(bubbleEl);
              }
            });

            viewerModal.classList.add("visible");
          }

          audioPlayer.addEventListener("timeupdate", updateMusicProgressBar);

          audioPlayer.addEventListener("pause", () => {
            if (state.musicState.isActive) {
              state.musicState.isPlaying = false;
              updatePlayerUI();
            }
          });
          audioPlayer.addEventListener("play", () => {
            if (state.musicState.isActive) {
              state.musicState.isPlaying = true;
              updatePlayerUI();
            }
          });

          document
            .getElementById("playlist-body")
            .addEventListener("click", async (e) => {
              const target = e.target;
              if (target.classList.contains("delete-track-btn")) {
                const index = parseInt(target.dataset.index);
                const track = state.musicState.playlist[index];
                const confirmed = await showCustomConfirm(
                  "Âà†Èô§Ê≠åÊõ≤",
                  `Á°ÆÂÆöË¶Å‰ªéÊí≠ÊîæÂàóË°®‰∏≠Âà†Èô§„Ää${track.name}„ÄãÂêóÔºü`,
                );
                if (confirmed) {
                  deleteTrack(index);
                }
                return;
              }

              if (target.classList.contains("cover-btn")) {
                const index = parseInt(target.dataset.index);
                if (!isNaN(index)) {
                  handleCoverUpload(index);
                }
                return; // Â§ÑÁêÜÂÆåÂ∞±ÈÄÄÂá∫ÔºåÈÅøÂÖçËß¶ÂèëÂÖ∂‰ªñÈÄªËæë
              }

              if (target.classList.contains("lyrics-btn")) {
                const index = parseInt(target.dataset.index);
                if (isNaN(index)) return;

                // 1. ÂºπÁ™óËØ¢ÈóÆÁî®Êà∑ÈÄâÊã©ÔºàÂ∑≤ÁßªÈô§ÂõæÊ†áÔºâ
                const choice = await showChoiceModal("ÈÄâÊã©Ê≠åËØçÊù•Ê∫ê", [
                  { text: "Use URL", value: "url" },
                  { text: "Upload from local", value: "local" },
                ]);

                let lrcContent = null;

                // 2. Ê†πÊçÆÈÄâÊã©ÊâßË°å‰∏çÂêåÊìç‰Ωú
                if (choice === "url") {
                  const url = await showCustomPrompt(
                    "Ê≠åËØçURL",
                    "ËØ∑ËæìÂÖ•.lrcÊ≠åËØçÊñá‰ª∂ÁöÑÁΩëÁªúÈìæÊé•",
                  );
                  if (url && url.trim()) {
                    try {
                      const response = await fetch(url.trim());
                      if (response.ok) {
                        lrcContent = await response.text();
                      } else {
                        alert("Êó†Ê≥ïËé∑ÂèñÊ≠åËØçÊñá‰ª∂ÔºåËØ∑Ê£ÄÊü•URLÊòØÂê¶Ê≠£Á°Æ„ÄÇ");
                      }
                    } catch (error) {
                      alert("Ëé∑ÂèñÊ≠åËØçÂ§±Ë¥•: " + error.message);
                    }
                  }
                } else if (choice === "local") {
                  lrcContent = await new Promise((resolve) => {
                    const lrcInput =
                      document.getElementById("lrc-upload-input");
                    const handler = (event) => {
                      const file = event.target.files[0];
                      if (file) {
                        const reader = new FileReader();
                        reader.onload = (re) => resolve(re.target.result);
                        reader.readAsText(file);
                      } else {
                        resolve(null);
                      }
                      lrcInput.removeEventListener("change", handler);
                      lrcInput.value = "";
                    };
                    lrcInput.addEventListener("change", handler);
                    lrcInput.click();
                  });
                }

                // 3. Â¶ÇÊûúÊàêÂäüËé∑ÂèñÂà∞Ê≠åËØçÔºåÂ∞±‰øùÂ≠òÂπ∂Êõ¥Êñ∞
                if (lrcContent !== null) {
                  state.musicState.playlist[index].lrcContent = lrcContent;
                  await saveGlobalPlaylist();
                  alert("Ê≠åËØçÂØºÂÖ•ÊàêÂäüÔºÅ");
                  if (state.musicState.currentIndex === index) {
                    state.musicState.parsedLyrics = parseLRC(lrcContent);
                    renderLyrics();
                  }
                }
              }
            });

          document
            .querySelector(".progress-bar")
            .addEventListener("click", (e) => {
              if (!audioPlayer.duration) return;
              const progressBar = e.currentTarget;
              const barWidth = progressBar.clientWidth;
              const clickX = e.offsetX;
              audioPlayer.currentTime =
                (clickX / barWidth) * audioPlayer.duration;
            });

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÊù•Â§ÑÁêÜÊâÄÊúâ‚ÄúÂ∑≤Êí§ÂõûÊ∂àÊÅØ‚ÄùÁöÑÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // Ê£ÄÊü•Ë¢´ÁÇπÂáªÁöÑÂÖÉÁ¥†ÊàñÂÖ∂Áà∂ÂÖÉÁ¥†ÊòØÂê¶ÊòØ‚ÄúÂ∑≤Êí§Âõû‚ÄùÊèêÁ§∫
              const placeholder = e.target.closest(
                ".recalled-message-placeholder",
              );
              if (!placeholder) return; // Â¶ÇÊûú‰∏çÊòØÔºåÂ∞±ÈÄÄÂá∫

              // Â¶ÇÊûúÊòØÔºåÂ∞±‰ªéËÅäÂ§©ËÆ∞ÂΩï‰∏≠ÊâæÂà∞ÂØπÂ∫îÁöÑÊï∞ÊçÆÂπ∂ÊòæÁ§∫
              const chat = state.chats[state.activeChatId];
              const wrapper = placeholder.closest(".message-wrapper"); // ÊâæÂà∞ÂÆÉÁöÑÁà∂ÂÆπÂô®
              if (chat && wrapper) {
                // ‰ªéÁà∂ÂÆπÂô®‰∏äÊâæÂà∞Êó∂Èó¥Êà≥
                const timestamp = parseInt(wrapper.dataset.timestamp);
                const recalledMsg = chat.history.find(
                  (m) => m.timestamp === timestamp,
                );

                if (recalledMsg && recalledMsg.recalledData) {
                  let originalContentText = "";
                  const recalled = recalledMsg.recalledData;

                  if (recalled.originalType === "text") {
                    originalContentText = `ÂéüÊñá: "${recalled.originalContent}"`;
                  } else {
                    originalContentText = `Êí§Âõû‰∫Ü‰∏ÄÊù°[${recalled.originalType}]Á±ªÂûãÁöÑÊ∂àÊÅØ`;
                  }
                  showCustomAlert("Â∑≤Êí§ÂõûÁöÑÊ∂àÊÅØ", originalContentText);
                }
              }
            });

          document
            .getElementById("close-category-manager-btn")
            .addEventListener("click", () => {
              document
                .getElementById("world-book-category-manager-modal")
                .classList.remove("visible");
              renderWorldBookScreen(); // ÂÖ≥Èó≠ÂêéÂà∑Êñ∞‰∏ªÂàóË°®
            });
          document
            .getElementById("add-new-category-btn")
            .addEventListener("click", addNewCategory);
          document
            .getElementById("existing-categories-list")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("delete-group-btn")) {
                const categoryId = parseInt(e.target.dataset.id);
                deleteCategory(categoryId);
              }
            });

          // --- Ëá™ÂÆö‰πâÂ§¥ÂÉèÊ°ÜÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö ---

          // ÊâìÂºÄ‚ÄúÈÄâÊã©‚ÄùÂºπÁ™óÁöÑÊåâÈíÆ
          document
            .getElementById("chat-settings-modal")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("change-frame-btn")) {
                openFrameSelectorModal(e.target.dataset.type);
              }
            });
          document
            .getElementById("member-settings-modal")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("change-frame-btn")) {
                openFrameSelectorModal("member", editingMemberId);
              }
            });

          // ‚ÄúÈÄâÊã©‚ÄùÂºπÁ™óÂÜÖÁöÑÊåâÈíÆ
          // ‚ÄúÈÄâÊã©‚ÄùÂºπÁ™óÂÜÖÁöÑÊåâÈíÆÔºàÂ∑≤‰øÆÊ≠£Ôºâ
          document
            .getElementById("manage-custom-frames-btn")
            .addEventListener("click", () => {
              // 1. ÂÖàÂÖ≥Èó≠ÂΩìÂâçÁöÑÈÄâÊã©ÂºπÁ™ó
              document
                .getElementById("avatar-frame-modal")
                .classList.remove("visible");

              // 2. ÁÑ∂ÂêéÂÜçÊâìÂºÄÁÆ°ÁêÜÂºπÁ™ó
              openFrameManager();
            });
          document
            .getElementById("cancel-frame-settings-btn")
            .addEventListener("click", () =>
              document
                .getElementById("avatar-frame-modal")
                .classList.remove("visible"),
            );
          document
            .getElementById("save-frame-settings-btn")
            .addEventListener("click", saveSelectedFrames);

          // ‚ÄúÁÆ°ÁêÜ‚ÄùÂºπÁ™óÂÜÖÁöÑÊåâÈíÆ
          document
            .getElementById("upload-custom-frame-btn")
            .addEventListener("click", handleUploadCustomFrame);
          document
            .getElementById("close-frame-manager-btn")
            .addEventListener("click", () => {
              document
                .getElementById("custom-frame-manager-modal")
                .classList.remove("visible");
              // ÂÖ≥Èó≠ÁÆ°ÁêÜÂêéÔºåÂà∑Êñ∞ÈÄâÊã©ÁïåÈù¢ÔºåÂõ†‰∏∫ÂàóË°®ÂèØËÉΩÂèò‰∫Ü
              openFrameSelectorModal(
                currentFrameSelection.type,
                currentFrameSelection.target,
              );
            });

          // ËÅäÂ§©ÂàóË°®Â∑¶ÊªëÂäüËÉΩJSÈÄªËæë
          const chatListEl = document.getElementById("chat-list");
          let chatSwipeState = {
            isDragging: false,
            startX: 0,
            activeContent: null,
          };

          // ÂÖ≥Èó≠ÊâÄÊúâÂ∑≤ÊªëÂºÄÁöÑÈ°π
          function resetAllChatSwipes(exceptThisOne = null) {
            document
              .querySelectorAll(".chat-list-item-content.swiped")
              .forEach((content) => {
                if (content !== exceptThisOne) {
                  content.classList.remove("swiped");
                }
              });
          }

          chatListEl.addEventListener("mousedown", (e) => {
            const content = e.target.closest(".chat-list-item-content");
            if (content) {
              resetAllChatSwipes(content);
              chatSwipeState.isDragging = true;
              chatSwipeState.startX = e.pageX;
              chatSwipeState.activeContent = content;
              // ÈòªÊ≠¢ÊãñÂä®Êó∂ÈÄâ‰∏≠ÊñáÊú¨
              e.preventDefault();
            }
          });

          document.addEventListener("mousemove", (e) => {
            if (!chatSwipeState.isDragging || !chatSwipeState.activeContent)
              return;
            const diffX = e.pageX - chatSwipeState.startX;
            if (diffX < 0 && diffX > -170) {
              // Âè™ÂÖÅËÆ∏ÂêëÂ∑¶Êªë, ÈôêÂà∂ÊúÄÂ§ßË∑ùÁ¶ª
              chatSwipeState.activeContent.style.transition = "none"; // ÊªëÂä®Êó∂Á¶ÅÁî®Âä®Áîª
              chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
            }
          });

          document.addEventListener("mouseup", (e) => {
            if (!chatSwipeState.isDragging || !chatSwipeState.activeContent)
              return;

            chatSwipeState.activeContent.style.transition =
              "transform 0.3s ease";
            const transformStyle = window.getComputedStyle(
              chatSwipeState.activeContent,
            ).transform;
            const currentTranslateX = new DOMMatrix(transformStyle).m41;

            if (currentTranslateX < -60) {
              // ÊªëÂä®Ë∂ÖËøáÈòàÂÄº
              chatSwipeState.activeContent.classList.add("swiped");
            } else {
              chatSwipeState.activeContent.classList.remove("swiped");
            }
            chatSwipeState.activeContent.style.transform = ""; // Ê∏ÖÈô§ÂÜÖËÅîÊ†∑ÂºèÔºå‰∫§Áî±CSS classÊéßÂà∂

            // ÈáçÁΩÆÁä∂ÊÄÅ
            chatSwipeState.isDragging = false;
            chatSwipeState.activeContent = null;
          });

          // ÁßªÂä®Á´ØËß¶Êë∏‰∫ã‰ª∂ÁöÑÂÖºÂÆπ
          chatListEl.addEventListener(
            "touchstart",
            (e) => {
              const content = e.target.closest(".chat-list-item-content");
              if (content) {
                resetAllChatSwipes(content);
                chatSwipeState.isDragging = true;
                chatSwipeState.startX = e.touches[0].pageX;
                chatSwipeState.activeContent = content;
              }
            },
            { passive: true },
          );

          chatListEl.addEventListener(
            "touchmove",
            (e) => {
              if (!chatSwipeState.isDragging || !chatSwipeState.activeContent)
                return;
              const diffX = e.touches[0].pageX - chatSwipeState.startX;
              if (diffX < 0 && diffX > -170) {
                chatSwipeState.activeContent.style.transition = "none";
                chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
              }
            },
            { passive: true },
          );

          chatListEl.addEventListener("touchend", (e) => {
            if (!chatSwipeState.isDragging || !chatSwipeState.activeContent)
              return;

            chatSwipeState.activeContent.style.transition =
              "transform 0.3s ease";
            const transformStyle = window.getComputedStyle(
              chatSwipeState.activeContent,
            ).transform;
            const currentTranslateX = new DOMMatrix(transformStyle).m41;

            if (currentTranslateX < -60) {
              chatSwipeState.activeContent.classList.add("swiped");
            } else {
              chatSwipeState.activeContent.classList.remove("swiped");
            }
            chatSwipeState.activeContent.style.transform = "";

            chatSwipeState.isDragging = false;
            chatSwipeState.activeContent = null;
          });

          // ËÅäÂ§©ÂàóË°®Êìç‰ΩúÊåâÈíÆÁÇπÂáª‰∫ã‰ª∂
          chatListEl.addEventListener("click", async (e) => {
            const target = e.target;
            if (target.classList.contains("swipe-action-btn")) {
              const container = target.closest(
                ".chat-list-item-swipe-container",
              );
              if (!container) return;

              const chatId = container.dataset.chatId;
              const chat = state.chats[chatId];
              if (!chat) return;

              if (
                target.classList.contains("pin") ||
                target.classList.contains("unpin")
              ) {
                // ÁΩÆÈ°∂ÊàñÂèñÊ∂àÁΩÆÈ°∂
                chat.isPinned = !chat.isPinned;
                await db.chats.put(chat);
                await renderChatList(); // ÈáçÊñ∞Ê∏≤ÊüìÂàóË°®‰ª•Êõ¥Êñ∞ÊéíÂ∫è
              } else if (target.classList.contains("delete")) {
                // Delete
                const confirmed = await showCustomConfirm(
                  "Âà†Èô§ÂØπËØù",
                  `Á°ÆÂÆöË¶ÅÂà†Èô§‰∏é "${chat.name}" ÁöÑÊï¥‰∏™ÂØπËØùÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ`,
                  { confirmButtonClass: "btn-danger" },
                );
                if (confirmed) {
                  if (
                    state.musicState.isActive &&
                    state.musicState.activeChatId === chat.id
                  )
                    await endListenTogetherSession(false);
                  delete state.chats[chat.id];
                  if (state.activeChatId === chat.id) state.activeChatId = null;
                  await db.chats.delete(chat.id);
                  await renderChatList();
                } else {
                  // Â¶ÇÊûúÂèñÊ∂àÂà†Èô§ÔºåÂàôÊääÊªëÂùóÊî∂ÂõûÂéª
                  const content = container.querySelector(
                    ".chat-list-item-content",
                  );
                  if (content) content.classList.remove("swiped");
                }
              }
            }
          });

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÊù•Â§ÑÁêÜÊâÄÊúâÁÇπÂáªÂíåÂãæÈÄâ‰∫ã‰ª∂ÔºåÊïàÁéáÊõ¥È´ò
          worldBookCheckboxesContainer.addEventListener("click", (e) => {
            const header = e.target.closest(".wb-category-header");
            // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØÊñá‰ª∂Â§πÂ§¥ÈÉ®ÔºåÂπ∂‰∏î‰∏çÊòØÁÇπÂú®Â§çÈÄâÊ°Ü‰∏ä
            if (header && !e.target.matches('input[type="checkbox"]')) {
              const categoryId = header.querySelector(".wb-category-checkbox")
                ?.dataset.categoryId;
              if (categoryId) {
                const bookContainer =
                  worldBookCheckboxesContainer.querySelector(
                    `.wb-book-container[data-container-for="${categoryId}"]`,
                  );
                if (bookContainer) {
                  header.classList.toggle("collapsed");
                  bookContainer.classList.toggle("collapsed");
                }
              }
            }
          });

          worldBookCheckboxesContainer.addEventListener("change", (e) => {
            const target = e.target;

            // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØÂàÜÁ±ªÁöÑ‚ÄúÂÖ®ÈÄâ‚ÄùÂ§çÈÄâÊ°Ü
            if (target.classList.contains("wb-category-checkbox")) {
              const categoryId = target.dataset.categoryId;
              const isChecked = target.checked;
              // ÊâæÂà∞Ëøô‰∏™ÂàÜÁ±ª‰∏ãÁöÑÊâÄÊúâ‰π¶Á±çÂ§çÈÄâÊ°ÜÔºåÂπ∂Â∞ÜÂÆÉ‰ª¨ÁöÑÁä∂ÊÄÅËÆæÁΩÆ‰∏∫‰∏éÂàÜÁ±ªÂ§çÈÄâÊ°Ü‰∏ÄËá¥
              const bookCheckboxes =
                worldBookCheckboxesContainer.querySelectorAll(
                  `input.wb-book-checkbox[data-parent-category="${categoryId}"]`,
                );
              bookCheckboxes.forEach((cb) => (cb.checked = isChecked));
            }

            // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØÂçï‰∏™‰π¶Á±çÁöÑÂ§çÈÄâÊ°Ü
            if (target.classList.contains("wb-book-checkbox")) {
              const categoryId = target.dataset.parentCategory;
              if (categoryId) {
                // Ê£ÄÊü•ÂÆÉÊòØÂê¶Â±û‰∫é‰∏Ä‰∏™ÂàÜÁ±ª
                const categoryCheckbox =
                  worldBookCheckboxesContainer.querySelector(
                    `input.wb-category-checkbox[data-category-id="${categoryId}"]`,
                  );
                const allBookCheckboxes =
                  worldBookCheckboxesContainer.querySelectorAll(
                    `input.wb-book-checkbox[data-parent-category="${categoryId}"]`,
                  );
                // Ê£ÄÊü•ËØ•ÂàÜÁ±ª‰∏ãÊòØÂê¶ÊâÄÊúâ‰π¶Á±çÈÉΩË¢´ÈÄâ‰∏≠‰∫Ü
                const allChecked = Array.from(allBookCheckboxes).every(
                  (cb) => cb.checked,
                );
                // ÂêåÊ≠•ÂàÜÁ±ª‚ÄúÂÖ®ÈÄâ‚ÄùÂ§çÈÄâÊ°ÜÁöÑÁä∂ÊÄÅ
                if (categoryCheckbox) categoryCheckbox.checked = allChecked;
              }
            }

            // ÊØèÊ¨°ÂèòÊõ¥ÂêéÈÉΩÊõ¥Êñ∞È°∂ÈÉ®ÁöÑÂ∑≤ÈÄâÊï∞ÈáèÊòæÁ§∫
            updateWorldBookSelectionDisplay();
          });

          // --- ÁæéÂåñÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö ---
          const themeEditor = document.getElementById("theme-css-editor");

          // È°µÈù¢Âä†ËΩΩÊó∂ÔºåÂä†ËΩΩ‰∏ªÈ¢òÂàóË°®Âπ∂ÊòæÁ§∫Ê®°Êùø
          await loadThemesToDropdown();
          themeEditor.value = THEME_CSS_TEMPLATE;

          // ÁªëÂÆö‰∏ãÊãâÊ°ÜÈÄâÊã©‰∫ã‰ª∂
          document
            .getElementById("theme-selector")
            .addEventListener("change", handleThemeSelection);

          // ÁªëÂÆöÊâÄÊúâÊìç‰ΩúÊåâÈíÆ
          document
            .getElementById("apply-theme-btn")
            .addEventListener("click", () => applyThemeCss(themeEditor.value));
          document
            .getElementById("save-theme-btn")
            .addEventListener("click", saveCurrentTheme);
          document
            .getElementById("save-as-new-theme-btn")
            .addEventListener("click", saveAsNewTheme);
          document
            .getElementById("rename-theme-btn")
            .addEventListener("click", renameSelectedTheme);
          document
            .getElementById("delete-theme-btn")
            .addEventListener("click", deleteSelectedTheme);
          document
            .getElementById("export-theme-btn")
            .addEventListener("click", exportTheme);
          document
            .getElementById("reset-theme-css-btn")
            .addEventListener("click", async () => {
              const confirmed = await showCustomConfirm(
                "ÈáçÁΩÆCSS",
                "Á°ÆÂÆöË¶ÅÂ∞ÜCSSÈáçÁΩÆ‰∏∫ÈªòËÆ§Ê®°ÊùøÂêóÔºü\nÂΩìÂâçÁºñËæëÊ°ÜÂÜÖÁöÑ‰ª£Á†ÅÂ∞Ü‰∏¢Â§±„ÄÇ",
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                const editor = document.getElementById("theme-css-editor");
                // ÊÅ¢Â§ç‰∏∫ÈªòËÆ§ÁöÑÊ≥®ÈáäÊ®°Êùø
                editor.value = THEME_CSS_TEMPLATE;
                // Á´ãÂç≥Â∫îÁî®ÊïàÊûú
                applyThemeCss(THEME_CSS_TEMPLATE);

                // ÈáçÁΩÆ‰∏ãÊãâÊ°ÜÈÄâÊã©Áä∂ÊÄÅ
                document.getElementById("theme-selector").value = "";
                state.globalSettings.activeThemeId = null;

                alert("Â∑≤ÈáçÁΩÆ‰∏∫ÈªòËÆ§Ê®°Êùø (ËØ∑ÁÇπÂáª'‰øùÂ≠ò'‰ª•Â∫îÁî®Êõ¥ÊîπÂà∞Á≥ªÁªü)");
              }
            });
          document
            .getElementById("manage-char-css-btn")
            .addEventListener("click", openCharCssManager);
          // ÁªëÂÆöÂØºÂÖ•ÊåâÈíÆÂíåÈöêËóèÁöÑÊñá‰ª∂ÈÄâÊã©Âô®
          document
            .getElementById("import-theme-btn")
            .addEventListener("click", () => {
              document.getElementById("import-theme-input").click();
            });
          document
            .getElementById("import-theme-input")
            .addEventListener("change", (e) => {
              importTheme(e.target.files[0]);
              e.target.value = null; // Ê∏ÖÁ©∫Ôºå‰ª•‰æø‰∏ãÊ¨°ËÉΩÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
            });

          document
            .getElementById("api-preset-select")
            .addEventListener("change", handleApiPresetSelectChange);
          document
            .getElementById("manage-api-presets-btn")
            .addEventListener("click", openApiPresetManager);

          // ÈîÅÂ±èÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨Âô®

          // 1. ÈîÅÂ±èÂ£ÅÁ∫∏‰∏ä‰º†
          document
            .getElementById("lockscreen-wallpaper-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res, rej) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.onerror = () => rej(reader.error);
                  reader.readAsDataURL(file);
                });
                newLockscreenWallpaperBase64 = dataUrl;
                renderWallpaperScreen(); // ‰∏ä‰º†ÂêéÂÆûÊó∂È¢ÑËßà
              }
            });

          // 2. ÂØÜÁ†ÅËæìÂÖ•Ê°ÜÊåâÈíÆ
          document
            .getElementById("password-confirm-btn")
            .addEventListener("click", checkPassword);
          document
            .getElementById("password-cancel-btn")
            .addEventListener("click", hidePasswordModal);
          // ÂÖÅËÆ∏Âú®ËæìÂÖ•Ê°ÜÂÜÖÊåâÂõûËΩ¶ÈîÆÁ°ÆËÆ§
          document
            .getElementById("password-input-field")
            .addEventListener("keypress", (e) => {
              if (e.key === "Enter") {
                checkPassword();
              }
            });

          // 3. Â∏¶ÊúâÂä®ÁîªÊïàÊûúÁöÑ‰∏äÊªëËß£ÈîÅÊâãÂäø
          const lockScreen = document.getElementById("lock-screen");
          const unlockHint = document.getElementById("unlock-hint");
          let touchStartY = 0;
          let isSwiping = false;

          // Áªü‰∏ÄÁöÑÂºÄÂßãÂ§ÑÁêÜÂáΩÊï∞
          const handleUnlockStart = (e) => {
            if (
              document
                .getElementById("password-modal-overlay")
                .classList.contains("visible")
            )
              return;

            // (‰Ω†ÂéüÊù•ÁöÑÂÖ∂‰ªñÈÄªËæë‰øùÊåÅ‰∏çÂèò)
            const blurBg = document.getElementById(
              "lock-screen-background-blur",
            );
            if (state.globalSettings.password) {
              blurBg.style.backgroundImage = lockScreen.style.backgroundImage;
              blurBg.style.display = "block";
            } else {
              document.getElementById("home-screen").classList.add("active");
            }

            touchStartY = getEventCoords(e).y; // ‰ΩøÁî®ËæÖÂä©ÂáΩÊï∞Ëé∑ÂèñYÂùêÊ†á
            isSwiping = true;
            lockScreen.style.transition = "none";
            unlockHint.style.transition = "none";
          };

          // Áªü‰∏ÄÁöÑÁßªÂä®Â§ÑÁêÜÂáΩÊï∞
          const handleUnlockMove = (e) => {
            if (!isSwiping) return;
            const currentY = getEventCoords(e).y; // ‰ΩøÁî®ËæÖÂä©ÂáΩÊï∞
            let diffY = currentY - touchStartY;
            // (‰Ω†ÂéüÊù•ÁöÑÂÖ∂‰ªñÈÄªËæë‰øùÊåÅ‰∏çÂèò)
            if (diffY > 0) diffY = 0;
            lockScreen.style.transform = `translateY(${diffY}px)`;
            unlockHint.style.opacity = Math.max(0, 1 - Math.abs(diffY) / 100);
            if (state.globalSettings.password) {
              const blurBg = document.getElementById(
                "lock-screen-background-blur",
              );
              blurBg.style.opacity = Math.min(1, Math.abs(diffY) / 80);
            }
          };

          // Áªü‰∏ÄÁöÑÁªìÊùüÂ§ÑÁêÜÂáΩÊï∞
          const handleUnlockEnd = (e) => {
            if (!isSwiping) return;
            isSwiping = false;

            lockScreen.style.transition = "transform 0.3s ease-out";
            unlockHint.style.transition = "opacity 0.3s ease-out";
            const blurBg = document.getElementById(
              "lock-screen-background-blur",
            );

            // Ê≥®ÊÑèÔºötouchend‰∫ã‰ª∂ÁöÑÂùêÊ†áÂú® e.changedTouches[0]
            const touchEndY = e.changedTouches
              ? e.changedTouches[0].clientY
              : e.pageY;
            const swipeDistance = touchStartY - touchEndY;

            if (swipeDistance > 80) {
              lockScreen.style.transform = "translateY(-100%)";
              setTimeout(() => {
                if (state.globalSettings.password) {
                  showPasswordModal();
                } else {
                  unlockPhone();
                }
              }, 300);
            } else {
              lockScreen.style.transform = "translateY(0)";
              unlockHint.style.opacity = "1";
              if (state.globalSettings.password) {
                blurBg.style.opacity = "0";
                setTimeout(() => {
                  blurBg.style.display = "none";
                }, 300);
              } else {
                document
                  .getElementById("home-screen")
                  .classList.remove("active");
              }
            }
          };

          // 2. ÁªëÂÆö‰∏§Áßç‰∫ã‰ª∂Âà∞Âêå‰∏ÄÂ•óÂ§ÑÁêÜÈÄªËæë‰∏ä
          lockScreen.addEventListener("touchstart", handleUnlockStart, {
            passive: true,
          });
          lockScreen.addEventListener("touchmove", handleUnlockMove, {
            passive: true,
          });
          lockScreen.addEventListener("touchend", handleUnlockEnd, {
            passive: true,
          });

          lockScreen.addEventListener("mousedown", handleUnlockStart);
          // Ê≥®ÊÑèÔºömousemoveÂíåmouseupÊúÄÂ•ΩÁªëÂÆöÂú®document‰∏äÔºåÈò≤Ê≠¢Èº†Ê†áÊãñÂá∫ËåÉÂõ¥ÂêéÂ§±Êïà
          document.addEventListener("mousemove", handleUnlockMove);
          document.addEventListener("mouseup", handleUnlockEnd);

          // „ÄêÂÖ®Êñ∞„Äë‰∏∫ËÅäÂ§©Â∫ïÈÉ®Â∑•ÂÖ∑Ê†èÊ∑ªÂä†Èº†Ê†áÊãñÂä®ÊªöÂä®ÂäüËÉΩ
          const actionsTopBar = document.getElementById(
            "chat-input-actions-top",
          );
          let isDown = false;
          let startX;
          let scrollLeft;

          actionsTopBar.addEventListener("mousedown", (e) => {
            isDown = true;
            actionsTopBar.classList.add("grabbing"); // Ê∑ªÂä†‰∏Ä‰∏™classÊù•ÊîπÂèòÈº†Ê†áÊ†∑Âºè
            startX = e.pageX - actionsTopBar.offsetLeft;
            scrollLeft = actionsTopBar.scrollLeft;
          });

          actionsTopBar.addEventListener("mouseleave", () => {
            isDown = false;
            actionsTopBar.classList.remove("grabbing");
          });

          actionsTopBar.addEventListener("mouseup", () => {
            isDown = false;
            actionsTopBar.classList.remove("grabbing");
          });

          actionsTopBar.addEventListener("mousemove", (e) => {
            if (!isDown) return;
            e.preventDefault();
            const x = e.pageX - actionsTopBar.offsetLeft;
            const walk = (x - startX) * 2; // ‰πò‰ª•2ÂèØ‰ª•Â¢ûÂä†ÊãñÂä®ÈÄüÂ∫¶ÔºåÊÑüËßâÊõ¥ÁÅµÊïè
            actionsTopBar.scrollLeft = scrollLeft - walk;
          });

          document
            .getElementById("location-cancel-btn")
            .addEventListener("click", () => {
              document
                .getElementById("send-location-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("location-confirm-btn")
            .addEventListener("click", sendUserLocation);

          // „ÄêÂÖ®Êñ∞„Äë‰∏∫ÂÆö‰ΩçÊ®°ÊÄÅÊ°ÜÁöÑ‚ÄúÊ∑ªÂä†ÈÄîÁªèÁÇπ‚ÄùÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("add-trajectory-point-btn")
            .addEventListener("click", () => {
              // ÈôêÂà∂ÊúÄÂ§öÊ∑ªÂä†3‰∏™ÈÄîÁªèÁÇπÔºåÈò≤Ê≠¢UIËøá‰∫éÊã•Êå§
              if (
                document.querySelectorAll(".trajectory-point-input").length < 3
              ) {
                addTrajectoryPointInput();
              } else {
                alert("ÊúÄÂ§öÂè™ËÉΩÊ∑ªÂä†3‰∏™ÈÄîÁªèÁÇπÂì¶ÔºÅ");
              }
            });

          document
            .getElementById("send-location-btn")
            .addEventListener("click", () => {
              document.getElementById("trajectory-points-container").innerHTML =
                "";
              document
                .getElementById("send-location-modal")
                .classList.add("visible");
            });

          document
            .getElementById("reroll-btn")
            .addEventListener("click", handleRerollClick);

          // --- ÊÇ¨ÊµÆÊ≠åËØçÊ†èËÆæÁΩÆÂäüËÉΩ ---
          document
            .getElementById("lyrics-settings-btn")
            .addEventListener("click", (e) => {
              e.stopPropagation(); // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°Ëß¶ÂèëÊãñÂä®ÊàñÊâìÂºÄÊí≠ÊîæÂô®
              document
                .getElementById("lyrics-settings-modal")
                .classList.add("visible");
            });

          document
            .getElementById("close-lyrics-settings-btn")
            .addEventListener("click", async () => {
              // ‰øùÂ≠òËÆæÁΩÆÂà∞ÂÖ®Â±ÄÁä∂ÊÄÅÂπ∂ÂÜôÂÖ•Êï∞ÊçÆÂ∫ì
              state.globalSettings.lyricsBarSettings = lyricsBarSettings;
              await db.globalSettings.put(state.globalSettings);
              document
                .getElementById("lyrics-settings-modal")
                .classList.remove("visible");
              alert("ËÆæÁΩÆÂ∑≤‰øùÂ≠òÔºÅ");
            });

          document
            .getElementById("reset-lyrics-settings-btn")
            .addEventListener("click", () => {
              // ÊÅ¢Â§çÂà∞ÈªòËÆ§ÂÄº
              lyricsBarSettings = {
                fontSize: 14,
                bgOpacity: 0,
                fontColor: "#FFFFFF",
                showOnClose: true,
              };
              applyLyricsSettings(); // Â∫îÁî®ÈªòËÆ§ËÆæÁΩÆ
            });

          // ÂÆûÊó∂Êõ¥Êñ∞Ê†∑Âºè
          document
            .getElementById("lyrics-font-size-slider")
            .addEventListener("input", (e) => {
              lyricsBarSettings.fontSize = e.target.value;
              applyLyricsSettings();
            });
          document
            .getElementById("lyrics-bg-opacity-slider")
            .addEventListener("input", (e) => {
              lyricsBarSettings.bgOpacity = e.target.value;
              applyLyricsSettings();
            });
          document
            .getElementById("lyrics-font-color-picker")
            .addEventListener("input", (e) => {
              lyricsBarSettings.fontColor = e.target.value;
              applyLyricsSettings();
            });

          // Ê≠åËØçÊ†è‰∏äÁöÑÂÖ≥Èó≠ÊåâÈíÆ
          document
            .querySelector("#floating-lyrics-bar .close-btn")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              document.getElementById("floating-lyrics-bar").style.display =
                "none";
            });

          // Êí≠ÊîæÂô®ÈáåÁöÑ‚ÄúÊÇ¨ÊµÆ/ÈöêËóè‚ÄùÂºÄÂÖ≥
          document
            .getElementById("toggle-lyrics-bar-btn")
            .addEventListener("click", async (e) => {
              lyricsBarSettings.showOnClose = !lyricsBarSettings.showOnClose;
              e.target.textContent = lyricsBarSettings.showOnClose
                ? "ÊÇ¨ÊµÆ"
                : "ÈöêËóè";
              e.target.style.opacity = lyricsBarSettings.showOnClose
                ? "1"
                : "0.5";
              // Á´ãÂç≥‰øùÂ≠òËøô‰∏™ËÆæÁΩÆ
              state.globalSettings.lyricsBarSettings = lyricsBarSettings;
              await db.globalSettings.put(state.globalSettings);
            });

          // Âú®È°µÈù¢Âä†ËΩΩÊó∂ÔºåÂ∞±Â∫îÁî®‰∏ÄÊ¨°Â∑≤‰øùÂ≠òÁöÑËÆæÁΩÆ
          applyLyricsSettings();
          // ‚ÄúÊü•ËßíËâ≤ÊâãÊú∫‚ÄùÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨Âô®

          // 1. ÁªëÂÆö‰∏ªÂ±èÂπï‰∏äÁöÑ‚ÄúÊü•ÊâãÊú∫‚ÄùAPPÂõæÊ†á
          const checkPhoneAppIcon = document.querySelector(
            '.app-icon[data-app-id="check-phone"]',
          );
          if (checkPhoneAppIcon) {
            checkPhoneAppIcon.onclick = openCharacterSelectionScreen; // ‰øÆÊîπonclick‰∫ã‰ª∂
          }

          // 2. ËßíËâ≤ÈÄâÊã©ÂàóË°®ÁöÑÁÇπÂáª‰∫ã‰ª∂ (‰∫ã‰ª∂ÂßîÊâò)
          document
            .getElementById("character-selection-list")
            .addEventListener("click", (e) => {
              const item = e.target.closest(".character-select-item");
              if (item && item.dataset.chatId) {
                openCharacterPhone(item.dataset.chatId);
              }
            });

          // ËßíËâ≤ÊâãÊú∫ËÅäÂ§©ÂàóË°®ÁöÑÁÇπÂáª‰∫ã‰ª∂ (‰∫ã‰ª∂ÂßîÊâò)
          document
            .getElementById("character-chat-list")
            .addEventListener("click", (e) => {
              const item = e.target.closest(".chat-list-item");
              if (item && item.dataset.contactName) {
                const isUserChat = item.dataset.isUserChat === "true";
                console.log("„ÄêËØäÊñ≠Êó•Âøó 2„Äë: ÁÇπÂáª‰∫ÜËÅäÂ§©ÂàóË°®È°π", {
                  contactName: item.dataset.contactName,
                  isUserChat: isUserChat,
                });

                // Â∞ÜËÅîÁ≥ª‰∫∫ÂêçÂ≠óÂíå‚ÄúË∫´‰ªΩËØÅ‚Äù‰∏ÄËµ∑‰º†ÈÄíÁªôÊ∏≤ÊüìÂáΩÊï∞
                renderCharacterChatHistory(
                  item.dataset.contactName,
                  isUserChat,
                );
                showCharacterPhonePage("character-chat-history-screen");
              }
            });

          // 3. ËßíËâ≤ÊâãÊú∫È°∂ÈÉ®ÁöÑ‚ÄúÂà∑Êñ∞‚ÄùÂíå‚ÄúÊ∏ÖÁ©∫‚ÄùÊåâÈíÆ
          document
            .getElementById("generate-character-data-btn")
            .addEventListener("click", generateCharacterPhoneData);
          document
            .getElementById("clear-character-data-btn")
            .addEventListener("click", clearCharacterPhoneData);

          // ËßíËâ≤ÊâãÊú∫ÂÜÖÈÉ®Áªü‰∏ÄËøîÂõû‰∫ã‰ª∂ÁõëÂê¨Âô®
          document
            .getElementById("character-phone-container")
            .addEventListener("click", (e) => {
              const backBtn = e.target.closest(".back-btn");
              if (!backBtn) return;

              // Ê£ÄÊü•ÊòØËøîÂõûÂà∞ËßíËâ≤ÊâãÊú∫ÂÜÖÈÉ®È°µÈù¢ÔºåËøòÊòØËøîÂõûÂà∞‰∏ªÂ±èÂπï
              if (backBtn.dataset.targetPage) {
                showCharacterPhonePage(backBtn.dataset.targetPage);
              } else if (backBtn.dataset.targetScreen) {
                showScreen(backBtn.dataset.targetScreen);
              }
            });

          // ËßíËâ≤ÊâãÊú∫Êó•ËÆ∞APP‰∫ã‰ª∂ÁõëÂê¨Âô®
          document
            .getElementById("character-app-grid")
            .addEventListener("click", (e) => {
              const icon = e.target.closest(".app-icon");
              if (icon && icon.querySelector(".label").textContent === "Diary") {
                renderCharacterDiary();
              }
            });
          document
            .getElementById("generate-diary-entry-btn")
            .addEventListener("click", generateNewDiaryEntry);

          // ‚ÄúÊü•ÊâãÊú∫‚ÄùÂÜÖÂÆπÂçïÊù°Âà†Èô§ÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("character-phone-container")
            .addEventListener("click", (e) => {
              const deleteBtn = e.target.closest(".item-delete-btn");
              if (deleteBtn) {
                // Â§ÑÁêÜÂæÆ‰ø°Ê∂àÊÅØÂà†Èô§
                if (deleteBtn.classList.contains("message-delete-btn")) {
                  const contactName = deleteBtn.dataset.contactName;
                  const index = parseInt(deleteBtn.dataset.index);
                  if (contactName && !isNaN(index)) {
                    handleCharacterChatMessageDeletion(contactName, index);
                  }
                }
                // Â§ÑÁêÜÂÖ∂‰ªñÂàóË°®Âà†Èô§
                else {
                  const dataType = deleteBtn.dataset.type;
                  const index = parseInt(deleteBtn.dataset.index);
                  if (dataType && !isNaN(index)) {
                    handleCharacterDataDeletion(dataType, index);
                  }
                }
              }
            });

          // NPCÂ∫ìÁÆ°ÁêÜÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö

          // ËÅäÂ§©ËÆæÁΩÆÈáåÁöÑ‚ÄúÁÆ°ÁêÜNPCÂ∫ì‚ÄùÊåâÈíÆ
          document
            .getElementById("chat-settings-modal")
            .addEventListener("click", (e) => {
              if (e.target.id === "manage-npcs-btn") {
                // ÂÖàÂÖ≥Èó≠ËÅäÂ§©ËÆæÁΩÆÔºåÂÜçÊâìÂºÄNPCÁÆ°ÁêÜ
                document
                  .getElementById("chat-settings-modal")
                  .classList.remove("visible");
                openNpcManager();
              }
            });

          // NPCÁÆ°ÁêÜÁïåÈù¢ÁöÑËøîÂõûÊåâÈíÆ
          document
            .getElementById("back-from-npc-management")
            .addEventListener("click", () => {
              // ËøîÂõûÊó∂ÔºåÈáçÊñ∞ÊâìÂºÄËÅäÂ§©ËÆæÁΩÆ
              showScreen("chat-interface-screen");
              document.getElementById("chat-settings-btn").click();
            });

          // NPCÁÆ°ÁêÜÁïåÈù¢ÁöÑ‚Äú+‚ÄùÊåâÈíÆ
          document
            .getElementById("add-new-npc-btn")
            .addEventListener("click", () => openNpcEditor(null));

          // --- ÂêéÂè∞Ê¥ªÂä®ËÆæÁΩÆÁïåÈù¢ÁöÑ‰∫ã‰ª∂ÁªëÂÆö ---

          // 1. ÊÄªÂºÄÂÖ≥ÁöÑ‰∫ã‰ª∂
          document
            .getElementById("background-activity-switch")
            .addEventListener("change", () => {
              // ÊØèÊ¨°ÁÇπÂáªÊÄªÂºÄÂÖ≥ÔºåÈÉΩÈáçÊñ∞Ê∏≤Êüì‰∏ÄÊ¨°ËØ¶ÁªÜËÆæÁΩÆÂå∫ÔºàÂÆÉ‰ºöÊ†πÊçÆÂºÄÂÖ≥Áä∂ÊÄÅËá™Âä®ÊòæÁ§∫ÊàñÈöêËóèÔºâ
              renderBackgroundFrequencySelector();
            });

          // 2. ÂÖ®ÈÄâÊåâÈíÆ
          document
            .getElementById("bg-select-all-chars")
            .addEventListener("click", () => {
              document
                .querySelectorAll(".bg-char-checkbox")
                .forEach((checkbox) => {
                  checkbox.checked = true;
                });
            });

          // 3. ÂÖ®‰∏çÈÄâÊåâÈíÆ
          document
            .getElementById("bg-deselect-all-chars")
            .addEventListener("click", () => {
              document
                .querySelectorAll(".bg-char-checkbox")
                .forEach((checkbox) => {
                  checkbox.checked = false;
                });
            });

          document
            .querySelector("#background-activity-details")
            .addEventListener("click", async (e) => {
              // Ê≥®ÊÑèËøôÈáåÂä†‰∫Ü async
              if (e.target.classList.contains("bg-freq-btn")) {
                const freq = e.target.dataset.freq;
                const selectedCheckboxes = document.querySelectorAll(
                  ".bg-char-checkbox:checked",
                );

                if (selectedCheckboxes.length === 0) {
                  alert("ËØ∑ÂÖàÈÄâÊã©Ëá≥Â∞ë‰∏Ä‰∏™ËßíËâ≤ÔºÅ");
                  return;
                }

                const config =
                  state.globalSettings.backgroundActivityConfig || {};
                selectedCheckboxes.forEach((checkbox) => {
                  const chatId = checkbox.dataset.chatId;
                  if (freq === "none") {
                    delete config[chatId];
                  } else {
                    config[chatId] = freq;
                  }
                });

                state.globalSettings.backgroundActivityConfig = config;

                // ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ ËøôÂ∞±ÊòØÊàë‰ª¨Êñ∞Âä†ÁöÑÂÖ≥ÈîÆ‰ª£Á†ÅÔºÅ‚òÖ‚òÖ‚òÖ
                await db.globalSettings.put(state.globalSettings);

                renderBackgroundFrequencySelector();

                const freqTextMap = {
                  low: "‰Ωé",
                  medium: "‰∏≠",
                  high: "È´ò",
                  none: "ÂÖ≥Èó≠",
                };
                const freqText = freqTextMap[freq];
                alert(
                  `Â∑≤‰∏∫ ${selectedCheckboxes.length} ‰∏™ËßíËâ≤Â∞ÜÂêéÂè∞Ê¥ªÂä®È¢ëÁéáËÆæ‰∏∫ "${freqText}"`,
                );
              }
            });
          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÔºå‰∏∫ÊâÄÊúâÂèØÁºñËæëÂÖÉÁ¥†Áªü‰∏ÄÁªëÂÆöÁÇπÂáª‰∫ã‰ª∂

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÔºå‰∏∫ÊâÄÊúâÂèØÁºñËæëÂÖÉÁ¥†Áªü‰∏ÄÁªëÂÆöÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("home-screen")
            .addEventListener("click", async (e) => {
              // <-- ÊääËøôË°å‰πüÊîπÊàê async
              // ‰ΩøÁî® .closest() Êù•Á°Æ‰øùÂç≥‰ΩøÁÇπÂáªÂà∞Â≠êÂÖÉÁ¥†‰πüËÉΩÊ≠£Á°ÆËß¶Âèë
              const editableText = e.target.closest(".editable-text");
              if (editableText) {
                handleEditText(editableText);
                return; // Â§ÑÁêÜÂÆåÂ∞±ÈÄÄÂá∫ÔºåÈÅøÂÖçÈáçÂ§çËß¶Âèë
              }

              const editableImage = e.target.closest(".editable-image");
              if (editableImage) {
                // 1. Âà§Êñ≠Ë¢´ÁÇπÂáªÁöÑÂõæÁâáÊòØ‰∏çÊòØ‰∏ªÂ±èÂπïÁöÑÈÇ£‰∏™Â§ßÂ§¥ÂÉè
                if (editableImage.id === "profile-avatar-img") {
                  // 2. Â¶ÇÊûúÊòØÔºåÂ∞±ÂºπÂá∫‰∏Ä‰∏™ÈÄâÊã©ËèúÂçï
                  const choice = await showChoiceModal("ÁºñËæëÂ§¥ÂÉè", [
                    { text: "Êõ¥Êç¢Â§¥ÂÉèÂõæÁâá", value: "avatar" },
                    { text: "Êõ¥Êç¢Â§¥ÂÉèÊ°Ü", value: "frame" },
                  ]);

                  // 3. Ê†πÊçÆÁî®Êà∑ÁöÑÈÄâÊã©ÔºåÊâßË°å‰∏çÂêåÁöÑÊìç‰Ωú
                  if (choice === "avatar") {
                    handleEditImage(editableImage); // Ë∞ÉÁî®ÂéüÊù•ÁöÑÊõ¥Êç¢ÂõæÁâáÂáΩÊï∞
                  } else if (choice === "frame") {
                    openFrameSelectorModal("home_profile"); // Ë∞ÉÁî®Êàë‰ª¨Êñ∞Â¢ûÁöÑÊõ¥Êç¢Â§¥ÂÉèÊ°ÜÂáΩÊï∞
                  }
                } else {
                  // 4. Â¶ÇÊûúÁÇπÂáªÁöÑ‰∏çÊòØ‰∏ªÂ§¥ÂÉèÔºàÊØîÂ¶ÇÊòØÂÖ∂‰ªñÂ∞èÁªÑ‰ª∂ÁöÑÂõæÁâáÔºâÔºåÂ∞±ËøòÊâßË°åÂéüÊù•ÁöÑÈÄªËæë
                  handleEditImage(editableImage);
                }

                return;
              }
            });

          // ‚ñº‚ÄúÊü•ÊâãÊú∫‚ÄùÂÜÖÂÆπÂçïÊù°Âà†Èô§ÂäüËÉΩ
          /**
           * Â§ÑÁêÜËßíËâ≤ÊâãÊú∫ÂÜÖÊï∞ÊçÆÂà†Èô§ÁöÑÈÄöÁî®ÂáΩÊï∞
           * @param {string} dataType - Ë¶ÅÂà†Èô§ÁöÑÊï∞ÊçÆÁ±ªÂûã, ÊØîÂ¶Ç 'memos', 'shoppingCart'
           * @param {number} index - Ë¶ÅÂà†Èô§ÁöÑÊï∞ÊçÆÂú®Êï∞ÁªÑ‰∏≠ÁöÑÁ¥¢Âºï
           */
          async function handleCharacterDataDeletion(dataType, index) {
            if (!activeCharacterPhoneId) return;
            const chat = state.chats[activeCharacterPhoneId];

            let dataArray;

            if (dataType.includes(".")) {
              const keys = dataType.split(".");
              dataArray = chat.characterPhoneData[keys[0]][keys[1]];
            } else {
              dataArray = chat.characterPhoneData[dataType];
            }

            if (!chat || !dataArray) return;

            const itemToDelete = dataArray[index];
            if (!itemToDelete) return;

            const confirmed = await showCustomConfirm(
              "Á°ÆËÆ§Âà†Èô§",
              "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËÆ∞ÂΩïÂêóÔºü",
              {
                confirmButtonClass: "btn-danger",
              },
            );

            if (confirmed) {
              dataArray.splice(index, 1);
              await db.chats.put(chat);

              // Ê†πÊçÆÂà†Èô§ÁöÑÁ±ªÂûãÔºåÈáçÊñ∞Ê∏≤ÊüìÂØπÂ∫îÁöÑAPPÁïåÈù¢
              switch (dataType) {
                case "memos":
                  renderCharacterMemos();
                  break;
                case "shoppingCart":
                  renderCharacterShoppingCart();
                  break;
                case "browserHistory":
                  renderCharacterBrowser();
                  break;
                case "diary":
                  renderCharacterDiary();
                  break;
                case "bank.transactions":
                  renderCharacterBank();
                  break; // Êñ∞Â¢û
                case "trajectory":
                  renderCharacterTrajectory();
                  break; // Êñ∞Â¢û
                case "appUsage":
                  renderCharacterAppUsage();
                  break; // Êñ∞Â¢û
                case "photoAlbum":
                  renderCharacterPhotoAlbum();
                  break; // Êñ∞Â¢û
              }
              alert("ËÆ∞ÂΩïÂ∑≤Âà†Èô§„ÄÇ");
            }
          }
          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÊù•Â§ÑÁêÜÊâÄÊúâÂà†Èô§ÊåâÈíÆÁöÑÁÇπÂáª
          document
            .getElementById("character-phone-container")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("item-delete-btn")) {
                const dataType = e.target.dataset.type;
                const index = parseInt(e.target.dataset.index);
                if (dataType && !isNaN(index)) {
                  handleCharacterDataDeletion(dataType, index);
                }
              }
            });

          // ‚ÄúÊü•ÊâãÊú∫‚ÄùÂÜÖÂÆπÂçïÊù°Âà†Èô§ÂäüËÉΩ
          /**
           * Â§ÑÁêÜËßíËâ≤ÊâãÊú∫ÂÜÖÊï∞ÊçÆÂà†Èô§ÁöÑÈÄöÁî®ÂáΩÊï∞
           * @param {string} dataType - Ë¶ÅÂà†Èô§ÁöÑÊï∞ÊçÆÁ±ªÂûã, ÊØîÂ¶Ç 'memos', 'shoppingCart'
           * @param {number} index - Ë¶ÅÂà†Èô§ÁöÑÊï∞ÊçÆÂú®Êï∞ÁªÑ‰∏≠ÁöÑÁ¥¢Âºï
           */
          async function handleCharacterDataDeletion(dataType, index) {
            if (!activeCharacterPhoneId) return;
            const chat = state.chats[activeCharacterPhoneId];

            let dataArray;
            // Â§ÑÁêÜÂÉè bank.transactions ËøôÊ†∑ÁöÑÂµåÂ•óÊï∞ÊçÆ
            if (dataType.includes(".")) {
              const keys = dataType.split(".");
              dataArray = chat.characterPhoneData[keys[0]][keys[1]];
            } else {
              dataArray = chat.characterPhoneData[dataType];
            }

            if (!chat || !dataArray) return;

            const itemToDelete = dataArray[index];
            if (!itemToDelete) return;

            const confirmed = await showCustomConfirm(
              "Á°ÆËÆ§Âà†Èô§",
              "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËÆ∞ÂΩïÂêóÔºü",
              {
                confirmButtonClass: "btn-danger",
              },
            );

            if (confirmed) {
              dataArray.splice(index, 1);
              await db.chats.put(chat);

              // Ê†πÊçÆÂà†Èô§ÁöÑÁ±ªÂûãÔºåÈáçÊñ∞Ê∏≤ÊüìÂØπÂ∫îÁöÑAPPÁïåÈù¢
              switch (dataType) {
                case "memos":
                  renderCharacterMemos();
                  break;
                case "shoppingCart":
                  renderCharacterShoppingCart();
                  break;
                case "browserHistory":
                  renderCharacterBrowser();
                  break;
                case "diary":
                  renderCharacterDiary();
                  break;
                case "bank.transactions":
                  renderCharacterBank();
                  break;
                case "trajectory":
                  renderCharacterTrajectory();
                  break;
                case "appUsage":
                  renderCharacterAppUsage();
                  break;
                case "photoAlbum":
                  renderCharacterPhotoAlbum();
                  break;
              }
              alert("ËÆ∞ÂΩïÂ∑≤Âà†Èô§„ÄÇ");
            }
          }

          startGroupSimulation(); // ÂêØÂä®Áæ§ËÅä‰∏ìÂ±ûÁöÑÂêéÂè∞Êó∂Èíü
          handleAutoBackupTimer();
          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÔºåÁõëÂê¨Êï¥‰∏™Âä®ÊÄÅÂàóË°®ÁöÑ‚ÄúÁÑ¶ÁÇπÁßªÂá∫‚Äù‰∫ã‰ª∂
          document
            .getElementById("qzone-posts-list")
            .addEventListener("focusout", (e) => {
              // Â¶ÇÊûúÊòØËØÑËÆ∫ËæìÂÖ•Ê°ÜÂ§±Âéª‰∫ÜÁÑ¶ÁÇπ
              if (e.target.classList.contains("comment-input")) {
                const commentInput = e.target;
                // Âπ∂‰∏îËæìÂÖ•Ê°ÜÊòØÁ©∫ÁöÑ
                if (commentInput.value.trim() === "") {
                  // Â∞±ÈáçÁΩÆÂÆÉÁöÑÁä∂ÊÄÅÔºåÂèñÊ∂àÂõûÂ§ç
                  commentInput.placeholder = "ÂèãÂñÑÁöÑËØÑËÆ∫ÊòØ‰∫§ÊµÅÁöÑËµ∑ÁÇπ";
                  delete commentInput.dataset.replyTo;
                }
              }
            });

          // ‰∏∫Êó∂Èó¥ÊÑüÁü•ÂºÄÂÖ≥Ê∑ªÂä†ÂÆûÊó∂‰∫§‰∫í‰∫ã‰ª∂
          document
            .getElementById("time-perception-toggle")
            .addEventListener("change", (e) => {
              const customTimeContainer = document.getElementById(
                "custom-time-container",
              );
              customTimeContainer.style.display = e.target.checked
                ? "none"
                : "block";
            });

          document
            .getElementById("char-heart-btn")
            .addEventListener("click", openInnerVoiceModal);

          document
            .getElementById("close-inner-voice-modal")
            .addEventListener("click", () => {
              document
                .getElementById("inner-voice-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("inner-voice-history-btn")
            .addEventListener("click", toggleInnerVoiceHistory);
          document
            .getElementById("back-from-history-btn")
            .addEventListener("click", toggleInnerVoiceHistory);

          /**
           * ÂØºÂá∫ÂΩìÂâçËßíËâ≤ÁöÑËÅäÂ§©ËÆ∞ÂΩï
           */
          async function exportChatHistory() {
            if (!state.activeChatId) return;
            const chat = state.chats[state.activeChatId];
            if (!chat) return;

            // 1. ÂàõÂª∫‰∏Ä‰∏™Âè™ÂåÖÂê´ËÅäÂ§©ËÆ∞ÂΩïÂíåËßíËâ≤ÂêçÁöÑÂØπË±°
            const exportData = {
              characterName: chat.name,
              exportedAt: new Date().toISOString(),
              history: chat.history,
            };

            // 2. Â∞ÜËøô‰∏™ÂØπË±°ËΩ¨Êç¢‰∏∫Ê†ºÂºèÂåñÁöÑJSONÂ≠óÁ¨¶‰∏≤
            const jsonString = JSON.stringify(exportData, null, 2);

            // 3. ÂàõÂª∫‰∏Ä‰∏™BlobÂØπË±°
            const blob = new Blob([jsonString], { type: "application/json" });

            // 4. ÂàõÂª∫‰∏Ä‰∏™‰∏¥Êó∂ÁöÑ‰∏ãËΩΩÈìæÊé•
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");

            // 5. ËÆæÁΩÆ‰∏ãËΩΩÈìæÊé•ÁöÑÂ±ûÊÄßÔºåÂåÖÊã¨Êñá‰ª∂Âêç
            const dateStr = new Date().toISOString().split("T")[0];
            link.href = url;
            link.download = `[${chat.name}]-ËÅäÂ§©ËÆ∞ÂΩï-${dateStr}.json`;

            // 6. Ê®°ÊãüÁÇπÂáªÈìæÊé•Êù•Ëß¶Âèë‰∏ãËΩΩ
            document.body.appendChild(link);
            link.click();

            // 7. Ê∏ÖÁêÜ‰∏¥Êó∂ÂàõÂª∫ÁöÑÂÖÉÁ¥†ÂíåURL
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            await showCustomAlert(
              "ÂØºÂá∫ÊàêÂäü",
              `‰∏é‚Äú${chat.name}‚ÄùÁöÑËÅäÂ§©ËÆ∞ÂΩïÂ∑≤ÂºÄÂßã‰∏ãËΩΩÔºÅ`,
            );
          }

          /**
           * ÂØºÂÖ•ËÅäÂ§©ËÆ∞ÂΩïÂà∞ÂΩìÂâçËßíËâ≤
           */
          async function importChatHistory(file) {
            if (!file) return;
            if (!state.activeChatId) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const data = JSON.parse(e.target.result);

                // ÂÖ≥ÈîÆÈ™åËØÅÔºöÊ£ÄÊü•ÂØºÂÖ•ÁöÑÊñá‰ª∂ÊòØÂê¶ÂåÖÂê´‰∏Ä‰∏™Âêç‰∏∫ 'history' ÁöÑÊï∞ÁªÑ
                if (!data.history || !Array.isArray(data.history)) {
                  throw new Error("Êñá‰ª∂Ê†ºÂºè‰∏çÊ≠£Á°ÆÔºåÁº∫Â∞ëÊúâÊïàÁöÑ'history'Êï∞ÊçÆ„ÄÇ");
                }

                const chat = state.chats[state.activeChatId];

                // ÂÆâÂÖ®Ë≠¶ÂëäÔºöÊèêÈÜíÁî®Êà∑ËøôÂ∞ÜË¶ÜÁõñÁé∞ÊúâËÆ∞ÂΩï
                const confirmed = await showCustomConfirm(
                  "Á°ÆËÆ§ÂØºÂÖ•",
                  `ËøôÂ∞Ü‰ºö„ÄêË¶ÜÁõñ„Äë‰Ω†‰∏é‚Äú${chat.name}‚ÄùÁöÑÂΩìÂâçÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩï„ÄÇÊ≠§Êìç‰ΩúÊó†Ê≥ïÊí§ÈîÄÔºåÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü`,
                  { confirmButtonClass: "btn-danger" },
                );

                if (confirmed) {
                  // ÊõøÊç¢ÂéÜÂè≤ËÆ∞ÂΩï
                  chat.history = data.history;
                  // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
                  await db.chats.put(chat);
                  // Âà∑Êñ∞ÁïåÈù¢
                  renderChatInterface(state.activeChatId);
                  renderChatList(); // Âà∑Êñ∞ÂàóË°®‰ª•Êõ¥Êñ∞ÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØ
                  await showCustomAlert(
                    "ÂØºÂÖ•ÊàêÂäü",
                    "ËÅäÂ§©ËÆ∞ÂΩïÂ∑≤ÊàêÂäüÂØºÂÖ•Âπ∂Ë¶ÜÁõñÔºÅ",
                  );
                }
              } catch (error) {
                console.error("ÂØºÂÖ•ËÅäÂ§©ËÆ∞ÂΩïÂ§±Ë¥•:", error);
                await showCustomAlert(
                  "ÂØºÂÖ•Â§±Ë¥•",
                  `Êó†Ê≥ïÂØºÂÖ•Êñá‰ª∂ÔºåËØ∑Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶‰∏∫Ê≠£Á°ÆÁöÑËÅäÂ§©ËÆ∞ÂΩïÂ§á‰ªΩÊñá‰ª∂„ÄÇ\n\nÈîôËØØ: ${error.message}`,
                );
              }
            };
            reader.readAsText(file, "UTF-8");
          }

          // ‚ñºÊ∞îÊ≥°Ê†∑ÂºèÈ¢ÑËÆæÂØºÂÖ•/ÂØºÂá∫ÂäüËÉΩ

          /**
           * ÂØºÂá∫ÂΩìÂâçÈÄâ‰∏≠ÁöÑÊ∞îÊ≥°Ê†∑ÂºèÈ¢ÑËÆæ
           */
          async function exportSelectedBubblePreset() {
            const selectEl = document.getElementById(
              "bubble-style-preset-select",
            );
            const selectedId = parseInt(selectEl.value);

            if (!selectedId) {
              alert("ËØ∑ÂÖà‰ªé‰∏ãÊãâÊ°Ü‰∏≠ÈÄâÊã©‰∏Ä‰∏™Ë¶ÅÂØºÂá∫ÁöÑÈ¢ÑËÆæ„ÄÇ");
              return;
            }

            const preset = await db.bubbleStylePresets.get(selectedId);
            if (!preset) {
              alert("Êâæ‰∏çÂà∞ÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæ„ÄÇ");
              return;
            }

            // ÂáÜÂ§áË¶ÅÂØºÂá∫ÁöÑÊï∞ÊçÆ
            const exportData = {
              presetName: preset.name,
              presetCss: preset.css,
            };

            // ÂàõÂª∫Âπ∂Ëß¶Âèë‰∏ãËΩΩ
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `[EPhoneÊ∞îÊ≥°]${preset.name}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }

          /**
           * ÂØºÂÖ•Ê∞îÊ≥°È¢ÑËÆæ (ÊîØÊåÅ JSON, TXT, CSS, DOCX)
           * Â¶ÇÊûúÊòØ JSONÔºå‰øùÂ≠ò‰∏∫È¢ÑËÆæÔºõÂ¶ÇÊûúÊòØ TXT/DOCXÔºåÁõ¥Êé•Â°´ÂÖ•ËæìÂÖ•Ê°Ü
           */
          function importBubblePreset(file) {
            if (!file) return;

            const fileName = file.name.toLowerCase();
            const customCssInput = document.getElementById("custom-css-input"); // Ëé∑ÂèñÊ∞îÊ≥°CSSËæìÂÖ•Ê°Ü

            // --- ÊÉÖÂÜµA: Word ÊñáÊ°£ ---
            if (fileName.endsWith(".docx")) {
              const reader = new FileReader();
              reader.onload = function (e) {
                mammoth
                  .extractRawText({ arrayBuffer: e.target.result })
                  .then(function (result) {
                    customCssInput.value = result.value; // Â°´ÂÖ•ËæìÂÖ•Ê°Ü
                    updateSettingsPreview(); // Âà∑Êñ∞È¢ÑËßà
                    alert(
                      "Â∑≤‰ªéWordÊèêÂèñCSS‰ª£Á†ÅÂà∞ËæìÂÖ•Ê°ÜÔºÅ(ËØ∑ÁÇπÂáª‚Äú‰øùÂ≠ò‚Äù‰ª•Â≠ò‰∏∫È¢ÑËÆæ)",
                    );
                  })
                  .catch(function (err) {
                    alert("ËØªÂèñWordÊñá‰ª∂Â§±Ë¥•");
                  });
              };
              reader.readAsArrayBuffer(file);
              return;
            }

            // --- ÊÉÖÂÜµB: ÊñáÊú¨Êñá‰ª∂ ---
            if (fileName.endsWith(".txt") || fileName.endsWith(".css")) {
              const reader = new FileReader();
              reader.onload = function (e) {
                customCssInput.value = e.target.result; // Â°´ÂÖ•ËæìÂÖ•Ê°Ü
                updateSettingsPreview(); // Âà∑Êñ∞È¢ÑËßà
                alert("Â∑≤ËØªÂèñCSS‰ª£Á†ÅÂà∞ËæìÂÖ•Ê°ÜÔºÅ(ËØ∑ÁÇπÂáª‚Äú‰øùÂ≠ò‚Äù‰ª•Â≠ò‰∏∫È¢ÑËÆæ)");
              };
              reader.readAsText(file);
              return;
            }

            // --- ÊÉÖÂÜµC: JSON Êñá‰ª∂ (‰øùÊåÅÂéüÊúâÈÄªËæë) ---
            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const data = JSON.parse(e.target.result);
                // È™åËØÅÊñá‰ª∂ÂÜÖÂÆπÊòØÂê¶Ê≠£Á°Æ
                if (data.presetName && typeof data.presetCss !== "undefined") {
                  const newPreset = {
                    name: `${data.presetName} (Import)`,
                    css: data.presetCss,
                  };
                  const newId = await db.bubbleStylePresets.add(newPreset);

                  if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
                  state.bubbleStylePresets.push({ id: newId, ...newPreset });

                  // Âà∑Êñ∞‰∏ãÊãâÊ°ÜÂπ∂Ëá™Âä®ÈÄâ‰∏≠Êñ∞ÂØºÂÖ•ÁöÑÈ¢ÑËÆæ
                  renderBubblePresetSelector();
                  document.getElementById("bubble-style-preset-select").value =
                    newId;
                  handlePresetSelectChange();
                  await showCustomAlert(
                    "ÂØºÂÖ•ÊàêÂäü",
                    `Ê∞îÊ≥°È¢ÑËÆæ "${newPreset.name}" Â∑≤ÊàêÂäüÂØºÂÖ•ÔºÅ`,
                  );
                } else {
                  // Â¶ÇÊûú‰∏çÊòØÊ†áÂáÜÈ¢ÑËÆæJSONÔºåÂ∞ùËØïÁõ¥Êé•Â°´ÂÖ•ËæìÂÖ•Ê°Ü
                  customCssInput.value = e.target.result;
                  updateSettingsPreview();
                  alert("JSONÊ†ºÂºè‰∏çÊòØÊ†áÂáÜÈ¢ÑËÆæÔºåÂ∑≤Â∞ÜÂÜÖÂÆπÂ°´ÂÖ•ËæìÂÖ•Ê°Ü„ÄÇ");
                }
              } catch (error) {
                // Ëß£ÊûêÂá∫ÈîôÔºåÂΩì‰ΩúÁ∫ØÊñáÊú¨Â°´ÂÖ•
                customCssInput.value = e.target.result;
                updateSettingsPreview();
                alert("Â∑≤Â∞ÜÊñá‰ª∂ÂÜÖÂÆπÂ°´ÂÖ•ËæìÂÖ•Ê°Ü„ÄÇ");
              }
            };
            reader.readAsText(file);
          }

          // --- Â°îÁΩóÁâåÂç†ÂçúÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö ---
          document
            .getElementById("open-tarot-btn")
            .addEventListener("click", openTarotModal);
          document
            .getElementById("close-tarot-modal-btn")
            .addEventListener("click", () => {
              document
                .getElementById("tarot-divination-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("draw-tarot-cards-btn")
            .addEventListener("click", handleDrawCards);
          document
            .getElementById("back-to-tarot-setup-btn")
            .addEventListener("click", () => {
              document.getElementById("tarot-result-view").style.display =
                "none";
              document.getElementById("tarot-setup-view").style.display =
                "block";
            });
          document
            .getElementById("send-tarot-result-btn")
            .addEventListener("click", sendTarotReadingToChat);
          document
            .getElementById("tarot-history-btn")
            .addEventListener("click", openTarotHistory);
          document
            .getElementById("back-to-tarot-main-btn")
            .addEventListener("click", () => {
              document.getElementById("tarot-history-view").style.display =
                "none";
              document.getElementById("tarot-setup-view").style.display =
                "block";
            });
          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÂ§ÑÁêÜÂéÜÂè≤ËÆ∞ÂΩïÁöÑÂà†Èô§ÊåâÈíÆ
          document
            .getElementById("tarot-history-list")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("tarot-history-delete-btn")) {
                const readingId = parseInt(e.target.dataset.id);
                if (!isNaN(readingId)) {
                  deleteTarotReading(readingId);
                }
              }
            });

          // 1. ÂàùÂßãÂåñÊó∂ÂàõÂª∫ÈªòËÆ§Â∞èÁªÑ
          await initializeDefaultGroups();
          /* === ‰øÆÂ§çÂêéÁöÑ‰∏ªÂ±èÂπïÊªëÂä®ÈÄªËæëÔºàÊîØÊåÅPCÈº†Ê†áÊãñÊãΩÔºâ === */
          function initHomeScreenSlider() {
            const slider = document.querySelector(".home-screen-slider");
            const dots = document.querySelectorAll(".pagination-dots .dot");

            if (!slider || dots.length === 0) return;

            // 1. ÁõëÂê¨ÊªöÂä®‰∫ã‰ª∂ÔºàÁî®‰∫éÊõ¥Êñ∞Â∞èÂúÜÁÇπÁä∂ÊÄÅÔºâ
            slider.addEventListener("scroll", () => {
              const pageIndex = Math.round(
                slider.scrollLeft / slider.clientWidth,
              );
              dots.forEach((dot, index) => {
                dot.classList.toggle("active", index === pageIndex);
              });
            });

            // 2. PCÁ´ØÈº†Ê†áÊãñÊãΩÊªëÂä®ÈÄªËæë
            let isDown = false;
            let startX;
            let scrollLeft;

            slider.addEventListener("mousedown", (e) => {
              isDown = true;
              slider.style.cursor = "grabbing"; // ÊîπÂèòÈº†Ê†áÊ†∑Âºè
              startX = e.pageX - slider.offsetLeft;
              scrollLeft = slider.scrollLeft;
              // Èò≤Ê≠¢ÊãñÂä®Êó∂ÈÄâ‰∏≠ÊñáÊú¨
              e.preventDefault();
            });

            slider.addEventListener("mouseleave", () => {
              isDown = false;
              slider.style.cursor = "default";
            });

            slider.addEventListener("mouseup", () => {
              isDown = false;
              slider.style.cursor = "default";

              // Èº†Ê†áÊùæÂºÄÊó∂ÔºåËá™Âä®Âê∏ÈôÑÂà∞ÊúÄËøëÁöÑ‰∏ÄÈ°µÔºàÊ®°ÊãüÁøªÈ°µÊïàÊûúÔºâ
              const pageWidth = slider.clientWidth;
              const currentPage = Math.round(slider.scrollLeft / pageWidth);
              slider.scrollTo({
                left: currentPage * pageWidth,
                behavior: "smooth",
              });
            });

            slider.addEventListener("mousemove", (e) => {
              if (!isDown) return;
              e.preventDefault();
              const x = e.pageX - slider.offsetLeft;
              const walk = (x - startX) * 2; // ‰πò‰ª•2ÂèØ‰ª•ËÆ©ÊªëÂä®Êõ¥ÁÅµÊïè
              slider.scrollLeft = scrollLeft - walk;
            });
          }

          initHomeScreenSlider(); // ÂàùÂßãÂåñ‰∏ªÂ±èÂπïÊªëÂä®ÂäüËÉΩ

          // --- È¢úËâ≤ÈÄâÊã©Âô®‰∏éÊñáÊú¨Ê°ÜËÅîÂä®ÈÄªËæë ---
          const colorPicker = document.getElementById(
            "home-icon-widget-text-color-picker",
          );
          const colorInput = document.getElementById(
            "home-icon-widget-text-color-input",
          );

          // 1. ÂΩìÈÄâËâ≤ÁõòÂèòÂåñÊó∂ -> ÂêåÊ≠•ÁªôÊñáÊú¨Ê°Ü + ÂÆûÊó∂Â∫îÁî®
          colorPicker.addEventListener("input", (e) => {
            const color = e.target.value;
            colorInput.value = color.toUpperCase(); // ÂêåÊ≠•ÊñáÂ≠ó
            applyHomeIconWidgetTextColor(color); // ÂÆûÊó∂Â∫îÁî®
          });

          // 2. ÂΩìÊñáÊú¨Ê°ÜËæìÂÖ•Êó∂ -> È™åËØÅ -> ÂêåÊ≠•ÁªôÈÄâËâ≤Áõò + ÂÆûÊó∂Â∫îÁî®
          colorInput.addEventListener("input", (e) => {
            let val = e.target.value;

            // Ëá™Âä®Ê∑ªÂä† # Âè∑ (Â¶ÇÊûúÁî®Êà∑Âøò‰∫ÜÂä†)
            if (val.length > 0 && !val.startsWith("#")) {
              val = "#" + val;
            }

            // ÁÆÄÂçïÁöÑÊ≠£ÂàôÈ™åËØÅÔºöÂøÖÈ°ªÊòØ # Âä†‰∏ä 6‰Ωç 0-9/A-F
            const hexRegex = /^#([0-9A-F]{3}){1,2}$/i;

            if (hexRegex.test(val)) {
              // Â¶ÇÊûúÊ†ºÂºèÊ≠£Á°Æ
              colorPicker.value = val; // ÂêåÊ≠•ÈÄâËâ≤Áõò
              applyHomeIconWidgetTextColor(val); // ÂÆûÊó∂Â∫îÁî®
              // (ÂèØÈÄâ) ÂèØ‰ª•Âú®ËøôÈáåÂéªÊéâÈîôËØØÊèêÁ§∫Ê†∑Âºè
              colorInput.style.color = "inherit";
            } else {
              // Â¶ÇÊûúÊ†ºÂºè‰∏çÂØπÔºå‰∏çÂ∫îÁî®Ôºå‰ΩÜ‰πü‰∏çÈòªÊ≠¢ËæìÂÖ• (ÂèØ‰ª•ÊääÂ≠óÂèòÁ∫¢ÊèêÁ§∫)
              colorInput.style.color = "red";
            }
          });

          // 3. ÂΩìÊñáÊú¨Ê°ÜÂ§±ÂéªÁÑ¶ÁÇπÊó∂ÔºåÂ¶ÇÊûúÂÜÖÂÆπ‰∏çÂÆåÊï¥ÔºåÈáçÁΩÆÂõûÈÄâËâ≤ÁõòÁöÑÂÄº
          colorInput.addEventListener("blur", () => {
            colorInput.value = colorPicker.value.toUpperCase();
            colorInput.style.color = "inherit";
          });

          // ‰∏ªÂ±èÂπïÂ≠ó‰ΩìÈò¥ÂΩ±ÂºÄÂÖ≥ÁöÑÂÆûÊó∂È¢ÑËßà‰∫ã‰ª∂
          document
            .getElementById("remove-home-font-shadow-toggle")
            .addEventListener("change", (e) => {
              document
                .getElementById("phone-screen")
                .classList.toggle("no-home-font-shadow", e.target.checked);
            });
          // ÂÆ†Áâ©ÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨Âô®
          // 1. ÁªëÂÆöËæìÂÖ•Ê°Ü‰∏äÊñπÁöÑÂÆ†Áâ©ÂõæÊ†áÊåâÈíÆ
          document
            .getElementById("pet-action-btn")
            .addEventListener("click", openPetModal);

          // 2. ÁªëÂÆöÂÆ†Áâ©ÂºπÁ™óÂÜÖÁöÑÂêÑÁßçÊåâÈíÆ
          document
            .getElementById("pet-modal-cancel-btn")
            .addEventListener("click", () => {
              document.getElementById("pet-modal").classList.remove("visible");
              currentPetData = null; // ÂèñÊ∂àÊó∂‰πüË¶ÅÊ∏ÖÁêÜ
            });
          document
            .getElementById("pet-modal-save-btn")
            .addEventListener("click", savePetSettings);

          // 3. ÂÆûÊó∂Êõ¥Êñ∞È¢ÑËßà
          document
            .getElementById("pet-type-input")
            .addEventListener("input", updatePetPreview);
          document
            .getElementById("pet-name-input")
            .addEventListener("input", updatePetPreview);
          document
            .getElementById("pet-image-input")
            .addEventListener("input", updatePetPreview);

          // 4. ‚ÄúÂú®ËÅäÂ§©ÁïåÈù¢ÊòæÁ§∫‚ÄùÂºÄÂÖ≥ÁöÑ‰∫§‰∫í
          document
            .getElementById("pet-display-toggle")
            .addEventListener("change", (e) => {
              document.getElementById("pet-position-controls").style.display = e
                .target.checked
                ? "block"
                : "none";
            });

          // 5. Â∞∫ÂØ∏ÊªëÂùóÁöÑ‰∫§‰∫í
          const sizeSlider = document.getElementById("pet-size-slider");
          sizeSlider.addEventListener("input", () => {
            document.getElementById("pet-size-value").textContent =
              `${sizeSlider.value}px`;
          });

          // 6. ÁªëÂÆöÊõ¥Êç¢Ëá™ÂÆö‰πâÂõæÁâáÁöÑÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("pet-preview-display")
            .addEventListener("click", () => {
              document.getElementById("pet-custom-image-input").click();
            });
          document
            .getElementById("pet-custom-image-input")
            .addEventListener("change", (e) => {
              const file = e.target.files[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                  // Â∞ÜÂõæÁâáÁöÑBase64ÈìæÊé•Áõ¥Êé•Â°´ÂÖ•ËæìÂÖ•Ê°Ü
                  document.getElementById("pet-image-input").value =
                    event.target.result;
                  updatePetPreview(); // Âπ∂Êõ¥Êñ∞È¢ÑËßà
                };
                reader.readAsDataURL(file);
              }
            });

          // 7. ÁªëÂÆö‰∫íÂä®ÊåâÈíÆ (‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâò)
          document
            .getElementById("pet-interaction-area")
            .addEventListener("click", (e) => {
              if (e.target.tagName === "BUTTON" && e.target.dataset.action) {
                handlePetInteraction(e.target.dataset.action);
              }
            });

          // 8. ÂàùÂßãÂåñÂÆ†Áâ©ÁöÑÊãñÂä®ÂäüËÉΩ
          initPetDragging();
          // ÂÆ†Áâ©ËÅäÂ§©ÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("send-to-pet-btn")
            .addEventListener("click", handleSendToPet);
          document
            .getElementById("pet-chat-input")
            .addEventListener("keypress", (e) => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                document.getElementById("send-to-pet-btn").click();
              }
            });

          // ‰∏∫ÂÆ†Áâ©ËÅäÂ§©Á™óÂè£ÁöÑ‚ÄúÂ§ñÈÉ®‚ÄùÁÇπÂáªÊ∑ªÂä†ÂÖ≥Èó≠ÂäüËÉΩ
          const petChatModal = document.getElementById("pet-chat-modal");
          petChatModal.addEventListener("click", (e) => {
            if (e.target === petChatModal) {
              // Âè™ÊúâÁÇπÂáªÁÅ∞Ëâ≤ÈÅÆÁΩ©Â±ÇÊâçÂÖ≥Èó≠
              petChatModal.classList.remove("visible");
            }
          });

          // ‰∏∫‚ÄúÊîæÁîüÂÆ†Áâ©‚ÄùÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("pet-abandon-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;

              const confirmed = await showCustomConfirm(
                "Á°ÆËÆ§ÊîæÁîü",
                "Á°ÆÂÆöË¶ÅÂÖ≥Èó≠ÂÆ†Áâ©Á≥ªÁªüÂêóÔºüËøôÂ∞Ü‰ºöÈáçÁΩÆÊâÄÊúâÂÆ†Áâ©Êï∞ÊçÆÔºàÊï∞ÂÄº„ÄÅËÅäÂ§©ËÆ∞ÂΩïÁ≠âÔºâÔºå‰ΩÜ‰∏ç‰ºöÂà†Èô§‰Ω†ÁöÑËÆæÁΩÆ„ÄÇ‰Ω†ÂèØ‰ª•ÈöèÊó∂ÈáçÊñ∞È¢ÜÂÖª„ÄÇ",
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                const chat = state.chats[state.activeChatId];
                chat.settings.petAdopted = false; // ÂÖ≥Èó≠È¢ÜÂÖªÁä∂ÊÄÅ
                delete chat.settings.pet; // Âà†Èô§ÂÆ†Áâ©Êï∞ÊçÆÂØπË±°

                await db.chats.put(chat);

                renderChatPet(); // ‰ªéËÅäÂ§©ÁïåÈù¢ÁßªÈô§ÂÆ†Áâ©
                document
                  .getElementById("pet-modal")
                  .classList.remove("visible"); // ÂÖ≥Èó≠ÂºπÁ™ó
                alert("ÂÆ†Áâ©Â∑≤ÊîæÁîüÔºåÊ±üÊπñÂÜçËßÅÔºÅ");
              }
            });

          // ÁªëÂÆöÁ∫ø‰∏ãÊ®°ÂºèÈ¢ÑËÆæÁöÑ‰∏ãÊãâÊ°ÜÂíåÁÆ°ÁêÜÊåâÈíÆ
          document
            .getElementById("offline-preset-select")
            .addEventListener("change", handleOfflinePresetSelection);
          document
            .getElementById("manage-offline-presets-btn")
            .addEventListener("click", openOfflinePresetManager);

          // ËÅäÂ§©ÊÄªÁªìÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("view-summaries-btn")
            .addEventListener("click", openSummaryViewer);
          document
            .getElementById("close-summary-viewer-btn")
            .addEventListener("click", () => {
              document
                .getElementById("summary-viewer-modal")
                .classList.remove("visible");
              // ÂÖ≥Èó≠ÂêéÈáçÊñ∞ÊâìÂºÄËÆæÁΩÆÂºπÁ™óÔºåÂõûÂà∞‰∏ä‰∏ÄÁ∫ß
              document.getElementById("chat-settings-btn").click();
            });

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÂ§ÑÁêÜÊÄªÁªìÂàóË°®‰∏≠ÁöÑÊâÄÊúâÊåâÈíÆ
          document
            .getElementById("summary-list")
            .addEventListener("click", (e) => {
              const editBtn = e.target.closest(".edit-summary-btn");
              if (editBtn) {
                const timestamp = parseInt(editBtn.dataset.timestamp);
                editSummary(timestamp);
                return;
              }

              const deleteBtn = e.target.closest(".delete-summary-btn");
              if (deleteBtn) {
                const timestamp = parseInt(deleteBtn.dataset.timestamp);
                deleteSummary(timestamp);
                return;
              }

              // Â§ÑÁêÜÂçïÊù°Á≤æÁÆÄÊåâÈíÆÁöÑÁÇπÂáª
              const conciseBtn = e.target.closest(".concise-summary-btn");
              if (conciseBtn) {
                const timestamp = parseInt(conciseBtn.dataset.timestamp);
                handleConciseSummary(timestamp);
                return;
              }
            });

          // ‰∏∫‚ÄúÂÖ®ÈÉ®Á≤æÁÆÄ‚ÄùÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("concise-all-summaries-btn")
            .addEventListener("click", handleConciseAllSummaries);

          document
            .getElementById("chat-settings-modal")
            .addEventListener("click", (e) => {
              if (e.target.id === "manual-summary-btn") {
                // ÁÇπÂáªÂêéÂÖàÂÖ≥Èó≠ËÆæÁΩÆÂºπÁ™ó
                document
                  .getElementById("chat-settings-modal")
                  .classList.remove("visible");
                // „ÄêË∞ÉÁî®Êàë‰ª¨Êñ∞ÂàõÂª∫ÁöÑÈÄâÊã©ÂáΩÊï∞ÔºåËÄå‰∏çÊòØÁõ¥Êé•ÊÄªÁªì
                openManualSummaryOptions();
              }
            });

          // ËßíËâ≤ÊâãÊú∫Â§ñËßÇËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
          document
            .getElementById("character-phone-container")
            .addEventListener("click", (e) => {
              // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÔºåÂà§Êñ≠ÁÇπÂáªÁöÑÊòØÂì™‰∏™ÊåâÈíÆ
              if (e.target.id === "upload-char-phone-wallpaper-btn") {
                document
                  .getElementById("char-phone-wallpaper-upload-input")
                  .click();
              } else if (e.target.id === "remove-char-phone-wallpaper-btn") {
                handleCharPhoneWallpaperChange(""); // ‰º†ÂÖ•Á©∫Â≠óÁ¨¶‰∏≤Êù•ÁßªÈô§Â£ÅÁ∫∏
              } else {
                const changeIconButton = e.target.closest(".change-icon-btn");
                if (changeIconButton) {
                  const iconId = changeIconButton.dataset.iconId;
                  handleChangeCharPhoneIcon(iconId);
                }
              }
            });

          // ÁõëÂê¨Â£ÅÁ∫∏Êñá‰ª∂ÈÄâÊã©
          document
            .getElementById("char-phone-wallpaper-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.readAsDataURL(file);
                });
                handleCharPhoneWallpaperChange(dataUrl);
              }
              event.target.value = null; // Ê∏ÖÁ©∫Ôºå‰ª•‰æø‰∏ãÊ¨°ËÉΩÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
            });

          /* ËßíËâ≤ÂæÆÂçöËµÑÊñôÁºñËæëÂô®‰∫ã‰ª∂ÁªëÂÆö */

          // 1. ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÔºå‰∏∫ËßíËâ≤ÂæÆÂçöÁºñËæëÂºπÁ™óÂÜÖÁöÑÊâÄÊúâÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("char-weibo-editor-modal")
            .addEventListener("click", (e) => {
              // a. Â¶ÇÊûúÁÇπÂáªÁöÑÊòØ‚ÄúÊõ¥Êç¢Â§¥ÂÉèÊ°Ü‚ÄùÊåâÈíÆ
              if (e.target.classList.contains("change-frame-btn")) {
                const type = e.target.dataset.type; // Ëé∑ÂèñÊåâÈíÆÁ±ªÂûã 'char-weibo'
                const targetId = currentViewingWeiboProfileId; // Ëé∑ÂèñÂΩìÂâçÊ≠£Âú®Êü•ÁúãÁöÑËßíËâ≤ID

                // Ë∞ÉÁî®Â§¥ÂÉèÊ°ÜÈÄâÊã©ÂáΩÊï∞ÔºåÂπ∂‰º†ÂÖ•Ê≠£Á°ÆÁöÑÂèÇÊï∞
                openFrameSelectorModal(type, targetId);
              }
              // b. Â¶ÇÊûúÁÇπÂáªÁöÑÊòØ‚ÄúÂèñÊ∂à‚ÄùÊåâÈíÆ
              else if (e.target.id === "cancel-char-weibo-editor-btn") {
                document
                  .getElementById("char-weibo-editor-modal")
                  .classList.remove("visible");
              }
              // c. Â¶ÇÊûúÁÇπÂáªÁöÑÊòØ‚Äú‰øùÂ≠ò‚ÄùÊåâÈíÆ
              else if (e.target.id === "save-char-weibo-editor-btn") {
                saveCharWeiboProfile();
              }
            });

          // 2. ‰∏∫ËßíËâ≤ÊâãÊú∫ÁöÑÂõæÁâá‰∏ä‰º†ËæìÂÖ•Ê°ÜÁªëÂÆö‰∫ã‰ª∂ÔºàËøôÊòØ‰πãÂâçÂ∞±ÊúâÁöÑÔºåÁ°Æ‰øùÂÆÉÂú®Ê≠£Á°ÆÁöÑ‰ΩçÁΩÆÔºâ
          setupFileUpload("char-weibo-editor-avatar-input", (base64) => {
            document.getElementById("char-weibo-editor-avatar-preview").src =
              base64;
          });
          setupFileUpload("char-weibo-editor-bg-input", (base64) => {
            document.getElementById("char-weibo-editor-bg-preview").src =
              base64;
          });

          /* ËßíËâ≤ÊâãÊú∫Â∞èÁªÑ‰ª∂‰∏ä‰º†ÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö */

          // ËæÖÂä©ÂáΩÊï∞ÔºöÂ§ÑÁêÜÂõæÁâá‰∏ä‰º†ÁöÑÈÄöÁî®ÈÄªËæë
          const handleWidgetUpload = async (widgetKey, inputFileId) => {
            const fileInput = document.getElementById(inputFileId);
            const file = fileInput.files[0];
            if (!file) return;

            const dataUrl = await new Promise((res) => {
              const reader = new FileReader();
              reader.onload = () => res(reader.result);
              reader.readAsDataURL(file);
            });

            const chat = state.chats[activeCharacterPhoneId];
            if (!chat.characterPhoneData.widgets) {
              chat.characterPhoneData.widgets = {};
            }
            chat.characterPhoneData.widgets[widgetKey] = dataUrl;

            await db.chats.put(chat);
            renderCharPhoneAppearanceScreen(); // Âà∑Êñ∞ËÆæÁΩÆÈ°µÈ¢ÑËßà
            openCharacterPhone(activeCharacterPhoneId); // Âà∑Êñ∞ÊâãÊú∫‰∏ªÂ±èÂπï
            alert("Â∞èÁªÑ‰ª∂ÂõæÁâáÂ∑≤Êõ¥Êñ∞ÔºÅ");
            fileInput.value = null; // Ê∏ÖÁ©∫‰ª•‰æø‰∏ãÊ¨°ÈÄâÊã©
          };

          // ËæÖÂä©ÂáΩÊï∞ÔºöÂ§ÑÁêÜÂõæÁâáÁßªÈô§ÁöÑÈÄöÁî®ÈÄªËæë
          const handleWidgetRemove = async (widgetKey) => {
            const chat = state.chats[activeCharacterPhoneId];
            if (
              chat.characterPhoneData.widgets &&
              chat.characterPhoneData.widgets[widgetKey]
            ) {
              delete chat.characterPhoneData.widgets[widgetKey];
              await db.chats.put(chat);
              renderCharPhoneAppearanceScreen();
              openCharacterPhone(activeCharacterPhoneId);
              alert("Â∞èÁªÑ‰ª∂ÂõæÁâáÂ∑≤ÁßªÈô§ÔºÅ");
            }
          };

          // ‰∏∫Âõõ‰∏™Êñ∞ÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("upload-widget-1-btn")
            .addEventListener("click", () => {
              document
                .getElementById("char-phone-widget-1-upload-input")
                .click();
            });
          document
            .getElementById("remove-widget-1-btn")
            .addEventListener("click", () => {
              handleWidgetRemove("widget1_url");
            });
          document
            .getElementById("char-phone-widget-1-upload-input")
            .addEventListener("change", () => {
              handleWidgetUpload(
                "widget1_url",
                "char-phone-widget-1-upload-input",
              );
            });

          document
            .getElementById("upload-widget-2-btn")
            .addEventListener("click", () => {
              document
                .getElementById("char-phone-widget-2-upload-input")
                .click();
            });
          document
            .getElementById("remove-widget-2-btn")
            .addEventListener("click", () => {
              handleWidgetRemove("widget2_url");
            });
          document
            .getElementById("char-phone-widget-2-upload-input")
            .addEventListener("change", () => {
              handleWidgetUpload(
                "widget2_url",
                "char-phone-widget-2-upload-input",
              );
            });

          // ËßíËâ≤ÊâãÊú∫Â§ñËßÇÈ¢ÑËÆæÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("char-phone-preset-selector")
            .addEventListener("change", handleCharPhonePresetSelection);
          document
            .getElementById("apply-char-phone-preset-btn")
            .addEventListener("click", applySelectedCharPhonePreset);
          document
            .getElementById("save-char-phone-preset-btn")
            .addEventListener("click", saveCurrentCharPhonePreset);
          document
            .getElementById("update-char-phone-preset-btn")
            .addEventListener("click", updateSelectedCharPhonePreset);
          document
            .getElementById("rename-char-phone-preset-btn")
            .addEventListener("click", renameSelectedCharPhonePreset);
          document
            .getElementById("delete-char-phone-preset-btn")
            .addEventListener("click", deleteSelectedCharPhonePreset);
          document
            .getElementById("export-char-phone-preset-btn")
            .addEventListener("click", exportCharPhonePreset);
          document
            .getElementById("import-char-phone-preset-btn")
            .addEventListener("click", () => {
              document.getElementById("import-char-phone-preset-input").click();
            });
          document
            .getElementById("import-char-phone-preset-input")
            .addEventListener("change", (e) => {
              importCharPhonePreset(e.target.files[0]);
              e.target.value = null; // Ê∏ÖÁ©∫‰ª•‰æø‰∏ãÊ¨°ËÉΩÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
            });

          // ËßíËâ≤ÊâãÊú∫AppÂÜÖÂ£ÅÁ∫∏ÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö

          // ÁõëÂê¨‚Äú‰∏ä‰º†‚ÄùÊåâÈíÆÁöÑÁÇπÂáªÔºåÂéªËß¶ÂèëÈöêËóèÁöÑÊñá‰ª∂ÈÄâÊã©Âô®
          document
            .getElementById("upload-char-phone-app-wallpaper-btn")
            .addEventListener("click", () => {
              document
                .getElementById("char-phone-app-wallpaper-upload-input")
                .click();
            });

          // ÁõëÂê¨Êñá‰ª∂ÈÄâÊã©Âô®ÁöÑÂèòÂåñ
          document
            .getElementById("char-phone-app-wallpaper-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.readAsDataURL(file);
                });
                // Êñá‰ª∂ËØªÂèñÊàêÂäüÂêéÔºåÁ´ãÂàªË∞ÉÁî®Â§ÑÁêÜÂáΩÊï∞Êù•‰øùÂ≠òÂíåÂ∫îÁî®
                handleCharPhoneAppWallpaperChange(dataUrl);
              }
              event.target.value = null; // Ê∏ÖÁ©∫Ôºå‰ª•‰æø‰∏ãÊ¨°ËÉΩÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
            });

          // ÁõëÂê¨‚ÄúÁßªÈô§‚ÄùÊåâÈíÆÁöÑÁÇπÂáª
          document
            .getElementById("remove-char-phone-app-wallpaper-btn")
            .addEventListener("click", () => {
              // Ë∞ÉÁî®Â§ÑÁêÜÂáΩÊï∞ÔºåÂπ∂‰º†ÂÖ•Á©∫Â≠óÁ¨¶‰∏≤Ë°®Á§∫ÁßªÈô§
              handleCharPhoneAppWallpaperChange("");
            });

          // ÂøÉÂ£∞ËÉåÊôØÊõ¥Êç¢ÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨
          document
            .getElementById("change-inner-voice-bg-btn")
            .addEventListener("click", handleInnerVoiceBgChange);

          document
            .getElementById("inner-voice-bg-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (!file) return;

              // Â∞ÜÂõæÁâáÊñá‰ª∂ËΩ¨Êç¢‰∏∫Base64Ôºå‰ª•‰æø‰øùÂ≠òÂíåÊòæÁ§∫
              const dataUrl = await new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsDataURL(file);
              });

              // Ë∞ÉÁî®‰øùÂ≠òÂáΩÊï∞
              await saveInnerVoiceBackground(dataUrl);

              // ÊØèÊ¨°Áî®ÂÆåÂêéÊ∏ÖÁ©∫Ôºå‰ª•‰æø‰∏ãÊ¨°ËÉΩÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
              event.target.value = null;
            });

          // ÊÉÖ‰æ£Á©∫Èó¥ÂèñÊ∂àÂíåËß£Èô§‚ñº‚ñº‚ñº
          document
            .getElementById("ls-cancel-space-btn")
            .addEventListener("click", handleCancelLoversSpace);
          document
            .getElementById("ls-disconnect-space-btn")
            .addEventListener("click", handleDisconnectLoversSpace);

          document
            .getElementById("member-management-list")
            .addEventListener("click", (e) => {
              const button = e.target.closest(".action-btn");
              if (!button) return;

              const action = button.dataset.action;
              const memberId = button.dataset.memberId;

              if (!action || !memberId) return;

              // --- Â§ÑÁêÜÁî®Êà∑Ëá™Â∑±ÁöÑÊåâÈíÆ ---
              if (memberId === "user") {
                if (action === "set-nickname") handleSetUserNickname();
                if (action === "set-title") handleSetUserTitle();
                // Áî®Êà∑ÁÇπÂáªËá™Â∑±ÁöÑ‚ÄúËß£Á¶Å‚ÄùÊåâÈíÆ
                if (action === "unmute-self") {
                  handleUserUnmute();
                }
                return;
              }

              // --- Â§ÑÁêÜÂÖ∂‰ªñÊàêÂëòÁöÑÊåâÈíÆ ---
              switch (action) {
                case "toggle-admin":
                  handleToggleAdmin(memberId);
                  break;
                case "set-title":
                  handleSetMemberTitle(memberId);
                  break;
                case "transfer-owner":
                  handleTransferOwnership(memberId);
                  break;
                case "remove-member":
                  removeMemberFromGroup(memberId);
                  break;
                case "mute-member": // Á¶ÅË®Ä/Ëß£Á¶ÅÁªü‰∏ÄËµ∞ËøôÈáå
                  handleMuteMember(memberId);
                  break;
              }
            });

          // Áæ§ÂÖ¨ÂëäÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("group-announcement-btn")
            .addEventListener("click", openGroupAnnouncementModal);

          // ÁªëÂÆöÁî®Êà∑Ë°®ÊÉÖÈù¢ÊùøÁöÑÊâπÈáèÂà†Èô§ÊåâÈíÆ
          document
            .getElementById("edit-user-stickers-btn")
            .addEventListener("click", toggleUserStickerSelectionMode);
          document
            .getElementById("done-user-stickers-btn")
            .addEventListener("click", toggleUserStickerSelectionMode);
          document
            .getElementById("delete-selected-user-stickers-btn")
            .addEventListener("click", handleBulkDeleteUserStickers);

          // ÂÖ≥Èó≠Èù¢ÊùøÊó∂Ôºå‰πüË¶ÅÈÄÄÂá∫ÈÄâÊã©Ê®°Âºè
          document
            .getElementById("close-sticker-panel-btn")
            .addEventListener("click", () => {
              exitUserStickerSelectionMode();
              stickerPanel.classList.remove("visible");
            });

          // ËæÖÂä©ÂáΩÊï∞ÔºöÂ§ÑÁêÜÂà†Èô§ÂàÜÁ±ªÊåâÈíÆÁöÑÁÇπÂáª
          function onStickerCategoryDelete(deleteButtonElement) {
            const categoryId = parseInt(deleteButtonElement.dataset.categoryId);
            const categoryName = deleteButtonElement.dataset.categoryName;

            // *** Ë∞ÉËØïÂÖ≥ÈîÆÁÇπ (Debugging Point) ***
            // ËØ∑Âú®ÊµèËßàÂô®‰∏≠Êåâ F12 ÊâìÂºÄÂºÄÂèëËÄÖÂ∑•ÂÖ∑ÔºåÂàáÊç¢Âà∞ "Console" (ÊéßÂà∂Âè∞) Ê†áÁ≠æÈ°µ„ÄÇ
            // ÁÇπÂáªÂà†Èô§ÊåâÈíÆÂêéÔºåÂú®ËøôÈáåÊü•ÁúãËæìÂá∫ÁöÑIDÂíåÂêçÁß∞ÊòØÂê¶ÊòØÊÇ®ÁÇπÂáªÁöÑÈÇ£‰∏Ä‰∏™„ÄÇ
            console.log(
              `[Ë∞ÉËØï] ÂáÜÂ§áÂà†Èô§ÂàÜÁ±ª: ID=${categoryId}, ÂêçÁß∞='${categoryName}'`,
            );

            if (!isNaN(categoryId) && categoryName) {
              handleDeleteStickerCategory(categoryId, categoryName);
            } else {
              console.error(
                "[ÈîôËØØ] Êó†Ê≥ï‰ªéÊåâÈíÆËé∑ÂèñÊúâÊïàÁöÑÂàÜÁ±ªIDÊàñÂêçÁß∞„ÄÇ",
                deleteButtonElement.dataset,
              );
              alert("Âà†Èô§Â§±Ë¥•ÔºöÊó†Ê≥ïËé∑ÂèñÂàÜÁ±ª‰ø°ÊÅØÔºåËØ∑Ê£ÄÊü•‰ª£Á†ÅÊàñÂà∑Êñ∞È°µÈù¢„ÄÇ");
            }
          }

          // ËæÖÂä©ÂáΩÊï∞ÔºöÂ§ÑÁêÜÂàáÊç¢ÂàÜÁ±ªÊåâÈíÆÁöÑÁÇπÂáª
          function onStickerCategorySelect(categoryButtonElement) {
            const categoryIdStr = categoryButtonElement.dataset.categoryId;
            activeStickerCategoryId =
              categoryIdStr === "uncategorized"
                ? "uncategorized"
                : parseInt(categoryIdStr);
            renderStickerPanel(); // ÂàáÊç¢ÂàÜÁ±ªÂπ∂ÈáçÊñ∞Ê∏≤ÊüìË°®ÊÉÖÂàóË°®
          }

          // ÁªëÂÆöËßíËâ≤Ë°®ÊÉÖÁÆ°ÁêÜÈ°µÁöÑÊâπÈáèÂà†Èô§ÊåâÈíÆ
          document
            .getElementById("edit-char-stickers-btn")
            .addEventListener("click", toggleCharStickerSelectionMode);
          document
            .getElementById("done-char-stickers-btn")
            .addEventListener("click", toggleCharStickerSelectionMode);
          document
            .getElementById("delete-selected-char-stickers-btn")
            .addEventListener("click", handleBulkDeleteCharStickers);

          // ËøîÂõûËÅäÂ§©ËÆæÁΩÆÊó∂Ôºå‰πüË¶ÅÈÄÄÂá∫ÈÄâÊã©Ê®°Âºè
          document
            .getElementById("back-from-sticker-manager")
            .addEventListener("click", () => {
              exitCharStickerSelectionMode();
              showScreen("chat-interface-screen");
              document.getElementById("chat-settings-btn").click();
            });

          // ÂøÉÂ£∞Èù¢ÊùøÁºñËæëÊåâÈíÆ‰∫ã‰ª∂ÁõëÂê¨
          document
            .getElementById("inner-voice-modal")
            .addEventListener("click", (e) => {
              if (e.target.closest("#inner-voice-edit-btn")) {
                showInnerVoiceEditOptions();
              }
            });

          // ÂøÉÂ£∞Ê†∑ÂºèÁºñËæëÂô®‰∫ã‰ª∂ÁªëÂÆö
          const ivEditorModal = document.getElementById(
            "inner-voice-editor-modal",
          );
          const ivPanel = document.getElementById("inner-voice-main-panel");

          // ÂÆûÊó∂È¢ÑËßàÂäüËÉΩ
          ivEditorModal.addEventListener("input", (e) => {
            const targetId = e.target.id;
            const value = e.target.value;

            switch (targetId) {
              case "iv-color-clothing":
                ivPanel.style.setProperty("--iv-color-clothing", value);
                break;
              case "iv-color-behavior":
                ivPanel.style.setProperty("--iv-color-behavior", value);
                break;
              case "iv-color-thoughts":
                ivPanel.style.setProperty("--iv-color-thoughts", value);
                break;
              case "iv-color-naughty":
                ivPanel.style.setProperty("--iv-color-naughty", value);
                break;
              case "iv-card-bg-color":
                ivPanel.style.setProperty("--iv-card-bg-rgb", hexToRgb(value));
                break;
              case "iv-opacity-slider":
                document.getElementById("iv-opacity-value").textContent =
                  `${Math.round(value * 100)}%`;
                ivPanel.style.setProperty("--iv-card-opacity", value);
                break;

              case "iv-icon-color":
                ivPanel.style.setProperty("--iv-icon-color", value);
                break;
            }
          });

          // ‰øùÂ≠òÊåâÈíÆ
          document
            .getElementById("iv-editor-save-btn")
            .addEventListener("click", saveInnerVoiceStyles);

          // ÂèñÊ∂àÊåâÈíÆ
          document
            .getElementById("iv-editor-cancel-btn")
            .addEventListener("click", () => {
              ivEditorModal.classList.remove("visible");
              // ÂèñÊ∂àÊó∂ÔºåÈáçÊñ∞Â∫îÁî®‰∏Ä‰∏ã‰øùÂ≠òÂ•ΩÁöÑÊ†∑ÂºèÔºå‰ª•Êí§ÈîÄÈ¢ÑËßàÊîπÂä®
              applySavedInnerVoiceStyles();
            });

          // AIÁîüÊàêÁæ§ÊàêÂëòÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("ai-generate-members-btn")
            .addEventListener("click", openAiGenerateMembersModal);
          document
            .getElementById("cancel-ai-generate-members-btn")
            .addEventListener("click", () => {
              document
                .getElementById("ai-generate-members-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("confirm-ai-generate-members-btn")
            .addEventListener("click", handleGenerateMembers);

          // È¢ÑËÆæÂäüËÉΩÊåâÈíÆ
          document
            .getElementById("dating-preset-select")
            .addEventListener("change", handleDatingPresetSelect);
          document
            .getElementById("manage-dating-presets-btn")
            .addEventListener("click", openDatingPresetManager);

          // --- Ë°®ÊÉÖÂàÜÁ±ªÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö ---
          document
            .getElementById("move-selected-stickers-btn")
            .addEventListener("click", openStickerCategoryModal);
          document
            .getElementById("cancel-sticker-category-btn")
            .addEventListener("click", () => {
              document
                .getElementById("sticker-category-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("confirm-sticker-category-btn")
            .addEventListener("click", handleMoveStickers);
          // È´òÁ∫ßÂØºÂÖ•/ÂØºÂá∫ÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨Âô®
          document
            .getElementById("advanced-transfer-btn")
            .addEventListener("click", openAdvancedTransferModal);

          document
            .getElementById("close-advanced-transfer-btn")
            .addEventListener("click", () => {
              document
                .getElementById("advanced-transfer-modal")
                .classList.remove("visible");
            });

          document
            .getElementById("export-selected-data-btn")
            .addEventListener("click", exportChunkedData);

          document
            .getElementById("import-chunked-data-btn")
            .addEventListener("click", () => {
              document.getElementById("import-chunked-data-input").click();
            });

          document
            .getElementById("import-chunked-data-input")
            .addEventListener("change", (e) => {
              const file = e.target.files[0];
              if (file) {
                importChunkedData(file);
              }
              e.target.value = null; // Ê∏ÖÁ©∫‰ª•‰æø‰∏ãÊ¨°ÈÄâÊã©
            });
          document
            .getElementById("export-for-330-btn")
            .addEventListener("click", exportDataFor330);

          // ‰∏∫‚ÄúÂÖºÂÆπ330Ê†ºÂºèÂØºÂÖ•‚ÄùÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("import-from-330-btn")
            .addEventListener("click", () => {
              // ÁÇπÂáªÊåâÈíÆÊó∂ÔºåËß¶ÂèëÈöêËóèÁöÑÊñá‰ª∂ÈÄâÊã©Âô®
              document.getElementById("import-from-330-input").click();
            });

          // ‰∏∫ÈöêËóèÁöÑÊñá‰ª∂ÈÄâÊã©Âô®ÁªëÂÆöchange‰∫ã‰ª∂
          document
            .getElementById("import-from-330-input")
            .addEventListener("change", (e) => {
              const file = e.target.files[0];
              if (file) {
                // ÂΩìÁî®Êà∑ÈÄâÊã©‰∫ÜÊñá‰ª∂ÂêéÔºåË∞ÉÁî®Êàë‰ª¨ÁöÑÊ†∏ÂøÉÂØºÂÖ•ÂáΩÊï∞
                importFrom330Format(file);
              }
              // ÊØèÊ¨°Áî®ÂÆåÂêéÊ∏ÖÁ©∫ÔºåËøôÊ†∑Áî®Êà∑‰∏ãÊ¨°ËøòËÉΩÈÄâÊã©Âêå‰∏Ä‰∏™Êñá‰ª∂
              e.target.value = null;
            });

          document
            .getElementById("compress-all-images-btn")
            .addEventListener("click", compressAllImagesInDB);
          document
            .getElementById("export-data-stream-btn")
            .addEventListener("click", exportDataStream);
          // Âú® init() ÂáΩÊï∞ÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®Âå∫ÂüüÊú´Â∞æÔºåÁ≤òË¥¥‰∏ãÈù¢ËøôË°å‰ª£Á†Å
          document
            .getElementById("reset-app-names-btn")
            .addEventListener("click", resetAppNamesToDefault);
          document.addEventListener("DOMContentLoaded", function () {
            const toggleCheckbox = document.getElementById("dark-mode-toggle");
            const storageKey = "darkModeManualPref";
            const darkReaderOptions = {
              brightness: 100,
              contrast: 90,
              sepia: 10,
            };
            const manualPref = localStorage.getItem(storageKey);
            if (manualPref === "true") {
              DarkReader.enable(darkReaderOptions);
              toggleCheckbox.checked = true;
            } else if (manualPref === "false") {
              DarkReader.disable();
              toggleCheckbox.checked = false;
            } else {
              DarkReader.auto(darkReaderOptions);
              setTimeout(() => {
                toggleCheckbox.checked = DarkReader.isEnabled();
              }, 100);
            }
            toggleCheckbox.addEventListener("change", function () {
              if (this.checked) {
                DarkReader.enable(darkReaderOptions);
                localStorage.setItem(storageKey, "true");
              } else {
                DarkReader.disable();
                localStorage.setItem(storageKey, "false");
              }
            });
          });

          document
            .getElementById("sticker-category-tabs")
            .addEventListener("click", (event) => {
              const target = event.target;

              // --- ÂßîÊâòÂ§ÑÁêÜ„ÄêÂà†Èô§„ÄëÊåâÈíÆÁöÑÁÇπÂáª ---
              if (target.classList.contains("sticker-category-delete-btn")) {
                event.stopPropagation();

                const parentBtn = target.closest(".sticker-category-btn");
                if (parentBtn) {
                  const categoryId = parseInt(parentBtn.dataset.categoryId);
                  const categoryName = parentBtn.dataset.categoryName;

                  if (!isNaN(categoryId) && categoryName) {
                    handleDeleteStickerCategory(categoryId, categoryName);
                  }
                }
                return;
              }

              // --- ÂßîÊâòÂ§ÑÁêÜ„ÄêÂàáÊç¢ÂàÜÁ±ª„ÄëÊåâÈíÆÁöÑÁÇπÂáª ---
              const categoryBtn = target.closest(".sticker-category-btn");
              if (categoryBtn) {
                const categoryIdStr = categoryBtn.dataset.categoryId;
                activeStickerCategoryId =
                  categoryIdStr === "uncategorized"
                    ? "uncategorized"
                    : parseInt(categoryIdStr);
                renderStickerPanel(); // ÂàáÊç¢ÂàÜÁ±ªÂπ∂ÈáçÊñ∞Ê∏≤ÊüìË°®ÊÉÖÂàóË°®
              }
            });

          // --- ‰∫≤ÂØÜÂÄºÈù¢Êùø‰∫ã‰ª∂ÁªëÂÆö ---

          // 1. ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÔºå‰∏∫Êï¥‰∏™ËÅäÂ§©ÂàóË°®ÁªëÂÆöÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("chat-list")
            .addEventListener("click", (e) => {
              // Ê£ÄÊü•Ë¢´ÁÇπÂáªÁöÑÊòØÂê¶ÊòØÊàë‰ª¨ÁöÑ‰∫≤ÂØÜÂÄºÊåâÈíÆ
              const intimacyBtn = e.target.closest(".intimacy-btn");
              if (intimacyBtn) {
                const chatId = intimacyBtn.dataset.chatId;
                if (chatId) {
                  openIntimacyPanel(chatId);
                }
              }
            });

          // 2. ‰∏∫Èù¢ÊùøÁöÑÂÖ≥Èó≠ÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("close-intimacy-panel")
            .addEventListener("click", () => {
              document
                .getElementById("intimacy-panel")
                .classList.remove("visible");
            });

          document
            .getElementById("open-intimacy-panel-btn")
            .addEventListener("click", () =>
              openIntimacyPanel(state.activeChatId),
            );

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÔºå‰∏∫Âä®ÊÄÅÈ°µÈù¢ÁöÑÂ§¥ÈÉ®ÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
          document
            .getElementById("qzone-screen")
            .addEventListener("click", (e) => {
              // Ê£ÄÊü•ÁÇπÂáªÁöÑÊòØÂê¶ÊòØÊ∏ÖÁ©∫ÊåâÈíÆ
              const clearBtn = e.target.closest("#clear-qzone-posts-btn");
              if (clearBtn) {
                clearAllQzonePosts(); // Â¶ÇÊûúÊòØÔºåÂ∞±Ë∞ÉÁî®Êàë‰ª¨ÂàöÂàöÂàõÂª∫ÁöÑÂáΩÊï∞
                return;
              }
            });

          // 1. ÁªëÂÆö‰∏ªÂ±èÂπï‰∏äÁöÑ‚ÄúÂÖîkËÆ∞Ë¥¶‚ÄùÂõæÊ†áÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("tukey-accounting-app-icon")
            .addEventListener("click", () => {
              // ÊâìÂºÄÊó∂ÔºåÁ°Æ‰øùÈªòËÆ§ÊòæÁ§∫ËÆ∞Ë¥¶Áæ§ËÅä
              switchTukeyView("tukey-group-chat-view");
              showScreen("tukey-accounting-screen");
            });

          // 2. ‰∏∫‚ÄúÂÖîkËÆ∞Ë¥¶‚ÄùÁöÑÂ∫ïÈÉ®ÂØºËà™Ê†èÁªëÂÆö‰∫ã‰ª∂ÂßîÊâò
          document
            .getElementById("tukey-bottom-nav")
            .addEventListener("click", (e) => {
              const navItem = e.target.closest(".tukey-nav-item");
              if (navItem && navItem.dataset.view) {
                switchTukeyView(navItem.dataset.view);
              }
            });

          // Êä•Ë°®È°µÈù¢ÁöÑÁÇπÂáª‰∫ã‰ª∂ÔºàÂ§ÑÁêÜÂà†Èô§Ôºâ
          document
            .getElementById("tukey-reports-view")
            .addEventListener("click", (e) => {
              // Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáª‰∫ÜÂà†Èô§ÊåâÈíÆ
              const deleteBtn = e.target.closest(".delete-record-btn");
              if (deleteBtn) {
                const recordId = parseInt(deleteBtn.dataset.id);
                if (!isNaN(recordId)) {
                  deleteTukeyAccountingRecord(recordId);
                }
              }
            });

          // ‚ÄúkkÊü•Â≤ó‚ÄùÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨Âô®
          document
            .getElementById("kk-checkin-app-icon")
            .addEventListener("click", openKkCheckin);

          document
            .getElementById("kk-char-selection-list")
            .addEventListener("click", (e) => {
              const item = e.target.closest(".character-select-item");
              if (item && item.dataset.chatId) {
                openKkHouseView(item.dataset.chatId);
              }
            });

          document
            .getElementById("kk-back-from-house-view")
            .addEventListener("click", () =>
              showScreen("kk-char-selection-screen"),
            );
          document
            .getElementById("kk-back-from-area-view")
            .addEventListener("click", () =>
              showScreen("kk-house-view-screen"),
            );
          document
            .getElementById("close-kk-computer-modal")
            .addEventListener("click", () =>
              document
                .getElementById("kk-computer-modal")
                .classList.remove("visible"),
            );

          document
            .getElementById("close-file-explorer-modal-btn")
            .addEventListener("click", () =>
              document
                .getElementById("kk-file-explorer-modal")
                .classList.remove("visible"),
            );
          document
            .getElementById("kk-reset-search-btn")
            .addEventListener("click", handleResetKkHouse);
          document
            .getElementById("kk-continue-search-btn")
            .addEventListener("click", handleContinueKkSearch);

          document
            .getElementById("close-kk-computer-modal")
            .addEventListener("click", () =>
              document
                .getElementById("kk-computer-modal")
                .classList.remove("visible"),
            );

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÂ§ÑÁêÜÁîµËÑëÊ°åÈù¢ÊâÄÊúâÂõæÊ†áÁöÑÁÇπÂáª
          document
            .getElementById("kk-computer-desktop")
            .addEventListener("click", (e) => {
              const icon = e.target.closest(".kk-desktop-icon");
              if (!icon) return;

              const computerData =
                state.chats[activeKkCharId]?.houseData?.computer;
              if (!computerData) {
                showCustomAlert("ÈîôËØØ", "Êâæ‰∏çÂà∞ÁîµËÑëÊï∞ÊçÆ„ÄÇ");
                return;
              }

              switch (icon.id) {
                case "kk-browser-icon":
                  const history = computerData.browser_history || [];
                  // „Äê‰øÆÊîπ„Äë‰∏çÂÜçÁî® showCustomAlertÔºåÊîπÁî®Êñ∞ÂÜôÁöÑÂàóË°®Â±ïÁ§∫ÂáΩÊï∞
                  showComputerContentList(
                    "ÊµèËßàÂô®ÂéÜÂè≤ (ÁÇπÂáªÂàÜ‰∫´)",
                    history,
                    "Browser",
                  );
                  break;

                case "kk-movies-icon":
                  const movies = computerData.movies || [];
                  // „Äê‰øÆÊîπ„ÄëÂêå‰∏ä
                  showComputerContentList("DÁõòÁîµÂΩ± (ÁÇπÂáªÂàÜ‰∫´)", movies, "DÁõò");
                  break;

                case "kk-files-icon":
                  // ‰øùÊåÅÂéüÊ†∑ÔºåÊâìÂºÄÊñá‰ª∂ÊµèËßàÂô®
                  // Ê≥®ÊÑèÔºöÂ¶ÇÊûú‰Ω†ÊÉ≥ËÆ©Êñá‰ª∂‰πüËÉΩÂàÜ‰∫´ÔºåÈúÄË¶ÅÂéª openFileExplorer ÂáΩÊï∞ÈáåÊîπÔºå
                  // ‰ΩÜÊñá‰ª∂ÁõÆÂâçÊòØÁÇπÂáªÊü•ÁúãÂÜÖÂÆπÔºåÂª∫ËÆÆ‰øùÊåÅÁé∞Áä∂ÊàñÂú®Êü•ÁúãÂô®ÈáåÂä†ÂàÜ‰∫´ÊåâÈíÆ
                  openFileExplorer();
                  break;

                case "kk-secret-folder-icon":
                  const secretFolder = computerData.secret_folder;
                  if (secretFolder) {
                    showCustomConfirm(
                      "Âä†ÂØÜËÆøÈóÆ",
                      `‰Ω†Â∞ùËØïÊâìÂºÄÊñá‰ª∂ "${secretFolder.fileName}"„ÄÇ<br><br>ËøôÊòØ‰∏Ä‰∏™Âä†ÂØÜÊñá‰ª∂Â§πÔºåÊòØÂê¶ÁªßÁª≠ËÆøÈóÆÔºü`,
                    ).then((confirmed) => {
                      if (confirmed) {
                        // „Äê‰øÆÊîπ„ÄëËß£ÂØÜÂêéÁõ¥Êé•ÂºπÂá∫ÂàÜ‰∫´Á°ÆËÆ§Ê°ÜÔºåËÄå‰∏çÊòØÂè™ÊòæÁ§∫ Alert
                        openComputerItemShareModal(
                          secretFolder.fileName,
                          secretFolder.content,
                          "Âä†ÂØÜÊñá‰ª∂Â§π",
                        );
                      }
                    });
                  } else {
                    showCustomAlert("Êú™ÂèëÁé∞", "Ê≤°ÊúâÊâæÂà∞ÈöêÁßòÊñá‰ª∂Â§π„ÄÇ");
                  }
                  break;

                case "kk-steam-icon":
                  openSteamScreen();
                  break;
              }
            });

          document
            .getElementById("close-kk-file-viewer-btn")
            .addEventListener("click", closeFileViewer);
          document
            .getElementById("kk-file-viewer-modal")
            .addEventListener("click", (e) => {
              if (e.target.id === "kk-file-viewer-modal") {
                closeFileViewer();
              }
            });

          document
            .getElementById("close-file-explorer-modal-btn")
            .addEventListener("click", () =>
              document
                .getElementById("kk-file-explorer-modal")
                .classList.remove("visible"),
            );

          // 1. ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÂ§ÑÁêÜÊñá‰ª∂ÂàóË°®ÁöÑÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("kk-file-list")
            .addEventListener("click", (e) => {
              // Ê£ÄÊü•Ë¢´ÁÇπÂáªÁöÑÊòØÂê¶ÊòØ‰∏Ä‰∏™Êñá‰ª∂È°π
              const fileItem = e.target.closest(".kk-file-item");
              if (fileItem) {
                // ‰ªédata-*Â±ûÊÄß‰∏≠ÂÆâÂÖ®Âú∞ËØªÂèñÊï∞ÊçÆ
                const fileName = fileItem.dataset.fileName;
                const fileContent = fileItem.dataset.fileContent;
                if (fileName && fileContent) {
                  openFileViewer(fileName, fileContent);
                }
              }
            });

          // 2. ÁªëÂÆöÊñ∞ÂºπÁ™óÁöÑÂÖ≥Èó≠ÊåâÈíÆ
          document
            .getElementById("close-kk-file-viewer-btn")
            .addEventListener("click", closeFileViewer);
          document
            .getElementById("kk-file-viewer-modal")
            .addEventListener("click", (e) => {
              // ÁÇπÂáªÈÅÆÁΩ©Â±Ç‰πüÂèØ‰ª•ÂÖ≥Èó≠
              if (e.target.id === "kk-file-viewer-modal") {
                closeFileViewer();
              }
            });

          // SteamÊ∏∏ÊàèÂ∫ìÂºπÁ™óÁöÑ‰∫ã‰ª∂
          document
            .getElementById("close-kk-steam-modal-btn")
            .addEventListener("click", () => {
              document
                .getElementById("kk-steam-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("kk-generate-more-games-btn")
            .addEventListener("click", generateMoreSteamGames);

          // ‰∏∫SteamÊ∏∏ÊàèÂàóË°®Ê∑ªÂä†Âà†Èô§ÊåâÈíÆÁöÑ‰∫ã‰ª∂ÂßîÊâò
          document
            .getElementById("kk-steam-games-list")
            .addEventListener("click", async (e) => {
              const deleteBtn = e.target.closest(".item-delete-btn");
              if (deleteBtn) {
                const index = parseInt(deleteBtn.dataset.index);
                const confirmed = await showCustomConfirm(
                  "Âà†Èô§ËÆ∞ÂΩï",
                  "Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°Ê∏∏ÊàèËÆ∞ÂΩïÂêóÔºü",
                  {
                    confirmButtonClass: "btn-danger",
                  },
                );
                if (confirmed) {
                  const chat = state.chats[activeKkCharId];
                  chat.houseData.computer.steam_games.splice(index, 1);
                  await db.chats.put(chat);
                  renderSteamScreen();
                }
              }
            });

          /* --- kkCheckin-ÁõëÊéßÂäüËÉΩ‰∫ã‰ª∂ÁõëÂê¨Âô® --- */
          document
            .getElementById("kk-house-view-screen")
            .addEventListener("click", (e) => {
              // ÁÇπÂáª‚ÄúÊü•ÁúãÁõëÊéß‚ÄùÂõæÊ†á
              if (e.target.closest("#kk-surveillance-icon")) {
                openSurveillanceView(activeKkCharId);
              }
            });

          document
            .getElementById("kk-back-from-monitor")
            .addEventListener("click", () => {
              // ‰ªéÁõëÊéßÁïåÈù¢ËøîÂõûÂà∞ÊàøÂ±ãÊÄªËßàÁïåÈù¢
              showScreen("kk-house-view-screen");
            });

          // ÁÇπÂáªÁõëÊéß‰∏≠ÂøÉÁöÑ‚ÄúÂà∑Êñ∞‚ÄùÊåâÈíÆ
          document
            .getElementById("kk-refresh-monitor-btn")
            .addEventListener("click", async () => {
              if (!activeKkCharId) return;
              const chat = state.chats[activeKkCharId];
              if (chat && chat.houseData) {
                // Ë∞ÉÁî®Êñ∞ÁöÑ‚ÄúÊõ¥Êñ∞‚ÄùÂáΩÊï∞
                const newSurveillanceData =
                  await generateSurveillanceUpdate(activeKkCharId);
                if (newSurveillanceData) {
                  chat.houseData.surveillanceData = {
                    timestamp: Date.now(),
                    characterLocation: newSurveillanceData.characterLocation,
                    feeds: newSurveillanceData.feeds,
                  };
                  await db.chats.put(chat);
                  renderSurveillanceView(chat.houseData.surveillanceData);
                  alert("ÊâÄÊúâÁõëÊéßÁîªÈù¢Â∑≤Âà∑Êñ∞ÔºÅ");
                }
              }
            });

          // ‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâòÔºåÁªü‰∏ÄÂ§ÑÁêÜÊâÄÊúâÁõëÊéßÁîªÈù¢ÁöÑÁÇπÂáª‰∫ã‰ª∂
          document
            .getElementById("kk-monitor-grid")
            .addEventListener("click", (e) => {
              const monitorItem = e.target.closest(".kk-monitor-item");
              if (!monitorItem) return;

              const areaName = monitorItem.dataset.areaName;
              const interactionButton = e.target.closest(".monitor-btn");

              // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØ‰∫íÂä®ÊåâÈíÆ
              if (interactionButton) {
                e.stopPropagation(); // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°Âà∞Âç°ÁâáÊú¨Ë∫´
                const action = interactionButton.dataset.action;
                handleMonitorInteraction(areaName, action, monitorItem);
              }
              // Âê¶ÂàôÔºåÁÇπÂáªÁöÑÊòØÂç°ÁâáÁöÑÂÖ∂‰ªñÂå∫Âüü
              else {
                openKkAreaView(areaName);
              }
            });

          // Check Phone-ÁîüÊàêËÅäÂ§©ÈÄâÊã©Âô®‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("cancel-chat-gen-btn")
            .addEventListener("click", () => {
              document
                .getElementById("chat-gen-selector-modal")
                .classList.remove("visible");
            });

          // ÈöèÊú∫ÂºÄÂÖ≥ÂàáÊç¢Êó∂ÔºåÂêØÁî®/Á¶ÅÁî®ÂàóË°®
          document
            .getElementById("chat-gen-random-checkbox")
            .addEventListener("change", (e) => {
              const list = document.getElementById("chat-gen-list");
              if (e.target.checked) {
                list.style.opacity = "0.5";
                list.style.pointerEvents = "none";
                // Ê∏ÖÁ©∫ÊâÄÊúâÂãæÈÄâ
                list
                  .querySelectorAll('input[type="checkbox"]')
                  .forEach((cb) => (cb.checked = false));
              } else {
                list.style.opacity = "1";
                list.style.pointerEvents = "auto";
              }
            });

          document
            .getElementById("confirm-chat-gen-btn")
            .addEventListener("click", () => {
              const isRandom = document.getElementById(
                "chat-gen-random-checkbox",
              ).checked;
              let selectedTargets = null;

              if (!isRandom) {
                // Â¶ÇÊûú‰∏çÊòØÈöèÊú∫ÔºåÊî∂ÈõÜÈÄâ‰∏≠ÁöÑÂØπË±°
                selectedTargets = [];
                document
                  .querySelectorAll("#chat-gen-list input:checked")
                  .forEach((checkbox) => {
                    selectedTargets.push({
                      name: checkbox.dataset.name,
                      persona: checkbox.dataset.persona,
                    });
                  });

                if (selectedTargets.length === 0) {
                  alert("ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏Ä‰∏™ËÅäÂ§©ÂØπË±°ÔºåÊàñËÄÖÂºÄÂêØÈöèÊú∫Ê®°Âºè„ÄÇ");
                  return;
                }
              }

              document
                .getElementById("chat-gen-selector-modal")
                .classList.remove("visible");
              // Ë∞ÉÁî®ÁîüÊàêÂáΩÊï∞Ôºå‰º†ÂÖ•ÈÄâ‰∏≠ÁöÑÁõÆÊ†áÔºàÂ¶ÇÊûúÊòØÈöèÊú∫Âàô‰∏∫nullÔºâ
              generateCharacterPhoneDataSegment("chats", selectedTargets);
            });
          // Âø´Êç∑ÂõûÂ§ç‰∫ã‰ª∂ÁªëÂÆö
          document
            .getElementById("quick-reply-btn")
            .addEventListener("click", openQuickReplyModal);

          document
            .getElementById("add-quick-reply-btn")
            .addEventListener("click", addNewQuickReply);

          document
            .getElementById("close-quick-reply-btn")
            .addEventListener("click", () => {
              document
                .getElementById("quick-reply-modal")
                .classList.remove("visible");
            });

          document
            .getElementById("export-quick-reply-btn")
            .addEventListener("click", exportQuickReplies);

          document
            .getElementById("import-quick-reply-btn")
            .addEventListener("click", () => {
              document.getElementById("import-quick-reply-input").click();
            });

          document
            .getElementById("import-quick-reply-input")
            .addEventListener("change", (e) => {
              importQuickReplies(e.target.files[0]);
              e.target.value = null;
            });

          // Êó∂Èó¥ËΩ¥ÂäüËÉΩ‰∫ã‰ª∂ÁªëÂÆö (Êõ¥Êñ∞Áâà)
          // Ê≥®ÊÑè ID ÂèòÊàê‰∫Ü timeline-branch-btn
          document
            .getElementById("timeline-branch-btn")
            .addEventListener("click", openBranchingModal);

          document
            .getElementById("create-branch-btn")
            .addEventListener("click", createBranchCheckpoint);
          document
            .getElementById("restart-chat-btn")
            .addEventListener("click", restartChatBranch);
          document
            .getElementById("close-branching-modal-btn")
            .addEventListener("click", () => {
              document
                .getElementById("branching-modal")
                .classList.remove("visible");
            });

          // Âú® init() ÂÜÖÈÉ®Ê∑ªÂä†Ôºö
          document
            .getElementById("aurora-media-btn")
            .addEventListener("click", openAuroraSetupModal);
          document
            .getElementById("cancel-aurora-setup")
            .addEventListener("click", () => {
              document
                .getElementById("aurora-setup-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("confirm-aurora-setup")
            .addEventListener("click", confirmAuroraSetup);
          document
            .getElementById("aurora-close-player")
            .addEventListener("click", closeAuroraPlayer);
          // ÊûÅÂÖâÊ®°ÂºèÂàáÊç¢‰∫ã‰ª∂ÁªëÂÆö
          // ËæÖÂä©ÂáΩÊï∞ÔºöÂéªÊéâÊñá‰ª∂ÂêéÁºÄ
          const autoFillAuroraTitle = (file) => {
            if (file) {
              // Ëé∑ÂèñÊñá‰ª∂ÂêçÔºåÂéªÊéâÊúÄÂêé‰∏Ä‰∏™ÁÇπ‰πãÂêéÁöÑÂÜÖÂÆπ
              const fileName = file.name.replace(/\.[^/.]+$/, "");
              document.getElementById("aurora-title-input").value = fileName;
            }
          };

          // ÁõëÂê¨ËßÜÈ¢ëÊñá‰ª∂ÈÄâÊã©
          document
            .getElementById("aurora-video-file")
            .addEventListener("change", (e) => {
              if (e.target.files.length > 0) {
                autoFillAuroraTitle(e.target.files[0]);
              }
            });

          // ÁõëÂê¨ÊñáÊú¨Êñá‰ª∂ÈÄâÊã©
          document
            .getElementById("aurora-text-file")
            .addEventListener("change", (e) => {
              if (e.target.files.length > 0) {
                autoFillAuroraTitle(e.target.files[0]);
              }
            });

          // ---------------- [‰øÆÊîπÂºÄÂßã] ‰øÆÂ§çÊñáÊú¨Èîô‰ΩçÈóÆÈ¢ò ----------------
          // Êº´Ê∏∏ÈòÖËØªËøõÂ∫¶Ëá™Âä®‰øùÂ≠ò & ÂÆûÊó∂‰∏ä‰∏ãÊñáÊõ¥Êñ∞ÂäüËÉΩ
          const textViewer = document.getElementById("aurora-text-viewer");
          let saveProgressTimer = null;

          // ËæÖÂä©ÂáΩÊï∞ÔºöËé∑ÂèñÂΩìÂâçÂèØËßÜÂå∫ÂüüÁöÑÊñáÊú¨
          function updateCurrentReadingContext() {
            if (!auroraState.textContent) return;

            const scrollHeight =
              textViewer.scrollHeight - textViewer.clientHeight;
            const scrollTop = textViewer.scrollTop;

            // Èò≤Ê≠¢Èô§‰ª•0
            const scrollPercentage =
              scrollHeight > 0 ? scrollTop / scrollHeight : 0;
            const totalLength = auroraState.textContent.length;

            // ËÆ°ÁÆó‰∏≠ÂøÉÁÇπÁ¥¢Âºï
            const centerIndex = Math.floor(totalLength * scrollPercentage);

            // Êà™ÂèñÂâçÂêéÂêÑ 500 Â≠óÔºå‰øùËØÅ‰∏ä‰∏ãÊñáË∂≥Â§ü
            const start = Math.max(0, centerIndex - 500);
            const end = Math.min(totalLength, centerIndex + 500);

            // ‚òÖ‚òÖ‚òÖ Ê†∏ÂøÉ‰øÆÂ§çÔºöÁõ¥Êé•ÊääËøôÊÆµÊñáÂ≠óÂ≠òËøõÂÖ®Â±ÄÁä∂ÊÄÅÔºå‰æõAIÈöèÊó∂ËØªÂèñ ‚òÖ‚òÖ‚òÖ
            auroraState.currentSegmentText = auroraState.textContent.substring(
              start,
              end,
            );

            return scrollPercentage; // ËøîÂõûËøõÂ∫¶Áªô‰∏ãÈù¢‰øùÂ≠òÁî®
          }

          textViewer.addEventListener("scroll", () => {
            // 1. ÂÆûÊó∂Êõ¥Êñ∞ÂΩìÂâçÈòÖËØªÁâáÊÆµÔºàÊó†ËÆ∫ÊòØÂê¶Âú®‰π¶Êû∂Ê®°ÂºèÔºâ
            const currentProgress = updateCurrentReadingContext();

            // 2. Ê£ÄÊü•ÂΩìÂâçÊòØÂê¶Â§Ñ‰∫é‰π¶Êû∂ÈòÖËØªÊ®°ÂºèÔºàÁî®‰∫é‰øùÂ≠òËøõÂ∫¶Âà∞Êï∞ÊçÆÂ∫ìÔºâ
            if (
              !auroraState.active ||
              auroraState.mode !== "text" ||
              !auroraState.currentBookId
            ) {
              return;
            }

            // 3. Èò≤ÊäñÂ§ÑÁêÜÔºöÁî®Êà∑ÂÅúÊ≠¢ÊªöÂä® 0.5 ÁßíÂêéÊâç‰øùÂ≠òÊï∞ÊçÆÂ∫ìÔºåÈÅøÂÖçÂç°È°ø
            if (saveProgressTimer) clearTimeout(saveProgressTimer);

            saveProgressTimer = setTimeout(async () => {
              // Á°Æ‰øùËøõÂ∫¶Âú® 0 Âà∞ 1 ‰πãÈó¥
              const progress = Math.max(0, Math.min(1, currentProgress));

              try {
                await db.auroraBooks.update(auroraState.currentBookId, {
                  progress: progress,
                });
              } catch (error) {
                console.error("‰øùÂ≠òÈòÖËØªËøõÂ∫¶Â§±Ë¥•:", error);
              }
            }, 500);
          });
          // ---------------- [‰øÆÊîπÁªìÊùü] ----------------

          document
            .querySelectorAll('input[name="aurora-mode"]')
            .forEach((radio) => {
              radio.addEventListener("change", toggleAuroraInputs);
            });

          // ÁªëÂÆö GitHub ÊâãÂä®‰∏ä‰º†ÊåâÈíÆ
          const githubBtn = document.getElementById("manual-github-backup-btn");
          if (githubBtn) {
            githubBtn.addEventListener("click", () =>
              uploadBackupToGitHub(false),
            );
          }
          // ÁªëÂÆö GitHub ÊÅ¢Â§çÊåâÈíÆ
          const githubRestoreBtn = document.getElementById(
            "manual-github-restore-btn",
          );
          const gitStreamUploadBtn = document.getElementById(
            "git-stream-upload-btn",
          );
          if (gitStreamUploadBtn) {
            gitStreamUploadBtn.addEventListener(
              "click",
              uploadBackupToGitHubStream,
            );
          }

          const gitStreamRestoreBtn = document.getElementById(
            "git-stream-restore-btn",
          );
          if (gitStreamRestoreBtn) {
            gitStreamRestoreBtn.addEventListener(
              "click",
              restoreBackupFromGitHubStream,
            );
          }

          if (githubRestoreBtn) {
            githubRestoreBtn.addEventListener("click", restoreBackupFromGitHub);
          }
          // --- KKÊü•Â≤ó‰∏ìÁî®ÂºπÁ™óÂÖ≥Èó≠‰∫ã‰ª∂ ---
          document
            .getElementById("kk-item-share-close-btn")
            .addEventListener("click", () => {
              document
                .getElementById("kk-item-share-modal")
                .classList.remove("visible");
            });

          // ÁÇπÂáªÈÅÆÁΩ©Â±Ç‰πüÂèØ‰ª•ÂÖ≥Èó≠
          document
            .getElementById("kk-item-share-modal")
            .addEventListener("click", (e) => {
              if (e.target.id === "kk-item-share-modal") {
                e.target.classList.remove("visible");
              }
            });

          // Á°Æ‰øù‰Ω†Âú® HTML ÈáåÂä†‰∫Ü id="kk-wardrobe-btn"
          const wardrobeEntryBtn = document.getElementById("kk-wardrobe-btn");
          if (wardrobeEntryBtn) {
            wardrobeEntryBtn.addEventListener("click", openKkWardrobe);
          }

          // 2. ÁªëÂÆöË°£ÊüúÂÜÖÈÉ®ÁöÑ‚ÄúËøîÂõû‚ÄùÊåâÈíÆ
          document
            .getElementById("kk-back-from-wardrobe")
            .addEventListener("click", () => {
              // ËøîÂõûÂà∞ÊàøÂ±ãÊÄªËßà
              showScreen("kk-house-view-screen");
            });

          // 3. ÁªëÂÆö‚ÄúÈáçÁΩÆË°£Êüú‚ÄùÊåâÈíÆ
          document
            .getElementById("kk-wardrobe-refresh-btn")
            .addEventListener("click", async () => {
              const confirmed = await showCustomConfirm(
                "ÈáçÁΩÆË°£Êüú",
                "Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫Âπ∂ÈáçÊñ∞ÁîüÊàêÊâÄÊúâË°£ÊúçÂêóÔºü",
                {
                  confirmButtonClass: "btn-danger",
                },
              );
              if (confirmed) {
                await generateWardrobeData(activeKkCharId); // ÈáçÊñ∞ÁîüÊàê
                currentOutfit = {
                  Top: null,
                  Bottoms: null,
                  Accessories: null,
                  Special: null,
                };
                renderWardrobeUI();
              }
            });

          // 4. ÁªëÂÆöÊ†áÁ≠æÈ°µÂàáÊç¢ (‰ΩøÁî®‰∫ã‰ª∂ÂßîÊâò)
          document
            .querySelector(".wardrobe-tabs")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("wardrobe-tab")) {
                activeWardrobeCategory = e.target.dataset.cat;
                renderWardrobeUI();
              }
            });

          // 5. ÁªëÂÆö‚ÄúËØïÁ©ø‚ÄùÊåâÈíÆ
          document
            .getElementById("wardrobe-try-on-btn")
            .addEventListener("click", handleTryOn);
          const sysNotifSwitch = document.getElementById(
            "system-notification-switch",
          );
          if (sysNotifSwitch) {
            sysNotifSwitch.addEventListener("change", (e) => {
              if (e.target.checked) {
                // Áî®Êà∑Â∞ùËØïÂºÄÂêØ
                if (!("Notification" in window)) {
                  alert("Êä±Ê≠âÔºå‰Ω†ÁöÑËÆæÂ§áÊàñÊµèËßàÂô®‰∏çÊîØÊåÅÁ≥ªÁªüÈÄöÁü•„ÄÇ");
                  e.target.checked = false;
                } else if (Notification.permission === "granted") {
                  // Â∑≤ÁªèÊòØÊéàÊùÉÁä∂ÊÄÅÔºåÊó†ÈúÄÊìç‰Ωú
                  new Notification("EPhone", {
                    body: "ÊµãËØïÈÄöÁü•ÔºöÁ≥ªÁªüÈÄöÁü•ÂäüËÉΩÊ≠£Â∏∏ÔºÅ",
                  });
                } else if (Notification.permission !== "denied") {
                  // ËØ∑Ê±ÇÊùÉÈôê
                  Notification.requestPermission().then((permission) => {
                    if (permission === "granted") {
                      new Notification("EPhone", {
                        body: "ÊàêÂäüÂºÄÂêØÔºÅ‰ª•ÂêéÊî∂Âà∞Ê∂àÊÅØ‰ºöÊúâÂºπÁ™óÂì¶„ÄÇ",
                      });
                    } else {
                      e.target.checked = false;
                      alert(
                        "‰Ω†ÊãíÁªù‰∫ÜÈÄöÁü•ÊùÉÈôê„ÄÇÂ¶ÇÈúÄÂºÄÂêØÔºåËØ∑Âú®ÊâãÊú∫Á≥ªÁªüËÆæÁΩÆ‰∏≠ÂÖÅËÆ∏Êú¨Â∫îÁî®ÂèëÈÄÅÈÄöÁü•„ÄÇ",
                      );
                    }
                  });
                } else {
                  // ‰πãÂâçË¢´ÊãíÁªùËøá
                  alert(
                    "ÊùÉÈôêÂ∑≤Ë¢´ÊãíÁªù„ÄÇËØ∑ÂâçÂæÄÊâãÊú∫„ÄêËÆæÁΩÆ -> ÈÄöÁü•„Äë‰∏≠ÊâæÂà∞Êú¨Â∫îÁî®ÔºåÊâãÂä®ÂºÄÂêØÈÄöÁü•ÊùÉÈôê„ÄÇ",
                  );
                  e.target.checked = false;
                }
              }
            });
          }
          // --- ÊÉÖ‰æ£Â§¥ÂÉèÂ∫ìÂäüËÉΩ‰∫ã‰ª∂ ---

          // 1. ÊâìÂºÄÁÆ°ÁêÜÂºπÁ™ó
          document
            .getElementById("manage-couple-avatar-library-btn")
            .addEventListener("click", (e) => {
              // ÈòªÊ≠¢ÂÜíÊ≥°Èò≤Ê≠¢ÂÖ≥Èó≠ËÆæÁΩÆÂºπÁ™óÔºàËßÜÊÉÖÂÜµËÄåÂÆöÔºåËøôÈáåÂª∫ËÆÆÂÖà‰∏çÂÖ≥Èó≠ËÆæÁΩÆÂºπÁ™óÔºåÊàñËÄÖÂ±ÇÂè†ÊòæÁ§∫Ôºâ
              // ‰∏∫‰∫Ü‰ΩìÈ™åÊõ¥Â•ΩÔºåÊàë‰ª¨ÂèØ‰ª•ÂÖàÈöêËóèËÅäÂ§©ËÆæÁΩÆÂºπÁ™ó
              document
                .getElementById("chat-settings-modal")
                .classList.remove("visible");
              openCoupleAvatarLibraryModal();
            });

          // 2. ÂÖ≥Èó≠ÁÆ°ÁêÜÂºπÁ™ó (ËøîÂõûËÆæÁΩÆ)
          document
            .getElementById("close-couple-avatar-library-btn")
            .addEventListener("click", () => {
              document
                .getElementById("couple-avatar-library-modal")
                .classList.remove("visible");
              // ÈáçÊñ∞ÊâìÂºÄËÆæÁΩÆÂºπÁ™ó
              document.getElementById("chat-settings-btn").click();
            });

          // 3. ÊâìÂºÄÊ∑ªÂä†ÂºπÁ™ó
          document
            .getElementById("add-couple-avatar-btn")
            .addEventListener("click", () => {
              // Ê∏ÖÁ©∫ËæìÂÖ•
              document.getElementById("new-couple-my-avatar-preview").src =
                "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
              document.getElementById("new-couple-char-avatar-preview").src =
                "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
              document.getElementById("new-couple-desc-input").value = "";
              document.getElementById("new-couple-my-avatar-input").value = "";
              document.getElementById("new-couple-char-avatar-input").value =
                "";

              document
                .getElementById("add-couple-avatar-modal")
                .classList.add("visible");
            });

          // 4. ÂÖ≥Èó≠Ê∑ªÂä†ÂºπÁ™ó
          document
            .getElementById("cancel-add-couple-avatar-btn")
            .addEventListener("click", () => {
              document
                .getElementById("add-couple-avatar-modal")
                .classList.remove("visible");
            });

          // 5. ‰øùÂ≠òÊñ∞ÊÉÖÂ§¥
          document
            .getElementById("save-couple-avatar-btn")
            .addEventListener("click", async () => {
              const myAvatarSrc = document.getElementById(
                "new-couple-my-avatar-preview",
              ).src;
              const charAvatarSrc = document.getElementById(
                "new-couple-char-avatar-preview",
              ).src;
              const desc = document
                .getElementById("new-couple-desc-input")
                .value.trim();

              if (
                myAvatarSrc.includes("placeholder") ||
                charAvatarSrc.includes("placeholder")
              ) {
                alert("ËØ∑‰∏ä‰º†‰∏§Âº†Â§¥ÂÉèÔºÅ");
                return;
              }
              if (!desc) {
                alert("ËØ∑ËæìÂÖ•ÊèèËø∞ÔºåËøôÂæàÈáçË¶ÅÔºåAIÈù†ÂÆÉÊù•ÈÄâÊã©Â§¥ÂÉèÔºÅ");
                return;
              }

              const chat = state.chats[state.activeChatId];
              if (!chat.settings.coupleAvatarLibrary)
                chat.settings.coupleAvatarLibrary = [];

              const newPair = {
                id: "couple_" + Date.now(),
                userAvatar: myAvatarSrc,
                charAvatar: charAvatarSrc,
                description: desc,
              };

              chat.settings.coupleAvatarLibrary.push(newPair);
              await db.chats.put(chat);

              document
                .getElementById("add-couple-avatar-modal")
                .classList.remove("visible");
              renderCoupleAvatarLibraryList(); // Âà∑Êñ∞ÂàóË°®
              alert("ÊÉÖ‰æ£Â§¥ÂÉèÊ∑ªÂä†ÊàêÂäüÔºÅ");
            });

          // 6. ÂõæÁâá‰∏ä‰º†È¢ÑËßàÁªëÂÆö (Â§çÁî®ÈÄöÁî®ÁöÑ‰∏ä‰º†ÂáΩÊï∞)
          setupFileUpload("new-couple-my-avatar-input", (base64) => {
            document.getElementById("new-couple-my-avatar-preview").src =
              base64;
          });
          setupFileUpload("new-couple-char-avatar-input", (base64) => {
            document.getElementById("new-couple-char-avatar-preview").src =
              base64;
          });

          // Ê†∏ÂøÉÂáΩÊï∞ÔºöÊâìÂºÄÁÆ°ÁêÜÂºπÁ™ó
          function openCoupleAvatarLibraryModal() {
            if (!state.activeChatId) return;
            renderCoupleAvatarLibraryList();
            document
              .getElementById("couple-avatar-library-modal")
              .classList.add("visible");
          }

          // Ê†∏ÂøÉÂáΩÊï∞ÔºöÊ∏≤ÊüìÂàóË°®
          function renderCoupleAvatarLibraryList() {
            const listEl = document.getElementById(
              "couple-avatar-library-list",
            );
            const chat = state.chats[state.activeChatId];
            const library = chat.settings.coupleAvatarLibrary || [];

            listEl.innerHTML = "";

            if (library.length === 0) {
              listEl.innerHTML =
                '<p style="text-align:center; color:#999; padding:20px;">ËøôÈáåÁ©∫Á©∫Â¶Ç‰πüÔºåÂø´ÂéªÊ∑ªÂä†Á¨¨‰∏ÄÂØπÊÉÖÂ§¥ÂêßÔºÅ</p>';
              return;
            }

            library.forEach((pair, index) => {
              const item = document.createElement("div");
              item.style.cssText = `
            background: #fff; padding: 10px; border-radius: 12px; 
            display: flex; flex-direction: column; gap: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        `;

              item.innerHTML = `
            <div style="display:flex; justify-content:center; gap: 15px; align-items:center;">
                <div style="text-align:center;">
                    <img src="${pair.userAvatar}" style="width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid #eee;">
                    <div style="font-size:10px; color:#666; margin-top:2px;">Me</div>
                </div>
                <div style="font-size:20px;">‚ù§Ô∏è</div>
                <div style="text-align:center;">
                    <img src="${pair.charAvatar}" style="width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid #eee;">
                    <div style="font-size:10px; color:#666; margin-top:2px;">Ta</div>
                </div>
            </div>
            <div style="font-size:13px; color:#333; background:#f9f9f9; padding:8px; border-radius:6px;">
                <strong>ÊèèËø∞Ôºö</strong>${pair.description}
            </div>
            <div style="display:flex; gap:10px; justify-content:flex-end;">
                <button class="moe-btn-mini apply-pair-btn" style="background:#4caf50; color:white;">Â∫îÁî®</button>
                <button class="moe-btn-mini delete-pair-btn" style="background:#ff3b30; color:white;">Delete</button>
            </div>
        `;

              // ÁªëÂÆöÂà†Èô§
              item.querySelector(".delete-pair-btn").onclick = async () => {
                if (confirm("Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÂØπÊÉÖÂ§¥ÂêóÔºü")) {
                  chat.settings.coupleAvatarLibrary.splice(index, 1);
                  await db.chats.put(chat);
                  renderCoupleAvatarLibraryList();
                }
              };

              // ÁªëÂÆöÊâãÂä®Â∫îÁî®
              item.querySelector(".apply-pair-btn").onclick = async () => {
                chat.settings.aiAvatar = pair.charAvatar;
                chat.settings.myAvatar = pair.userAvatar;
                chat.settings.isCoupleAvatar = true;
                chat.settings.coupleAvatarDescription = pair.description;
                await db.chats.put(chat);

                // Â¶ÇÊûúËÅäÂ§©ÁïåÈù¢ÂºÄÁùÄÔºåÂà∑Êñ∞ÂÆÉ
                if (
                  document
                    .getElementById("chat-interface-screen")
                    .classList.contains("active")
                ) {
                  renderChatInterface(chat.id);
                }
                alert("Â∑≤Â∫îÁî®Ê≠§ÊÉÖ‰æ£Â§¥ÂÉèÔºÅ");
              };

              listEl.appendChild(item);
            });
          }
          // 1. Âä†ËΩΩÊï∞ÊçÆÂà∞ÂÜÖÂ≠ò
          state.passerbyAvatars = await db.passerbyAvatars.toArray();

          // 2. ÁªëÂÆöËÆæÁΩÆÈ°µÈù¢ÁöÑÊåâÈíÆ
          document
            .getElementById("manage-passerby-avatars-btn")
            .addEventListener("click", openPasserbyManager);
          document
            .getElementById("add-passerby-avatar-btn")
            .addEventListener("click", handleAddPasserbyAvatar);

          // 3. ÁªëÂÆöÂºπÁ™óÂÜÖÁöÑÊåâÈíÆ
          document
            .getElementById("close-passerby-manager-btn")
            .addEventListener("click", () => {
              document
                .getElementById("passerby-avatar-manager-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("bulk-add-passerby-btn")
            .addEventListener("click", handleAddPasserbyAvatar);

          // 4. ÁªëÂÆöÊñá‰ª∂ËæìÂÖ•Ê°Ü
          document
            .getElementById("passerby-upload-input")
            .addEventListener("change", handlePasserbyFileChange);
          initAuroraDrag(); // ÂàùÂßãÂåñÊãñÊãΩ
          initAuroraFontControl();
          initAuroraResize();
          initVideoBubbleDrag(); // ÂàùÂßãÂåñËßÜÈ¢ëÊÇ¨ÊµÆÁêÉÊãñÊãΩ
          initLoversSpace();
          initTaobao();
          initTukeyAccounting();
          initDesktopManager();

          // ===================================================================
          // 5. ÂêØÂä®ÔºÅ

          // Â∫îÁî®Â£ÅÁ∫∏Âπ∂Êõ¥Êñ∞ÊâÄÊúâÊó∂Èíü
          applyLockscreenWallpaper();
          updateLockClock();

          // 1. ËØªÂèñ„ÄÅÂ∫îÁî®Âπ∂ÁõëÂê¨‚ÄúÂêØÁî®ÈîÅÂ±è‚ÄùËÆæÁΩÆ
          const enableLockScreenToggle = document.getElementById(
            "enable-lock-screen-toggle",
          );
          const lockScreenEnabled =
            localStorage.getItem("lockScreenEnabled") !== "false";
          enableLockScreenToggle.checked = lockScreenEnabled;

          // 2. ËØªÂèñ„ÄÅÂ∫îÁî®Âπ∂ÁõëÂê¨‚ÄúÊòæÁ§∫Áä∂ÊÄÅÊ†è‚ÄùËÆæÁΩÆ
          const showStatusBarToggle = document.getElementById(
            "show-status-bar-toggle",
          );
          const statusBar = document.getElementById("status-bar");
          // ËØªÂèñ‰øùÂ≠òÁöÑÁä∂ÊÄÅÔºåÂ¶ÇÊûúÊ≤°‰øùÂ≠òËøáÔºåÈªòËÆ§ÊòØ true (ÊòæÁ§∫)
          const showStatusBar =
            localStorage.getItem("showStatusBar") !== "false";
          // ËÆ©ÂºÄÂÖ≥ÁöÑÁä∂ÊÄÅÂíå‰øùÂ≠òÁöÑÁä∂ÊÄÅÂêåÊ≠•
          showStatusBarToggle.checked = showStatusBar;
          // Ê†πÊçÆ‰øùÂ≠òÁöÑÁä∂ÊÄÅÔºåÂÜ≥ÂÆö‰∏ÄÂä†ËΩΩËøõÊù•Êó∂ÊòØÂê¶ÊòæÁ§∫Áä∂ÊÄÅÊ†è
          if (showStatusBar) {
            statusBar.style.display = "flex";
          } else {
            statusBar.style.display = "none";
          }

          // 3. ÁªôÂºÄÂÖ≥Ê∑ªÂä†‚ÄúÂèòÂåñ‚ÄùÁõëÂê¨Âô®ÔºåËøôÊ†∑‰Ω†ÊØèÊ¨°ÁÇπÂáªÂÆÉÈÉΩ‰ºö‰øùÂ≠òÁä∂ÊÄÅ
          showStatusBarToggle.addEventListener("change", (e) => {
            const isEnabled = e.target.checked;
            // a. Â∞ÜÊñ∞ÁöÑÂºÄÂÖ≥Áä∂ÊÄÅ (true Êàñ false) ‰øùÂ≠òÂà∞ÊµèËßàÂô®ÁöÑ localStorage Èáå
            localStorage.setItem("showStatusBar", isEnabled);
            // b. Á´ãÂàªÊ†πÊçÆÊñ∞ÁöÑÁä∂ÊÄÅÊù•ÊòæÁ§∫ÊàñÈöêËóèÁä∂ÊÄÅÊ†è
            statusBar.style.display = isEnabled ? "flex" : "none";
          });

          // 4. Ê†πÊçÆÊúÄÁªàÁöÑÈîÅÂ±èËÆæÁΩÆÔºåÂÜ≥ÂÆöÂ∫îÁî®ÂêØÂä®Êó∂Á¨¨‰∏Ä‰∏™ÊòæÁ§∫ÁöÑÂ±èÂπï
          if (lockScreenEnabled) {
            lockPhone(); // Â¶ÇÊûúËÆæÁΩÆÊòØ‚ÄúÂêØÁî®‚ÄùÔºåÂ∞±ÈîÅÂÆöÊâãÊú∫
          } else {
            showScreen("home-screen"); // Âê¶ÂàôÔºåÁõ¥Êé•ËøõÂÖ•‰∏ªÂ±èÂπï
          }
        }
        function renderLoginOverlay() {
          if (document.getElementById("login-overlay")) return;

          // 1. ÂºïÂÖ•Â≠ó‰Ωì
          if (!document.getElementById("pixel-font-link")) {
            const fontLink = document.createElement("link");
            fontLink.id = "pixel-font-link";
            fontLink.href =
              "https://fonts.googleapis.com/css2?family=VT323&display=swap";
            fontLink.rel = "stylesheet";
            document.head.appendChild(fontLink);
          }

          // 2. Ê†∑ÂºèÂÆö‰πâ
          const style = document.createElement("style");
          style.innerHTML = `
            #login-overlay {
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background-color: #dbc6c6; 
                z-index: 99999;
                display: flex; flex-direction: column;
                justify-content: center; align-items: center;
                font-family: 'VT323', monospace;
                overflow: hidden;
            }

            /* --- Êú∫Ë∫´ --- */
            .gameboy-body {
                width: 360px; height: 640px;
                background-color: #eed7d5; /* ÊûØÁé´Áë∞Á≤â */
                border-radius: 60px;
                box-shadow: 
                    20px 20px 60px #c5b0ae, 
                    -20px -20px 60px #fffaf8,
                    inset 2px 2px 5px rgba(255,255,255,0.5);
                border: 6px solid #e6cfcd;
                display: flex; flex-direction: column;
                align-items: center;
                padding: 30px; box-sizing: border-box; position: relative;
            }

            /* --- Â±èÂπïÂ§ñÊ°Ü --- */
            .screen-bezel {
                width: 100%;
                background-color: #dcbdbb;
                border-radius: 40px 40px 50px 40px;
                padding: 20px; box-sizing: border-box;
                box-shadow: inset 3px 3px 10px rgba(0,0,0,0.1);
                display: flex; flex-direction: column; align-items: center;
                margin-bottom: 30px; position: relative;
            }
            .bezel-dots { position: absolute; top: 12px; left: 25px; display: flex; gap: 6px; }
            .dot { width: 6px; height: 6px; border-radius: 50%; background: #b09896; opacity: 0.5;}

            /* --- Ê∂≤Êô∂Â±èÂπï --- */
            .screen-lcd {
                width: 100%; height: 320px;
                background-color: #4a3b3b;
                border-radius: 20px;
                box-shadow: inset 0 0 15px rgba(0,0,0,0.6);
                background-image: 
                    linear-gradient(rgba(255, 192, 203, 0.03) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(255, 192, 203, 0.03) 1px, transparent 1px);
                background-size: 4px 4px;
                display: flex; flex-direction: column; align-items: center; justify-content: center;
                color: #fce4ec; text-shadow: 0 0 4px rgba(252, 228, 236, 0.6);
                position: relative; overflow: hidden;
            }
            
            .scanline {
                width: 100%; height: 100%; position: absolute; left: 0; top: 0;
                background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
                background-size: 100% 4px; pointer-events: none; z-index: 5; opacity: 0.3;
            }

            .game-logo { font-size: 28px; margin-bottom: 30px; letter-spacing: 4px; opacity: 0.9; }

            /* --- ËæìÂÖ•Ê°ÜÁªÑ (ÂåÖÂê´Ë°åËµ∞ÁöÑÂ∞è‰∫∫) --- */
            .input-group {
                width: 85%;
                position: relative;
                margin-bottom: 25px; /* Â¢ûÂä†Èó¥Ë∑ùÁªôÂ∞è‰∫∫Áïô‰ΩçÁΩÆ */
            }

            .pixel-input {
                width: 100%; height: 40px;
                background: rgba(255, 255, 255, 0.1);
                border: 2px solid #8d7878;
                border-radius: 10px;
                color: #fff;
                font-family: 'VT323', monospace;
                font-size: 20px;
                padding: 0 10px;
                text-align: center;
                outline: none;
                transition: all 0.3s;
                box-sizing: border-box; /* Á°Æ‰øùpadding‰∏çÊíëÂ§ßÂÆΩÂ∫¶ */
            }
            .pixel-input:focus {
                background: rgba(255, 255, 255, 0.2);
                border-color: #f8a5c2;
                box-shadow: 0 0 10px rgba(248, 165, 194, 0.4);
            }
            .pixel-input::placeholder { color: rgba(252, 228, 236, 0.3); font-size: 18px; }

            /* --- Ë°åËµ∞ÁöÑÂ∞è‰∫∫Âä®Áîª --- */
            .walker {
                position: absolute;
                /* ÊîæÂú®ËæìÂÖ•Ê°Ü‰∏äÊñπËæπÊ°ÜÁöÑ‰ΩçÁΩÆ */
                top: -38px; 
                height: 40px; /* Á®çÂæÆÂ§ß‰∏ÄÁÇπÁÇπ */
                width: auto;
                z-index: 10;
                pointer-events: none; /* ËÆ©Èº†Ê†áÁÇπÂáªÁ©øÈÄèÂõæÁâáÔºå‰∏çÂΩ±ÂìçÁÇπËæìÂÖ•Ê°Ü */
                image-rendering: pixelated; /* ‰øùÊåÅÂÉèÁ¥†Ê∏ÖÊô∞ */
            }

            /* ÂÆö‰πâË°åËµ∞Âä®ÁîªÔºö‰ªéÂ∑¶Ë∑ëÂà∞Âè≥ÔºåÁÑ∂ÂêéÁû¨Èó¥ÂõûÂà∞Â∑¶ËæπÂæ™ÁéØ */
            @keyframes walkRight {
                0% { left: -10px; }
                100% { left: calc(100% - 30px); } 
            }

            .walker-uid {
                animation: walkRight 8s linear infinite;
            }
            
            .walker-pwd {
                /* Á®çÂæÆÊÖ¢‰∏ÄÁÇπÔºåÂπ∂‰∏îÊúâÂª∂ËøüÔºåÂà∂ÈÄ†Ë∑ùÁ¶ªÊÑü */
                animation: walkRight 9s linear infinite; 
                animation-delay: -4s; /* Ë¥üÂª∂ËøüË°®Á§∫Âä®Áîª‰∏ÄÂºÄÂßãÂ∞±Âú®‰∏≠Èó¥ */
            }

            #login-msg { height: 20px; font-size: 16px; color: #fab1a0; margin-top: 5px; }

            /* --- ÊìçÊéßÂå∫ --- */
            .controls-area { width: 100%; flex: 1; position: relative; }

            .d-pad { position: absolute; top: 20px; left: 20px; width: 100px; height: 100px; }
            .d-pad-h, .d-pad-v {
                background: #b5a3a3; border-radius: 10px;
                box-shadow: inset 2px 2px 5px rgba(255,255,255,0.2), 3px 3px 5px rgba(0,0,0,0.1);
                position: absolute;
            }
            .d-pad-h { width: 100px; height: 34px; top: 33px; }
            .d-pad-v { width: 34px; height: 100px; left: 33px; }
            .d-pad-center {
                width: 34px; height: 34px; background: #b5a3a3;
                position: absolute; top: 33px; left: 33px; z-index: 2;
                border-radius: 50%; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.1);
            }

            .action-btns { position: absolute; top: 30px; right: 20px; display: flex; gap: 20px; transform: rotate(-10deg); }
            .round-btn {
                width: 55px; height: 55px; border-radius: 50%; border: none; cursor: pointer;
                font-family: 'VT323', monospace; font-size: 24px; color: rgba(255,255,255,0.6);
                display: flex; justify-content: center; align-items: center;
                box-shadow: 0 6px 0 rgba(0,0,0,0.15), 0 10px 10px rgba(0,0,0,0.1);
                transition: transform 0.1s; position: relative;
            }
            .btn-a { background: radial-gradient(circle at 30% 30%, #eababa, #cd8d8d); margin-top: -20px; }
            .btn-b { background: radial-gradient(circle at 30% 30%, #c4d4c4, #8fa08f); margin-top: 20px; }
            .round-btn:active { transform: translateY(6px); box-shadow: 0 0 0 rgba(0,0,0,0.15); }
            .btn-label { position: absolute; bottom: -25px; width: 100%; text-align: center; color: #bcaaaa; font-size: 14px; font-weight: bold; }

            .options-group { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: center; gap: 30px; }
            .pill-btn { width: 60px; height: 16px; background: #cbbaba; border-radius: 20px; transform: rotate(-15deg); box-shadow: inset 1px 1px 3px rgba(0,0,0,0.1); border: 1px solid rgba(255,255,255,0.2); }
            .speakers { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 5px; transform: rotate(-15deg); }
            .sp-slot { width: 6px; height: 6px; background: rgba(0,0,0,0.05); border-radius: 50%; box-shadow: inset 1px 1px 1px rgba(0,0,0,0.1); }
          `;
          document.head.appendChild(style);

          // 3. HTMLÁªìÊûÑ
          const overlay = document.createElement("div");
          overlay.id = "login-overlay";

          overlay.innerHTML = `
            <div class="gameboy-body">
                <div class="screen-bezel">
                    <div class="bezel-dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
                    
                    <div class="screen-lcd">
                        <div class="scanline"></div>
                        <div class="game-logo">E-PHONE TUKI</div>
                        
                        <!-- Ë¥¶Âè∑ËæìÂÖ•Ê°ÜÁªÑ -->
                        <div class="input-group">
                            <img src="https://i.postimg.cc/bwyK9rVr/1000109644.png" class="walker walker-uid" alt="char1">
                            <input type="text" id="login-uid" class="pixel-input" placeholder="ACCOUNT ID" spellcheck="false" autocomplete="off">
                        </div>

                        <!-- ÂØÜÁ†ÅËæìÂÖ•Ê°ÜÁªÑ -->
                        <div class="input-group">
                            <img src="https://i.postimg.cc/NjsWkFCQ/test.png" class="walker walker-pwd" alt="char2">
                            <input type="password" id="login-pwd" class="pixel-input" placeholder="PASSWORD" autocomplete="off">
                        </div>
                        
                        <p id="login-msg">WAITING...</p>
                        
                        <div style="margin-top: 15px; font-size: 14px; color: rgba(252, 228, 236, 0.5);">‚óè REC</div>
                    </div>
                    
                    <div style="margin-top: 10px; color: #a69292; font-size: 12px; letter-spacing: 1px; font-weight: bold;">
                        Ephone TUKI ^ Ã≥- ‚ÄßÃ´ ‚Ä¢ Ã≥^‡∏Ö
                    </div>
                </div>

                <div class="controls-area">
                    <div class="d-pad">
                        <div class="d-pad-h"></div><div class="d-pad-v"></div><div class="d-pad-center"></div>
                    </div>
                    <div class="action-btns">
                        <div style="position:relative;">
                             <button id="btn-login-reset" class="round-btn btn-b">B</button>
                             <div class="btn-label">RESET</div>
                        </div>
                        <div style="position:relative;">
                             <button id="btn-login-submit" class="round-btn btn-a">A</button>
                             <div class="btn-label">START</div>
                        </div>
                    </div>
                    <div class="options-group">
                        <div class="pill-btn"></div><div class="pill-btn"></div>
                    </div>
                    <div class="speakers">
                        <div class="sp-slot"></div><div class="sp-slot"></div><div class="sp-slot"></div>
                        <div class="sp-slot"></div><div class="sp-slot"></div><div class="sp-slot"></div>
                    </div>
                </div>
            </div>
            <div style="margin-top: 25px; font-size: 14px; color: #7f6e6e;">
                PRESS <span style="color:#cd8d8d; font-weight:bold;">( A )</span> TO LOGIN
            </div>
          `;

          document.body.prepend(overlay);

          // 4. ‰∫ã‰ª∂ÁªëÂÆö
          const submitBtn = document.getElementById("btn-login-submit");
          const resetBtn = document.getElementById("btn-login-reset");
          const uidInput = document.getElementById("login-uid");
          const pwdInput = document.getElementById("login-pwd");

          function handleLoginTrigger() {
            const msg = document.getElementById("login-msg");
            if (msg) msg.textContent = "CONNECTING...";
            setTimeout(() => {
              if (typeof tryLogin === "function") {
                tryLogin();
              } else {
                console.error("tryLogin function missing");
              }
            }, 200);
          }

          submitBtn.onclick = handleLoginTrigger;
          resetBtn.onclick = () => {
            pwdInput.value = "";
            const msg = document.getElementById("login-msg");
            if (msg) msg.textContent = "CLEARED";
            pwdInput.focus();
          };
          pwdInput.onkeypress = function (e) {
            if (e.key === "Enter") handleLoginTrigger();
          };

          const bindVisualEffect = (btn) => {
            const down = () => {
              btn.style.transform = "translateY(6px)";
              btn.style.boxShadow = "none";
            };
            const up = () => {
              btn.style.transform = "translateY(0)";
              btn.style.boxShadow =
                "0 6px 0 rgba(0,0,0,0.15), 0 10px 10px rgba(0,0,0,0.1)";
            };
            btn.addEventListener("mousedown", down);
            btn.addEventListener("mouseup", up);
            btn.addEventListener("mouseleave", up);
            btn.addEventListener("touchstart", down, { passive: true });
            btn.addEventListener("touchend", up);
          };
          bindVisualEffect(submitBtn);
          bindVisualEffect(resetBtn);
        }

        // 2. È™åËØÅ‰∏éÂêØÂä®ÂáΩÊï∞
        async function tryLogin() {
          // Ëé∑ÂèñÂÖÉÁ¥†
          const uidEl = document.getElementById("login-uid");
          const pwdEl = document.getElementById("login-pwd");
          const msgEl = document.getElementById("login-msg");
          const submitBtn = document.getElementById("btn-login-submit");

          // ÂÆâÂÖ®Ê£ÄÊü•
          if (!uidEl || !pwdEl) {
            console.error("Êâæ‰∏çÂà∞ÁôªÂΩïËæìÂÖ•Ê°ÜÔºåËØ∑Âà∑Êñ∞È°µÈù¢");
            return;
          }

          const uid = uidEl.value.trim();
          const pwd = pwdEl.value.trim();

          if (!uid || !pwd) {
            msgEl.textContent = "ËØ∑ËæìÂÖ•ÂÆåÊï¥ÁöÑË¥¶Âè∑ÂíåÂØÜÁ†Å";
            if (msgEl) msgEl.style.color = "#ff453a"; // Á∫¢Ëâ≤Ë≠¶Âëä
            return;
          }

          // 1. ËÆæÁΩÆÂä†ËΩΩÁä∂ÊÄÅ
          msgEl.style.color = "#fab1a0"; // ÊÅ¢Â§çÈªòËÆ§È¢úËâ≤
          msgEl.textContent = "VERIFYING...";
          if (submitBtn) submitBtn.disabled = true; // Èò≤Ê≠¢ÈáçÂ§çÁÇπÂáª

          try {
            // 2. ÂèëËµ∑ÁΩëÁªúËØ∑Ê±Ç (‰Ω†ÁöÑÊñ∞ÈÄªËæë)
            const res = await fetch(
              "https://puppy-subscription-api.zeabur.app/api/verify",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ account: uid, password: pwd }),
              },
            );

            // Â§ÑÁêÜÁΩëÁªúÂ±ÇÈù¢ÁöÑÈîôËØØ (Â¶Ç404, 500)
            if (!res.ok) {
              throw new Error(`HTTP error! status: ${res.status}`);
            }

            const data = await res.json();

            // 3. Â§ÑÁêÜÈ™åËØÅÁªìÊûú
            if (data.success) {
              // --- È™åËØÅÊàêÂäü ---
              msgEl.style.color = "#32d74b"; // ÁªøËâ≤ÊàêÂäü
              msgEl.textContent = "È™åËØÅÈÄöËøáÔºåÊ≠£Âú®ËøõÂÖ•...";

              // ‰øùÂ≠òÁôªÂΩïÁä∂ÊÄÅ
              localStorage.setItem("ephone_saved_uid", uid);
              // ÂêåÊó∂‰øùÂ≠ò‰Ω†ÁöÑÊñ∞È™åËØÅÊ†áËÆ∞
              localStorage.setItem("ephone_auth", "true");

              // ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì (‰ΩøÁî® uid ‰Ωú‰∏∫Êï∞ÊçÆÂ∫ìÊ†áËØÜ)
              initDatabase(uid);

              // ÁßªÈô§ÈÅÆÁΩ©Âä®Áîª
              const overlay = document.getElementById("login-overlay");
              if (overlay) {
                overlay.style.transition = "opacity 0.5s ease";
                overlay.style.opacity = "0";
                setTimeout(() => overlay.remove(), 500);
              }

              // ÂêØÂä® App
              init();
            } else {
              // --- È™åËØÅÂ§±Ë¥• (‰∏öÂä°ÈÄªËæëÊãíÁªùÔºåÂ¶ÇÂØÜÁ†ÅÈîôËØØ) ---
              throw new Error(data.message || "Ë¥¶Âè∑ÊàñÂØÜÁ†ÅÈîôËØØ");
            }
          } catch (error) {
            // --- ÈîôËØØÂ§ÑÁêÜ ---
            console.error("ÁôªÂΩïÂá∫Èîô:", error);
            msgEl.style.color = "#ff453a"; // Á∫¢Ëâ≤Ë≠¶Âëä
            // ÊòæÁ§∫ÂÖ∑‰ΩìÈîôËØØ‰ø°ÊÅØÔºåÂ¶ÇÊûúÊòØÁΩëÁªúÈîôËØØÊòæÁ§∫"ÁΩëÁªúËøûÊé•Â§±Ë¥•"
            msgEl.textContent = error.message.includes("fetch")
              ? "ÁΩëÁªúËøûÊé•Â§±Ë¥•"
              : error.message || "È™åËØÅÂ§±Ë¥•";

            // ÊåâÈíÆËßÜËßâÂèçÈ¶à (ÂèòÁ∫¢‰∏Ä‰∏ã)
            if (submitBtn) {
              const originalBg = submitBtn.style.background;
              submitBtn.style.background = "#ff453a";
              setTimeout(
                () => (submitBtn.style.background = originalBg || ""),
                500,
              );
              submitBtn.disabled = false; // ÊÅ¢Â§çÊåâÈíÆÂèØÁî®
            }
          }
        }

        // ==========================================
       // ==========================================
// ‚ñº‚ñº‚ñº Ëá™Âä®ÁôªÂΩïÂà§Êñ≠ (‰∏ªÂÖ•Âè£) - BYPASS LOCAL ‚ñº‚ñº‚ñº
// ==========================================

// N·∫øu ch∆∞a c√≥ uid th√¨ t·ª± t·∫°o 1 c√°i local
let savedUid = localStorage.getItem("ephone_saved_uid");

if (!savedUid) {
  savedUid = "local_user";
  localStorage.setItem("ephone_saved_uid", savedUid);
  console.log("[Bypass] T·∫°o local user:", savedUid);
}

try {
  initDatabase(savedUid);
  init();
} catch (e) {
  console.error("ÂàùÂßãÂåñÂ§±Ë¥•:", e);
}


        // ==========================================
        // ‚ñº‚ñº‚ñº ÈÄÄÂá∫ÁôªÂΩïÊåâÈíÆ‰∫ã‰ª∂ÁªëÂÆö ‚ñº‚ñº‚ñº
        // ==========================================
        // ÊîæÂú®‰∏Ä‰∏™ÂÆöÊó∂Âô®ÈáåÔºåÁ°Æ‰øù logout-btn Â∑≤ÁªèÂä†ËΩΩÂá∫Êù•
        setTimeout(() => {
          const logoutBtn = document.getElementById("logout-btn");
          if (logoutBtn) {
            // ÁßªÈô§ÊóßÁöÑÁõëÂê¨Âô®Èò≤Ê≠¢ÈáçÂ§ç
            const newBtn = logoutBtn.cloneNode(true);
            logoutBtn.parentNode.replaceChild(newBtn, logoutBtn);

            newBtn.addEventListener("click", async () => {
              // ‰ΩøÁî®ÂéüÁîüÁöÑ confirmÔºåÈò≤Ê≠¢ showCustomConfirm Ê≤°Âä†ËΩΩ
              if (confirm("Á°ÆÂÆöË¶ÅÈÄÄÂá∫ÁôªÂΩïÂêóÔºü")) {
                localStorage.removeItem("ephone_saved_uid");
                window.location.reload();
              }
            });
          }
        }, 1000);

        /*
         * ===================================================================
         * === ÂÖ®Â±ÄÊé•Âè£ (Public API for other scripts) ===
         * ===================================================================
         * Â∞Ü‰∏ªÂ∫îÁî®ÁöÑÊ†∏ÂøÉÂäüËÉΩÊö¥Èú≤ÁªôÂÖ∂‰ªñËÑöÊú¨Êñá‰ª∂ÔºàÂ¶Ç game-hall.jsÔºâ‰ΩøÁî®
         */
        window.openChat = openChat;
        window.openChat = openChat;
        // „ÄêÊñ∞Â¢û„ÄëÊääË∑≥ËΩ¨ÂáΩÊï∞Êö¥Èú≤ÁªôÂÖ®Â±ÄÔºå‰ª•‰æøÂú®ÂºπÁ™ó‰∏≠ÁÇπÂáªË∞ÉÁî®
        window.jumpToMessage = async function (timestamp) {
          // 1. ÂÖ≥Èó≠ÊâÄÊúâÂèØËÉΩÊå°‰ΩèËßÜÁ∫øÁöÑÊ®°ÊÄÅÊ°Ü
          document
            .querySelectorAll(".modal")
            .forEach((el) => el.classList.remove("visible"));
          document
            .getElementById("custom-modal-overlay")
            .classList.remove("visible");
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          // ÂàáÊç¢ÂõûËÅäÂ§©ÁïåÈù¢
          showScreen("chat-interface-screen");

          // ÁÆÄÂçïÁöÑÊªöÂä®ÂÆûÁé∞
          setTimeout(() => {
            const bubble = document.querySelector(
              `.message-bubble[data-timestamp="${timestamp}"]`,
            );
            if (bubble) {
              bubble.scrollIntoView({ behavior: "auto", block: "center" });
              bubble.classList.add("flash"); // Èó™ÁÉÅÁâπÊïà
              setTimeout(() => bubble.classList.remove("flash"), 1500);
            } else {
              alert(
                "ËØ•Ê∂àÊÅØ‰∏çÂú®ÂΩìÂâçÊòæÁ§∫ËåÉÂõ¥ÂÜÖÔºàÂèØËÉΩÂ§™‰πÖËøúÔºâÔºåËØ∑ÂÖàÁÇπÂáª'Âä†ËΩΩÊõ¥Â§ö'„ÄÇ",
              );
            }
          }, 300);
        };

        window.triggerAiResponse = triggerAiResponse;
        window.openLoversSpaceFromCard = openLoversSpaceFromCard;
      });

      (function () {
        "use strict";

        // ‰∏ãËΩΩÂõæÁâáÁöÑÊ†∏ÂøÉÂáΩÊï∞
        function downloadImage(imageSrc, filename) {
          try {
            // ÂàõÂª∫‰∏Ä‰∏™ÈöêËóèÁöÑ‰∏ãËΩΩÈìæÊé•
            const link = document.createElement("a");
            link.href = imageSrc;
            link.download = filename;
            link.style.display = "none";

            document.body.appendChild(link);
            link.click(); // Ëß¶Âèë‰∏ãËΩΩ

            // Áü≠ÊöÇÂª∂ËøüÂêéÁßªÈô§ÈìæÊé•
            setTimeout(() => {
              document.body.removeChild(link);
            }, 100);

            console.log("‚úÖ [NAI‰∏ãËΩΩ] ÂºÄÂßã‰∏ãËΩΩÂõæÁâá:", filename);

            // ÊòæÁ§∫‰∏ãËΩΩÊèêÁ§∫
            showDownloadToast();
          } catch (error) {
            console.error("‚ùå [NAI‰∏ãËΩΩ] ‰∏ãËΩΩÂ§±Ë¥•:", error);
            showDownloadToast("‰∏ãËΩΩÂ§±Ë¥•ÔºåËØ∑ÈáçËØï", "error");
          }
        }

        // ÊòæÁ§∫‰∏ãËΩΩÊèêÁ§∫Ôºà‰∏¥Êó∂ToastÔºâ
        function showDownloadToast(
          message = "üì• ÂõæÁâá‰∏ãËΩΩ‰∏≠...",
          type = "success",
        ) {
          const toast = document.createElement("div");
          toast.textContent = message;
          toast.style.cssText = `
			            position: fixed;
			            bottom: 20px;
			            right: 20px;
			            background: ${type === "success" ? "#4CAF50" : "#f44336"};
			            color: white;
			            padding: 12px 24px;
			            border-radius: 8px;
			            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
			            z-index: 10000;
			            font-size: 14px;
			            pointer-events: none;
			            opacity: 0;
			            transform: translateY(20px);
			            transition: all 0.3s ease;
			        `;

          document.body.appendChild(toast);

          // Âä®ÁîªËøõÂÖ•
          setTimeout(() => {
            toast.style.opacity = "1";
            toast.style.transform = "translateY(0)";
          }, 10);

          // 2ÁßíÂêéÊ∑°Âá∫Âπ∂ÁßªÈô§
          setTimeout(() => {
            toast.style.opacity = "0";
            toast.style.transform = "translateY(-20px)";
            setTimeout(() => {
              toast.remove();
            }, 300);
          }, 2000);
        }

        // ÁîüÊàêÊô∫ËÉΩÊñá‰ª∂Âêç
        function generateFilename(imgElement) {
          // Â∞ùËØï‰ªétitleÂ±ûÊÄßËé∑ÂèñpromptÔºàÁî®‰∫éÊñá‰ª∂ÂêçÔºâ
          const title =
            imgElement.getAttribute("title") ||
            imgElement.getAttribute("alt") ||
            "";

          // Ê∏ÖÁêÜtitleÔºåÊèêÂèñÂâç30‰∏™ÊúâÊïàÂ≠óÁ¨¶
          let cleanTitle = title
            .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, "_") // ‰øùÁïô‰∏≠Ëã±ÊñáÂ≠óÊØçÊï∞Â≠óÂíåÁ©∫Ê†º
            .replace(/\s+/g, "_") // Á©∫Ê†ºËΩ¨‰∏ãÂàíÁ∫ø
            .substring(0, 30);

          if (!cleanTitle) {
            cleanTitle = "NAI_Image";
          }

          // Ê∑ªÂä†Êó∂Èó¥Êà≥ÔºàÁ≤æÁ°ÆÂà∞ÁßíÔºâ
          const timestamp = new Date()
            .toISOString()
            .replace(/[-:]/g, "")
            .replace("T", "_")
            .split(".")[0]; // Ê†ºÂºèÔºö20250124_123045

          // ÁîüÊàêÊñá‰ª∂Âêç
          return `${cleanTitle}_${timestamp}.png`;
        }

        // ‰∏∫ÂõæÁâáÊ∑ªÂä†ÂèåÂáªÊó∂ÁöÑËßÜËßâÂèçÈ¶à
        function addVisualFeedback(imgElement) {
          const originalTransform = imgElement.style.transform || "";
          const originalTransition = imgElement.style.transition || "";

          // Ê∑ªÂä†Áº©ÊîæÂä®Áîª
          imgElement.style.transition = "transform 0.15s ease";
          imgElement.style.transform = "scale(0.95)";

          setTimeout(() => {
            imgElement.style.transform = originalTransform;
            setTimeout(() => {
              imgElement.style.transition = originalTransition;
            }, 150);
          }, 150);
        }

        // ‰∏âÂáªÊ£ÄÊµãÁõ∏ÂÖ≥ÂèòÈáè
        let clickCount = 0;
        let clickTimer = null;
        let lastClickedElement = null;

        // ÂÖ®Â±Ä‰∫ã‰ª∂ÁõëÂê¨Âô®Ôºà‰∫ã‰ª∂ÂßîÊâò - ‰∏âÂáªËß¶ÂèëÔºâ
        document.addEventListener(
          "click",
          function (e) {
            const target = e.target;

            // Ê£ÄÊü•ÊòØÂê¶ÊòØNAIÂõæÁâáÔºàrealimag-image Êàñ naiimag-imageÔºâ
            if (
              target.tagName === "IMG" &&
              (target.classList.contains("realimag-image") ||
                target.classList.contains("naiimag-image"))
            ) {
              // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØÂêå‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÂ¢ûÂä†ËÆ°Êï∞
              if (target === lastClickedElement) {
                clickCount++;
              } else {
                // ÁÇπÂáª‰∫Ü‰∏çÂêåÁöÑÂÖÉÁ¥†ÔºåÈáçÁΩÆËÆ°Êï∞
                clickCount = 1;
                lastClickedElement = target;
              }

              // Ê∏ÖÈô§‰πãÂâçÁöÑÂÆöÊó∂Âô®
              if (clickTimer) {
                clearTimeout(clickTimer);
              }

              // Â¶ÇÊûúËææÂà∞‰∏âÂáª
              if (clickCount === 3) {
                // ÈáçÁΩÆËÆ°Êï∞
                clickCount = 0;
                lastClickedElement = null;

                // ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫Âíå‰∫ã‰ª∂ÂÜíÊ≥°
                e.preventDefault();
                e.stopPropagation();

                console.log("üñºÔ∏è [NAI‰∏ãËΩΩ] Ê£ÄÊµãÂà∞‰∏âÂáªNAIÂõæÁâá");

                // Ê∑ªÂä†ËßÜËßâÂèçÈ¶à
                addVisualFeedback(target);

                // Ëé∑ÂèñÂõæÁâáÊ∫êÔºàÂèØËÉΩÊòØbase64ÊàñURLÔºâ
                const imageSrc = target.src;

                if (!imageSrc || imageSrc === "about:blank") {
                  console.warn("‚ö†Ô∏è [NAI‰∏ãËΩΩ] ÂõæÁâáÊ∫ê‰∏∫Á©∫ÔºåÊó†Ê≥ï‰∏ãËΩΩ");
                  showDownloadToast("ÂõæÁâáÂä†ËΩΩ‰∏≠ÔºåËØ∑Á®çÂêéÈáçËØï", "error");
                  return;
                }

                // ÁîüÊàêÊñá‰ª∂Âêç
                const filename = generateFilename(target);

                // Ëß¶Âèë‰∏ãËΩΩ
                downloadImage(imageSrc, filename);
              } else {
                // ËÆæÁΩÆÂÆöÊó∂Âô®Ôºå500msÂêéÈáçÁΩÆËÆ°Êï∞ÔºàÂ¶ÇÊûúÁî®Êà∑ÂÅúÊ≠¢ÁÇπÂáªÔºâ
                clickTimer = setTimeout(() => {
                  clickCount = 0;
                  lastClickedElement = null;
                }, 500);
              }
            }
          },
          true,
        ); // ‰ΩøÁî®ÊçïËé∑Èò∂ÊÆµÔºåÁ°Æ‰øù‰ºòÂÖàÂ§ÑÁêÜ

        console.log("‚úÖ [NAI‰∏ãËΩΩ] ‰∏âÂáª‰∏ãËΩΩÂäüËÉΩÂ∑≤ÂàùÂßãÂåñ");
        console.log("üí° [NAI‰∏ãËΩΩ] ÊèêÁ§∫Ôºö‰∏âÂáª‰ªªÊÑèNAIÂõæÁâáÂç≥ÂèØ‰∏ãËΩΩ");
      })();
    </script>

    <input
      type="file"
      id="character-card-input"
      accept=".png, .json"
      style="display: none"
    />

    <input
      type="file"
      id="world-book-import-input"
      accept=".json, .jsonl"
      style="display: none"
    />
    <input type="file" id="ludo-qbank-import-input" accept=".json" hidden />
    <input type="file" id="inner-voice-bg-input" accept="image/*" hidden />
    <input type="file" id="script-kill-import-input" accept=".json" hidden />
  </body>
</html>
